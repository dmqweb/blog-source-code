[{"title":"33个JavaScript概念","url":"/2023/10/02/33%E4%B8%AAJavascript%E6%A6%82%E5%BF%B5/","content":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><strong><a href=\"#1-%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88\">调用堆栈</a></strong></li>\n<li><strong><a href=\"#2-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B\">原始类型</a></strong></li>\n<li><strong><a href=\"#3-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\">值类型和引用类型</a></strong></li>\n<li><strong><a href=\"#4-%E9%9A%90%E5%BC%8F-%E6%98%BE%E5%BC%8F-%E5%90%8D%E4%B9%89%E5%92%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\">隐式, 显式, 名义和鸭子类型</a></strong></li>\n<li><strong><a href=\"#5--vs--typeof-vs-instanceof\">&#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D;, typeof 与 instanceof</a></strong></li>\n<li><strong><a href=\"#6-this-call-apply-%E5%92%8C-bind\">this, call, apply 和 bind</a></strong></li>\n<li><strong><a href=\"#7-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\">函数作用域, 块级作用域和词法作用域</a></strong></li>\n<li><strong><a href=\"#8-%E9%97%AD%E5%8C%85\">闭包</a></strong></li>\n<li><strong><a href=\"#9-map-reduce-filter-%E7%AD%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\">map, reduce, filter 等高阶函数</a></strong></li>\n<li><strong><a href=\"#10-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5\">表达式和语句</a></strong></li>\n<li><strong><a href=\"#11-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87\">变量提升</a></strong></li>\n<li><strong><a href=\"#12-promise\">Promise</a></strong></li>\n<li><strong><a href=\"#13-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\">立即执行函数, 模块化, 命名空间</a></strong></li>\n<li><strong><a href=\"#14-%E9%80%92%E5%BD%92\">递归</a></strong></li>\n<li><strong><a href=\"#15-%E7%AE%97%E6%B3%95\">算法</a></strong></li>\n<li><strong><a href=\"#16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a></strong></li>\n<li><strong><a href=\"#17-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\">消息队列和事件循环</a></strong></li>\n<li><strong><a href=\"#18-settimeout-setinterval-%E5%92%8C-requestanimationframe\">setTimeout, setInterval 和 requestAnimationFrame</a></strong></li>\n<li><strong><a href=\"#19-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8\">继承, 多态和代码复用</a></strong></li>\n<li><strong><a href=\"#20-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84\">按位操作符, 类数组对象和类型化数组</a></strong></li>\n<li><strong><a href=\"#21-dom-%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B\">DOM 树和渲染过程</a></strong></li>\n<li><strong><a href=\"#22-new-%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-instanceof-%E4%B8%8E%E5%AE%9E%E4%BE%8B\">new 与构造函数, instanceof 与实例</a></strong></li>\n<li><strong><a href=\"#23-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\">原型继承与原型链</a></strong></li>\n<li><strong><a href=\"#24-objectcreate-%E5%92%8C-objectassign\">Object.create 和 Object.assign</a></strong></li>\n<li><strong><a href=\"#25-%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB\">工厂函数和类</a></strong></li>\n<li><strong><a href=\"#26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">设计模式</a></strong></li>\n<li><strong><a href=\"#27-memoization\">Memoization</a></strong></li>\n<li><strong><a href=\"#28-%E7%BA%AF%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8%E5%92%8C%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96\">纯函数, 函数副作用和状态变化</a></strong></li>\n<li><strong><a href=\"#29-%E8%80%97%E6%80%A7%E8%83%BD%E6%93%8D%E4%BD%9C%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">耗性能操作和时间复杂度</a></strong></li>\n<li><strong><a href=\"#30-javascript-%E5%BC%95%E6%93%8E\">JavaScript 引擎</a></strong></li>\n<li><strong><a href=\"#31-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6-%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95\">二进制, 十进制, 十六进制, 科学记数法</a></strong></li>\n<li><strong><a href=\"#32-%E5%81%8F%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-compose-%E5%92%8C-pipe\">偏函数, 柯里化, Compose 和 Pipe</a></strong></li>\n<li><strong><a href=\"#33-%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93\">代码整洁之道</a></strong></li>\n</ol>\n<hr>\n<h2 id=\"1-调用堆栈\"><a href=\"#1-调用堆栈\" class=\"headerlink\" title=\"1. 调用堆栈\"></a>1. 调用堆栈</h2><h3 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9DYWxsX3N0YWNr\">Call Stack — MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTA1YjQ1NzZmYjlhMDQ1MTk2OTBkNDI=\">[译] JavaScript 如何工作：对引擎、运行时、调用堆栈的概述 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YmEzMjE3MWYyNjVkYTBhYjcxOWE2ZDc=\">[译] 理解 JavaScript 中的执行上下文和执行栈 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWU4NWVlYmYyNjVkYTQzMGQ1NzFmODk=\">这一次，彻底弄懂 JavaScript 执行机制 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cub3NjaGluYS5uZXQvdHJhbnNsYXRlL2hvdy1kb2VzLWphdmFzY3JpcHQtYWN0dWFsbHktd29yay1wYXJ0LTE=\">解读 JavaScript 之引擎、运行时和堆栈调用 —— 开源中国</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8yMDE1L3Rhc2tzLW1pY3JvdGFza3MtcXVldWVzLWFuZC1zY2hlZHVsZXMv\">Tasks, microtasks, queues and schedules —— Jake Archibald</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTVkYmQ1MWE2MGIyZjNhOTJhOGY1YmZm\">Tasks, microtasks, queues and schedules（译） —— 掘金</span></li>\n</ul>\n<h3 id=\"视频\"><a href=\"#视频\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly92LnFxLmNvbS94L3BhZ2UvaDAzNzJibGQ4cmUuaHRtbD9wdGFnPXFxYnJvd3Nlcg==\">What is the event loop anyway? —— 腾讯视频(英文字幕)</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2MzM4MjQ5MzMv\">Understanding The JavaScript Call Stack, Event Queue, Event Table, &amp; Event Loop —— Bilibili</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5hY2Z1bi5jbi92L2FjNDQ5NTY0MQ==\">JS 中的变量提升、堆栈内存及闭包详解 —— Acfun</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5waHAuY24vY29kZS8yMTE5NC5odG1s\">事件循环模型 —— PHP 中文网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj13NlFHRWlRY2VPTQ==\">Javascript: the Call Stack explained — Coding Blocks India</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1XOEFlTXJWdEZMWQ==\">The JS Call Stack Explained In 9 Minutes — Colt Steele</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1qVDBVU0plTkZFQQ==\">JavaScript Execution Stack — Codecademy</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj13N1FXUWxrTFlfcw==\">What is the Call Stack? — Eric Traub</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1RMnNGbXF2cEJlMA==\">The Call Stack — Kevin Drumm</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1aNmExY0x5cTdBYyZsaXN0PVBMV3JRWm5HOGwwRTRrZDFUX255dVZveFFVYVlFV0ZnY0Q=\">Understanding JavaScript Execution — Codesmith</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1tazBsdTlNS0J0bw==\">Call Stack &amp; Event Loop — movies com</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"2-原始类型\"><a href=\"#2-原始类型\" class=\"headerlink\" title=\"2. 原始类型\"></a>2. 原始类型</h2><h3 id=\"文章-1\"><a href=\"#文章-1\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9QcmltaXRpdmU=\">原始数据 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNzA5MDI3Mg==\">[译]JavaScript 是怎样编码数字的 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly95YW5oYWlqaW5nLmNvbS9qYXZhc2NyaXB0LzIwMTQvMDMvMTQvd2hhdC1ldmVyeS1qYXZhc2NyaXB0LWRldmVsb3Blci1zaG91bGQta25vdy1hYm91dC1mbG9hdGluZy1wb2ludHMv\">每一个 JavaScript 开发者应该了解的浮点知识 —— 颜海镜</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3R5cGVzL251bWJlci5odG1s\">JavaScript 标准参考教程(基本语法之数值) —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhc2NyaXB0d2VibG9nLndvcmRwcmVzcy5jb20vMjAxMC8wOS8yNy90aGUtc2VjcmV0LWxpZmUtb2YtamF2YXNjcmlwdC1wcmltaXRpdmVzLw==\">The Secret Life of JavaScript Primitives —— Angus Croll</span></li>\n</ul>\n<h3 id=\"视频-1\"><a href=\"#视频-1\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL3ZpZGVvLzU2NzQ=\">javascript 六种数据类型 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5waHAuY24vY29kZS81ODA4Lmh0bWw=\">javascript 视频教程(数据类型) —— PHP 中文网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj05b29ZWVJMZGdfZw==\">JavaScript Reference vs Primitive Types — Academind</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Ic2JXUXNTQ0U1WQ==\">JavaScript Primitive Types — Simon Sez IT</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GN1liaEticEZpYw==\">Javascript Primitive and Reference Types — Baljeet Singh</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1lLV9tRHlxbTJvVQ==\">Value Types and Reference Types in JavaScript — Programming with Mosh</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1xdzNqMEEzREl6UQ==\">JavaScript Primitive Data Types — Avelx</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1NcUhERHRWWUpSSQ==\">Everything you never wanted to know about JavaScript numbers — Bartek Szopka</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"3-值类型和引用类型\"><a href=\"#3-值类型和引用类型\" class=\"headerlink\" title=\"3. 值类型和引用类型\"></a>3. 值类型和引用类型</h2><h3 id=\"文章-2\"><a href=\"#文章-2\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vanMvcHJvX2pzX3JlZmVyZW5jZXR5cGVzLmFzcA==\">ECMAScript 引用类型 —— W3school</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGVpdGluZy9wLzgwODE0MTMuaHRtbA==\">js 中的值类型和引用类型的区别 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmZ1bmRlYnVnLmNvbS8yMDE3LzA4LzA5L2V4cGxhaW5fdmFsdWVfcmVmZXJlbmNlX2luX2pzLw==\">JavaScript 的值传递和引用传递 —— FunDebug</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzdG9yZS5taWsudWEvb3JlbGx5L3dlYnByb2cvanNjcmlwdC9jaDA0XzA0Lmh0bQ==\">Primitive Types &amp; Reference Types in JavaScript —— Bran van der Meer</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaWFfYm9rZS9hcnRpY2xlL2RldGFpbHMvNTQ5MDY1MDk=\">JavaScript: Passing by Value or by Reference —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTQxMTE5NQ==\">js 值引用和值复制 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6emFxdWFyaXVzL2FydGljbGUvZGV0YWlscy80OTAyMjM1\">js- 引用和复制(传值和传址) —— CSDN</span></li>\n</ul>\n<h3 id=\"视频-2\"><a href=\"#视频-2\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1FLWRBbkZkcThrOA==\">Javascript Pass by Value vs Pass by Reference — techsith</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1mRDB0X0RLUkViRQ==\">JavaScript Value vs Reference Types — Programming with Mosh</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"4-隐式-显式-名义和鸭子类型\"><a href=\"#4-隐式-显式-名义和鸭子类型\" class=\"headerlink\" title=\"4. 隐式, 显式, 名义和鸭子类型\"></a>4. 隐式, 显式, 名义和鸭子类型</h2><h3 id=\"文章-3\"><a href=\"#文章-3\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vanMvcHJvX2pzX3R5cGVjb252ZXJzaW9uLmFzcA==\">ECMAScript 类型转换 —— W3school</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2p1c3RqYXZhYy5jb20vamF2YXNjcmlwdC8yMDEzLzA0LzA4L2phdmFzY3JpcHQtcXVpcmstMS1pbXBsaWNpdC1jb252ZXJzaW9uLW9mLXZhbHVlcy5odG1s\">JavaScript 的怪癖 1：隐式类型转换 —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWFkMjU4NWYyNjVkYTI0NmEyMGUwMjY=\">JavaScript 运算符规则与隐式类型转换详解 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDQ4MjM4OA==\">聊一聊 JS 中的隐式类型转换 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXVnZWdlL3AvNTI3Nzg4My5odG1s\">有趣的 JavaScript 隐式类型转换 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdqdm4vYXJ0aWNsZS9kZXRhaWxzLzQ4Mjg0MTYz\">JavaScript 显式类型转换与隐式类型转换 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83NzdhODliNGVkOWE=\">你不知道的 JavaScript（中卷）强制类型转换 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIwMTUxMg==\">你懂 JavaScript 嗎？#8 強制轉型 —— cythilya</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2Jvb2suNTFjdG8uY29tL2FydC8yMDE1MDUvNDc1MTUzLmh0bQ==\">动态类型语言和鸭子类型 —— 曾探</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9mbG93Lm9yZy9lbi9kb2NzL2xhbmcvbm9taW5hbC1zdHJ1Y3R1cmFsLw==\">Nominal &amp; Structural Typing —— flow</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk5MTU2ODgvd2hhdC1leGFjdGx5LWlzLXR5cGUtY29lcmNpb24taW4tamF2YXNjcmlwdA==\">What exactly is Type Coercion in Javascript? —— stackoverflow</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9Zb3UtRG9udC1Lbm93LUpTL2Jsb2IvbWFzdGVyL3R5cGVzJTIwJiUyMGdyYW1tYXIvY2g0Lm1k\">You Don’t Know JS: Types &amp; Grammar —— github</span></li>\n</ul>\n<h3 id=\"视频-3\"><a href=\"#视频-3\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL3ZpZGVvLzU2NzU=\">javascript 隐式转换 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NzY3MDA5Lmh0bWw=\">Javascript 基础加强-类型转换 —— 黑马程序员</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<div id=\"5--vs--typeof-vs-instanceof\"></div>\n\n<h2 id=\"5-x3D-x3D-vs-x3D-x3D-x3D-typeof-vs-instanceof\"><a href=\"#5-x3D-x3D-vs-x3D-x3D-x3D-typeof-vs-instanceof\" class=\"headerlink\" title=\"5. &#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D;, typeof vs instanceof\"></a>5. &#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D;, typeof vs instanceof</h2><h3 id=\"文章-4\"><a href=\"#文章-4\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9FcXVhbGl0eV9jb21wYXJpc29uc19hbmRfc2FtZW5lc3M=\">JavaScript 中的相等性判断 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg0OTE4NjEyZjMwMWUwMDU3MTZhZGQ2\">js 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3c5NzUzMS9hcnRpY2xlL2RldGFpbHMvODIyNTUyMjU=\">&#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D; in Javascript —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21ldmlja3kvYXJ0aWNsZS9kZXRhaWxzLzUwMzUzODgx\">深入理解 javascript 之 typeof 和 instanceof —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2p1c3RqYXZhYy5jb20vamF2YXNjcmlwdC8yMDEyLzEyLzIzL3doYXQtaXMtamF2YXNjcmlwdHMtdHlwZW9mLW9wZXJhdG9yLXVzZWQtZm9yLmh0bWw=\">JavaScript 的 typeof 的用途 —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ODM1ODYwNjU3MGMzNTAwNWU0MTQyYmQ=\">一张图看懂 Function 和 Object 的关系及简述 instanceof 运算符 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjBiOWI5MDUxODgyNTE1NzczYWU3MTQ=\">浅谈 instanceof 和 typeof 的实现原理 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMDczMDk4Mg==\">typeof 和 instanceOf 的区别</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"6-this-call-apply-和-bind\"><a href=\"#6-this-call-apply-和-bind\" class=\"headerlink\" title=\"6. this, call, apply 和 bind\"></a>6. this, call, apply 和 bind</h2><h3 id=\"文章-5\"><a href=\"#文章-5\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTAvMDQvdXNpbmdfdGhpc19rZXl3b3JkX2luX2phdmFzY3JpcHQuaHRtbA==\">Javascript 的 this 用法 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2FydGljbGUvMTc1OA==\">学会 JS 的 this 这一篇就够了，根本不用记 —— 慕课网</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjlmMTc2YjZmYjlhMDVkMzgyN2QwM2Y=\">[译] this（他喵的）到底是什么 — 理解 JavaScript 中的 this、call、apply 和 bind —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWJmZTg0MzUxODgyNTMxYjczMGJhYzI=\">this、apply、call、bind —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGluZ3l1LWJsb2cvcC82MjEyMzkyLmh0bWw=\">使用 call、apply 和 bind 解决 js 中烦人的 this，事件绑定时的 this 和传参问题 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FiaWVsMTAyNC9ibG9nL2lzc3Vlcy8xNg==\">call、apply 和 bind 的原生实现 —— github</span></li>\n</ul>\n<h3 id=\"视频-4\"><a href=\"#视频-4\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXFpeWkuY29tL3dfMTlycjFhdWdzZC5odG1s\">JavaScript 关于 this 关键字解释 —— 爱奇艺</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL2JhaWR1LmlxaXlpLmNvbS93YXRjaC84NDUzMzU1MzMzODM4NzQ2ODguaHRtbD9wYWdlPXZpZGVvTXVsdGlOZWVk\">JS 关于作用域闭包和 this 的综合面试题 —— 百度视频</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NDc4NDEzLmh0bWw/Y2g9YmFpZHVfcw==\">js 面向对象闭包数组 12.函数中的 this —— 乐视视频</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI0ODM1OTExLmh0bWw/Y2g9YmFpZHVfcw==\">1.3.10-this 指向及 this 应用 —— 乐视视频</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHVkeS4xNjMuY29tL2NvdXJzZS9pbnRyb2R1Y3Rpb24vNTkwMDA1Lmh0bQ==\">珠峰培训 JavaScript 开发课程：关于 this 关键字、闭包作用域 —— 网易云课堂</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"7-函数作用域-块级作用域和词法作用域\"><a href=\"#7-函数作用域-块级作用域和词法作用域\" class=\"headerlink\" title=\"7. 函数作用域, 块级作用域和词法作用域\"></a>7. 函数作用域, 块级作用域和词法作用域</h2><h3 id=\"文章-6\"><a href=\"#文章-6\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5MzE1OTc3M2E0NjRmMzRlMTcyNDcwMGE2ZDVkZDllMjM1Y2ViN2MwMDA=\">变量作用域与解构赋值 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMDkvMDgvbGVhcm5pbmdfamF2YXNjcmlwdF9jbG9zdXJlcy5odG1s\">学习 Javascript 闭包（Closure） —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjY3MTAyMA==\">JavaScript 中词法作用域、闭包与跳出闭包 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNThlNzAwNzdiMTIzZGIxNWViODhkYzdl\">JavaScript 深入之词法作用域和动态作用域 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWZiMGFlNTZmYjlhMDdhYTIxMzg0MjU=\">深入理解闭包之前置知识 → 作用域与词法作用域 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA0NzQ1NC93aGF0LWlzLWxleGljYWwtc2NvcGU=\">What is lexical scope? —— stackoverflow</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Zpc2hlbmFsL1lvdS1Eb250LUtub3ctSlMvYmxvYi9tYXN0ZXIvc2NvcGUlMjAmJTIwY2xvc3VyZXMvY2gyLm1k\">You Don’t Know JS: Scope &amp; Closures —— Kyle Simpson</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"8-闭包\"><a href=\"#8-闭包\" class=\"headerlink\" title=\"8. 闭包\"></a>8. 闭包</h2><h3 id=\"文章-7\"><a href=\"#文章-7\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9DbG9zdXJlcw==\">闭包 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vanMvcHJvX2pzX2Z1bmN0aW9uc19jbG9zdXJlcy5hc3A=\">ECMAScript 闭包（closure）—— w3school</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMDkvMDgvbGVhcm5pbmdfamF2YXNjcmlwdF9jbG9zdXJlcy5odG1s\">学习 Javascript 闭包（Closure） —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5MzQ1NDM0NjFjOWQ1ZGZlZWI4NDhmNWI3MmJkMDEyZTExMTNkMTUwMDA=\">闭包 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83OTZlOTAzNzU0ZjE=\">一次性搞懂 JavaScript 闭包 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjg3NTY2Mg==\">JavaScript 闭包 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTgwMGViN2RhMjJiOWQwMDViMzYxNTZl\">js 匿名自执行函数中闭包的高级使用 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTlkZjQwNTI1MTg4MjU1MWJmN2U1OGM2\">高效使用 JavaScript 闭包 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2Z1cGVuZzE5ODgvcC8zOTc3OTI0Lmh0bWw=\">深入理解 JavaScript 原型与闭包 —— 王福朋</span></li>\n</ul>\n<h3 id=\"视频-5\"><a href=\"#视频-5\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pcWl5aS5jb20vd18xOXJyMWFtYWVsLmh0bWw=\">JavaScript 闭包和闭包面试题 —— 爱奇艺</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NDc4NDEwLmh0bWw=\">js 面向对象闭包数组 11.闭包 —— 乐视</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzMwNTA1ODUyLmh0bWw=\">白贺翔_函数(闭包) —— 乐视</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"9-map-reduce-filter-等高阶函数\"><a href=\"#9-map-reduce-filter-等高阶函数\" class=\"headerlink\" title=\"9. map, reduce, filter 等高阶函数\"></a>9. map, reduce, filter 等高阶函数</h2><h3 id=\"文章-8\"><a href=\"#文章-8\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5MzU1ODI5ZWFkOTc0ZTU1MDY0NGUyZWJkOWZkOGJiMWIwZGQ3MjEwMDA=\">高阶函数 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMTMvMDQvZXM1JWU2JTk2JWIwJWU1JWEyJTllJWU2JTk1JWIwJWU3JWJiJTg0JWU2JTk2JWI5JWU2JWIzJTk1Lw==\">ES5 中新增的 Array 方法详细说明 —— 张鑫旭</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ODM1ODA4MDY3ZjM1NjAwNjVlZDRhYjI=\">一张图看懂 JavaScript 中数组的迭代方法：forEach、map、filter、reduce、every、some —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjEyNzMyOQ==\">Transducing（上）－《JavaScript 轻量级函数式编程》 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0J1cHRTdEV2ZS9ibG9nL2lzc3Vlcy8xNQ==\">JavaScript 函数式编程（三） —— @BuptStEve</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"10-表达式和语句\"><a href=\"#10-表达式和语句\" class=\"headerlink\" title=\"10. 表达式和语句\"></a>10. 表达式和语句</h2><h3 id=\"文章-9\"><a href=\"#文章-9\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhbnNoZW5nbHUvcC84Mzg2OTE4Lmh0bWw=\">js 表达式与语句 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwNDEwMjgwNA==\">JS 表达式和语句的区别 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21ldHRfc21pdGgvYXJ0aWNsZS9kZXRhaWxzLzc4NzYxMjQ3\">JavaScript 中的表达式（expression）和语句&#x2F;声明（statement） —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDU2NTY5Mw==\">重讀 Axel 的 Javascript 中的 Expression vs Statement 一文 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovLzJhbGl0eS5jb20vMjAxMi8wOS9leHByZXNzaW9ucy12cy1zdGF0ZW1lbnRzLmh0bWw=\">Expressions versus statements in JavaScript —— Dr. Axel</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"11-变量提升\"><a href=\"#11-变量提升\" class=\"headerlink\" title=\"11. 变量提升\"></a>11. 变量提升</h2><h3 id=\"文章-10\"><a href=\"#文章-10\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydW5vb2IuY29tL2pzL2pzLWhvaXN0aW5nLmh0bWw=\">JavaScript 变量提升 —— 菜鸟教程</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTkwNWJlYTZmYjlhMDNjMzQxOTJjNTE=\">ES6 变量作用域与提升：变量的生命周期详解 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDM0NTM1NSNhcnRpY2xlSGVhZGVyNQ==\">[翻译] JavaScript Scoping and Hoisting —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5hZGVxdWF0ZWx5Z29vZC5jb20vSmF2YVNjcmlwdC1TY29waW5nLWFuZC1Ib2lzdGluZy5odG1s\">JavaScript Scoping and Hoisting —— Ben Cherry</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"12-Promise\"><a href=\"#12-Promise\" class=\"headerlink\" title=\"12. Promise\"></a>12. Promise</h2><h3 id=\"文章-11\"><a href=\"#文章-11\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9Vc2luZ19wcm9taXNlcw==\">使用 promises —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZQ==\">Promise —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NTAwODUzOTE1NWU5M2ZjMTYwNDZkNGJiNzg1NDk0MzgxNGM0ZjlkYzIwMDA=\">Promise — 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcnVieWxvdXZyZS9wLzM0OTUyODYuaHRtbA==\">JavaScript Promise：去而复返 —— 司徒正美</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9wcmltZXJzL3Byb21pc2VzI18x\">(上面的原文)JavaScript Promise：简介 —— Web Fundamentals</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTgxMzkzNA==\">1 分钟读完《10 分钟学会 JavaScript 的 Async&#x2F;Await》 —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTY0OTlhZTE2MGIyZDE0MDRjNGY4ODM0\">JavaScript Promise 迷你书（中文版）</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXVuZmVpZmVpL3AvNDQ1MzY5MC5odG1s\">JavaScript 进阶之路——认识和使用 Promise，重构你的 Js 代码 —— 博客园</span></li>\n</ul>\n<h3 id=\"视频-6\"><a href=\"#视频-6\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzk0OQ==\">Promise 入门 —— 慕课网</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"13-立即执行函数-模块化-命名空间\"><a href=\"#13-立即执行函数-模块化-命名空间\" class=\"headerlink\" title=\"13. 立即执行函数, 模块化, 命名空间\"></a>13. 立即执行函数, 模块化, 命名空间</h2><h3 id=\"文章-12\"><a href=\"#文章-12\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMTAvamF2YXNjcmlwdF9tb2R1bGUuaHRtbA==\">Javascript 模块化编程（一）：模块的写法 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80ZGJmNGE0YzhlYmI=\">javascript 模块化编程-详解立即执行函数表达式 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTdmZWUzNjBhMjJiOWQwMDViMWQ5YWUz\">Javascript 的匿名函数与自执行 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjk2NjM1OA==\">前端模块化——技术选型 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTk5MTg2OSNhcnRpY2xlSGVhZGVyOA==\">谈谈 Js 前端模块化规范 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3dlYi5qb2Jib2xlLmNvbS84NzUzNC8=\">函数声明与函数表达式的区别 —— 伯乐在线</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"14-递归\"><a href=\"#14-递归\" class=\"headerlink\" title=\"14. 递归\"></a>14. 递归</h2><h3 id=\"文章-13\"><a href=\"#文章-13\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwMzk0MjM0Nw==\">求解释 js 递归 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTQ4YzBkOGZlODhjMjAwNmE5MzllMmE=\">JavaScript 中的递归 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWMxZDkxZDZmYjlhMDBhNTMyNzVmNzk=\">递归（上）－《JavaScript 轻量级函数式编程》 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWM4N2ZiNDZmYjlhMDBhNDM3YjFhMmU=\">递归（下）－《JavaScript 轻量级函数式编程》 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWNkZDc0ODZmYjlhMDI4Y2E1MzU0N2M=\">尾调用和尾递归 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5xaWFuc3RkL2FydGljbGUvZGV0YWlscy83NTgwNzQ2Mg==\">几个经典递归问题用 js 实现 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hfaV94dy9hcnRpY2xlL2RldGFpbHMvNzIwMjY4Njg=\">递归函数的几个例子 —— CSDN</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"15-算法\"><a href=\"#15-算法\" class=\"headerlink\" title=\"15. 算法\"></a>15. 算法</h2><h3 id=\"文章-14\"><a href=\"#文章-14\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81N2RjZDM5NGEyMmI5ZDAwNjEwYzVlYzg=\">十大经典排序算法总结（JavaScript 描述） —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTRkZmU3OTUxODgyNTBkNzI1YTIyMGEjY29tbWVudA==\">在 JavaScript 中学习数据结构与算法 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGM5ZDVmYjFiNjllNjAwNmI2ODZiY2U=\">JS 中可能用得到的全部的排序算法 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xYjQwNjhjY2Q1MDU=\">JS 家的排序算法 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODU5MzcxNQ==\">前端常见算法的 JS 实现 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamFja3B1LmNvbS9xaWFuLWR1YW4tbWlhbi1zaGktemhvbmctZGUtY2hhbmctamlhbi1kZS1zdWFuLWZhLXdlbi10aS8=\">前端面试中的常见的算法问题 ——蒲小花的博客</span></li>\n</ul>\n<h3 id=\"视频-7\"><a href=\"#视频-7\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzg4OA==\">Javascript 实现二叉树算法 —— 慕课网</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"16-数据结构\"><a href=\"#16-数据结构\" class=\"headerlink\" title=\"16. 数据结构\"></a>16. 数据结构</h2><h3 id=\"文章-15\"><a href=\"#文章-15\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81ZTBlOGQxODMxMDI=\">来我们浅谈一下 js 的数据结构 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vbmIvMTY4MzU0OTY=\">JavaScript 中的算法与数据结构 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzdiOWM1ZTQxMDEwMTdtanQuaHRtbA==\">学 JS 必看-JavaScript 数据结构深度剖析 —— 大道至简的博客</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg2ZWZmZTBkYTJmNjAwMDUzZDg1YTlh\">js 中基础数据结构数组去重问题 —— 掘金</span></li>\n</ul>\n<h3 id=\"视频-8\"><a href=\"#视频-8\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: :tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NjA2OTY0Lmh0bWw=\">JavaScript 数据结构-运算符 —— 乐视</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"17-消息队列和事件循环\"><a href=\"#17-消息队列和事件循环\" class=\"headerlink\" title=\"17. 消息队列和事件循环\"></a>17. 消息队列和事件循环</h2><h3 id=\"文章-16\"><a href=\"#文章-16\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9FdmVudExvb3A=\">并发模型与事件循环 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMTAvZXZlbnQtbG9vcC5odG1s\">JavaScript 运行机制详解：再谈 Event Loop —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG9uZy14dS9wLzcwMDAxNjMuaHRtbA==\">深入理解 JavaScript 事件循环 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjIyOTI5Mw==\">深入浅出 Javascript 事件循环机制 —— 知乎</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDk0MDkwNCNhcnRpY2xlSGVhZGVyNw==\">JS 事件循环机制（event loop）之宏任务、微任务 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDMyMjM1OA==\">JavaScript：彻底理解同步、异步和事件循环 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTY1NDdkMGYyNjVkYTNlMjgzYTFkZjc=\">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 —— 掘金</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"18-setTimeout-setInterval-和-requestAnimationFrame\"><a href=\"#18-setTimeout-setInterval-和-requestAnimationFrame\" class=\"headerlink\" title=\"18. setTimeout, setInterval 和 requestAnimationFrame\"></a>18. setTimeout, setInterval 和 requestAnimationFrame</h2><h3 id=\"文章-17\"><a href=\"#文章-17\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydW5vb2IuY29tL2pzcmVmL21ldC13aW4tc2V0dGltZW91dC5odG1s\">Window setTimeout() 方法 —— 菜鸟教程</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydW5vb2IuY29tL2pzcmVmL21ldC13aW4tc2V0aW50ZXJ2YWwuaHRtbA==\">Window setInterval() 方法 —— 菜鸟教程</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWE0YzQ3YWYyNjVkYTIzOTg2NmUyMzY=\">关于 setTimeout —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTc3ZjhjZTUxODgyNTdhNmQ2MzVkNzY=\">你不知道的 Javascript：有趣的 setTimeout —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg2MWViZjAxYjY5ZTYwMDZjZTYxZDM4\">原来你是这样的 setTimeout —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwNTk4OTQ5MQ==\">setTimeout() 和 setInterval() 本质区别在哪里？ —— SegmentFault</span></li>\n<li>book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWU=\">window.requestAnimationFrame —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9vbmVwaXhlbC9wLzcwNzg2MTcuaHRtbA==\">requestAnimationFrame 知多少？ —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMTMvMDkvY3NzMy1hbmltYXRpb24tcmVxdWVzdGFuaW1hdGlvbmZyYW1lLXR3ZWVuLSVlNSU4YSVhOCVlNyU5NCViYiVlNyVhZSU5NyVlNiViMyU5NS8=\">CSS3 动画那么强，requestAnimationFrame 还有毛线用？ —— 张鑫旭</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDY2MTAzNQ==\">「JavaScript 定时器」setInterval、setTimeout 和 requestAnimationFrame 浅析 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMDM4NjM2OA==\">翻译：setInterval 与 requestAnimationFrame 的时间间隔测试 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAxMzkwOTQzMA==\">阿里前端面试题：requestAnimationFrame 实现类似 setInterval 的计时器 —— SegmentFault</span></li>\n</ul>\n<h3 id=\"视频-9\"><a href=\"#视频-9\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3YueW91a3UuY29tL3Zfc2hvdy9pZF9YTlRBNE9UUTBOekEwLmh0bWw=\">setTimeout 和 setInterval —— 优酷</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"19-继承-多态和代码复用\"><a href=\"#19-继承-多态和代码复用\" class=\"headerlink\" title=\"19. 继承, 多态和代码复用\"></a>19. 继承, 多态和代码复用</h2><h3 id=\"文章-18\"><a href=\"#文章-18\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTGVvX3dsL3AvNTczNDc5NC5odG1s\">JS 面向对象编程之：封装、继承、多态 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81Y2I2OTI2NTg3MDQ=\">Javascript 的继承与多态 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTM5NmM5NmZlODhjMjAwNmFmYzI3MDc=\">js:面向对象编程，带你认识封装、继承和多态 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDY5MzIwOQ==\">JavaScript 中的“多继承” —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1Rvb0J1Zy9qYXZhc2NyaXB0LnBhdHRlcm5zL2Jsb2IvbWFzdGVyL2NoYXB0ZXI2Lm1hcmtkb3du\">代码复用模式 —— github</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9Ub21YdS9hcmNoaXZlLzIwMTIvMDQvMjQvMjQzODA1MC5odG1s\">深入理解 JavaScript：代码复用模式(推荐篇) —— 汤姆大叔</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vVG9tWHUvYXJjaGl2ZS8yMDEyLzA0LzIzLzI0MzgwMDUuaHRtbA==\">深入理解 JavaScript：代码复用模式(避免篇) —— 汤姆大叔</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"20-按位操作符-类数组对象和类型化数组\"><a href=\"#20-按位操作符-类数组对象和类型化数组\" class=\"headerlink\" title=\"20. 按位操作符, 类数组对象和类型化数组\"></a>20. 按位操作符, 类数组对象和类型化数组</h2><h3 id=\"文章-19\"><a href=\"#文章-19\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3Jz\">按位操作符 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9UeXBlZF9hcnJheXM=\">类数组对象 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXI=\">类型化数组 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ3JhZG9sYWJzL3AvNDc2MjEzNC5odG1s\">JavaScript ArrayBuffer 浅析 —— 博客园</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"21-DOM-树和渲染过程\"><a href=\"#21-DOM-树和渲染过程\" class=\"headerlink\" title=\"21. DOM 树和渲染过程\"></a>21. DOM 树和渲染过程</h2><h3 id=\"文章-20\"><a href=\"#文章-20\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbC9Ib3dfdG9fY3JlYXRlX2FfRE9NX3RyZWU=\">如何创建一个 DOM 树 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vaHRtbGRvbS9kb21fbm9kZXMuYXNw\">HTML DOM 节点 —— W3school</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2phdmFzY3JpcHQucnVhbnlpZmVuZy5jb20vZG9tL25vZGUuaHRtbA==\">DOM 概述 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xMDAzMWJiMjRkYWY=\">《JavaScript 闯关记》之 DOM（上）—— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ODliMTZkY2UxNGE=\">《JavaScript 闯关记》之 DOM（下）—— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTgzMTRlZmQ4YWMyNDcwMDYxYmIzMGZk\">掌握 DOM 操作 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NTAwNDk0NDUxMjczZTZiM2RlYzlkNDExZDliYTg0MWRlZThjYWVjNDUwMDA=\">操作 DOM —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWM2MDY5MTUxODgyNTM5NmY0ZjcxYTE=\">原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的 —— 掘金</span></li>\n</ul>\n<h3 id=\"视频-10\"><a href=\"#视频-10\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzQ4OA==\">DOM 探索之基础详解篇 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzEzOA==\">DOM 事件探秘 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzUzMA==\">jQuery 基础(二)DOM 篇 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pcWl5aS5jb20vd18xOXJyMTlzMDhsLmh0bWw=\">JS 操作 DOM 对象属性和方法 —— 爱奇艺</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"22-new-与构造函数-instanceof-与实例\"><a href=\"#22-new-与构造函数-instanceof-与实例\" class=\"headerlink\" title=\"22. new 与构造函数, instanceof 与实例\"></a>22. new 与构造函数, instanceof 与实例</h2><h3 id=\"文章-21\"><a href=\"#文章-21\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2phdmFzY3JpcHQucnVhbnlpZmVuZy5jb20vb29wL2Jhc2ljLmh0bWw=\">构造函数与 new 命令 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTAvMDUvb2JqZWN0LW9yaWVudGVkX2phdmFzY3JpcHRfaW5oZXJpdGFuY2UuaHRtbA==\">Javascript 面向对象编程（二）：构造函数的继承 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NwaWN5Qm9pbGVkRmlzaC9hcnRpY2xlL2RldGFpbHMvNzExMjMxNjI=\">完整原型链详细图解(构造函数、原型、实例化对象) —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5waHAuY24vanMtdHV0b3JpYWwtMzc2MjQ2Lmh0bWw=\">JavaScript 中构造函数与 new 操作符的实例详解 —— PHP 中文网</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbl85OTEvYXJ0aWNsZS9kZXRhaWxzLzgwOTU0NDUz\">构造函数、实例、原型、原型链之间的关系 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NlY2lsaWE2MjAvYXJ0aWNsZS9kZXRhaWxzLzcxMTU4MDQ4\">深入理解 JS—instanceof 和原型链 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xNWFjNzM5M2JjMWY=\">前端基础进阶（九）：详解面向对象、构造函数、原型与原型链 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82MGZmYzQ4MzFiZmY=\">js 用 new 实例化对象与直接调用的 this 的区别 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2p1c3RqYXZhYy5jb20vamF2YXNjcmlwdC8yMDEyLzEyLzIyL2phdmFzY3JpcHQtdmFsdWVzLW5vdC1ldmVyeXRoaW5nLWlzLWFuLW9iamVjdC5odG1s\">JavaScript 并非所有的东西都是对象 —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi93ZWIvMTMwNl9qaWFuZ2pqX2pzaW5zdGFuY2VvZi8=\">JavaScript instanceof 运算符深入剖析 —— IBM</span></li>\n</ul>\n<h3 id=\"视频-11\"><a href=\"#视频-11\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NzY2ODg5Lmh0bWw=\">改良版的构造函数 —— 乐视</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"23-原型继承与原型链\"><a href=\"#23-原型继承与原型链\" class=\"headerlink\" title=\"23. 原型继承与原型链\"></a>23. 原型继承与原型链</h2><h3 id=\"文章-22\"><a href=\"#文章-22\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9Jbmhlcml0YW5jZV9hbmRfdGhlX3Byb3RvdHlwZV9jaGFpbg==\">继承与原型链 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2JpZ2RvdHMvYmxvZy9pc3N1ZXMvMQ==\">构造函数、原型与原型链 —— github</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0b25lMDA5MC9qYXZhc2NyaXB0LWxlc3NvbnMvdHJlZS9tYXN0ZXIvMi41LVByb3RvdHlwZQ==\">原型及原型链 —— github(1269 Star)</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDI4MjIwNg==\">理清 javascript 中的面向对象(一) 原型继承 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2p1c3RqYXZhYy5jb20vMjAxNS8xMi8wOS9pbmhlcml0YW5jZS1hbmQtdGhlLXByb3RvdHlwZS1jaGFpbi5odG1s\">JavaScript：继承和原型链(译) —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9zaHVpeWkvcC81MzA1NDM1Lmh0bWw=\">三张图搞懂 JavaScript 的原型对象与原型链 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9fYXBvbGxvL2FydGljbGUvZGV0YWlscy83Njc3NDY5OA==\">一张图让你搞懂 JavaScript 的继承与原型链 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW90YW9fY3NzL2FydGljbGUvZGV0YWlscy83Mjc4MjQxNg==\">JS 高级–原型链(一看就懂，但 18 岁以下请绕道) —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5NzAxMzQwNWFiZmI3ZjBlMTkwNGEwNGJhNjg5OGEzODRiMWU5MjUwMDA=\">原型继承 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGY5NGM5YmIxMjNkYjQxMTk1MzY5MWI=\">JS 原型链与继承别再被问倒了 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg4NWRiMjIxYjY5ZTYwMDU5MjI1M2U3\">征服 JavaScript 面试系列：类继承和原型继承的区别 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21xeXFpbmdmZW5nL0Jsb2cvaXNzdWVzLzI=\">JavaScript 深入之从原型到原型链 —— 冴羽</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2Z1cGVuZzE5ODgvcC8zOTc3OTI0Lmh0bWw=\">深入理解 JavaScript 原型与闭包 —— 王福朋</span></li>\n</ul>\n<h3 id=\"视频-12\"><a href=\"#视频-12\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NTUyNzUzLmh0bWw=\">JS 高级-07-原型链继承 —— 乐视</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly92LnFxLmNvbS94L3BhZ2UvYjA1MTFud2E3ZDMuaHRtbA==\">JS 原型对象和原型链简介 —— 腾讯视频</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"24-Object-create-和-Object-assign\"><a href=\"#24-Object-create-和-Object-assign\" class=\"headerlink\" title=\"24. Object.create 和 Object.assign\"></a>24. Object.create 和 Object.assign</h2><h3 id=\"文章-23\"><a href=\"#文章-23\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZQ==\">Object.create —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbg==\">Object.assign —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2FydGljbGUvMTc1OTE=\">Object.create vs Object.assign —— 慕课网手记</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlZXBMaWVzL2FydGljbGUvZGV0YWlscy81MjkxNTE0Mw==\">JS 中的 Object.assign()、Object.create()、Object.defineProperty() —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NhaWtvam9zaC9PYmplY3QtQXNzaWduLURlZXA=\">Object-Assign-Deep —— github</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"25-工厂函数和类\"><a href=\"#25-工厂函数和类\" class=\"headerlink\" title=\"25. 工厂函数和类\"></a>25. 工厂函数和类</h2><h3 id=\"文章-24\"><a href=\"#文章-24\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvQ2xhc3Nlcw==\">类 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxMzc0NzM4MTI1MDk1Yzk1NWMxZTZkOGJiNDkzMTgyMTAzZmFjOTI3MDc2MmEwMDAvMDAxMzg2ODIwMDQwNzczNzZkMmQ3ZjhjYzhhNGUyYzk5ODJmOTI3ODg1ODgzMjIwMDA=\">类和实例 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDcvdGhyZWVfd2F5c190b19kZWZpbmVfYV9qYXZhc2NyaXB0X2NsYXNzLmh0bWw=\">Javascript 定义类（class）的三种方法 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWM4Yzg3NTZmYjlhMDBhNjgxYWU1YmQ=\">【译】ES6 的工厂函数 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg3OTkyYzk2MWZmNGIwMDY1ZWRmMWZm\">JavaScript 创建对象之单例、工厂、构造函数模式 —— 掘金</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"26-设计模式\"><a href=\"#26-设计模式\" class=\"headerlink\" title=\"26. 设计模式\"></a>26. 设计模式</h2><h3 id=\"文章-25\"><a href=\"#文章-25\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWRmNGY3NGYyNjVkYTQzMGYzMTE5MDk=\">JavaScript 设计模式 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3dpa2kuamlrZXh1ZXl1YW4uY29tL3Byb2plY3QvamF2YXNjcmlwdC1kZXNpZ24tcGF0dGVybnMv\">学用 JavaScript 设计模式 —— 极客学院</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMDkxNDAzMg==\">[面试专题]JS 设计模式 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2x4ai9qYXZhc2NyaXB0LnBhdHRlcm5z\">JavaScript Patterns 中译本 —— github</span></li>\n</ul>\n<h3 id=\"视频-13\"><a href=\"#视频-13\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly90di5zb2h1LmNvbS92L2RYTXZNalF3TnpZd056UTRMemc1TnpNMk1EQTNMbk5vZEcxcy5odG1s\">HTML5 课程大纲 2-11JS 设计模式</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"27-Memoization\"><a href=\"#27-Memoization\" class=\"headerlink\" title=\"27. Memoization\"></a>27. Memoization</h2><h3 id=\"文章-26\"><a href=\"#文章-26\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcnVieWxvdXZyZS9hcmNoaXZlLzIwMDkvMDgvMDYvMTU0MDY3OC5odG1s\">JavaScript Memoization —— 司徒正美</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWluZ3NodWl6eS9wLzQ1MTcxMDIuaHRtbA==\">memoization 提升递归效率 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2RldmVsb3Blci41MWN0by5jb20vYXJ0LzIwMTAxMC8yMzE1MTMuaHRt\">如何提升 JavaScript 的递归效率 —— 51CTO</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNjcwMzEwNg==\">JavaScript 高级技巧 Memoization —— SegmentFaut</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"28-纯函数-函数副作用和状态变化\"><a href=\"#28-纯函数-函数副作用和状态变化\" class=\"headerlink\" title=\"28. 纯函数, 函数副作用和状态变化\"></a>28. 纯函数, 函数副作用和状态变化</h2><h3 id=\"文章-27\"><a href=\"#文章-27\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2h1emlrZXRhbmcubWFuZ29qdWljZS50b3AvYm9va3MvcmVhY3QvbGVzc29uMzI=\">纯函数(Pure Function) —— React.js 小书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9uaW5naGFvLm5ldC9ibG9nLzQ2MzQ=\">JavaScript Functional Programming：纯函数 —— 宁皓网</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yODA3OS5odG0=\">js 函数的副作用分析 —— 脚本之家</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjgyYmRiMzUxODgyNTQyZTI0MWVkMzI/dXRtX21lZGl1bT1oYW8uY2FpYmFvamlhbi5jb20mdXRtX3NvdXJjZT1oYW8uY2FpYmFvamlhbi5jb20=\">如何使用纯函数式 JavaScript 处理脏副作用 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS96aGFuZ3ljdW4vcC85NDAzMzM1Lmh0bWw=\">原生 JavaScript 实现 state 状态管理系统 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0J1cHRTdEV2ZS9ibG9nL2lzc3Vlcy8xMA==\">JavaScript 函数式编程 —— @BuptStEve</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"29-耗性能操作和时间复杂度\"><a href=\"#29-耗性能操作和时间复杂度\" class=\"headerlink\" title=\"29. 耗性能操作和时间复杂度\"></a>29. 耗性能操作和时间复杂度</h2><h3 id=\"文章-28\"><a href=\"#文章-28\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTkzZjU2NTI4ZDZkODEwMDU4YTM1NWY0\">时间复杂度 O(log n) 意味着什么？ —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWE0OWY3ZDM2ZmI5YTA0NTBhNjdiMjY5\">算法的时间复杂度和空间复杂度 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGQxNWYxMDQ0ZDkwNDAwNjkxODM0ZDQ=\">算法（一）时间复杂度 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5icmFkb25jb2RlLmNvbS9ibG9nLzIwMTIvMDQvYmlnLW8tYWxnb3JpdGhtLWV4YW1wbGVzLWluLWphdmFzY3JpcHQuaHRtbA==\">Big O Search Algorithms in JavaScript —— Bradley Braithwaite</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamVubmlmZXJibGFuZC5jb20vdGltZS1jb21wbGV4aXR5LWFuYWx5c2lzLWluLWphdmFzY3JpcHQv\">Time Complexity Analysis in JavaScript — Jennifer Bland</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"30-JavaScript-引擎\"><a href=\"#30-JavaScript-引擎\" class=\"headerlink\" title=\"30. JavaScript 引擎\"></a>30. JavaScript 引擎</h2><h3 id=\"文章-29\"><a href=\"#文章-29\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9qYXZhc2NyaXB0JUU1JUJDJTk1JUU2JTkzJThFLzUzNTYxMDg=\">javascript 引擎 —— 百度百科</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9WOC82MTc4MTI1\">V8(JavaScript 引擎) —— 百度百科</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTYzMDlmNzZmYjlhMDFjYWIyODU4YjE=\">图解搞懂 JavaScript 引擎 Event Loop —— 掘金</span>3</li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMDgxOTAyMA==\">V8 JavaScript 引擎：高性能的 ES2015+ —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjgwNjYzNw==\">10 分钟理解 JS 引擎的执行机制 —— SegmentFaut</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2VpcmRvUWkvcC82NjA5ODExLmh0bWw=\">V8 javascript 引擎 —— 博客园</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"31-二进制-十六进制-十进制-科学记数法\"><a href=\"#31-二进制-十六进制-十进制-科学记数法\" class=\"headerlink\" title=\"31. 二进制, 十六进制, 十进制, 科学记数法\"></a>31. 二进制, 十六进制, 十进制, 科学记数法</h2><h3 id=\"文章-30\"><a href=\"#文章-30\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9nYWl6YWkvcC80MjMzNzgwLmh0bWw=\">二、八、十、十六进制转换(图解篇) —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjkzZGFkYWYyNjVkYTBhODU3YTU4YTM=\">JavaScript 读写二进制数据 —— 掘金</span></li>\n</ul>\n<h3 id=\"视频-14\"><a href=\"#视频-14\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL2JhaXNoaS5iYWlkdS5jb20vd2F0Y2gvNzg3MzA2MDk2MzQ3MTQ3ODQ1Ni5odG1s\">二进制、十进制、十六进制互相转化很难吗？ —— 百度视频</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"32-偏函数-柯里化-Compose-和-Pipe\"><a href=\"#32-偏函数-柯里化-Compose-和-Pipe\" class=\"headerlink\" title=\"32. 偏函数, 柯里化, Compose 和 Pipe\"></a>32. 偏函数, 柯里化, Compose 和 Pipe</h2><h3 id=\"文章-31\"><a href=\"#文章-31\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTI5MDYzL2FydGljbGUvZGV0YWlscy84MTg3NDMxNA==\">Javascript 函数式编程之偏函数 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMDY4NjE0NA==\">JavaScript 专题之偏函数 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwODYyNjA1OA==\">柯里化和偏函数有什么区别？ —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld2Vhc3RzdW4vYXJ0aWNsZS9kZXRhaWxzLzc1OTQ3Nzg1\">Javascript 偏函数与柯里化 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sbGg5MTEwMDEuZ2l0Ym9va3MuaW8vbW9zdGx5LWFkZXF1YXRlLWd1aWRlLWNoaW5lc2UvY29udGVudC9jaDQuaHRtbA==\">柯里化(curry) —— JS 函数式编程指南</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sbGg5MTEwMDEuZ2l0Ym9va3MuaW8vbW9zdGx5LWFkZXF1YXRlLWd1aWRlLWNoaW5lc2UvY29udGVudC9jaDUuaHRtbA==\">代码组合(compose) —— JS 函数式编程指南</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODM5NDc0OQ==\">关于 javascript 函数式编程中 compose 的实现 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTQ0NzE2NA==\">实现 compose 的五种思路 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTEwMjgwNA==\">JavaScript 函数式编程之函数组合函数 compose 和 pipe 的实现 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWE2MmYzZDZmYjlhMDI0ODM2M2ZkOWQjY29tbWVudA==\">JavaScript 轻量级函数式编程-第 4 章:组合函数 ——掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0J1cHRTdEV2ZS9ibG9nL2lzc3Vlcy8xMQ==\">JavaScript 函数式编程（二） —— @BuptStEve</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"33-代码整洁之道\"><a href=\"#33-代码整洁之道\" class=\"headerlink\" title=\"33. 代码整洁之道\"></a>33. 代码整洁之道</h2><h3 id=\"文章-32\"><a href=\"#文章-32\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemNmeS5jYy9hcnRpY2xlL2NsZWFuLWNvZGUtamF2YXNjcmlwdC1yZWFkbWUtbWQtYXQtbWFzdGVyLXJ5YW5tY2Rlcm1vdHQtY2xlYW4tY29kZS1qYXZhc2NyaXB0LWdpdGh1Yi0yMjczLmh0bWw=\">[译] JavaScript 代码整洁之道 —— 边城</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDQvamF2YXNjcmlwdF9wcm9ncmFtbWluZ19zdHlsZS5odG1s\">Javascript 编程风格 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTViMmE1YzZmYjlhMDFjYmM2ZTU5Zjk=\">重构 - 代码整洁之道 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTdkNzE4MzZmYjlhMDYzNDM1ZWNmNTE=\">让你的代码更简短，更整洁，更易读的 ES6 小技巧 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMjM2MTcv\">Web 前端：11 个让你代码整洁的原则 —— 伯乐在线</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3J5YW5tY2Rlcm1vdHQvY2xlYW4tY29kZS1qYXZhc2NyaXB0\">Clean Code concepts adapted for JavaScript —— ryanmcdermott</span></li>\n</ul>\n<br>\n\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n","categories":["JS"],"tags":["JS","概念"]},{"title":"Blob","url":"/2023/12/07/Blob/","content":"<h1 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob:\"></a>Blob:</h1><p>Blob（Binary Large Object）对象是 JavaScript 中用来表示二进制数据的对象，通常用于存储和操作文件或其他类型的二进制数据。Blob 对象可以表示大型数据对象，比如图像、视频、音频文件等。</p>\n<p>Blob 对象通常由两部分组成：数据和数据的类型。数据部分包含实际的二进制数据，而类型部分描述了数据的 MIME 类型，例如 “image&#x2F;png” 或 “application&#x2F;pdf”。</p>\n<p>Blob 对象可以通过 new Blob() 构造函数创建，传入一个数组作为参数，数组中包含要存储的二进制数据。另外，你还可以通过传入一个可选的对象参数，来指定数据的 MIME 类型。例如：</p>\n<pre><code class=\"js\">javascriptCopy Codevar binaryData = [0x48, 0x65, 0x6c, 0x6c, 0x6f]; // 用十六进制表示的字符串 &quot;Hello&quot;\nvar blob = new Blob([binaryData], &#123; type: &quot;text/plain&quot; &#125;);\n</code></pre>\n<p>在上面的例子中，我们使用 new Blob() 创建了一个包含 “Hello” 文本数据的 Blob 对象，并指定了它的 MIME 类型为 “text&#x2F;plain”。</p>\n<p>Blob 对象可以被用于多种用途，比如：</p>\n<p>通过 URL.createObjectURL() 方法创建一个临时的 URL，用于在页面中显示或下载文件,一般配置a标签（download属性）。<br>作为 XMLHttpRequest 的响应数据类型，用于接收和处理文件或二进制数据。<br>作为 FormData 对象的值，用于将二进制数据发送到服务器。<br>总之，Blob 对象在 JavaScript 中提供了一种方便的方式来处理和操作二进制数据，特别适合于文件操作和网络通信中的数据传输</p>\n","categories":["JS"],"tags":["JS","Blob"]},{"title":"Blob、File和FileReader","url":"/2024/05/17/Blob%E5%92%8CFile/","content":"<h1 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h1><p>Blob的全称为：binary larget object（二进制大对象），blob的本质是一个js对象，里面可以存储大量的二进制编码的数据。</p>\n<h3 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h3><ul>\n<li>不可修改</li>\n<li>只能使用FileReader读取内容</li>\n<li>存储大量二进制数据的 js 对象</li>\n</ul>\n<h3 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p><strong>new Blob(array,options)</strong></p>\n<ul>\n<li><p>array是由ArrayBuffer、ArrayBufferView、Blob和DOMString对象构成的，将对被放进blob中</p>\n</li>\n<li><p>options配置项有：</p>\n<ul>\n<li><p>type：默认值为：” “，表示将会被放入到blob中的数组内容的MIME类型。</p>\n</li>\n<li><p>endings：默认值为：”transparent“，用于指定包含行结束符\\n的字符串如何被写入，不常用。</p>\n<table>\n<thead>\n<tr>\n<th>MIME类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>text&#x2F;plain</td>\n<td>纯文本文档</td>\n</tr>\n<tr>\n<td>text&#x2F;html</td>\n<td>HTML文档</td>\n</tr>\n<tr>\n<td>text&#x2F;javascript</td>\n<td>JavaScript文档</td>\n</tr>\n<tr>\n<td>text&#x2F;css</td>\n<td>CSS文件</td>\n</tr>\n<tr>\n<td>application&#x2F;json</td>\n<td>JSON文件</td>\n</tr>\n<tr>\n<td>application&#x2F;pdf</td>\n<td>pdf文件</td>\n</tr>\n<tr>\n<td>application&#x2F;xml</td>\n<td>XML文件</td>\n</tr>\n<tr>\n<td>image&#x2F;jpeg</td>\n<td>JPEG文件</td>\n</tr>\n<tr>\n<td>image&#x2F;png</td>\n<td>PNG文件</td>\n</tr>\n<tr>\n<td>image&#x2F;gif</td>\n<td>GIF文件</td>\n</tr>\n<tr>\n<td>image&#x2F;svg+xml</td>\n<td>SVG+XML文件</td>\n</tr>\n<tr>\n<td>audio&#x2F;mpeg</td>\n<td>MP3文件</td>\n</tr>\n<tr>\n<td>video&#x2F;mpeg</td>\n<td>MP4文件</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"js\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\n</code></pre>\n<h3 id=\"分片：\"><a href=\"#分片：\" class=\"headerlink\" title=\"分片：\"></a>分片：</h3><p>Blob 对象内置了 slice() 方法用来将 blob 对象分片</p>\n<p>其有三个参数：</p>\n<p>start：设置切片的起点，即切片开始位置。默认值为 0，这意味着切片应该从第一个字节开始；</p>\n<p>end：设置切片的结束点，会对该位置之前的数据进行切片。默认值为blob.size；</p>\n<p>contentType：设置新 blob 的 MIME 类型。如果省略 type，则默认为 blob 的原始值。</p>\n<pre><code class=\"js\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\nlet blob1 = blob.slice(0,2,&quot;text/plain&quot;);\n</code></pre>\n<h3 id=\"读取：\"><a href=\"#读取：\" class=\"headerlink\" title=\"读取：\"></a>读取：</h3><p>blob对象只能通过FileReader读取内容。</p>\n<pre><code class=\"js\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\nlet reader = new fileReader();\nreader.readAsText(blob);\nconsole.log(reader.result);\n</code></pre>\n<h1 id=\"File\"><a href=\"#File\" class=\"headerlink\" title=\"File\"></a>File</h1><h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>File对象是特殊的Blob对象。是基于Blob对象的进一步封装，js中主要有两种方式获得FIle对象：</p>\n<ol>\n<li>input元素选择后返回的FileList对象（通过change事件的event.target.files获取）</li>\n<li>文件拖放操作生成的DataTransfer对象（通过ondrop事件的event.dataTransfer.files获取）</li>\n</ol>\n<h1 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h1><h3 id=\"介绍：-1\"><a href=\"#介绍：-1\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>FileReader用于读取Blob对象（包含File对象）内容的方法，通过result属性获取。</p>\n<ul>\n<li><p>readAsArrayBuffer方法：读取为ArrayBuffer</p>\n</li>\n<li><p>readAsDataURL方法：读取为data:URL的Base64字符串表示文件内容</p>\n</li>\n<li><p>readAsText方法：读取为原始text文件内容</p>\n</li>\n<li><p>readAsBinaryString方法：读取为原始二进制数据</p>\n<p>但是直接使用此方法还是会得到原始的文本内容，因为二进制数据需要使用ArrayBuffer对象来进行处理。</p>\n</li>\n</ul>\n<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h1><h3 id=\"介绍：-2\"><a href=\"#介绍：-2\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>ArrayBuffer可以理解为一个特殊的数组，其本身是一个黑盒，不能直接读写所存储的数据，需要借助视图对象来读写。它只是一个用于存储二进制数据的缓冲区，创建时只能传一个空间大小biteLength。</p>\n<p><strong>读写ArrayBuffer的方式：</strong></p>\n<ol>\n<li>TypedArray</li>\n<li>DataView</li>\n<li>TextDecoder</li>\n<li>用Blob存储，然后用FileReader读写</li>\n</ol>\n<h3 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><p>ArrayBuffer提供了一个slice方法用于切片。参数为：开始位置，结束位置和解析类型。</p>\n<h3 id=\"使用：-1\"><a href=\"#使用：-1\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"js\">const buffer = new ArrayBuffer(32);\nbuffer.slice(0,4,&#39;text/plain&#39;);\n</code></pre>\n<h1 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h1><p>TypedArray只是一个概念，提供了一种机制来解读ArrayBuffer中的数据（相当于一个视图，将ArrayBuffer中的数据进行展示和操作），实际上是那九个类型对象（每个类型对应一个特定的数据类型和大小）：</p>\n<ul>\n<li><code>Int8Array</code>：8位有符号整数</li>\n<li><code>Uint8Array</code>：8位无符号整数</li>\n<li><code>Int16Array</code>：16位有符号整数</li>\n<li><code>Uint16Array</code>：16位无符号整数</li>\n<li><code>Int32Array</code>：32位有符号整数</li>\n<li><code>Uint32Array</code>：32位无符号整数</li>\n<li><code>Float32Array</code>：32位浮点数</li>\n<li><code>Float64Array</code>：64位浮点数</li>\n</ul>\n<h3 id=\"使用：-2\"><a href=\"#使用：-2\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"js\">const buffer = new ArrayBuffer(32);\nconst slice = buffer.slice(0,4,&#39;text/plain&#39;);\nconst sliceView = new Int8Array(slice);\nsliceView.set([10,20,30]);\nsliceView.forEach((value,index)=&gt;&#123;\n    console.log(value,index);\n&#125;)\n</code></pre>\n<h1 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h1><h3 id=\"读取：-1\"><a href=\"#读取：-1\" class=\"headerlink\" title=\"读取：\"></a>读取：</h3><p>DataView数据视图可以用于读写buffer,DataView实例提供了许多方法来读取内存，他们呢的参数都是一个字节序号。表示开始读取的字节位置：</p>\n<ul>\n<li>getInt8：读取1个字节，返回一个8位整数</li>\n<li>getUint8：读取1个字节，返回一个无符号8位整数</li>\n<li>getInt16：读取2个字节，返回一个16位整数</li>\n<li>getUnit16：读取2个字节，返回一个无符号16位整数</li>\n<li>getInt32：读取4个字节，返回一个32位整数</li>\n<li>getUnit32：读取4个字节，返回一个无符号32位整数</li>\n<li>getFloat32：读取4个字节，返回一个32位浮点数</li>\n<li>getUnit64：读取8个字节，返回一个64位浮点数</li>\n</ul>\n<h3 id=\"写入：\"><a href=\"#写入：\" class=\"headerlink\" title=\"写入：\"></a>写入：</h3><p>DataView实例提供以下方法写入内存，他们都接受两个参数，第一个参数表示开始写入数据的字节序号，第二个参数为写入的数据：</p>\n<ul>\n<li>setInt8：写入1个字节的8位整数</li>\n<li>setUint8：写入1个字节的8位无符号整数</li>\n<li>setInt16：写入2个字节的16位整数</li>\n<li>setUint16：写入2个字节的16位无符号整数</li>\n<li>setInt32：写入4个字节的32位整数</li>\n<li>setUnit32：写入4个字节的32位无符号整数</li>\n<li>setFloat32：写入4个字节的32位浮点数</li>\n<li>setFloat64：写入8个自己的64位浮点数</li>\n</ul>\n<h1 id=\"Object-URL\"><a href=\"#Object-URL\" class=\"headerlink\" title=\"Object URL\"></a>Object URL</h1><p>Object URL是一个用于表示File Object或者Blob Object的URL，可以将<strong>Blob对象（包括File对象）</strong>变为一个URL地址。</p>\n<h3 id=\"使用：-3\"><a href=\"#使用：-3\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p>使用URL.createObjectURL来创建。</p>\n<pre><code class=\"js\">const blob = new Blob([&#39;你好世界&#39;],&#123;type:&#39;text/plain&#39;&#125;);\nconst newUrl = URL.createObjectURL(blob);\n</code></pre>\n<h1 id=\"base64编码\"><a href=\"#base64编码\" class=\"headerlink\" title=\"base64编码\"></a>base64编码</h1><h3 id=\"介绍：-3\"><a href=\"#介绍：-3\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>base64是一个保存二进制数据的工具，将多种形式的二进制数据或其构成的文件<strong>以ASCII的形式保存</strong>，因为很多地方不支持直接的二进制文件保存或呈现，比如可以将图片直接转换成base64码嵌入HTML文档中，而避免使用网络http加载图片。另外，将数据编码为 base64 进行传输，然后解码获得数据，可以一定程度上保证数据的完整并且不用在传输过程中修改这些数据，避免在传输过程中可能出现的问题；</p>\n<h3 id=\"组成：\"><a href=\"#组成：\" class=\"headerlink\" title=\"组成：\"></a>组成：</h3><p><code>A-Z a-z 0-9 + /</code> 共64个字符组成;</p>\n<h3 id=\"使用：-4\"><a href=\"#使用：-4\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p>JS中有两个函数用于base64格式（ASCII码）的转换:</p>\n<ul>\n<li><p>btoa()：编码（Binary To ASCII  二进制转ASCII）</p>\n<p>该函数用于将二进制转为Base64字符串（ASCII码）</p>\n</li>\n<li><p>atob()：解码（ASCII To Binary  ASCII码转二进制）</p>\n<p>该函数用于将Base64字符串（ASCII码）解码为二进制</p>\n</li>\n</ul>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>btoa和atob方法有个弊端就是只能处理拉丁字符集内的字符，其不包括中文或非西欧语言的字符（<strong>只能处理单字节字符</strong>）。要处理多字节字符需要使用TextEncoder API将字符串转为Uint8Array，然后手动将这些字节转为一个字符串（String.fromCharCode）。</p>\n<h1 id=\"TextEncoder\"><a href=\"#TextEncoder\" class=\"headerlink\" title=\"TextEncoder\"></a>TextEncoder</h1><h3 id=\"介绍：-4\"><a href=\"#介绍：-4\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>TextEncoder构造函数创建一个编码器，encode方法用于将字符串编码为一个UTF-8编码文本的Uint8Array视图。</p>\n<h3 id=\"使用：-5\"><a href=\"#使用：-5\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"js\">const encoder = new TextEncoder();\nconst view = encoder.encode(&quot;$&quot;);\nconsole.log(view)\n</code></pre>\n","categories":["Blob"],"tags":["Blob","FileReader"]},{"title":"ArrayBuffer","url":"/2023/09/02/ArrayBuffer/","content":"<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer:\"></a>ArrayBuffer:</h1><p>ArrayBuffer 是 JavaScript 中用于表示通用的固定长度的二进制数据缓冲区的对象。它可以在内存中分配一块连续的内存空间，用于存储二进制数据。</p>\n<p>ArrayBuffer 对象本身只是一个占用了一定字节数的内存块，它没有提供直接的方法来读取或写入数据。为了操作 ArrayBuffer 中的数据，我们需要使用不同的视图（如 TypedArray 或 DataView）来读取、写入和操作底层的二进制数据。</p>\n<p>在内存中，ArrayBuffer 对象以连续的字节序列表示。这意味着存储在 ArrayBuffer 中的数据是紧密排列的，没有额外的空隙或填充。每个字节都有一个唯一的地址，我们可以通过偏移量来访问和操作特定位置的字节。</p>\n<p>以下是一个示例，展示了如何创建和使用 ArrayBuffer：</p>\n<pre><code class=\"js\">javascriptCopy Code// 创建一个包含 16 字节的 ArrayBuffer\nconst buffer = new ArrayBuffer(16);\n\n// 使用一个 Int32Array 视图来读取和写入数据\nconst int32Array = new Int32Array(buffer);\n\n// 写入数据\nint32Array[0] = 42;\nint32Array[1] = 99;\n\n// 读取数据\nconsole.log(int32Array[0]); // 输出 42\nconsole.log(int32Array[1]); // 输出 99\n</code></pre>\n<p>在上述示例中，我们创建了一个长度为 16 字节的 ArrayBuffer。然后，我们使用 Int32Array 视图来操作这个 ArrayBuffer，将数据写入到数组中，并通过下标直接访问和读取数据。在内存中，这些数据被紧密排列在连续的字节中。</p>\n<p>需要注意的是，ArrayBuffer 的长度是固定的，一旦分配了特定大小的内存空间，就无法改变它的大小。如果我们需要更改数据的长度，我们需要创建一个新的 ArrayBuffer，并将旧数据拷贝到新的 ArrayBuffer 中。</p>\n<p>总之，ArrayBuffer 提供了一种在 JavaScript 中操作底层二进制数据的机制，它在内存中以连续的字节序列表示，可以用于存储和操作各种类型的二进制数据。</p>\n","categories":["JS"],"tags":["JS","ArrayBuffer"]},{"title":"ES6","url":"/2023/08/02/ES6/","content":"<h2 id=\"ECMAScript-6简介\"><a href=\"#ECMAScript-6简介\" class=\"headerlink\" title=\"ECMAScript 6简介\"></a>ECMAScript 6简介</h2><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n<h2 id=\"let和const命名\"><a href=\"#let和const命名\" class=\"headerlink\" title=\"let和const命名\"></a>let和const命名</h2><h3 id=\"let基本用法-块级作用域\"><a href=\"#let基本用法-块级作用域\" class=\"headerlink\" title=\"let基本用法-块级作用域\"></a>let基本用法-块级作用域</h3><p>在es6中可以使用let声明变量，用法类似于var</p>\n<blockquote>\n<p>⚠️ let声明的变量，只在<code>let</code>命令所在的代码块内有效</p>\n</blockquote>\n<pre><code class=\"js\">&#123;\n    let a = 10;\n    var b = 20;\n&#125;\nconsole.log(a); //a is not defined\nconsole.log(b); //20\n复制代码\n</code></pre>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p><code>var</code>命令会发生<code>变量提升</code>现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>\n<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定在声明后使用，否则报错</p>\n<pre><code class=\"js\">//var的情况\nconsole.log(c);//输出undefined\nvar c = 30;\n\n\n//let的情况\nconsole.log(c);// 报错ReferenceError\nlet c = 30;\n复制代码\n</code></pre>\n<h4 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量</p>\n<pre><code class=\"js\">let c = 10;\nlet c = 30;\nconsole.log(c); //报错\n\nfunction func(arg) &#123;\n  let arg; // 报错\n&#125;\n复制代码\n</code></pre>\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>了解的一个名词，说的就是<code>let</code>和<code>const</code>命令声明变量的特征。</p>\n<p>在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为<code>暂时性死区</code>(temporal dead zone，简称 TDZ)</p>\n<h3 id=\"为什么需要块级作用域？\"><a href=\"#为什么需要块级作用域？\" class=\"headerlink\" title=\"为什么需要块级作用域？\"></a>为什么需要块级作用域？</h3><h4 id=\"原因一：内层变量可能会覆盖外层变量\"><a href=\"#原因一：内层变量可能会覆盖外层变量\" class=\"headerlink\" title=\"原因一：内层变量可能会覆盖外层变量\"></a>原因一：内层变量可能会覆盖外层变量</h4><pre><code class=\"js\">function foo(a)&#123;\n    console.log(a);\n    if(1===2)&#123;\n        var a = &#39;hello 小马哥&#39;;\n    &#125;\n&#125;\nvar a = 10;\nfoo(a);\n复制代码\n</code></pre>\n<h4 id=\"原因二：用来计数的循环遍历泄露为全局变量\"><a href=\"#原因二：用来计数的循环遍历泄露为全局变量\" class=\"headerlink\" title=\"原因二：用来计数的循环遍历泄露为全局变量\"></a>原因二：用来计数的循环遍历泄露为全局变量</h4><pre><code class=\"js\">var arr = []\nfor(var i = 0; i &lt; 10; i++)&#123;\n    arr[i] = function()&#123;\n        return i;\n    &#125;\n&#125;\nconsole.log(arr[5]());\n复制代码\n</code></pre>\n<p>变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，用于变量提升，泄露成了全局变量。</p>\n<p><strong>解决循环计数问题</strong></p>\n<pre><code class=\"js\">//解决方式一：使用闭包\nvar arr = []\nfor(var i = 0; i &lt; 10; i++)&#123;\n    arr[i] = (function(n)&#123;\n        \n        return function()&#123;\n            return n;\n        &#125;\n    &#125;)(i)\n&#125;\n//解决方式二：使用let声明i\n\nvar arr = []\nfor(let i = 0; i &lt; 10; i++)&#123;\n    arr[i] = function () &#123;\n        return i;\n    &#125;\n&#125;\n复制代码\n</code></pre>\n<h3 id=\"const基本用法-声明只读的常量\"><a href=\"#const基本用法-声明只读的常量\" class=\"headerlink\" title=\"const基本用法-声明只读的常量\"></a>const基本用法-声明只读的常量</h3><p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。对于<code>const</code>来说，只声明不赋值，就会报错。</p>\n<pre><code class=\"js\">const a = 10;\na = 20;//报错\n\nconst b; //报错\n复制代码\n</code></pre>\n<h3 id=\"与let命令相同点\"><a href=\"#与let命令相同点\" class=\"headerlink\" title=\"与let命令相同点\"></a>与<code>let</code>命令相同点</h3><ul>\n<li>块级作用域</li>\n<li>暂时性死区</li>\n<li>不可重复声明</li>\n</ul>\n<h3 id=\"let和const使用建议\"><a href=\"#let和const使用建议\" class=\"headerlink\" title=\"let和const使用建议\"></a><code>let</code>和<code>const</code>使用建议</h3><blockquote>\n<p>在默认情况下用const,而只有你在知道变量值需要被修改的情况下使用let</p>\n</blockquote>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>传统的 JavaScript 语言，输出模板通常是这样写的</p>\n<pre><code class=\"js\">const oBox = document.querySelector(&#39;.box&#39;);\n// 模板字符串\nlet id = 1,name = &#39;小马哥&#39;;\nlet htmlTel = &quot;&lt;ul&gt;&lt;li&gt;&lt;p&gt;id:&quot; + id + &quot;&lt;/p&gt;&lt;p&gt;name:&quot; + name + &quot;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&quot;;\noBox.innerHTML = htmlTel;\n复制代码\n</code></pre>\n<p>上面的这种写法相当繁琐不方便,ES6引入了模板字符串解决这个问题</p>\n<pre><code class=\"js\">let htmlTel = `&lt;ul&gt;\n    &lt;li&gt;\n    &lt;p&gt;id:$&#123;id&#125;&lt;/p&gt;\n    &lt;p&gt;name:$&#123;name&#125;&lt;/p&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;`;\n复制代码\n</code></pre>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p>解构赋值是对赋值运算符的一种扩展。它通常针对数组和对象进行操作。</p>\n<blockquote>\n<p>优点：代码书写简洁且易读性高</p>\n</blockquote>\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><p>在以前，为变量赋值，只能直接指定值</p>\n<pre><code class=\"js\">let a = 1;\nlet b = 2;\nlet c = 3;\n复制代码\n</code></pre>\n<p>ES6允许我们这样写:</p>\n<pre><code class=\"js\">let [a,b,c] = [1,2,3];\n复制代码\n</code></pre>\n<blockquote>\n<p>如果解构不成功，变量的值就等于<code>undefined</code></p>\n</blockquote>\n<pre><code class=\"js\">let [foo] = [];\nlet [bar, foo] = [1];\n复制代码\nfoo`的值都会等于`undefined\n</code></pre>\n<h3 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h3><p>解构可以用于对象</p>\n<pre><code class=\"bash\">let node = &#123;\n    type:&#39;identifier&#39;,\n    name:&#39;foo&#39;\n&#125;\n\nlet &#123;type,name&#125; = node;\nconsole.log(type,name)//identifier foo\n复制代码\n</code></pre>\n<p>对象的解构赋值时，可以对属性忽略和使用剩余运算符</p>\n<pre><code class=\"css\">let obj = &#123;\n    a:&#123;\n        name:&#39;张三&#39;\n    &#125;,\n    b:[],\n    c:&#39;hello world&#39;\n&#125;\n//可忽略 忽略b,c属性\nlet &#123;a&#125; = obj;\n//剩余运算符 使用此法将其它属性展开到一个对象中存储\nlet &#123;a,...res&#125; = obj;\nconsole.log(a,res);\n复制代码\n</code></pre>\n<p><strong>默认值</strong></p>\n<pre><code class=\"css\">let &#123;a,b = 10&#125; = &#123;a:20&#125;;\n复制代码\n</code></pre>\n<h3 id=\"函数参数解构赋值\"><a href=\"#函数参数解构赋值\" class=\"headerlink\" title=\"函数参数解构赋值\"></a>函数参数解构赋值</h3><p>直接看例子</p>\n<pre><code class=\"js\">function add([x, y])&#123;\n  return x + y;\n&#125;\n\nadd([1, 2]); // 3\n复制代码\n</code></pre>\n<p>使用默认值</p>\n<pre><code class=\"js\">function addCart(n,num=0)&#123;\n    \n    return n+num;\n&#125;\naddCart(10);//10\naddCart(10,20); //30\n复制代码\n</code></pre>\n<h3 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h3><ul>\n<li><p>交换变量的值</p>\n<pre><code class=\"js\">let x = 1;\nlet y = 2;\nlet [x,y] = [y,x];\n复制代码\n</code></pre>\n<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>\n</li>\n<li><p>从函数返回多个值</p>\n<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>\n<pre><code class=\"js\">// 返回一个数组\n\nfunction example() &#123;\n  return [1, 2, 3];\n&#125;\nlet [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() &#123;\n  return &#123;\n    foo: 1,\n    bar: 2\n  &#125;;\n&#125;\nlet &#123; foo, bar &#125; = example();\n复制代码\n</code></pre>\n</li>\n<li><p>函数参数的定义</p>\n<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>\n<pre><code class=\"js\">// 参数是一组有次序的值\nfunction f([x, y, z]) &#123; ... &#125;\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f(&#123;x, y, z&#125;) &#123; ... &#125;\nf(&#123;z: 3, y: 2, x: 1&#125;);\n复制代码\n</code></pre>\n</li>\n<li><p>提取JSON数据</p>\n<p>解构赋值对提取 JSON 对象中的数据，尤其有用</p>\n<pre><code class=\"typescript\">let jsonData = &#123;\n  id: 42,\n  status: &quot;OK&quot;,\n  data: [867, 5309]\n&#125;;\n\nlet &#123; id, status, data: number &#125; = jsonData;\n//对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者\nconsole.log(id, status, number);\n// 42, &quot;OK&quot;, [867, 5309]\n复制代码\n</code></pre>\n</li>\n<li><p>函数参数的默认值</p>\n</li>\n<li><p>输入模块的指定方法</p>\n<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>\n<pre><code class=\"scss\">const &#123;ajax&#125; = require(&#39;xxx&#39;)\n\najax()\n复制代码\n</code></pre>\n</li>\n</ul>\n<h2 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h2><h3 id=\"带参数默认值的函数\"><a href=\"#带参数默认值的函数\" class=\"headerlink\" title=\"带参数默认值的函数\"></a>带参数默认值的函数</h3><p>ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法</p>\n<pre><code class=\"bash\">function log(x,y)&#123;\n    y = y || &#39;world&#39;;\n    console.log(x,y);\n&#125;\nlog(&#39;hello&#39;);//hello world\nlog(&#39;hello&#39;,&#39;china&#39;) //hello china\nlog(&#39;hello&#39;,&#39;&#39;)//hello world\n复制代码\n</code></pre>\n<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<pre><code class=\"arduino\">function log(x, y = &#39;World&#39;) &#123;\n  console.log(x, y);\n&#125;\n\nlog(&#39;Hello&#39;) // Hello World\nlog(&#39;Hello&#39;, &#39;China&#39;) // Hello China\nlog(&#39;Hello&#39;, &#39;&#39;) // Hello\n复制代码\n</code></pre>\n<blockquote>\n<p>ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>\n</blockquote>\n<p><strong>默认的表达式可以是一个函数</strong></p>\n<pre><code class=\"javascript\">function getVal(val) &#123;\n    return val + 5;\n&#125;\nfunction add2(a, b = getVal(5)) &#123;\n    return a + b;\n&#125;\nconsole.log(add2(10));\n复制代码\n</code></pre>\n<p><strong>小练习</strong></p>\n<p>请问下面两种写法有什么区别？</p>\n<pre><code class=\"javascript\">// 写法一\nfunction m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;\n  return [x, y];\n&#125;\n\n// 写法二\nfunction m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;\n  return [x, y];\n&#125;\n复制代码\n</code></pre>\n<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>\n<pre><code class=\"scss\">// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n\n// x 和 y 都有值的情况\nm1(&#123;x: 3, y: 8&#125;) // [3, 8]\nm2(&#123;x: 3, y: 8&#125;) // [3, 8]\n\n// x 有值，y 无值的情况\nm1(&#123;x: 3&#125;) // [3, 0]\nm2(&#123;x: 3&#125;) // [3, undefined]\n\n// x 和 y 都无值的情况\nm1(&#123;&#125;) // [0, 0];\nm2(&#123;&#125;) // [undefined, undefined]\n\nm1(&#123;z: 3&#125;) // [0, 0]\nm2(&#123;z: 3&#125;) // [undefined, undefined]\n复制代码\n</code></pre>\n<h3 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h3><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>\n<pre><code class=\"bash\">function add(...values) &#123;\n \n  let sum = 0;\n\n  for (var val of values) &#123;\n    sum += val;\n  &#125;\n\n  return sum;\n&#125;\n\nadd(2, 5, 3) // 10\n复制代码\n</code></pre>\n<p>上面代码的<code>add</code>函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数 ***\"></a>箭头函数 ***</h3><p>ES6允许使用箭头<code>=&gt;</code>定义函数</p>\n<pre><code class=\"js\">let f = v=&gt;v;\n//等同于\nlet f = function(v)&#123;\n    return v;\n&#125;\n\n// 有一个参数\nlet add = value =&gt; value;\n\n// 有两个参数\nlet add = (value,value2) =&gt; value + value2;\n\nlet add = (value1,value2)=&gt;&#123;\n    \n    return value1 + value2;\n&#125; \n// 无参数\nlet fn = () =&gt; &quot;hello world&quot;;\n\nlet doThing = () =&gt; &#123;\n\n&#125;\n//如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\nlet getId = id =&gt; (&#123;id: id,name: &#39;mjj&#39;&#125;) //注意\nlet obj = getId(1);\n复制代码\n</code></pre>\n<h3 id=\"箭头函数的作用\"><a href=\"#箭头函数的作用\" class=\"headerlink\" title=\"箭头函数的作用\"></a>箭头函数的作用</h3><ul>\n<li><p>使表达更加简洁</p>\n<pre><code class=\"js\">const isEven = n =&gt; n % 2 == 0;\nconst square = n =&gt; n * n;\n复制代码\n</code></pre>\n</li>\n<li><p>简化回调函数</p>\n<pre><code class=\"ini\">// 正常函数写法\n[1,2,3].map(function (x) &#123;\n  return x * x;\n&#125;);\n\n// 箭头函数写法\n[1,2,3].map(x =&gt; x * x);\n复制代码\n</code></pre>\n</li>\n</ul>\n<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><ul>\n<li><p>没有this绑定</p>\n<pre><code class=\"javascript\">let PageHandler = &#123;\n    id:123,\n    init:function()&#123;\n        document.addEventListener(&#39;click&#39;,function(event) &#123;\n            this.doSomeThings(event.type);\n        &#125;,false);\n    &#125;,\n    doSomeThings:function(type)&#123;\n        console.log(`事件类型:$&#123;type&#125;,当前id:$&#123;this.id&#125;`);\n    &#125;\n&#125;\nPageHandler.init();\n\n//解决this指向问题\nlet PageHandler = &#123;\n    id: 123,\n    init: function () &#123;\n        // 使用bind来改变内部函数this的指向\n        document.addEventListener(&#39;click&#39;, function (event) &#123;\n            this.doSomeThings(event.type);\n        &#125;.bind(this), false);\n    &#125;,\n    doSomeThings: function (type) &#123;\n        console.log(`事件类型:$&#123;type&#125;,当前id:$&#123;this.id&#125;`);\n    &#125;\n&#125;\nPageHandler.init();\n\nlet PageHandler = &#123;\n    id: 123,\n    init: function () &#123;\n        // 箭头函数没有this的指向，箭头函数内部的this值只能通过查找作用域链来确定\n\n        // 如果箭头函数被一个非箭头函数所包括，那么this的值与该函数的所属对象相等，否则 则是全局的window对象\n        document.addEventListener(&#39;click&#39;, (event) =&gt; &#123;\n            console.log(this);\n            this.doSomeThings(event.type);\n        &#125;, false);\n    &#125;,\n    doSomeThings: function (type) &#123;\n        console.log(`事件类型:$&#123;type&#125;,当前id:$&#123;this.id&#125;`);\n    &#125;\n&#125;\nPageHandler.init();\n复制代码\n</code></pre>\n</li>\n<li><p>箭头函数中没有arguments对象</p>\n<pre><code class=\"javascript\">var getVal = (a,b) =&gt; &#123;\n    console.log(arguments);\n    return a + b;\n&#125;\nconsole.log(getVal(1,2)); //arguments is not defined\n复制代码\n</code></pre>\n</li>\n<li><p>箭头函数不能使用new关键字来实例化对象</p>\n<pre><code class=\"ini\">let Person = ()=&gt;&#123;&#125;\nlet p1 = new Person();// Person is not a constructor\n复制代码\n</code></pre>\n</li>\n</ul>\n<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a>对象的扩展</h2><h3 id=\"属性的简洁表示法\"><a href=\"#属性的简洁表示法\" class=\"headerlink\" title=\"属性的简洁表示法\"></a>属性的简洁表示法</h3><pre><code class=\"js\">const name = &#39;张三&#39;;\nconst age = 19;\nconst person = &#123;\n    name, //等同于name:name\n    age,\n    // 方法也可以简写\n    sayName() &#123;\n        console.log(this.name);\n    &#125;\n&#125;\nperson.sayName();\n</code></pre>\n<p>这种写法用于函数的返回值，将会非常方便。</p>\n<pre><code class=\"ini\">function getPoint() &#123;\n  const x = 1;\n  const y = 10;\n  return &#123;x, y&#125;;\n&#125;\n\ngetPoint()\n// &#123;x:1, y:10&#125;\n复制代码\n</code></pre>\n<h4 id=\"对象扩展运算符\"><a href=\"#对象扩展运算符\" class=\"headerlink\" title=\"对象扩展运算符\"></a>对象扩展运算符</h4><pre><code class=\"less\">const [a, ...b] = [1, 2, 3];\na // 1\nb // [2, 3]\n复制代码\n</code></pre>\n<h4 id=\"解构赋值-1\"><a href=\"#解构赋值-1\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>\n<pre><code class=\"yaml\">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;\nx // 1\ny // 2\nz // &#123; a: 3, b: 4 &#125;\n复制代码\n</code></pre>\n<blockquote>\n<p>解构赋值必须是最后一个参数，否则会报错</p>\n<pre><code class=\"csharp\">let &#123; ...x, y, z &#125; = obj; // 句法错误\nlet &#123; x, ...y, ...z &#125; = obj; // 句法错误\n复制代码\n</code></pre>\n</blockquote>\n<h3 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h3><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<pre><code class=\"ini\">let z = &#123; a: 3, b: 4 &#125;;\nlet n = &#123; ...z &#125;;\nn // &#123; a: 3, b: 4 &#125;\n复制代码\n</code></pre>\n<p>扩展运算符可以用于合并两个对象。</p>\n<pre><code class=\"ini\">let ab = &#123; ...a, ...b &#125;;\n// 等同于\nlet ab = Object.assign(&#123;&#125;, a, b);\n复制代码\n</code></pre>\n<h2 id=\"Promise-对象\"><a href=\"#Promise-对象\" class=\"headerlink\" title=\"Promise 对象\"></a>Promise 对象</h2><p>异步编程模块在前端开发中，显得越来越重要。从最开始的XHR到封装后的Ajax都在试图解决异步编程过程中的问题。随着ES6新标准的到来，处理异步数据流又有了新的解决方案。在传统的ajax请求中，当异步请求之间的数据存在依赖关系的时候，就可能产生不优雅的多层回调，俗称”回调地域“(callback hell)，这却让人望而生畏，Promise的出现让我们告别回调地域，写出更优雅的异步代码。</p>\n<p>回调地狱带来的负面作用有以下几点：</p>\n<ul>\n<li>代码臃肿。</li>\n<li>可读性差。</li>\n<li>耦合度过高，可维护性差。</li>\n<li>代码复用性差。</li>\n<li>容易滋生 bug。</li>\n<li>只能在回调里处理异常。</li>\n</ul>\n<blockquote>\n<p>在实践过程中，却发现Promise并不完美，Async&#x2F;Await是近年来JavaScript添加的最革命性的的特性之一，<strong>Async&#x2F;Await提供了一种使得异步代码看起来像同步代码的替代方法</strong>。接下来我们介绍这两种处理异步编程的方案。</p>\n</blockquote>\n<h3 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是Promise</h3><blockquote>\n<p>Promise 是异步编程的一种解决方案：</p>\n<p>从语法上讲，Promise是一个对象，通过它可以获取异步操作的消息；</p>\n<p>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p>\n<p>promise有三种<strong>状态</strong>：**pending(等待态)，fulfilled(成功态)，rejected(失败态)**；</p>\n<p>状态一旦改变，就不会再变。</p>\n<p>创造promise实例后，它会立即执行。</p>\n</blockquote>\n<p>看段习以为常的代码：</p>\n<pre><code class=\"javascript\">// Promise是一个构造函数，自己身上有all,reject,resolve,race方法，原型上有then、catch等方法\nlet p = new Promise((resolve,reject)=&gt;&#123;\n    // 做一些异步操作\n    setTimeout(()=&gt;&#123;\n    /* \tlet res = &#123;\n            ok:1,\n            data:&#123;\n                name:&quot;张三&quot;\n            &#125;\n        &#125; */\n        let res = &#123;\n            ok:0,\n            error:new Error(&#39;有错&#39;)\n        &#125;\n        if(res.ok === 1)&#123;\n            resolve(res.data);\n        &#125;else&#123;\n            reject(res.error.message)\n        &#125;\n\n    &#125;, 1000)\n&#125;)\n\n复制代码\n</code></pre>\n<h3 id=\"Promise的状态和值\"><a href=\"#Promise的状态和值\" class=\"headerlink\" title=\"Promise的状态和值\"></a>Promise的状态和值</h3><p><code>Promise</code>对象存在以下三种状态</p>\n<ul>\n<li>Pending(进行中)</li>\n<li>Fulfilled(已成功)</li>\n<li>Rejected(已失败)</li>\n</ul>\n<blockquote>\n<p>状态只能由 <code>Pending</code> 变为 <code>Fulfilled</code> 或由 <code>Pending</code> 变为 <code>Rejected</code> ，且状态改变之后不会在发生变化，会一直保持这个状态。</p>\n</blockquote>\n<p><code>Promise</code>的值是指状态改变时传递给回调函数的值</p>\n<p>上面例子中的参数为resolve和reject，他们都是函数，用他们可以改变Promise的状态和传入的Promise的值</p>\n<pre><code>resolve` 和 `reject\n</code></pre>\n<ul>\n<li><code>resolve</code> : 将Promise对象的状态从 <code>Pending(进行中)</code> 变为 <code>Fulfilled(已成功)</code></li>\n<li><code>reject</code> : 将Promise对象的状态从 <code>Pending(进行中)</code> 变为 <code>Rejected(已失败)</code></li>\n<li><code>resolve</code> 和 <code>reject</code> 都可以传入任意类型的值作为实参，表示 <code>Promise</code> 对象成功<code>（Fulfilled）</code>和失败<code>（Rejected）</code>的值</li>\n</ul>\n<h3 id=\"then方法\"><a href=\"#then方法\" class=\"headerlink\" title=\"then方法\"></a>then方法</h3><pre><code class=\"javascript\">p.then((data)=&gt;&#123;\n    console.log(data);\n    return data;\n&#125;,(error)=&gt;&#123;\n    console.log(error)\n&#125;).then(data=&gt;&#123;\n    console.log(data);\n&#125;)\n复制代码\n</code></pre>\n<p>promise的then方法返回一个promise对象，所以可以继续链式调用</p>\n<p>上述代码我们可以继续改造，因为上述代码不能传参</p>\n<pre><code class=\"javascript\">function timeout(ms) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(&#39;hello world&#39;)\n        &#125;, ms);\n    &#125;)\n&#125;\ntimeout(1000).then((value) =&gt; &#123;\n    console.log(value);\n&#125;)\n复制代码\n</code></pre>\n<h3 id=\"then方法的规则\"><a href=\"#then方法的规则\" class=\"headerlink\" title=\"then方法的规则\"></a>then方法的规则</h3><ul>\n<li><code>then</code>方法下一次的输入需要上一次的输出</li>\n<li>如果一个promise执行完后 返回的还是一个promise，会把这个promise 的执行结果，传递给下一次<code>then</code>中</li>\n<li>如果<code>then</code>中返回的不是Promise对象而是一个普通值，则会将这个结果作为下次then的成功的结果</li>\n<li>如果当前<code>then</code>中失败了 会走下一个<code>then</code>的失败</li>\n<li>如果返回的是undefined 不管当前是成功还是失败 都会走下一次的成功</li>\n<li>catch是错误没有处理的情况下才会走</li>\n<li><code>then</code>中不写方法则值会穿透，传入下一个<code>then</code>中</li>\n</ul>\n<h3 id=\"Promise封装XHR对象\"><a href=\"#Promise封装XHR对象\" class=\"headerlink\" title=\"Promise封装XHR对象\"></a>Promise封装XHR对象</h3><pre><code class=\"javascript\">const getJSON = function (url) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        const xhr = new XMLHttpRequest();\n        xhr.open(&#39;GET&#39;, url);\n        xhr.onreadystatechange = handler;\n        xhr.responseType = &#39;json&#39;;\n        xhr.setRequestHeader(&#39;Accept&#39;, &#39;application/json&#39;);\n        xhr.send();\n        function handler() &#123;\n            console.log(this.readyState);\n            if (this.readyState !== 4) &#123;\n                return;\n            &#125;\n            if (this.status === 200) &#123;\n                resolve(this.response);\n            &#125; else &#123;\n                reject(new Error(this.statusText));\n            &#125;\n        &#125;\n    &#125;)\n&#125;\ngetJSON(&#39;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#39;)\n    .then((res) =&gt; &#123;\n    console.log(res);\n\n&#125;, function (error) &#123;\n    console.error(error);\n\n&#125;)\n\n//then方法的链式调用\ngetJSON(&#39;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#39;)\n    .then((res)=&gt;&#123;\n    return res.HeWeather6;\n&#125;).then((HeWeather6)=&gt;&#123;\n    console.log(HeWeather6);\n&#125;)\n复制代码\n</code></pre>\n<h3 id=\"catch方法\"><a href=\"#catch方法\" class=\"headerlink\" title=\"catch方法\"></a>catch方法</h3><blockquote>\n<p>then里面第二个参数捕捉错误只能捕捉上级的 不能捕捉同级的第一个参数里的错误 所以要用catch</p>\n</blockquote>\n<pre><code>catch(err=&gt;&#123;&#125;)`方法等价于`then(null,err=&gt;&#123;&#125;)\ngetJSON(&#39;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#39;)\n    .then((json) =&gt; &#123;\n    console.log(json);\n&#125;).then(null,err=&gt;&#123;\n    console.log(err);   \n&#125;)\n//等价于\ngetJSON(&#39;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#39;)\n    .then((json) =&gt; &#123;\n    console.log(json);\n&#125;).catch(err=&gt;&#123;\n    console.log(err);   \n&#125;)\n复制代码\n</code></pre>\n<h3 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\"resolve()\"></a>resolve()</h3><p><code>resolve()</code>方法将现有对象转换成Promise对象，该实例的状态为fulfilled</p>\n<pre><code class=\"js\">let p = Promise.resolve(&#39;foo&#39;);\n//等价于 new Promise(resolve=&gt;resolve(&#39;foo&#39;));\np.then((val)=&gt;&#123;\n    console.log(val);\n&#125;)\n复制代码\n</code></pre>\n<h3 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\"reject()\"></a>reject()</h3><p><code>reject()</code>方法返回一个新的Promise实例，该实例的状态为rejected</p>\n<pre><code class=\"vbnet\">let p2 = Promise.reject(new Error(&#39;出错了&#39;));\n//等价于 let p2 = new Promise((resolve,reject)=&gt;reject(new Error(&#39;出错了)));\np2.catch(err =&gt; &#123;\n    console.log(err);\n&#125;)\n复制代码\n</code></pre>\n<h3 id=\"all-方法\"><a href=\"#all-方法\" class=\"headerlink\" title=\"all()方法\"></a>all()方法</h3><p>all()方法提供了并行执行异步操作的能力，并且再所有异步操作执行完后才执行回调</p>\n<p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all实现如下</p>\n<pre><code class=\"javascript\">let meInfoPro = new Promise( (resolve, reject)=&gt; &#123;\n    setTimeout(resolve, 500, &#39;P1&#39;);\n&#125;);\nlet youInfoPro = new Promise( (resolve, reject)=&gt; &#123;\n    setTimeout(resolve, 600, &#39;P2&#39;);\n&#125;);\n// 同时执行p1和p2，并在它们都完成后执行then:\nPromise.all([meInfoPro, youInfoPro]).then( (results)=&gt; &#123;\n    console.log(results); // 获得一个Array: [&#39;P1&#39;, &#39;P2&#39;]\n&#125;);\n</code></pre>\n<h3 id=\"race-方法\"><a href=\"#race-方法\" class=\"headerlink\" title=\"race()方法\"></a>race()方法</h3><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：</p>\n<pre><code class=\"javascript\">let meInfoPro1 = new Promise( (resolve, reject)=&gt; &#123;\n    setTimeout(resolve, 500, &#39;P1&#39;);\n&#125;);\nlet meInfoPro2 = new Promise( (resolve, reject)=&gt; &#123;\n    setTimeout(resolve, 600, &#39;P2&#39;);\n&#125;);\nPromise.race([meInfoPro1, meInfoPro2]).then((result)=&gt; &#123;\n    console.log(result); // P1\n&#125;);\n</code></pre>\n<blockquote>\n<p><strong>Promise.all接受一个promise对象的数组，待全部完成之后，统一执行success</strong>;</p>\n<p><strong>Promise.race接受一个包含多个promise对象的数组，只要有一个完成，就执行success</strong></p>\n</blockquote>\n<p>举个更具体的例子，加深对race()方法的理解</p>\n<p>当我们请求某个图片资源，会导致时间过长，给用户反馈</p>\n<p>用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p>\n<pre><code class=\"javascript\">function requestImg(imgSrc) &#123;\n   return new Promise((resolve, reject) =&gt; &#123;\n        var img = new Image();\n        img.onload = function () &#123;\n            resolve(img);\n        &#125;\n        img.src = imgSrc;\n    &#125;);\n&#125;\n//延时函数，用于给请求计时\nfunction timeout() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            reject(&#39;图片请求超时&#39;);\n        &#125;, 5000);\n    &#125;);\n&#125;\nPromise.race([requestImg(&#39;images/2.png&#39;), timeout()]).then((data) =&gt; &#123;\n    console.log(data);\n&#125;).catch((err) =&gt; &#123;\n    console.log(err);\n&#125;); \n</code></pre>\n<h2 id=\"async-函数\"><a href=\"#async-函数\" class=\"headerlink\" title=\"async 函数\"></a>async 函数</h2><p>异步操作是JavaScript编程的麻烦事，很多人认为async函数是异步编程的解决方案</p>\n<p><span style=\"color:red\">async函数执行返回的结果一定是一个promise</span></p>\n<h3 id=\"Async-x2F-await介绍\"><a href=\"#Async-x2F-await介绍\" class=\"headerlink\" title=\"Async&#x2F;await介绍\"></a>Async&#x2F;await介绍</h3><ul>\n<li>async&#x2F;await是写异步代码的新方式，优于回调函数和Promise。</li>\n<li>async&#x2F;await是基于Promise实现的，它不能用于普通的回调函数。</li>\n<li>async&#x2F;await与Promise一样，是非阻塞的。</li>\n<li>async&#x2F;await使得异步代码看起来像同步代码，再也没有回调函数。但是改变不了JS单线程、异步的本质。(<strong>异步代码同步化</strong>)</li>\n</ul>\n<h3 id=\"Async-x2F-await的使用规则\"><a href=\"#Async-x2F-await的使用规则\" class=\"headerlink\" title=\"Async&#x2F;await的使用规则\"></a>Async&#x2F;await的使用规则</h3><ul>\n<li><p><strong>凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象</strong></p>\n<pre><code class=\"javascript\">async function test() &#123;\n    \n&#125;\n\nlet result = test()\nconsole.log(result)  //即便代码里test函数什么都没返回，我们依然打出了Promise对象\n复制代码\n</code></pre>\n</li>\n<li><p><strong>await必须在async函数里使用，不能单独使用</strong></p>\n<pre><code class=\"javascript\">async test() &#123;\n    let result = await Promise.resolve(&#39;success&#39;)\n    console.log(result)\n&#125;\ntest()\n</code></pre>\n</li>\n<li><p><strong>await后面需要跟Promise对象，不然就没有意义，而且await后面的Promise对象不必写then，因为await的作用之一就是获取后面Promise对象成功状态传递出来的参数。</strong></p>\n<pre><code class=\"javascript\">function fn() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(&#39;success&#39;)\n        &#125;)\n    &#125;)\n&#125;\n\nasync test() &#123;\n    let result = await fn() //因为fn会返回一个Promise对象\n    console.log(result)    //这里会打出Promise成功后传递过来的&#39;success&#39;\n&#125;\n\ntest()\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Async-x2F-Await的用法\"><a href=\"#Async-x2F-Await的用法\" class=\"headerlink\" title=\"Async&#x2F;Await的用法\"></a>Async&#x2F;Await的用法</h3><ul>\n<li>使用await，函数必须用async标识</li>\n<li>await后面跟的是一个Promise实例</li>\n</ul>\n<pre><code class=\"javascript\">function loadImg(src) &#123;\n    const promise = new Promise(function (resolve, reject) &#123;\n        const img = document.createElement(&#39;img&#39;)\n        img.onload = function () &#123;\n            resolve(img)\n        &#125;\n        img.onerror = function () &#123;\n            reject(&#39;图片加载失败&#39;)\n        &#125;\n        img.src = src\n    &#125;)\n    return promise\n&#125;\nconst src1 = &#39;https://hcdn1.luffycity.com/static/frontend/index/banner@2x_1574647618.8112254.png&#39;\nconst src2 = &#39;https://hcdn2.luffycity.com/media/frontend/index/%E7%94%BB%E6%9D%BF.png&#39;\nconst load = async function () &#123;\n    const result1 = await loadImg(src1)\n    console.log(result1)\n    const result2 = await loadImg(src2)\n    console.log(result2)\n&#125;\nload()\n</code></pre>\n<p><strong>当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</strong></p>\n<h3 id=\"async-x2F-await的错误处理\"><a href=\"#async-x2F-await的错误处理\" class=\"headerlink\" title=\"async&#x2F;await的错误处理\"></a>async&#x2F;await的错误处理</h3><p>关于错误处理，如规则三所说，await可以直接获取到后面Promise成功状态传递的参数，但是却捕捉不到失败状态。在这里，我们通过给包裹await的async函数添加then&#x2F;catch方法来解决，因为根据规则一，async函数本身就会返回一个Promise对象。</p>\n<pre><code class=\"javascript\">const load = async function () &#123;\n    try&#123;\n        const result1 = await loadImg(src1)\n        console.log(result1)\n        const result2 = await loadImg(src2)\n        console.log(result2)\n    &#125;catch(err)&#123;\n        console.log(err);\n    &#125;\n&#125;\nload()\n</code></pre>\n<h3 id=\"为什么Async-x2F-Await更好？\"><a href=\"#为什么Async-x2F-Await更好？\" class=\"headerlink\" title=\"为什么Async&#x2F;Await更好？\"></a>为什么Async&#x2F;Await更好？</h3><p>Async&#x2F;Await较Promise有诸多好处，以下介绍其中三种优势：</p>\n<ul>\n<li><p><strong>简洁</strong></p>\n<p>使用Async&#x2F;Await明显节约了不少代码。我们不需要写.then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。</p>\n</li>\n<li><p><strong>中间值</strong></p>\n</li>\n</ul>\n<p>在前端编程中，我们偶尔会遇到这样一个场景：我们需要发送多个请求，而<strong>后面请求的发送总是需要依赖上一个请求返回的数据</strong>。对于这个问题，我们既可以用的Promise的链式调用来解决，也可以用async&#x2F;await来解决，然而后者会更简洁些</p>\n<pre><code class=\"javascript\">const makeRequest = () =&gt; &#123;\n  return promise1()\n    .then(value1 =&gt; &#123;\n      return promise2(value1)\n        .then(value2 =&gt; &#123;        \n          return promise3(value1, value2)\n        &#125;)\n    &#125;)\n&#125;\n复制代码\n</code></pre>\n<p>使用async&#x2F;await的话，代码会变得异常简单和直观</p>\n<pre><code class=\"javascript\">const makeRequest = async () =&gt; &#123;\n  const value1 = await promise1()\n  const value2 = await promise2(value1)\n  return promise3(value1, value2)\n&#125;\n复制代码\n</code></pre>\n<ul>\n<li><strong>提高可读性</strong></li>\n</ul>\n<p>下面示例中，需要获取数据，然后根据返回数据决定是直接返回，还是继续获取更多的数据。</p>\n<pre><code class=\"kotlin\">const makeRequest = () =&gt; &#123;\n  return getJSON()\n    .then(data =&gt; &#123;\n      if (data.needsAnotherRequest) &#123;\n        return makeAnotherRequest(data)\n          .then(moreData =&gt; &#123;\n            console.log(moreData)\n            return moreData\n          &#125;)\n      &#125; else &#123;\n        console.log(data)\n        return data\n      &#125;\n    &#125;)\n&#125;\n复制代码\n</code></pre>\n<p>代码嵌套（6层）可读性较差，它们传达的意思只是需要将最终结果传递到最外层的Promise。使用async&#x2F;await编写可以大大地提高可读性:</p>\n<pre><code class=\"kotlin\">const makeRequest = async () =&gt; &#123;\n  const data = await getJSON()\n  if (data.needsAnotherRequest) &#123;\n    const moreData = await makeAnotherRequest(data);\n    console.log(moreData)\n    return moreData\n  &#125; else &#123;\n    console.log(data)\n    return data    \n  &#125;\n&#125;\n复制代码\n</code></pre>\n<h2 id=\"Class的基本用法\"><a href=\"#Class的基本用法\" class=\"headerlink\" title=\"Class的基本用法\"></a>Class的基本用法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>JavaScript语言中，生成实例对象的传统方法是通过构造函数</p>\n<pre><code class=\"js\">function Person(name,age) &#123;\n    this.name = name;\n    this.age = age;\n&#125;\nPerson.prototype.sayName  = function() &#123;\n    return this.sayName;\n&#125;\nlet p = new Person(&#39;小马哥&#39;,18);\nconsole.log(p);\n</code></pre>\n<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑</p>\n<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p>\n<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样</p>\n<pre><code class=\"kotlin\">class Person &#123;\n    // constructor方法 是类的默认方法,通过new命令生成对象实例时,自动调用该方法,一个类必须有constructor方法,如果没有定义,会被默认添加\n    constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    //等同于Person.prototype = function sayName()&#123;&#125;\n    sayName()&#123;\n        return this.name;\n    &#125;\n&#125;\nconsole.log(Person===Person.prototype.constructor)\n</code></pre>\n<blockquote>\n<p>类的方法内部如果含有<code>this</code>，它默认指向类的实例</p>\n</blockquote>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><pre><code class=\"js\">class Animal &#123;\n    constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    sayName()&#123;\n        return this.name;\n    &#125;\n    sayAge()&#123;\n        return this.age;\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n    constructor(name, age,color) &#123;\n          super(name,age);\n        this.color = color;\n    &#125;\n    //子类自己的方法\n    sayColor()&#123;\n        return `$&#123;this.name&#125;是$&#123;this.age&#125;岁了，它的颜色是$&#123;this.color&#125;`;\n    &#125;\n    //重写父类的方法\n    sayName()&#123;\n        return super.sayName() + this.color;\n    &#125;\n&#125;\nlet d1 = new Dog(&#39;小红&#39;,8,&#39;red&#39;);\nconsole.log(d1); //=&gt;Dog &#123;name: &#39;小红&#39;, age: 8, color: &#39;red&#39;&#125;\nconsole.log(d1.sayName()); //=&gt;&#39;小红&#39;\nconsole.log(d1.sayColor());//=&gt;&#39;小红是8岁了，它的颜色是red&#39;\nconsole.log(d1.sayName()); //=&gt;&#39;小红red&#39;\n</code></pre>\n<h3 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h3><h2 id=\"Module-模块化\"><a href=\"#Module-模块化\" class=\"headerlink\" title=\"Module 模块化\"></a>Module 模块化</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>\n<h3 id=\"export命令\"><a href=\"#export命令\" class=\"headerlink\" title=\"export命令\"></a>export命令</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>\n<pre><code class=\"js\">//module/index.js\nexport const name = &#39;zhangsan &#39;;\nexport const age = 18;\nexport const color = &#39;red &#39;;\nexport const sayName = function() &#123;\n    console.log(fristName);\n&#125;\n\n//也可以这样\nconst name = &#39;zhangsan &#39;;\nconst age = 18;\nconst color = &#39;red &#39;;\nconst sayName = function() &#123;\n    console.log(fristName);\n&#125;\nexport &#123;name,age,color,sayName&#125;\n</code></pre>\n<h3 id=\"import命令\"><a href=\"#import命令\" class=\"headerlink\" title=\"import命令\"></a>import命令</h3><p><span style=\"color:red\">在一个文件或模块中，export可以导出多个，对应的 import导入加{ }</span></p>\n<p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>\n<pre><code class=\"javascript\">//main.js\nimport &#123;name,age,color,sayName,fn&#125; from &#39;./modules/index.js&#39;;\n</code></pre>\n<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名</p>\n<pre><code class=\"javascript\">import * as obj from &#39;./modules/index.js&#39;;\nconsole.log(obj);\n</code></pre>\n<h3 id=\"export-default-命令\"><a href=\"#export-default-命令\" class=\"headerlink\" title=\"export default 命令\"></a>export default 命令</h3><p><span style=\"color:red\">export default仅可以导出一个，对应的import导入时候不用加花括号</span></p>\n<p>使用<code>export default</code>命令为模块指定默认输出</p>\n<pre><code class=\"javascript\">//export-default.js\nexport default function()&#123;\n    console.log(&#39;foo&#39;);\n&#125;\n\n//或者写成\nfunction foo() &#123;\n  console.log(&#39;foo&#39;);\n&#125;\n\nexport default foo;\n</code></pre>\n<p>在其它模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字</p>\n<pre><code class=\"javascript\">//import-default.js\nimport customName from &#39;./export-default.js&#39;\ncustomNmae();//foo\n</code></pre>\n<p>如果想在一条import语句中，同事输入默认方法和其他接口，可以写成下面这样</p>\n<pre><code class=\"csharp\">import customName,&#123;add&#125; from &#39;export-default.js&#39;\n</code></pre>\n<p>对应上面<code>export</code>语句如下</p>\n<pre><code class=\"javascript\">//export-default.js\nexport default function()&#123;\n    console.log(&#39;foo&#39;);\n&#125;\n\nexport function add()&#123;\n    console.log(&#39;add&#39;)\n&#125;\n</code></pre>\n<p><code>export default</code>也可以用来输出类。</p>\n<pre><code class=\"javascript\">// MyClass.js\nexport default class Person&#123; ... &#125;\n\n// main.js\nimport Person from &#39;MyClass&#39;;\nlet o = new Person();\n</code></pre>\n<p><span style=\"color:red\">export与export default均可用于导出常量、函数、文件、模块等</span></p>\n","categories":["ES6"],"tags":["JS","ES6"]},{"title":"DataView","url":"/2023/12/08/DataView/","content":"<h1 id=\"DataView视图：\"><a href=\"#DataView视图：\" class=\"headerlink\" title=\"DataView视图：\"></a>DataView视图：</h1><p>DataView 是 JavaScript 中的一个类型化数组视图，用于以不同的字节序（如大端序或小端序）和不同的数据类型（如整数、浮点数等）来读取和写入 ArrayBuffer 中的二进制数据。与 TypedArray 不同，DataView 可以指定任意的字节偏移量和长度，可以更加灵活地操作二进制数据。</p>\n<p>以下是一个使用 DataView 读取 ArrayBuffer 中的二进制数据的示例：</p>\n<pre><code class=\"js\">javascriptCopy Code// 创建一个包含 8 字节的 ArrayBuffer\nconst buffer = new ArrayBuffer(8);\n\n// 使用一个 DataView 视图来读取和写入数据\nconst dataView = new DataView(buffer);\n\n// 写入数据\ndataView.setInt16(0, 42); // 在第 1 和第 2 个字节中写入 42\ndataView.setInt32(2, -100); // 在第 3 到第 6 个字节中写入 -100\n\n// 读取数据\nconsole.log(dataView.getInt16(0)); // 输出 42\nconsole.log(dataView.getInt32(2)); // 输出 -100\n</code></pre>\n<p>在上述示例中，我们创建了一个长度为 8 字节的 ArrayBuffer。然后，我们使用一个 DataView 视图来操作这个 ArrayBuffer，分别在前两个字节和后四个字节中写入两个不同的数据，然后通过 DataView 的方法来读取这些数据。</p>\n<p>需要注意的是，DataView 的方法名都以数据类型名称开头，并以字节偏移量作为第一个参数。例如，setInt16(offset, value) 方法将一个 16 位整数值写入到指定偏移量处，而 getInt32(offset) 方法则从指定偏移量处读取一个 32 位整数值。这些方法还可以接受一个可选的第二个参数，用于指定字节序，以帮助正确地解释二进制数据。</p>\n<p>总之，DataView 提供了一种灵活和可定制的方式来读取和写入 ArrayBuffer 中的二进制数据，可以指定不同的字节序和数据类型，并支持任意偏移量和长度。</p>\n","categories":["JS"],"tags":["JS","DataView"]},{"title":"HTTP","url":"/2023/05/02/HTTP/","content":"<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"#目录\"></a>#目录</h1><blockquote>\n<p>[TOC]</p>\n</blockquote>\n<h1 id=\"浅学浏览器工作原理\"><a href=\"#浅学浏览器工作原理\" class=\"headerlink\" title=\"浅学浏览器工作原理\"></a>浅学浏览器工作原理</h1><h1 id=\"一、浏览器工作流程概览\"><a href=\"#一、浏览器工作流程概览\" class=\"headerlink\" title=\"一、浏览器工作流程概览\"></a>一、<strong>浏览器工作流程</strong>概览</h1><blockquote>\n<p>•浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；</p>\n<p>•把请求回来的 HTML 代码经过解析，构建成 DOM 树；</p>\n<p>•计算 DOM 树上的 CSS 属性；</p>\n<p>•根据 CSS 属性对元素逐个进行渲染，得到内存中的<code>位图</code>①；</p>\n<p>•一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；</p>\n<p>•合成之后，再绘制到界面上。</p>\n<p><img data-src=\"/images/image-20210621175650437.png\" alt=\"该图来自视频课程截图\"> </p>\n</blockquote>\n<h3 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h3><blockquote>\n<p>位图，又称为点阵图像、像素图或栅格图像，是由像素（图片元素）的单个点组成。这些点可以进行不同的排列和染色以构成图样。</p>\n<p>位图的单位：像素（Pixel）</p>\n</blockquote>\n<h1 id=\"二、HTTP协议底层原理概览\"><a href=\"#二、HTTP协议底层原理概览\" class=\"headerlink\" title=\"二、HTTP协议底层原理概览\"></a>二、HTTP协议底层原理概览</h1><blockquote>\n<p>Http是基于Tcp协议基础上出现的,HTTP在Tcp基础上规定了Request与Response</p>\n<p>http1标准:</p>\n<ul>\n<li>HTTP1.1 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTY=\">https://tools.ietf.org/html/rfc2616</span></li>\n<li>HTTP1.1 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzQ=\">https://tools.ietf.org/html/rfc7234</span></li>\n</ul>\n<p>http2标准: <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MTg=\">https://tools.ietf.org/html/rfc2818</span></p>\n<p>HTTPS标准: <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MTg=\">https://tools.ietf.org/html/rfc2818</span></p>\n</blockquote>\n<h2 id=\"1-HTTP请求-是一种规则，无状态，无记忆：\"><a href=\"#1-HTTP请求-是一种规则，无状态，无记忆：\" class=\"headerlink\" title=\"1.HTTP请求:是一种规则，无状态，无记忆：\"></a>1.HTTP请求:是一种规则，无状态，无记忆：</h2><h3 id=\"Ⅰ-HTTP请求过程\"><a href=\"#Ⅰ-HTTP请求过程\" class=\"headerlink\" title=\"Ⅰ- HTTP请求过程\"></a>Ⅰ- HTTP请求过程</h3><blockquote>\n<p>（1）建立TCP连接</p>\n<p>（2）web浏览器向web服务器发送请求指令</p>\n<p>（3）web浏览器发送请求头信息</p>\n<p>（4）web服务器应答</p>\n<p>（5）web服务器发送应答头信息</p>\n<p>（6）web服务器向浏览器发送数据</p>\n<p>（7）web服务器关闭TCP连接</p>\n</blockquote>\n<h3 id=\"Ⅱ-HTTP请求的四个组成部分：\"><a href=\"#Ⅱ-HTTP请求的四个组成部分：\" class=\"headerlink\" title=\"Ⅱ- HTTP请求的四个组成部分：\"></a>Ⅱ- HTTP请求的四个组成部分：</h3><blockquote>\n<p> a、HTTP请求方法或者动作(GET&#x2F;POST)</p>\n<p> b、正在请求的URL</p>\n<p> c、请求头，包含客户环境信息、身份信息等</p>\n<p> d、请求体（正文），包含客户提交的查询字符串信息、表单信息</p>\n</blockquote>\n<h3 id=\"Ⅲ-HTTP响应的三个组成部分：\"><a href=\"#Ⅲ-HTTP响应的三个组成部分：\" class=\"headerlink\" title=\"Ⅲ- HTTP响应的三个组成部分：\"></a>Ⅲ- HTTP响应的三个组成部分：</h3><blockquote>\n<p> a、一个数字和文字组成的转态码。作用：显示请求是否成功</p>\n<p> b、响应头，包含服务器类型、日期、内容类型、长度等</p>\n<p> c、响应体，即响应正文，字符串、HTML等 </p>\n</blockquote>\n<h2 id=\"2、HTTP-协议格式\"><a href=\"#2、HTTP-协议格式\" class=\"headerlink\" title=\"2、HTTP 协议格式\"></a>2、<strong>HTTP</strong> <strong>协议格式</strong></h2><blockquote>\n<p><img data-src=\"/images/image-20210622195949961.png\" alt=\"/images//image-20210622195949961\"> </p>\n</blockquote>\n<h3 id=\"Ⅰ-HTTP-Method\"><a href=\"#Ⅰ-HTTP-Method\" class=\"headerlink\" title=\"Ⅰ- HTTP Method\"></a>Ⅰ- <strong>HTTP Method</strong></h3><blockquote>\n<p>GET POST  HEAD PUT  DELETE CONNECT  <code>OPTIONS TRACE(通常这两种是调试时才使用的)</code></p>\n</blockquote>\n<h3 id=\"Ⅱ-HTTP-Status-code\"><a href=\"#Ⅱ-HTTP-Status-code\" class=\"headerlink\" title=\"Ⅱ- HTTP Status code\"></a>Ⅱ- <strong>HTTP Status code</strong></h3><blockquote>\n<p>•1xx：临时回应，表示客户端请继续。</p>\n<p>•2xx：请求成功。 &#x3D;&gt;表示用户请求被正确接收、理解和处理，如200</p>\n<p>•3xx: 表示请求的目标有变化，希望客户端进一步处理。 &#x3D;&gt;做定向使用  如nginx请求转发 再如303前端使用重定向</p>\n<p>•4xx：客户端请求错误。  </p>\n<p>•5xx：服务端请求错误。</p>\n</blockquote>\n<h3 id=\"Ⅲ-HTTP-Head\"><a href=\"#Ⅲ-HTTP-Head\" class=\"headerlink\" title=\"Ⅲ- HTTP Head\"></a>Ⅲ- <strong>HTTP Head</strong></h3><h4 id=\"①-Request-Header\"><a href=\"#①-Request-Header\" class=\"headerlink\" title=\"① Request Header\"></a>① <em>Request Header</em></h4><blockquote>\n<p><img data-src=\"/images/image-20210622202103234.png\" alt=\"/images//image-20210622202103234\"> </p>\n</blockquote>\n<h4 id=\"②-Response-Header\"><a href=\"#②-Response-Header\" class=\"headerlink\" title=\"② Response Header\"></a>② <em>Response Header</em></h4><blockquote>\n<p><img data-src=\"/images/image-20210622202158322.png\" alt=\"/images//image-20210622202158322\"> </p>\n</blockquote>\n<h4 id=\"③-HTTP-Request-Body\"><a href=\"#③-HTTP-Request-Body\" class=\"headerlink\" title=\"③ HTTP Request Body\"></a>③ <em><strong>HTTP Request Body</strong></em></h4><blockquote>\n<p>•application&#x2F;json \t\t\t\t  –&gt;最常用的json格式</p>\n<p>•application&#x2F;x-www-form-urlencoded  –&gt;常用的from表单提交格式</p>\n<p>•multipart&#x2F;form-data   \t\t\t –&gt;常用的文件上传格式</p>\n<p>•text&#x2F;xml               \t\t\t–&gt;常用xml文件格式</p>\n</blockquote>\n<h4 id=\"④-HTTP-head\"><a href=\"#④-HTTP-head\" class=\"headerlink\" title=\"④ HTTP head\"></a>④ <em>HTTP head</em></h4><blockquote>\n<p>略</p>\n</blockquote>\n<h2 id=\"3、OSI模型图\"><a href=\"#3、OSI模型图\" class=\"headerlink\" title=\"3、OSI模型图\"></a>3、OSI模型图</h2><blockquote>\n<p><img data-src=\"/images/image-20210622203341816.png\"> </p>\n</blockquote>\n<h2 id=\"4、数据传输简单基础原理-x3D-gt-服务端-浏览器-POST-GET\"><a href=\"#4、数据传输简单基础原理-x3D-gt-服务端-浏览器-POST-GET\" class=\"headerlink\" title=\"4、数据传输简单基础原理&#x3D;&gt;(服务端,浏览器,POST,GET)\"></a>4、数据传输简单基础原理&#x3D;&gt;(服务端,浏览器,POST,GET)</h2><blockquote>\n<h5 id=\"1-浏览器访问原理-x3D-gt\"><a href=\"#1-浏览器访问原理-x3D-gt\" class=\"headerlink\" title=\"1. 浏览器访问原理&#x3D;&gt;\"></a>1. 浏览器访问原理&#x3D;&gt;</h5><ul>\n<li><code>协议=&gt;ip=&gt;端口=&gt;uri</code></li>\n</ul>\n<h5 id=\"2-服务端-前端-数据传输过程-x3D-gt\"><a href=\"#2-服务端-前端-数据传输过程-x3D-gt\" class=\"headerlink\" title=\"2. 服务端(前端)数据传输过程&#x3D;&gt;\"></a>2. 服务端(前端)数据传输过程&#x3D;&gt;</h5><ul>\n<li><code>控制层=&gt;逻辑层=&gt;数据层=&gt;后端(数据持久层)</code></li>\n</ul>\n<h5 id=\"3-GET与POST区别-x3D-gt\"><a href=\"#3-GET与POST区别-x3D-gt\" class=\"headerlink\" title=\"3. GET与POST区别:&#x3D;&gt;\"></a>3. GET与POST区别:&#x3D;&gt;</h5><ul>\n<li>GET是进行明文传递,POST非明文请求数据放在请求体中</li>\n</ul>\n</blockquote>\n<h2 id=\"5、请求响应与跨域概念\"><a href=\"#5、请求响应与跨域概念\" class=\"headerlink\" title=\"5、请求响应与跨域概念\"></a>5、请求响应与跨域概念</h2><blockquote>\n<h5 id=\"1-req-request（请求对象）-x3D-gt\"><a href=\"#1-req-request（请求对象）-x3D-gt\" class=\"headerlink\" title=\"1.req:request（请求对象）&#x3D;&gt;\"></a>1.req:request（请求对象）&#x3D;&gt;</h5><ul>\n<li><pre><code>代表,所有跟请求有关的东西都在req对象里头,包括请求参数 请求头 请求头 cookie\n</code></pre>\n</li>\n</ul>\n<h5 id=\"2-res-response（响应对象）-x3D-gt\"><a href=\"#2-res-response（响应对象）-x3D-gt\" class=\"headerlink\" title=\"2.res:response（响应对象）&#x3D;&gt;\"></a>2.res:response（响应对象）&#x3D;&gt;</h5><ul>\n<li>所有响应客户端的东西都在res里头,包括相应参数,响应头(跨域处理就是在这)</li>\n</ul>\n<h5 id=\"3-跨域请求的本质与原理-x3D-gt\"><a href=\"#3-跨域请求的本质与原理-x3D-gt\" class=\"headerlink\" title=\"3.跨域请求的本质与原理&#x3D;&gt;\"></a>3.跨域请求的本质与原理&#x3D;&gt;</h5><ul>\n<li><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p>\n</li>\n<li><p>请求本质是成功的,但是浏览器判断本次请求不安全</p>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"目录-1\"><a href=\"#目录-1\" class=\"headerlink\" title=\"#目录\"></a>#目录</h1><blockquote>\n<p>[TOC]</p>\n</blockquote>\n<h1 id=\"从URL输入到页面展现-这中间发生了什么？\"><a href=\"#从URL输入到页面展现-这中间发生了什么？\" class=\"headerlink\" title=\"从URL输入到页面展现,这中间发生了什么？\"></a>从URL输入到页面展现,这中间发生了什么？</h1><blockquote>\n<p>完整流程图<img data-src=\"/images/image-20210623183143882.png\" alt=\"/images//image-20210623183143882\"></p>\n<p>总体来说分为以下几个过程：</p>\n<ul>\n<li>DNS 解析:将域名解析成 IP 地址</li>\n<li>TCP 连接：TCP 三次握手</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>断开连接：TCP 四次挥手</li>\n</ul>\n</blockquote>\n<h2 id=\"一、什么是URL？\"><a href=\"#一、什么是URL？\" class=\"headerlink\" title=\"一、什么是URL？\"></a>一、什么是URL？</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。</p>\n<p><strong><code>scheme</code>: &#x2F;&#x2F; <code>host</code>.<code>domain</code>:<code>port</code> &#x2F; <code>path</code> &#x2F;<code>filename</code> ?<code> query</code> # <code>fragment</code></strong></p>\n<blockquote>\n<ul>\n<li>scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file -其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>\n<li>host         - 定义域主机（http 的默认主机是 www）</li>\n<li>domain       - 定义因特网域名，比如 baidu.com</li>\n<li>port         - 定义主机上的端口号（http 的默认端口号是 80）</li>\n<li>path         - 定义服务器上的路径（如缺省则文档必须位于网站的根目录中）。</li>\n<li>filename     - 定义文档&#x2F;资源的名称  (如缺省文件必须位于前面<code>path</code>后的根目录中)</li>\n<li>query        - 即 ? 后的查询参数 <code>可以缺省</code></li>\n<li>fragment     - 即 # 后的hash值，一般用来定位到某个位置  <code>可以缺省</code></li>\n</ul>\n<p>举个栗子:</p>\n<p><img data-src=\"/images/image-20210623184854722.png\" alt=\"/images//image-20210623184854722\"> </p>\n</blockquote>\n<h2 id=\"二、DNS域名解析\"><a href=\"#二、DNS域名解析\" class=\"headerlink\" title=\"二、DNS域名解析\"></a>二、DNS域名解析</h2><blockquote>\n<p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址</p>\n</blockquote>\n<h3 id=\"1、IP地址是什么\"><a href=\"#1、IP地址是什么\" class=\"headerlink\" title=\"1、IP地址是什么?\"></a>1、IP地址是什么?</h3><blockquote>\n<p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>\n</blockquote>\n<h3 id=\"2、域名是什么\"><a href=\"#2、域名是什么\" class=\"headerlink\" title=\"2、域名是什么?\"></a>2、域名是什么?</h3><blockquote>\n<p><code>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址</code>。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称,相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生</p>\n<p>举个栗子:<a href=\"https://gitee.com/hongjilin\"><code>47.100.xxx.xxx.xx:80/hongjilin</code></a>&#x3D;&#x3D;&#x3D;<a href=\"https://gitee.com/hongjilin\"><code>gitee.com/hongjilin</code></a>,对于我们肯定是<a href=\"https://gitee.com/hongjilin\"><code>gitee.com/hongjilin</code></a>更便于记忆,而对计算机而言更擅长前者</p>\n</blockquote>\n<h3 id=\"3、什么是域名解析\"><a href=\"#3、什么是域名解析\" class=\"headerlink\" title=\"3、什么是域名解析?\"></a>3、什么是域名解析?</h3><blockquote>\n<p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。**<code>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录</code>**</p>\n<p>举个栗子 <code>baidu.com</code> &#x3D;&#x3D;解析&#x3D;&#x3D;&gt; <code>220.114.23.56(服务器外网IP地址)80(服务器端口)</code></p>\n</blockquote>\n<h3 id=\"4、浏览器如何通过域名去查询-URL-对应的-IP-呢\"><a href=\"#4、浏览器如何通过域名去查询-URL-对应的-IP-呢\" class=\"headerlink\" title=\"4、浏览器如何通过域名去查询 URL 对应的 IP 呢?\"></a>4、浏览器如何通过域名去查询 URL 对应的 IP 呢?</h3><blockquote>\n<ul>\n<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>\n<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>\n<li>路由缓存：路由器也有 DNS 缓存。</li>\n<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>\n<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>\n</ul>\n<p><img data-src=\"/images/image-20210623191500569.png\" alt=\"/images//image-20210623191500569\"></p>\n<p><code>结论</code>:<strong>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</strong> </p>\n</blockquote>\n<h3 id=\"5、DNS的优化与应用\"><a href=\"#5、DNS的优化与应用\" class=\"headerlink\" title=\"5、DNS的优化与应用\"></a>5、DNS的优化与应用</h3><blockquote>\n<ol>\n<li>DNS缓存 <code>DNS存在着多级缓存</code>，从离浏览器的距离排序的话，有以下几种: <code>浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</code>。</li>\n<li>DNS负载均衡<code>(DNS重定向) DNS负载均衡技术</code>的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。</li>\n</ol>\n<ul>\n<li>大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</li>\n</ul>\n<ol start=\"3\">\n<li>dns-prefetch <code>DNS Prefetch 是一种 DNS 预解析技术</code>。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</li>\n</ol>\n</blockquote>\n<h2 id=\"三、TCP三次握手\"><a href=\"#三、TCP三次握手\" class=\"headerlink\" title=\"三、TCP三次握手\"></a>三、TCP三次握手</h2><blockquote>\n<p><strong>HTTP 请求分为三个部分：<code>TCP 三次握手</code>、http 请求响应信息、关闭 TCP 连接。</strong></p>\n<ol>\n<li>比喻图</li>\n</ol>\n<p> <img data-src=\"/images/image-20210623192336724.png\" alt=\"/images//image-20210623192336724\"> </p>\n<ol start=\"2\">\n<li>三次握手时序图(该图来自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8zMzg2MTUxNTQ1ODY5Nzgz\">williamife</span>)</li>\n</ol>\n<p> <img data-src=\"/images/1692e4385f72aae4\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"1、TCP三次握手的过程如下\"><a href=\"#1、TCP三次握手的过程如下\" class=\"headerlink\" title=\"1、TCP三次握手的过程如下:\"></a>1、TCP三次握手的过程如下:</h3><blockquote>\n<p>客户端发送一个带 SYN&#x3D;1，Seq&#x3D;X 的数据包到服务器端口<code>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</code></p>\n<p>服务器发回一个带 SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y 的响应包以示传达确认信息<code>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</code></p>\n<p>客户端再回传一个带 ACK&#x3D;Y+1， Seq&#x3D;Z 的数据包，代表“握手结束”<code>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</code></p>\n</blockquote>\n<h3 id=\"2、为何需要三次握手\"><a href=\"#2、为何需要三次握手\" class=\"headerlink\" title=\"2、为何需要三次握手?\"></a>2、为何需要三次握手?</h3><blockquote>\n<p>“三次握手”的目的是“**<code>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</code>**”。</p>\n</blockquote>\n<h2 id=\"四、发送-HTTP-请求\"><a href=\"#四、发送-HTTP-请求\" class=\"headerlink\" title=\"四、发送 HTTP 请求\"></a>四、发送 HTTP 请求</h2><blockquote>\n<p>TCP 三次握手结束后，开始发送 HTTP 请求报文。</p>\n</blockquote>\n<h2 id=\"五、服务器处理请求并返回-HTTP-报文\"><a href=\"#五、服务器处理请求并返回-HTTP-报文\" class=\"headerlink\" title=\"五、服务器处理请求并返回 HTTP 报文\"></a>五、服务器处理请求并返回 HTTP 报文</h2><h3 id=\"1、服务器\"><a href=\"#1、服务器\" class=\"headerlink\" title=\"1、服务器\"></a>1、服务器</h3><blockquote>\n<p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。<br><strong><code>web server</code> 担任管控的角色</strong>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（常见的web server产品有apache、<code>nginx</code>、IIS、Lighttpd等），然后返回后台程序处理产生的结果作为响应。</p>\n</blockquote>\n<h3 id=\"2、http-响应报文\"><a href=\"#2、http-响应报文\" class=\"headerlink\" title=\"2、http 响应报文\"></a>2、http 响应报文</h3><blockquote>\n<p>此处同上</p>\n</blockquote>\n<h2 id=\"六、浏览器解析渲染页面\"><a href=\"#六、浏览器解析渲染页面\" class=\"headerlink\" title=\"六、浏览器解析渲染页面\"></a>六、浏览器解析渲染页面</h2><blockquote>\n<p>相关详细内容包括如何优化已在‘浏览器解析渲染页面原理及回流重绘优化笔记’中有叙述  –》 <strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vaG9uZ2ppbGluL2hvbmdzLXN0dWR5LW5vdGVzL3RyZWUvbWFzdGVyLyVFNyVCQyU5NiVFNyVBOCU4Ql8lRTUlODklOEQlRTclQUIlQUYlRTUlQkMlODAlRTUlOEYlOTElRTUlQUQlQTYlRTQlQjklQTAlRTclQUMlOTQlRTglQUUlQjAvQ2hyb21lJUU1JUJDJTgwJUU1JThGJTkxJUU0JUJEJUJGJUU3JTk0JUE4JUU1JThGJThBJUU1JUFEJUE2JUU0JUI5JUEwJUU3JUFDJTk0JUU4JUFFJUIwLyVFNiVCNSU4RiVFOCVBNyU4OCVFNSU5OSVBOCVFOCVBNyVBMyVFNiU5RSU5MCVFNiVCOCVCMiVFNiU5RiU5MyVFOSVBMSVCNSVFOSU5RCVBMiVFNSU4RSU5RiVFNyU5MCU4NiVFNSU4RiU4QSVFNSU5QiU5RSVFNiVCNSU4MSVFOSU4NyU4RCVFNyVCQiU5OCVFNCVCQyU5OCVFNSU4QyU5NiVFNyVBQyU5NCVFOCVBRSVCMA==\">浏览器解析渲染页面原理及回流重绘优化笔记</span></strong> </p>\n<p>浏览器解析渲染页面分为一下五个步骤：</p>\n<ol>\n<li>根据HTML解析出DOM树</li>\n<li>根据CSS解析生成CSS规则树</li>\n<li>结合DOM树和CSS规则树，生成渲染树</li>\n<li>根据渲染树计算每一个节点的信息</li>\n<li>根据计算好的信息绘制页面</li>\n</ol>\n</blockquote>\n<h3 id=\"1、根据HTML解析DOM树\"><a href=\"#1、根据HTML解析DOM树\" class=\"headerlink\" title=\"1、根据HTML解析DOM树\"></a>1、根据HTML解析DOM树</h3><blockquote>\n<ul>\n<li>根据HTML的内容，将标签按照结构解析成为DOM树，DOM树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>\n<li>在读取HTML文档，构建DOM树的过程中，若遇到script标签，则DOM树的构建会暂停，直至脚本执行完毕。</li>\n</ul>\n</blockquote>\n<h3 id=\"2、根据CSS解析生成CSS规则树-–》【CSSOM树】\"><a href=\"#2、根据CSS解析生成CSS规则树-–》【CSSOM树】\" class=\"headerlink\" title=\"2、根据CSS解析生成CSS规则树 –》【CSSOM树】\"></a>2、根据CSS解析生成CSS规则树 –》【CSSOM树】</h3><blockquote>\n<ul>\n<li>解析CSS规则树时js 执行将暂停，直至CSS规则树就绪。</li>\n<li>浏览器在CSS规则树生成之前不会进行渲染。</li>\n</ul>\n</blockquote>\n<h3 id=\"3、结合DOM树和CSS规则树，生成渲染树\"><a href=\"#3、结合DOM树和CSS规则树，生成渲染树\" class=\"headerlink\" title=\"3、结合DOM树和CSS规则树，生成渲染树\"></a>3、结合DOM树和CSS规则树，生成渲染树</h3><blockquote>\n<ul>\n<li>DOM树和CSS规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>\n<li>精简 CSS 并可以加快CSS规则树的构建，从而加快页面相应速度。</li>\n</ul>\n</blockquote>\n<h3 id=\"4、根据渲染树计算每一个节点的信息（布局）\"><a href=\"#4、根据渲染树计算每一个节点的信息（布局）\" class=\"headerlink\" title=\"4、根据渲染树计算每一个节点的信息（布局）\"></a>4、根据渲染树计算每一个节点的信息（布局）</h3><blockquote>\n<ul>\n<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>\n<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>\n</ul>\n</blockquote>\n<h3 id=\"5、根据计算好的信息绘制页面\"><a href=\"#5、根据计算好的信息绘制页面\" class=\"headerlink\" title=\"5、根据计算好的信息绘制页面\"></a>5、根据计算好的信息绘制页面</h3><blockquote>\n<ul>\n<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>\n<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的<code>重绘</code>。</li>\n<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>\n</ul>\n</blockquote>\n<h2 id=\"七、断开连接\"><a href=\"#七、断开连接\" class=\"headerlink\" title=\"七、断开连接\"></a>七、断开连接</h2><p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手</strong>。<br><img data-src=\"/%E6%B5%85%E6%9E%90%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/1460000017184713.png\" alt=\"img\"></p>\n<ul>\n<li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态</strong>。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>\n<li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态</strong>。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>\n<li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态</strong>。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>\n<li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭</strong>。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>\n</ul>\n<h2 id=\"1、前端缓存\"><a href=\"#1、前端缓存\" class=\"headerlink\" title=\"1、前端缓存\"></a>1、前端缓存</h2><blockquote>\n<p>当我们第一次访问网站时,电脑会把网站上的图片与数据下载到电脑上,当我们再次访问该网站时,网站就会从电脑中直接加载出来,这就是缓存</p>\n<ul>\n<li>web缓存是指一个Web资源(如html页面、图、JS等)存在于web服务器和客户端(浏览器)之间的副本</li>\n<li>缓存会根据进来的请求保存输出内容的副本: 当下一个请求来到的时候,如果是相同的Url,缓存会根据缓存机制决定是直接使用副本响应访问请求还是像源服务器再次发起请求</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅰ-缓存有哪些好处\"><a href=\"#Ⅰ-缓存有哪些好处\" class=\"headerlink\" title=\"Ⅰ - 缓存有哪些好处\"></a>Ⅰ - 缓存有哪些好处</h3><blockquote>\n<ul>\n<li>缓解服务端压力,不用每次都去请求某些数据</li>\n<li>提升性能,打开本地资源肯定比请求服务器来的更快 </li>\n<li>减少宽带消耗,当我们使用缓存的时候,只会产生很小的网络消耗,至于为什么打开本地资源也会产生网络消耗?</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-前端缓存种类\"><a href=\"#Ⅱ-前端缓存种类\" class=\"headerlink\" title=\"Ⅱ - 前端缓存种类\"></a>Ⅱ - 前端缓存种类</h3><blockquote>\n<ol>\n<li>数据库缓存</li>\n<li>CDN缓存</li>\n<li>代理服务器缓存</li>\n<li>浏览器缓存</li>\n</ol>\n<p><strong>此图截取自网上相关文章</strong></p>\n<p><img data-src=\"/images/image-20211027182618788.png\" alt=\"/images//image-20211027182618788\"></p>\n</blockquote>\n<h2 id=\"2、什么是浏览器缓存策略\"><a href=\"#2、什么是浏览器缓存策略\" class=\"headerlink\" title=\"2、什么是浏览器缓存策略\"></a>2、什么是浏览器缓存策略</h2><blockquote>\n<p>良好的缓存策略可以降低资源的重复加载从而提高页面整体加载速度,通常浏览器缓存策略分为两种结果</p>\n<ul>\n<li>强缓存</li>\n<li>协商缓存</li>\n</ul>\n<p><img data-src=\"/images/image-20211027184535569.png\" alt=\"/images//image-20211027184535569\"> </p>\n</blockquote>\n<h3 id=\"Ⅰ-基本原理\"><a href=\"#Ⅰ-基本原理\" class=\"headerlink\" title=\"Ⅰ - 基本原理\"></a>Ⅰ - 基本原理</h3><blockquote>\n<ul>\n<li>浏览器在加载资源时,根据请求头的 <code>Expires(过期时间)</code> 和<code>chche-control(缓存控制)</code>判断是否命中强缓存,命中则直接从缓存中读取资源,不会发送到服务器</li>\n<li>如果没有命中强缓存,浏览器一定会发送一个请求到服务器,通过<code>last-modified</code>和<code>etag</code>验证资源是否命中协商缓存,如果命中,服务器回将这个请求返回,但是不会返回这个资源的数据,依然是从缓存中读取资源</li>\n<li>如果前面两者都没有命中,则直接从服务器加载资源</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-根据什么规则缓存\"><a href=\"#Ⅱ-根据什么规则缓存\" class=\"headerlink\" title=\"Ⅱ - 根据什么规则缓存\"></a>Ⅱ - 根据什么规则缓存</h3><blockquote>\n<ol>\n<li><strong>新鲜度</strong>(过期机制):也就是缓存副本有效期. 一个缓存副本必须满足以下条件,浏览器会认为它是有效的,足够新的</li>\n</ol>\n<ul>\n<li>含有完整的过期时间控制头信息(HTTP协议报头),并且仍在有效期内</li>\n<li>浏览器已经使用过这个缓存副本,并且在一个会话中已经检查过新鲜度</li>\n<li><strong>通常是强缓存阶段使用的机制</strong></li>\n</ul>\n<ol start=\"2\">\n<li><strong>校验值</strong>(验证机制): 服务器返回资源的时候有时在控制头信息带上这个资源的实体标签<code>Etag</code>,</li>\n</ol>\n<ul>\n<li>它可以用来作为浏览器再次请求过程的校验标识</li>\n<li>如果发现校验标识不匹配,说明资源已经被修改或者过期,浏览器需要重新获取资源内容</li>\n<li><strong>所以通常是协商缓存中使用的机制</strong></li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅲ-HTTP缓存的两个阶段\"><a href=\"#Ⅲ-HTTP缓存的两个阶段\" class=\"headerlink\" title=\"Ⅲ - HTTP缓存的两个阶段\"></a>Ⅲ - HTTP缓存的两个阶段</h3><blockquote>\n<p>浏览器缓存一般分为两类: <strong>强缓存</strong>(也称本地缓存) 和 <strong>协商缓存</strong>(也称弱缓存)</p>\n<h6 id=\"强缓存阶段\"><a href=\"#强缓存阶段\" class=\"headerlink\" title=\"强缓存阶段\"></a>强缓存阶段</h6><blockquote>\n<p>浏览器发送请求前,会去缓存里查看是否命中强缓存,如果命中,则直接从缓存中读取资源,不会发送请求到服务器;</p>\n</blockquote>\n<h6 id=\"协商缓存阶段\"><a href=\"#协商缓存阶段\" class=\"headerlink\" title=\"协商缓存阶段\"></a>协商缓存阶段</h6><blockquote>\n<p>当强缓存没有命中时,浏览器一定会向服务器发起请求</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>服务器会根据 <code>request header</code> 中的一些字段来判断是否命中协商缓存</li>\n<li>如果命中,服务端会返回304响应,但是不会携带任何响应实体,只是高速浏览器可以直接从浏览器缓存中获取这个资源</li>\n<li>如果 <strong>强缓存</strong> 和 <strong>协商缓存</strong> 都没有命中,则直接从服务器加载资源</li>\n</ul>\n</blockquote>\n<p><img data-src=\"/images/image-20211027190616969.png\" alt=\"/images//image-20211027190616969\"> </p>\n</blockquote>\n<h3 id=\"Ⅳ-优先级\"><a href=\"#Ⅳ-优先级\" class=\"headerlink\" title=\"Ⅳ - 优先级\"></a>Ⅳ - 优先级</h3><blockquote>\n<ul>\n<li><code>Cache-Control</code>优先级大于 <code>expires</code></li>\n<li><code>Etag</code> 优先级大于 <code>last - Modified/if-Modified-since</code>,同时存在时会以Etag为准</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅴ-浏览器缓存流程图\"><a href=\"#Ⅴ-浏览器缓存流程图\" class=\"headerlink\" title=\"Ⅴ - 浏览器缓存流程图\"></a>Ⅴ - 浏览器缓存流程图</h3><blockquote>\n<p><img data-src=\"/images/image-20211027190721706.png\" alt=\"/images//image-20211027190721706\"> </p>\n</blockquote>\n<h2 id=\"3、强缓存与协商缓存\"><a href=\"#3、强缓存与协商缓存\" class=\"headerlink\" title=\"3、强缓存与协商缓存\"></a>3、强缓存与协商缓存</h2><h3 id=\"Ⅰ-强缓存\"><a href=\"#Ⅰ-强缓存\" class=\"headerlink\" title=\"Ⅰ - 强缓存\"></a>Ⅰ - 强缓存</h3><blockquote>\n<h6 id=\"通过Expires-过yu期-和cache-control-缓存控制器-两种响应头实现\"><a href=\"#通过Expires-过yu期-和cache-control-缓存控制器-两种响应头实现\" class=\"headerlink\" title=\"通过Expires(过yu期)和cache-control(缓存控制器)两种响应头实现\"></a>通过<code>Expires(过yu期)</code>和<code>cache-control(缓存控制器)</code>两种响应头实现</h6><p>浏览器在加载资源时,根据请求头的 <code>Expires(过期时间)</code> 和<code>chche-control(缓存控制)</code>判断是否命中强缓存,命中则直接从缓存中读取资源,不会发送到服务器</p>\n</blockquote>\n<h4 id=\"①-Expires-过期\"><a href=\"#①-Expires-过期\" class=\"headerlink\" title=\"①  Expires(过期)\"></a>①  Expires(过期)</h4><blockquote>\n<p><code>Expires</code>是 http1.0 提出的表示资源过期时间的header, 它描述的是一个绝对时间,由服务端返回;当我们准备再次发起请求时,本地时间未超过这个设置的时间,那么就不会真正的发出请求,而是读取缓存</p>\n<p>expires受限于本地时间,如果修改了本地时间,可能会造成缓存失效</p>\n</blockquote>\n<h4 id=\"②-cache-control\"><a href=\"#②-cache-control\" class=\"headerlink\" title=\"②  cache-control\"></a>②  cache-control</h4><blockquote>\n<p><code>cache-control</code>出现于HTTP1.1, 优先级高于Expires ,表示的是相对时间</p>\n<ul>\n<li><code>cache-control:no-cache</code> 的响应实际上是可以存储在本地缓存去中的,只是在与原始服务器进行新鲜度再验证之前,缓存不能将其提供给客户端使用</li>\n<li><code>Cache-Control: no-store</code> 真正的不缓存到本地</li>\n<li><code>Cache-Control: public</code> 可以被所有用户缓存(多用户共享),包括终端和CDN等中间代理服务器</li>\n<li><code>Cache-Control: private</code>只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存</li>\n</ul>\n<p>Cache-Control除了在响应中使用，在请求中也可以使用。我们用开发者工具来模拟下请求时带上Cache-Control：勾选Disable cache，刷新页面，可以看到Request Headers中有个字段Cache-Control: no-cache。</p>\n<p><img data-src=\"/images/image-20220225160543826.png\" alt=\"/images//image-20220225160543826\"></p>\n</blockquote>\n<h3 id=\"Ⅱ-协商缓存\"><a href=\"#Ⅱ-协商缓存\" class=\"headerlink\" title=\"Ⅱ - 协商缓存\"></a>Ⅱ - 协商缓存</h3><blockquote>\n<h6 id=\"协商缓存是通过【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的\"><a href=\"#协商缓存是通过【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的\" class=\"headerlink\" title=\"协商缓存是通过【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的\"></a>协商缓存是通过<code>【Last-Modified，If-Modified-Since】</code>和<code>【ETag、If-None-Match】</code>这两对Header来管理的</h6><ul>\n<li>当浏览器对某个资源的请求没有命中强缓存(换句话说就是: <strong>强缓存失效后</strong>)</li>\n<li>就会发一个请求到服务器,验证协商缓存是否命中; </li>\n<li>如果协商缓存命中,请求响应返回的http状态为<code>304</code> 并且会显示一个<code>Not Modified(未修改的)</code>的字符串</li>\n</ul>\n</blockquote>\n<h4 id=\"①-Last-Modified，If-Modified-Since\"><a href=\"#①-Last-Modified，If-Modified-Since\" class=\"headerlink\" title=\"①  Last-Modified，If-Modified-Since\"></a>①  Last-Modified，If-Modified-Since</h4><blockquote>\n<ol>\n<li><code>Last-Modified</code>表示本地文件最后修改日期</li>\n</ol>\n<ul>\n<li>浏览器会在request header 加上 <code>If-Modified-Since</code>(上此返回的<code>Last-Modified</code>的值)</li>\n<li>询问服务器在该日期后资源是否有更新</li>\n<li>有更新的话就会将新的资源发送过来</li>\n</ul>\n<ol start=\"2\">\n<li>但如果在本地打开缓存文件,就会造成<code>Last-Modified</code>的修改,所以在HTTP1.1中出现了<code>Etag</code></li>\n<li>当资源过期时（使用<code>Cache-Control</code>标识的max-age&#x2F;s-maxage）</li>\n</ol>\n<ul>\n<li>发现资源具有<code>Last-Msodified</code>声明，则向服务器请求时带上头 <code>If-Modified-Since</code>（即响应头中的<code>Last-Modified</code>值），表示请求时间。</li>\n<li>这个时候服务器收到请求后发现有头<code>If-Modified-Since</code>则与<strong>被请求资源</strong>的最后修改时间进行比对</li>\n<li>若最后修改时间较新，说明资源有被改动过，将新资源返回并返回状态<code>200</code>，否则返回<code>304</code>表示资源没被更新使用缓存即可。</li>\n</ul>\n</blockquote>\n<h4 id=\"②-ETag、If-None-Match\"><a href=\"#②-ETag、If-None-Match\" class=\"headerlink\" title=\"② ETag、If-None-Match\"></a>② ETag、If-None-Match</h4><blockquote>\n<ol>\n<li><code>Etag</code>就行是一个直问,资源变化都会导致Etag变化,跟最后修改时间没有关系,Etag可以保证每一个资源都是唯一的</li>\n<li>当资源过期时（使用Cache-Control标识的max-age&#x2F;s-maxage）</li>\n</ol>\n<ul>\n<li>发现资源具有<code>Etage</code>声明，则向服务器请求时带上头<code>If-None-Match</code>（即响应头中<code>Etag</code>的值）</li>\n<li>服务器收到请求后发现有头<code>If-None-Match</code> 则与被请求资源的相应校验串进行比对</li>\n<li>决定返回200或304（<strong>注意：服务器会优先验证If-None-Match</strong>）</li>\n</ul>\n<h6 id=\"两者优先级\"><a href=\"#两者优先级\" class=\"headerlink\" title=\"两者优先级?\"></a>两者优先级?</h6><blockquote>\n<p><strong><code>ETag</code>的优先级比<code>Last-Modified</code>更高</strong></p>\n</blockquote>\n<blockquote>\n<p>具体为什么要用<code>ETag</code>，主要出于下面几种情况考虑：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>一些文件也许会周期性的更改,但是它的内容并不会改变(仅仅只改变了修改时间),这种时候我们并不希望客户端认为这个文件被修改了,而重新GET</li>\n<li>某些文件修改非常频繁,比如在秒以下的时间内进行修改(比如说1s内修改了N次),而其他方法检查到的粒度是s级的,这种修改无法判断</li>\n<li>某些服务器不能精确的得到文件的最后修改时间</li>\n</ul>\n</blockquote>\n<h6 id=\"服务端返回-304-流程图\"><a href=\"#服务端返回-304-流程图\" class=\"headerlink\" title=\"服务端返回 304 流程图\"></a>服务端返回 304 流程图</h6><p><img data-src=\"/images/image-20211027175045937-16353282573951.png\" alt=\"/images//image-20211027175045937\"></p>\n</blockquote>\n<h3 id=\"Ⅲ-强缓存与协商缓存简单异同点\"><a href=\"#Ⅲ-强缓存与协商缓存简单异同点\" class=\"headerlink\" title=\"Ⅲ -强缓存与协商缓存简单异同点\"></a>Ⅲ -强缓存与协商缓存简单异同点</h3><blockquote>\n<ul>\n<li><strong>相同点</strong>: 如果命中,都是从客户端缓存中加载资源,而不是从服务器加载资源数据</li>\n<li><strong>不同点</strong>: 强缓存不发送请求到服务器,协商缓存会发送请求到服务器</li>\n</ul>\n</blockquote>\n<h2 id=\"4、常见几种状态码的区别\"><a href=\"#4、常见几种状态码的区别\" class=\"headerlink\" title=\"4、常见几种状态码的区别\"></a>4、常见几种状态码的区别</h2><blockquote>\n<p>缓存中: 200状态码总是强缓存, 304总是协商缓存</p>\n<ul>\n<li><code>200</code>: 强缓存<code>expires/Cache-Control</code>失效时,返回新的资源文件</li>\n<li><code>200(form cache)</code>: 强缓存两者都存在且未过期; <code>Cache-Control</code> 优先<code>Expirs</code>(默认就是这个优先级)时–&gt;浏览器从本地获取资源成功  (这个状态还能更详细分类,在下面再给出详解)</li>\n<li><code>304(Not Modified)</code>:协商缓存<code>Last-modified/Etag</code>没有过期时,服务端返回状态码304</li>\n</ul>\n<h6 id=\"这里给出个截图-安装了中文包-所以显示的中文\"><a href=\"#这里给出个截图-安装了中文包-所以显示的中文\" class=\"headerlink\" title=\"这里给出个截图(安装了中文包,所以显示的中文)\"></a>这里给出个截图(安装了中文包,所以显示的中文)</h6><p><img data-src=\"/images/image-20211102140503290.png\" alt=\"/images//image-20211102140503290\"> </p>\n</blockquote>\n<h2 id=\"5、缓存位置\"><a href=\"#5、缓存位置\" class=\"headerlink\" title=\"5、缓存位置\"></a>5、缓存位置</h2><blockquote>\n<h6 id=\"强缓存我们会把资源放在-memory-cache-内存缓存-和disk-cache-磁盘缓存-中-那么他们的区别在哪呢-为何要如此区分\"><a href=\"#强缓存我们会把资源放在-memory-cache-内存缓存-和disk-cache-磁盘缓存-中-那么他们的区别在哪呢-为何要如此区分\" class=\"headerlink\" title=\"强缓存我们会把资源放在 memory cache(内存缓存)和disk cache(磁盘缓存) 中,那么他们的区别在哪呢?为何要如此区分?\"></a>强缓存我们会把资源放在 <code>memory cache(内存缓存)</code>和<code>disk cache(磁盘缓存)</code> 中,那么他们的区别在哪呢?为何要如此区分?</h6><p><img data-src=\"/images/image-20211102140503290.png\" alt=\"/images//image-20211102140503290\"></p>\n<ul>\n<li>存储图像和网页等资源主要存储在<code>disk cache(磁盘存储)</code></li>\n<li>操作系统缓存文件等资源大部分都会缓存在<code>memory cache</code>中</li>\n<li>具体操作浏览器自动分配,看谁的资源利用率不高就给谁</li>\n<li>查找浏览器缓存时会按照 <code>Service Worker</code> –&gt; <code>Memory Cache</code> –&gt; <code>Disk Cache</code> –&gt;  <code>Push Cache</code></li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅰ-Service-Worker\"><a href=\"#Ⅰ-Service-Worker\" class=\"headerlink\" title=\"Ⅰ -  Service Worker\"></a>Ⅰ -  Service Worker</h3><blockquote>\n<ul>\n<li>是运行在浏览器背后的独立线程,一般可以用来实现缓存功能. </li>\n<li>使用<code>Service Worker</code> 的话,因为其中涉及到请求拦截,所以传输协议必须为<code>HTTPS</code>来保障安全</li>\n<li><code>Service Worker</code>的缓存和浏览器其他内建的缓存机制不同,它可以让我们自由控制缓存那些文件,如何匹配缓存、读取缓存,并且缓存时持续性的</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-Memory-Cache\"><a href=\"#Ⅱ-Memory-Cache\" class=\"headerlink\" title=\"Ⅱ - Memory Cache\"></a>Ⅱ - Memory Cache</h3><blockquote>\n<ul>\n<li><strong>内存中的缓存</strong>: 主要包含的是当前页面中已经抓取到的资源: 例如页面下载的样式、脚本、图片等</li>\n<li>读取 <strong>内存</strong> 中的数据肯定比 <strong>磁盘</strong> 的快</li>\n<li><strong>内存缓存</strong> 虽然读取高效,但是缓存持续性很短,会随着进程的释放而释放: 如我们关闭了tab页面 ,内存中的缓存也就被释放了</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅲ-Disk-Cache\"><a href=\"#Ⅲ-Disk-Cache\" class=\"headerlink\" title=\"Ⅲ -  Disk Cache\"></a>Ⅲ -  Disk Cache</h3><blockquote>\n<ul>\n<li>存储在 <strong>硬盘</strong> 中的缓存,读取速度慢点,但是什么都能存储到磁盘中,比之 <code>Memory Cache</code> 胜在容量和存储时效性上</li>\n<li>在所有浏览器缓存中,<code>Disk Cache</code>覆盖面基本是最大的</li>\n<li>他会根据 <code>HTTP Header</code> 中的字段判断哪些资源需要缓存,哪些资源可以不请求直接使用,哪些资源已经过期需要重新请求</li>\n<li>并且即便在跨站点的情况下,相同地址的资源一旦被硬盘缓存下来,就不会再去请求数据,绝大部分数据都来自<code>Disk Cache</code></li>\n<li><strong>磁盘缓存</strong> 比 <strong>内存缓存</strong> 慢的多</li>\n</ul>\n<h6 id=\"举个🌰\"><a href=\"#举个🌰\" class=\"headerlink\" title=\"举个🌰\"></a>举个🌰</h6><blockquote>\n<p>从远程 Web 服务器直接提取访问文件可能需要 <strong>500毫秒(半秒)</strong>, 那么磁盘访问可能需要 <strong>10~20毫秒</strong> ; 而内存访问可能只需要 <strong>100纳秒</strong>; 更高级的还有 <strong>L1缓存访问</strong> 只需要0.5纳秒 (最快和最小的CPU缓存,详见此笔记 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vaG9uZ2ppbGluL2hvbmdzLXN0dWR5LW5vdGVzL2Jsb2IvbWFzdGVyLyVFNyVCQyU5NiVFNyVBOCU4Ql8lRTclQUUlOTclRTYlQjMlOTUlRTUlOEYlOEElRTglQUYlQkUlRTclQTglOEIlRTUlOUYlQkElRTclQTElODAlRTUlQUQlQTYlRTQlQjklQTAlRTclQUMlOTQlRTglQUUlQjAvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUJCJTg0JUU2JTg4JTkwJUU1JThFJTlGJUU3JTkwJTg2LyVFNyVCQyU5MyVFNSVBRCU5OCVFMyU4MCU4MSVFNSU4NiU4NSVFNSVBRCU5OCVFMyU4MCU4MUNQVSVFNyU5RiVBNSVFOCVBRiU4NiVFNyU4MiVCOSVFOCVBNyVBMyVFNiU5RSU5MCVFNyVBQyU5NCVFOCVBRSVCMC5tZCMlRTUlOUIlOUJjcHUlRTclOUElODQlRTUlQTQlOUElRTclQkElQTclRTclQkMlOTMlRTUlQUQlOTglRTklQUIlOTglRTklODAlOUYlRTclQkMlOTMlRTUlQUQlOTg=\">缓存、内存、CPU知识点解析</span> )</p>\n</blockquote>\n</blockquote>\n<h3 id=\"Ⅳ-prefetch-cache-预取缓存\"><a href=\"#Ⅳ-prefetch-cache-预取缓存\" class=\"headerlink\" title=\"Ⅳ -  prefetch cache(预取缓存)\"></a>Ⅳ -  prefetch cache(预取缓存)</h3><blockquote>\n<ul>\n<li><strong>link</strong> 标签带上 <strong>prefetch</strong> ,再次加载时会出现</li>\n<li><code>prefetch</code> 是 <strong>预加载</strong> 的一种方式: 被标记为 <code>prefetch</code> 的资源,将会被浏览器在空闲时间加载</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅴ-Push-Cache\"><a href=\"#Ⅴ-Push-Cache\" class=\"headerlink\" title=\"Ⅴ -  Push Cache\"></a>Ⅴ -  Push Cache</h3><blockquote>\n<ul>\n<li><code>Push Cache(推送缓存)</code> 是 <strong>HTTP&#x2F;2</strong> 中的内容,当以上三种缓存都没有命中时,它才会被使用</li>\n<li>它只在 <strong>会话 (Session)</strong> 中存在,一旦会话结束就会被释放,并且缓存时间也会很短暂</li>\n<li>在Chrome浏览器中只有 <strong>5分钟</strong> 左右,同时它也并非严格执行HTTP头中的缓存指令</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅵ-CPU、内存、硬盘概述\"><a href=\"#Ⅵ-CPU、内存、硬盘概述\" class=\"headerlink\" title=\"Ⅵ -  CPU、内存、硬盘概述\"></a>Ⅵ -  CPU、内存、硬盘概述</h3><blockquote>\n<h6 id=\"可能有小伙伴对于此处知识点没什么直观的概念-此处给出一个大概叙述-想了解更多的话此部分知识点本人有专门梳理笔记文件\"><a href=\"#可能有小伙伴对于此处知识点没什么直观的概念-此处给出一个大概叙述-想了解更多的话此部分知识点本人有专门梳理笔记文件\" class=\"headerlink\" title=\"可能有小伙伴对于此处知识点没什么直观的概念,此处给出一个大概叙述; 想了解更多的话此部分知识点本人有专门梳理笔记文件\"></a>可能有小伙伴对于此处知识点没什么直观的概念,此处给出一个大概叙述; 想了解更多的话此部分知识点本人有专门梳理笔记文件</h6><h6 id=\"–-gt-点我传送\"><a href=\"#–-gt-点我传送\" class=\"headerlink\" title=\"–&gt; 点我传送\"></a>–&gt; <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vaG9uZ2ppbGluL2hvbmdzLXN0dWR5LW5vdGVzL2Jsb2IvbWFzdGVyLyVFNyVCQyU5NiVFNyVBOCU4Ql8lRTclQUUlOTclRTYlQjMlOTUlRTUlOEYlOEElRTglQUYlQkUlRTclQTglOEIlRTUlOUYlQkElRTclQTElODAlRTUlQUQlQTYlRTQlQjklQTAlRTclQUMlOTQlRTglQUUlQjAvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUJCJTg0JUU2JTg4JTkwJUU1JThFJTlGJUU3JTkwJTg2LyVFNyVCQyU5MyVFNSVBRCU5OCVFMyU4MCU4MSVFNSU4NiU4NSVFNSVBRCU5OCVFMyU4MCU4MUNQVSVFNyU5RiVBNSVFOCVBRiU4NiVFNyU4MiVCOSVFOCVBNyVBMyVFNiU5RSU5MCVFNyVBQyU5NCVFOCVBRSVCMC5tZA==\">点我传送</span></h6><ul>\n<li>CPU、内存、硬盘都是计算机的主要组成部分</li>\n<li><strong>CPU</strong>: 中央处理单元的缩写,也叫做 <code>处理器</code>,是计算机的运算核心和控制核心; 电脑靠CPU来运算、控制. 让电脑各个部件顺利工作,起到协调作用</li>\n<li><strong>硬盘</strong>: 存储资料和软件等数据的设备,有容量大、断电数据不丢失的特点</li>\n<li><strong>内存</strong>: 负责 <strong>硬盘</strong> 等硬件上的数据与 <strong>CPU</strong> 之间数据的交换处理. 特点是: <code>体积小</code>、<code>速度快</code>、<code>有电可存</code>、<code>无电清空</code>,即电脑在开机状态时内存中可存储数据,关机后将自动清空其中的所有数据</li>\n</ul>\n</blockquote>\n<h2 id=\"6、强缓存有协商缓存的区别\"><a href=\"#6、强缓存有协商缓存的区别\" class=\"headerlink\" title=\"6、强缓存有协商缓存的区别\"></a>6、强缓存有协商缓存的区别</h2><blockquote>\n<p>这里再次总结整理一下两者之间的区别</p>\n<ul>\n<li>强缓存不发请求到服务端,所以有时候资源更新了浏览器还不知道; </li>\n<li>但是协商缓存会发请求到服务器,所以资源是否更新,服务器肯定知道</li>\n<li>大部分web服务器都默认开启协商缓存</li>\n</ul>\n</blockquote>\n<h2 id=\"7、刷新对于强缓存和协商缓存的影响\"><a href=\"#7、刷新对于强缓存和协商缓存的影响\" class=\"headerlink\" title=\"7、刷新对于强缓存和协商缓存的影响\"></a>7、刷新对于强缓存和协商缓存的影响</h2><blockquote>\n<ul>\n<li>当 <code>ctrl+F5</code>强制刷新网页时: 直接从服务器加载, <strong>跳过强缓存和协商缓存</strong></li>\n<li>当 f5 刷新网页时,跳过强缓存,但是会检查协商缓存</li>\n<li>浏览器地址写入URL并回车: 浏览器发现缓存中有这个文件了,就不用继续请求了,直接去缓存拿 (最快)</li>\n</ul>\n</blockquote>\n","categories":["HTTP"],"tags":["HTTP","协议"]},{"title":"OSI七层网络模型","url":"/2024/05/27/OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","content":"<h1 id=\"OSI七层网络模型\"><a href=\"#OSI七层网络模型\" class=\"headerlink\" title=\"OSI七层网络模型\"></a>OSI七层网络模型</h1><p><img data-src=\"/images/e3cc1860482648d5a2b2f6bac23280d3~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp\" alt=\"images\"></p>\n<h1 id=\"七、应用层（应用）\"><a href=\"#七、应用层（应用）\" class=\"headerlink\" title=\"七、应用层（应用）\"></a>七、应用层（应用）</h1><p>应用层就是我们最接近我们、最常用的一层，例如：</p>\n<ul>\n<li>ajax调用接口发送<strong>http请求</strong></li>\n<li>使用<strong>DNS域名查询</strong>系统</li>\n<li><strong>邮件协议SMTP</strong></li>\n<li><strong>websock长连接</strong></li>\n<li><strong>SSH协议</strong></li>\n<li>等。</li>\n</ul>\n<h1 id=\"六、表示层（安全、压缩、翻译）\"><a href=\"#六、表示层（安全、压缩、翻译）\" class=\"headerlink\" title=\"六、表示层（安全、压缩、翻译）\"></a>六、表示层（安全、压缩、翻译）</h1><p>表示层做了几件重要的事情如：</p>\n<ul>\n<li>压缩</li>\n<li>安全（数据发送前进行加密，在接受者的表示层进行解密）</li>\n<li>程序在网络中的翻译官（对图片文件等格式进行解码和编码）</li>\n</ul>\n<h1 id=\"五、会话层（检查点机制）\"><a href=\"#五、会话层（检查点机制）\" class=\"headerlink\" title=\"五、会话层（检查点机制）\"></a>五、会话层（检查点机制）</h1><ul>\n<li>会话层是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方</li>\n<li>会话层定义了一种机制，允许发送方和接收方启动或停止请求会话，当及当双方发生拥塞时仍然能保持对话</li>\n<li>会话层包含了一种<strong>检查点的机制</strong>来维持可靠会话，检查点定义了一个最接近成功通信的点，并且定义了当发生内容丢失或者损坏时需要回滚以便回复丢失或损坏数据的点，即断点下载的原理</li>\n</ul>\n<h1 id=\"四、传输层（TCP、UDP连接）\"><a href=\"#四、传输层（TCP、UDP连接）\" class=\"headerlink\" title=\"四、传输层（TCP、UDP连接）\"></a>四、传输层（TCP、UDP连接）</h1><ul>\n<li>传输层主要就是定义端口号，以及控流和校验</li>\n<li>TCP（面向连接的协议并且TCP是可靠的），因为TCP会进行三报文握手和四报文挥手，所以是可靠的，但是这样会降低速度</li>\n<li>UDP（UDP没有三报文握手和四报文挥手，因此不够稳定，但是速度快，常用于直播和游戏）</li>\n</ul>\n<h1 id=\"三、网络层（IP地址）\"><a href=\"#三、网络层（IP地址）\" class=\"headerlink\" title=\"三、网络层（IP地址）\"></a>三、网络层（IP地址）</h1><ul>\n<li>网络层是最复杂的一层，在网络层定义了IP</li>\n<li>网络层控制数据链路层与传输层之间的信息转发，建立，维持和终止网络的连接。</li>\n<li>数据链路层的数据在网络层被转换为数据包，然后通过路径选择、分段组合、顺序、进&#x2F;出路由等控制，将信息从一个网络设备传送到另一个网络设备</li>\n<li>寻址：对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信（类似于数据链路层的MAC地址）</li>\n<li>路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</li>\n<li>如果所有的使用互联网的用户在同一个网段中，<strong>会产生广播风暴，所以要将用户进行划分</strong>，让他们在不同的网段中，自己在自己的小网段中广播。而<strong>互联网就是这无数的子网络构成的一个巨型网络</strong>。</li>\n<li>在网络层中引入了一套新的地址，让我们能够区分不同的网段。这套地址就叫做“网络地址”，简称“网址”。于是，<strong>”网络层”出现以后，每台计算机有了两种地址</strong>，<strong>一种是MAC地址，另一种是网络地址</strong>。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。<strong>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。</strong>因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</li>\n<li>这一层中有一个<strong>规定网络地址的协议，叫做IP协议</strong>，它所定义的地址，就被称为IP地址。</li>\n<li>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。因为IPv4的地址已经不够用了，所以现在推广IPv6，</li>\n</ul>\n<h1 id=\"二、数据链路层（MAC地址）\"><a href=\"#二、数据链路层（MAC地址）\" class=\"headerlink\" title=\"二、数据链路层（MAC地址）\"></a>二、数据链路层（MAC地址）</h1><ul>\n<li>建立逻辑连接、进行硬件地址寻址、差错校验等功能（底层网络定义协议）</li>\n<li>及比特组合成字节进而组合成帧，用MAC地址访问介质，此时可以发现错误但不能纠正。</li>\n<li>MAC地址是每个网卡的唯一标识，有了MAC地址就能知道谁是接收者，谁是发送者，并且知道了数据的内容，并且进行分组。</li>\n<li>传播数据是通过广播的方式进行传输，在局域网中的所有计算机都能接收到消息</li>\n</ul>\n<h1 id=\"一、物理层（物理信道）\"><a href=\"#一、物理层（物理信道）\" class=\"headerlink\" title=\"一、物理层（物理信道）\"></a>一、物理层（物理信道）</h1><ul>\n<li><p>物理层是直接和物理介质打交道的。</p>\n</li>\n<li><p>物理层的设备 网卡，网线，集线器，中继器，调制解调器</p>\n</li>\n</ul>\n<p><strong>物理层信道：</strong></p>\n<ul>\n<li><p>有线信道</p>\n<ul>\n<li>明线（平行架设在电线杆上的架空线路）</li>\n<li>对称电缆（对多双绞线组成）</li>\n<li>同轴电缆（具有外层屏蔽层）</li>\n<li>光纤（利用光在纤维中的反射原理进行传输）</li>\n</ul>\n</li>\n<li><p>无线信道</p>\n<p>以辐射无线电波为传输方式无线信道主要有地波传输，天波传输和视距传输 例如：卫星通讯，电台广播</p>\n</li>\n</ul>\n<p>物理层通过以上的方式，会获取他们对应的传送信号，电压，转换成010101010101但是数据还未组织，仅作为原始的电气电压处理<code>单位为bit</code></p>\n","categories":["OSI七层网络模型"],"tags":["OSI七层网络模型"]},{"title":"JS进阶","url":"/2023/08/02/JS/","content":"<h1 id=\"JavaScript-进阶-第1天\"><a href=\"#JavaScript-进阶-第1天\" class=\"headerlink\" title=\"JavaScript 进阶 - 第1天\"></a>JavaScript 进阶 - 第1天</h1><blockquote>\n<p>学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。</p>\n</blockquote>\n<ul>\n<li>理解作用域对程序执行的影响</li>\n<li>能够分析程序执行的作用域范围</li>\n<li>理解闭包本质，利用闭包创建隔离作用域</li>\n<li>了解什么变量提升及函数提升</li>\n<li>掌握箭头函数、解析剩余参数等简洁语法</li>\n</ul>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。</p>\n</blockquote>\n<p>作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。</p>\n<h3 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h3><p>局部作用域分为<strong>函数作用域</strong>和<strong>块作用域</strong>。</p>\n<h4 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h4><p>在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 声明 counter 函数\n  function counter(x, y) &#123;\n    // 函数内部声明的变量\n    const s = x + y\n    console.log(s) // 18\n  &#125;\n  // 设用 counter 函数\n  counter(10, 8)\n  // 访问变量 s\n  console.log(s)// 报错\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>函数内部声明的变量，在函数外部无法被访问</li>\n<li>函数的参数也是函数内部的局部变量</li>\n<li>不同函数内部声明的变量无法互相访问</li>\n<li>函数执行完毕后，函数内部的变量实际被清空了</li>\n</ol>\n<h4 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h4><p>在 JavaScript 中使用 <code>&#123;&#125;</code> 包裹的代码称为<strong>代码块</strong>，代码块内部声明的变量外部将【<span style=\"color:red\">有可能</span>】无法被访问。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  &#123;\n    // age 只能在该代码块中被访问\n    let age = 18;\n    console.log(age); // 正常\n  &#125;\n  \n  // 超出了 age 的作用域\n  console.log(age) // 报错\n  \n  let flag = true;\n  if(flag) &#123;\n    // str 只能在该代码块中被访问\n    let str = &#39;hello world!&#39;\n    console.log(str); // 正常\n  &#125;\n  \n  // 超出了 age 的作用域\n  console.log(str); // 报错\n  \n  for(let t = 1; t &lt;= 6; t++) &#123;\n    // t 只能在该代码块中被访问\n    console.log(t); // 正常\n  &#125;\n  \n  // 超出了 t 的作用域\n  console.log(t); // 报错\n&lt;/script&gt;\n</code></pre>\n<p>JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 必须要有值\n  const version = &#39;1.0.0&#39;;\n\n  // 不能重新赋值\n  // version = &#39;1.0.1&#39;;\n\n  // 常量值为对象类型\n  const user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  // 不能重新赋值\n  user = &#123;&#125;;\n\n  // 属性和方法允许被修改\n  user.name = &#39;小小明&#39;;\n  user.gender = &#39;男&#39;;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>let</code> 声明的变量会产生块作用域，<code>var</code> 不会产生块作用域</li>\n<li><code>const</code> 声明的常量也会产生块作用域</li>\n<li>不同代码块之间的变量无法互相访问</li>\n<li>推荐使用 <code>let</code> 或 <code>const</code></li>\n</ol>\n<p>注：开发中 <code>let</code> 和 <code>const</code> 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 <code>const</code> 声明成常量。</p>\n<h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p><code>&lt;script&gt;</code> 标签和 <code>.js</code> 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 此处是全局\n  \n  function sayHi() &#123;\n    // 此处为局部\n  &#125;\n\n  // 此处为全局\n&lt;/script&gt;\n</code></pre>\n<p>全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n    // 全局变量 name\n    const name = &#39;小明&#39;\n  \n      // 函数作用域中访问全局\n    function sayHi() &#123;\n      // 此处为局部\n      console.log(&#39;你好&#39; + name)\n    &#125;\n\n    // 全局变量 flag 和 x\n    const flag = true\n    let x = 10\n  \n      // 块作用域中访问全局\n    if(flag) &#123;\n      let y = 5\n      console.log(x + y) // x 是全局的\n    &#125;\n&lt;/script&gt;\n</code></pre>\n<p>注意：</p>\n<ol>\n<li>为 <code>window</code> 对象动态添加的属性默认也是全局的，不推荐！</li>\n<li>函数中未使用任何关键字声明的变量为全局变量，不推荐！！！</li>\n<li>尽可能少的声明全局变量，防止全局变量被污染</li>\n</ol>\n<p>JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>在解释什么是作用域链前先来看一段代码：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 全局作用域\n  let a = 1\n  let b = 2\n  // 局部作用域\n  function f() &#123;\n    let c\n    // 局部作用域\n    function g() &#123;\n      let d = &#39;yo&#39;\n    &#125;\n  &#125;\n&lt;/script&gt;\n</code></pre>\n<p>函数内部允许创建新的函数，<code>f</code> 函数内部创建的新函数 <code>g</code>，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。</p>\n<p>如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。</p>\n<p>作用域链本质上是底层的<strong>变量查找机制</strong>，在函数被执行时，会<strong>优先查找当前</strong>函数作用域中查找变量，如果当前作用域查找不到则会依次<strong>逐级查找父级作用域</strong>直到全局作用域，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 全局作用域\n  let a = 1\n  let b = 2\n\n  // 局部作用域\n  function f() &#123;\n    let c\n    // let a = 10;\n    console.log(a) // 1 或 10\n    console.log(d) // 报错\n    \n    // 局部作用域\n    function g() &#123;\n      let d = &#39;yo&#39;\n      // let b = 20;\n      console.log(b) // 2 或 20\n    &#125;\n    \n    // 调用 g 函数\n    g()\n  &#125;\n\n  console.log(c) // 报错\n  console.log(d) // 报错\n  \n  f();\n&lt;/script&gt;\n</code></pre>\n<p><strong>总结</strong>：</p>\n<ol>\n<li>嵌套关系的作用域串联起来形成了作用域链</li>\n<li>相同作用域链中按着从小到大的规则查找变量</li>\n<li>子作用域能够访问父作用域，父级作用域无法访问子级作用域</li>\n</ol>\n<h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p><span style=\"color:red\">垃圾回收机制 (Garbage Collection) 简称 GC</span></p>\n<p>JS中<span style=\"color:red\">内存</span>的分配和回收都是<span style=\"color:red\">自动完成</span>的，内存在不使用的时候会被<span style=\"color:red\">垃圾回收器</span>自动回收</p>\n<ul>\n<li><p><strong>内存的生命周期</strong></p>\n<p>Js 环境中分配的内存，一般有如下<span style=\"color:red\">生命周期</span></p>\n<ol>\n<li><span style=\"color:red\">内存分配: </span> 当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</li>\n<li><span style=\"color:red\">内存使用:  </span>即读写内存，也就是使用变量、函数等</li>\n<li><span style=\"color:red\">内存回收:  </span>使用完毕，由<span style=\"color:red\">垃圾回收器</span>自动回收不再使用的内存</li>\n</ol>\n</li>\n<li><p><strong>说明:</strong></p>\n<ul>\n<li>全局变量一般不会回收 (关闭页面回收)</li>\n<li>一般情况下<span style=\"color:red\">局部变量的值</span>，不用了，会被<span style=\"color:red\">自动回收</span>掉</li>\n</ul>\n</li>\n<li><p>**内存泄漏: ** 程序中分配的<span style=\"color:red\">内存</span>由于某种原因程序<span style=\"color:red\">未释放</span>或<span style=\"color:red\">无法释放</span>叫做<span style=\"color:red\">内存泄漏</span></p>\n</li>\n</ul>\n<p>堆栈空间分配的区别:</p>\n<ol>\n<li>栈 (操作系统) :  由<span style=\"color:red\">操作系统自动分配释放</span>函数的参数值、局部变量等，基本数据类型放到栈里面。</li>\n<li>堆 (操作系统) :  一般由程序员分配释放，若程序员不释放，由<span style=\"color:red\">垃圾回收机制</span>回收。<span style=\"color:red\">复杂数据类型</span>放到堆里面。</li>\n</ol>\n<p>两种常见的浏览器<span style=\"color:red\">垃圾回收算法</span>  :  <span style=\"color:red\">引用计数法</span>和<span style=\"color:red\">标记清除法</span> </p>\n<p><img data-src=\"/./assets/3a6a0d0eb00f0fc93da43bef340def09fb852cfd.png\" alt=\"/images/image-20230222143512473\"></p>\n<p><img data-src=\"/./assets/8bd6f7f95a204d6ebf00baf191f18ea65c0274a3.png\" alt=\"/images/image-20230222143950850\"></p>\n<p><img data-src=\"/./assets/431107ef8e51bc1dfe39c9ecd525c5c85874e645.png\" alt=\"/images/image-20230222144237548\"></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。从代码形式上看闭包是一个做为返回值的函数，如下代码所示：</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // 1. 闭包 : 内层函数 + 外层函数变量\n    // function outer() &#123;\n    //   const a = 1\n    //   function f() &#123;\n    //     console.log(a)\n    //   &#125;\n    //   f()\n    // &#125;\n    // outer()\n\n    // 2. 闭包的应用： 实现数据的私有。统计函数的调用次数\n    // let count = 1\n    // function fn() &#123;\n    //   count++\n    //   console.log(`函数被调用$&#123;count&#125;次`)\n    // &#125;\n\n    // 3. 闭包的写法  统计函数的调用次数\n    function outer() &#123;\n      let count = 1\n      function fn() &#123;\n        count++\n        console.log(`函数被调用$&#123;count&#125;次`)\n      &#125;\n      return fn\n    &#125;\n    const re = outer()\n    // const re = function fn() &#123;\n    //   count++\n    //   console.log(`函数被调用$&#123;count&#125;次`)\n    // &#125;\n    re()\n    re()\n    // const fn = function() &#123; &#125;  函数表达式\n    // 4. 闭包存在的问题： 可能会造成内存泄漏\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>总结：</p>\n<p>1.怎么理解闭包？</p>\n<ul>\n<li><strong>闭包 &#x3D; 内层函数 + 外层函数的变量</strong></li>\n</ul>\n<p>2.闭包的作用？</p>\n<ul>\n<li>封闭数据，实现数据私有，外部也可以访问函数内部的变量</li>\n<li>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来</li>\n</ul>\n<p>3.闭包可能引起的问题？</p>\n<ul>\n<li>内存泄漏</li>\n</ul>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问，</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 访问变量 str\n  console.log(str + &#39;world!&#39;);\n\n  // 声明变量 str\n  var str = &#39;hello &#39;;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>变量在未声明即被访问时会报语法错误</li>\n<li>变量在声明之前即被访问，变量的值为 <code>undefined</code></li>\n<li><code>let</code> 声明的变量不存在变量提升，推荐使用 <code>let</code></li>\n<li>变量提升出现在相同作用域当中</li>\n<li><span style=\"color:red\">实际开发中推荐先声明再访问变量</span></li>\n</ol>\n<p>注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 <code>let</code> 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMzkxNTkzNQ==\">查阅资料</span>。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><blockquote>\n<p>知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。</p>\n</blockquote>\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h3><p>函数提升与变量提升比较类似，是指函数在声明之前即可被调用。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 调用函数\n  foo()\n  // 声明函数\n  function foo() &#123;\n    console.log(&#39;声明之前即被调用...&#39;)\n  &#125;\n\n  // 不存在提升现象\n  bar()  // 错误\n  var bar = function () &#123;\n    console.log(&#39;函数表达式不存在提升现象...&#39;)\n  &#125;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>函数提升能够使函数的声明调用更灵活</li>\n<li>函数表达式不存在提升的现象</li>\n<li>函数提升出现在相同作用域当中</li>\n</ol>\n<h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>函数参数的使用细节，能够提升函数应用的灵活度。</p>\n<h4 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><pre><code class=\"html\">&lt;script&gt;\n  // 设置参数默认值\n  function sayHi(name=&quot;小明&quot;, age=18) &#123;\n    document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`);\n  &#125;\n  // 调用函数\n  sayHi();\n  sayHi(&#39;小红&#39;);\n  sayHi(&#39;小刚&#39;, 21);\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>声明函数时为形参赋值即为参数的默认值</li>\n<li>如果参数未自定义默认值时，参数的默认值为 <code>undefined</code></li>\n<li>调用函数时没有传入对应实参时，参数的默认值被当做实参传入</li>\n</ol>\n<h4 id=\"动态参数\"><a href=\"#动态参数\" class=\"headerlink\" title=\"动态参数\"></a>动态参数</h4><p><code>arguments</code> 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 求生函数，计算所有参数的和\n  function sum() &#123;\n    // console.log(arguments)\n    let s = 0\n    for(let i = 0; i &lt; arguments.length; i++) &#123;\n      s += arguments[i]\n    &#125;\n    console.log(s)\n  &#125;\n  // 调用求和函数\n  sum(5, 10)// 两个参数\n  sum(1, 2, 4) // 两个参数\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>arguments</code> 是一个伪数组</li>\n<li><code>arguments</code> 的作用是动态获取函数的实参</li>\n</ol>\n<h4 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h4><pre><code class=\"html\">&lt;script&gt;\n  function config(baseURL, ...other) &#123;\n    console.log(baseURL) // 得到 &#39;http://baidu.com&#39;\n    console.log(other)  // other  得到 [&#39;get&#39;, &#39;json&#39;]\n  &#125;\n  // 调用函数\n  config(&#39;http://baidu.com&#39;, &#39;get&#39;, &#39;json&#39;);\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>...</code> 是语法符号，置于最末函数形参之前，用于获取多余的实参</li>\n<li>借助 <code>...</code> 获取的剩余实参，是个真数组</li>\n</ol>\n<p><strong>展开运算符</strong> (…)</p>\n<p>说明:</p>\n<ol>\n<li>不会修改原数组</li>\n</ol>\n<pre><code class=\"html\">&lt;script&gt;\n    const arr1 = [1,2,3]\n    // 展开运算符，可以展开数组\n    // console.log(...arr1)\n\n    // ...arr1 === 1,2,3\n    // 1.求数组最大值\n    console.log(Math.max(...arr1))  // 3\n    console.log(Math.min(...arr1))  // 1\n    // 2.合并数组\n    const arr2 = [3,4,5]\n    const arr = [...arr1,...arr2]\n    console.log(arr)  // [1, 2, 3, 3, 4, 5]\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // const fn = function () &#123;\n    //   console.log(123)\n    // &#125;\n    // 1. 箭头函数 基本语法\n    // const fn = () =&gt; &#123;\n    //   console.log(123)\n    // &#125;\n    // fn()\n    // const fn = (x) =&gt; &#123;\n    //   console.log(x)\n    // &#125;\n    // fn(1)\n    // 2. 只有一个形参的时候，可以省略小括号\n    // const fn = x =&gt; &#123;\n    //   console.log(x)\n    // &#125;\n    // fn(1)\n    // // 3. 只有一行代码的时候，我们可以省略大括号\n    // const fn = x =&gt; console.log(x)\n    // fn(1)\n    // 4. 只有一行代码的时候，可以省略return\n    // const fn = x =&gt; x + x\n    // console.log(fn(1))\n    // 5. 箭头函数可以直接返回一个对象\n    // const fn = (uname) =&gt; (&#123; uname: uname &#125;)\n    // console.log(fn(&#39;刘德华&#39;))\n\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>箭头函数属于表达式函数，因此不存在函数提升</li>\n<li>箭头函数只有一个参数时可以省略圆括号 <code>()</code></li>\n<li>箭头函数函数体只有一行代码时可以省略花括号 <code>&#123;&#125;</code>，并自动做为返回值被返回</li>\n</ol>\n<h4 id=\"箭头函数参数\"><a href=\"#箭头函数参数\" class=\"headerlink\" title=\"箭头函数参数\"></a>箭头函数参数</h4><p>箭头函数中没有 <code>arguments</code>，只能使用 <code>...</code> 动态获取实参</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // 1. 利用箭头函数来求和\n    const getSum = (...arr) =&gt; &#123;\n      let sum = 0\n      for (let i = 0; i &lt; arr.length; i++) &#123;\n        sum += arr[i]\n      &#125;\n      return sum\n    &#125;\n    const result = getSum(2, 3, 4)\n    console.log(result) // 9\n  &lt;/script&gt;\n</code></pre>\n<h4 id=\"箭头函数-this\"><a href=\"#箭头函数-this\" class=\"headerlink\" title=\"箭头函数 this\"></a>箭头函数 this</h4><p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。</p>\n<pre><code class=\"html\"> &lt;script&gt;\n    // 以前this的指向：  谁调用的这个函数，this 就指向谁\n    // console.log(this)  // window\n    // // 普通函数\n    // function fn() &#123;\n    //   console.log(this)  // window\n    // &#125;\n    // window.fn()\n    // // 对象方法里面的this\n    // const obj = &#123;\n    //   name: &#39;andy&#39;,\n    //   sayHi: function () &#123;\n    //     console.log(this)  // obj\n    //   &#125;\n    // &#125;\n    // obj.sayHi()\n\n    // 2. 箭头函数的this  是上一层作用域的this 指向\n    // const fn = () =&gt; &#123;\n    //   console.log(this)  // window\n    // &#125;\n    // fn()\n    // 对象方法箭头函数 this\n    // const obj = &#123;\n    //   uname: &#39;pink老师&#39;,\n    //   sayHi: () =&gt; &#123;\n    //     console.log(this)  // this 指向谁？ window\n    //   &#125;\n    // &#125;\n    // obj.sayHi()\n\n    const obj = &#123;\n      uname: &#39;pink老师&#39;,\n      sayHi: function () &#123;\n        console.log(this)  // obj\n        let i = 10\n        const count = () =&gt; &#123;\n          console.log(this)  // obj \n        &#125;\n        count()\n      &#125;\n    &#125;\n    obj.sayHi()\n\n  &lt;/script&gt;\n</code></pre>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><blockquote>\n<p>知道解构的语法及分类，使用解构简洁语法快速为变量赋值。</p>\n</blockquote>\n<p>解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。</p>\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><p><strong>数组解构</strong>是将数组的<strong>单元值</strong>快速批量<strong>赋值</strong>给一系列变量的<strong>简洁语法</strong>，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通的数组\n  let arr = [1, 2, 3]\n  // 批量声明变量 a b c \n  // 同时将数组单元值 1 2 3 依次赋值给变量 a b c\n  let [a, b, c] = arr\n  console.log(a); // 1\n  console.log(b); // 2\n  console.log(c); // 3\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>赋值运算符 <code>=</code> 左侧的 <code>[]</code> 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量</li>\n<li>变量的顺序对应数组单元值的位置依次进行赋值操作</li>\n<li>变量的数量大于单元值数量时，多余的变量将被赋值为  <code>undefined</code></li>\n<li>变量的数量小于单元值数量时，可以通过 <code>...</code> 获取剩余单元值，但只能置于最末位</li>\n<li>允许初始化变量的默认值，且只有单元值为 <code>undefined</code> 时默认值才会生效</li>\n</ol>\n<p>注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析</p>\n<h3 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h3><p>对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;;\n  // 批量声明变量 name age\n  // 同时将数组单元值 小明  18 依次赋值给变量 name  age\n  const &#123;name, age&#125; = user\n\n  console.log(name) // 小明\n  console.log(age) // 18\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>赋值运算符 <code>=</code> 左侧的 <code>&#123;&#125;</code> 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量</li>\n<li>对象属性的值将被赋值给与属性名<span style=\"color:red\">相同的</span>变量</li>\n<li>对象中找不到与变量名一致的属性时变量值为 <code>undefined</code></li>\n<li>允许初始化变量的默认值，属性不存在或单元值为 <code>undefined</code> 时默认值才会生效</li>\n</ol>\n<p>注：支持多维解构赋值</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // 1. 这是后台传递过来的数据\n    const msg = &#123;\n      &quot;code&quot;: 200,\n      &quot;msg&quot;: &quot;获取新闻列表成功&quot;,\n      &quot;data&quot;: [\n        &#123;\n          &quot;id&quot;: 1,\n          &quot;title&quot;: &quot;5G商用自己，三大运用商收入下降&quot;,\n          &quot;count&quot;: 58\n        &#125;,\n        &#123;\n          &quot;id&quot;: 2,\n          &quot;title&quot;: &quot;国际媒体头条速览&quot;,\n          &quot;count&quot;: 56\n        &#125;,\n        &#123;\n          &quot;id&quot;: 3,\n          &quot;title&quot;: &quot;乌克兰和俄罗斯持续冲突&quot;,\n          &quot;count&quot;: 1669\n        &#125;,\n\n      ]\n    &#125;\n\n    // 需求1： 请将以上msg对象  采用对象解构的方式 只选出  data 方面后面使用渲染页面\n    // const &#123; data &#125; = msg\n    // console.log(data)\n    // 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数\n    // const &#123; data &#125; = msg\n    // msg 虽然很多属性，但是我们利用解构只要 data值\n    function render(&#123; data &#125;) &#123;\n      // const &#123; data &#125; = arr\n      // 我们只要 data 数据\n      // 内部处理\n      console.log(data)\n\n    &#125;\n    render(msg)\n\n    // 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData\n    function render(&#123; data: myData &#125;) &#123;\n      // 要求将 获取过来的 data数据 更名为 myData\n      // 内部处理\n      console.log(myData)\n\n    &#125;\n    render(msg)\n\n  &lt;/script&gt;\n</code></pre>\n<h2 id=\"综合案例\"><a href=\"#综合案例\" class=\"headerlink\" title=\"综合案例\"></a>综合案例</h2><h3 id=\"forEach遍历数组\"><a href=\"#forEach遍历数组\" class=\"headerlink\" title=\"forEach遍历数组\"></a>forEach遍历数组</h3><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数</p>\n<p><strong>语法:</strong> </p>\n<pre><code class=\"js\">被遍历的数组.forEach(function(当前数组元素,当前元素索引号)&#123;\n    // 函数体\n&#125;)\n</code></pre>\n<blockquote>\n<p>注意：  </p>\n<ol>\n<li><p>forEach 主要是遍历数组</p>\n</li>\n<li><p>参数当前数组元素是必须要写的， 索引号可选。</p>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // forEach 就是遍历  加强版的for循环  适合于遍历数组对象\n    const arr = [&#39;red&#39;, &#39;green&#39;, &#39;pink&#39;]\n    const result = arr.forEach(function (item, index) &#123;\n      console.log(item)  // 数组元素 red  green pink\n      console.log(index) // 索引号\n    &#125;)\n    // console.log(result)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h3 id=\"filter筛选数组\"><a href=\"#filter筛选数组\" class=\"headerlink\" title=\"filter筛选数组\"></a>filter筛选数组</h3><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素</p>\n<p>主要使用场景： <span style=\"color:red\">筛选数组符合条件的元素</span>，<strong>并返回筛选之后元素的新数组</strong></p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    const arr = [10, 20, 30]\n    // const newArr = arr.filter(function (item, index) &#123;\n    //   // console.log(item)\n    //   // console.log(index)\n    //   return item &gt;= 20\n    // &#125;)\n    // 返回的符合条件的新数组\n\n    const newArr = arr.filter(item =&gt; item &gt;= 20)\n    console.log(newArr)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h1 id=\"JavaScript-进阶-第2天\"><a href=\"#JavaScript-进阶-第2天\" class=\"headerlink\" title=\"JavaScript 进阶 - 第2天\"></a>JavaScript 进阶 - 第2天</h1><blockquote>\n<p>了解面向对象编程的基础概念及构造函数的作用，体会 JavaScript 一切皆对象的语言特征，掌握常见的对象属性和方法的使用。</p>\n</blockquote>\n<ul>\n<li>了解面向对象编程中的一般概念</li>\n<li>能够基于构造函数创建对象</li>\n<li>理解 JavaScript 中一切皆对象的语言特征</li>\n<li>理解引用对象类型值存储的的特征</li>\n<li>掌握包装类型对象常见方法的使用</li>\n</ul>\n<h2 id=\"深入对象\"><a href=\"#深入对象\" class=\"headerlink\" title=\"深入对象\"></a>深入对象</h2><blockquote>\n<p>了解面向对象的基础概念，能够利用构造函数创建对象。</p>\n</blockquote>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>创建对象有三种方式: </p>\n<p><img data-src=\"/./assets/f5ecf72264886ba2724b6a413d1aee2bf5e148c3.png\" alt=\"/images/image-20230224115719324\"></p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><strong>构造函数</strong>是专门用于创建对象的函数，如果一个函数使用 <code>new</code> 关键字调用，那么这个函数就是构造函数。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 定义函数\n  function foo() &#123;\n    console.log(&#39;通过 new 也能调用函数...&#39;);\n  &#125;\n  // 调用函数\n  new foo;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><p>使用 <code>new</code> 关键字调用函数的行为被称为<strong>实例化</strong></p>\n</li>\n<li><p>实例化构造函数时没有参数时可以省略 <code>()</code></p>\n</li>\n<li><p>构造函数的返回值即为新创建的对象</p>\n</li>\n<li><p>构造函数内部的 <code>return</code> 返回的值无效！所以不要写return</p>\n</li>\n<li><p><code>new Object()</code>和 <code>new Date()</code>也是实例化构造函数</p>\n</li>\n</ol>\n<p>注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的<strong>首字母大写</strong>。</p>\n<h3 id=\"实例化过程\"><a href=\"#实例化过程\" class=\"headerlink\" title=\"实例化过程\"></a>实例化过程</h3><ol>\n<li>创建新空对象</li>\n<li>构造函数this指向新对象</li>\n<li>执行构造函数代码，修改this，添加新的属性</li>\n<li>返回新对象</li>\n</ol>\n<h3 id=\"实例成员\"><a href=\"#实例成员\" class=\"headerlink\" title=\"实例成员\"></a>实例成员</h3><p>通过构造函数创建的对象称为实例对象，<span style=\"color:red\">实例对象中</span>的属性和方法称为<span style=\"color:red\">实例成员</span> (实例属性和实例方法)。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 构造函数\n  function Person() &#123;\n    // 构造函数内部的 this 就是实例对象\n    // 实例对象中动态添加属性\n    this.name = &#39;小明&#39;\n    // 实例对象动态添加方法\n    this.sayHi = function () &#123;\n      console.log(&#39;大家好~&#39;)\n    &#125;\n  &#125;\n  // 实例化，p1 是实例对象\n  // p1 实际就是 构造函数内部的 this\n  const p1 = new Person()\n  console.log(p1)\n  console.log(p1.name) // 访问实例属性\n  p1.sayHi() // 调用实例方法\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>构造函数内部 <code>this</code> 实际上就是实例对象，为其动态添加的属性和方法即为实例成员</li>\n<li>为构造函数传入参数，动态创建结构相同但值不同的对象</li>\n</ol>\n<p>注：构造函数创建的实例对象彼此独立互不影响。</p>\n<h3 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h3><p>在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 构造函数\n  function Person(name, age) &#123;\n    // 省略实例成员\n  &#125;\n  // 静态属性\n  Person.eyes = 2\n  Person.arms = 2\n  // 静态方法\n  Person.walk = function () &#123;\n    console.log(&#39;^_^人都会走路...&#39;)\n    // this 指向 Person\n    console.log(this.eyes)\n  &#125;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>静态成员指的是添加到构造函数本身的属性和方法</li>\n<li>一般公共特征的属性或方法静态成员设置为静态成员</li>\n<li>静态成员方法中的 <code>this</code> 指向构造函数本身</li>\n</ol>\n<h2 id=\"内置构造函数\"><a href=\"#内置构造函数\" class=\"headerlink\" title=\"内置构造函数\"></a>内置构造函数</h2><blockquote>\n<p>掌握各引用类型和包装类型对象属性和方法的使用。</p>\n</blockquote>\n<p>在 JavaScript 中<strong>最主要</strong>的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。</p>\n<p>在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 <code>Date</code> 就是内置的构造函数。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 实例化\n    let date = new Date();\n  \n  // date 即为实例对象\n  console.log(date);\n&lt;/script&gt;\n</code></pre>\n<p>甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。</p>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><p><code>Object</code> 是内置的构造函数，用于创建普通对象。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 通过构造函数创建普通对象\n  const user = new Object(&#123;name: &#39;小明&#39;, age: 15&#125;)\n\n  // 这种方式声明的变量称为【字面量】\n  let student = &#123;name: &#39;杜子腾&#39;, age: 21&#125;\n  \n  // 对象语法简写\n  let name = &#39;小红&#39;;\n  let people = &#123;\n    // 相当于 name: name\n    name,\n    // 相当于 walk: function () &#123;&#125;\n    walk () &#123;\n      console.log(&#39;人都要走路...&#39;);\n    &#125;\n  &#125;\n\n  console.log(student.constructor);\n  console.log(user.constructor);\n  console.log(student instanceof Object);\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><p>推荐使用字面量方式声明对象，而不是 <code>Object</code> 构造函数</p>\n</li>\n<li><p><code>Object.assign</code> 静态方法创建新的对象，经常使用给对象添加属性的场景</p>\n<p><strong>语法</strong>: <code>Object.assign(target, ...sources)</code></p>\n<p><strong>参数:</strong> </p>\n<ul>\n<li><p><code>target</code> 目标对象，接收源对象属性的对象，也是修改后的返回值。</p>\n</li>\n<li><p><code>sources</code> 源对象，包含将被合并的属性。</p>\n</li>\n</ul>\n<p><strong>返回值:</strong> 目标对象</p>\n<pre><code class=\"js\">// 拷贝对象 把 o 拷贝给 obj\nconst o = &#123; name: &#39;佩奇&#39;, age: 6 &#125;\nconst obj = &#123;&#125;\nconst newObj = Object.assign(obj, o)\nconsole.log(obj)  // &#123;name: &#39;佩奇&#39;, age: 6&#125;\nconsole.log(newObj)  // &#123;name: &#39;佩奇&#39;, age: 6&#125;\n\n// 给 o 添加属性\nObject.assign(o,&#123; gender: &#39;女&#39; &#125;)\nconsole.log(o)  // &#123;name: &#39;佩奇&#39;, age: 6, gender: &#39;女&#39;&#125;\n\n// 源对象存在目标对象相同的值，则会修改目标对象的该数据\nObject.assign(o,&#123;name:&#39;小猪佩奇&#39;&#125;)\nconsole.log(o) // &#123;name: &#39;小猪佩奇&#39;, age: 6, gender: &#39;女&#39;&#125;\n</code></pre>\n</li>\n<li><p><code>Object.keys</code> 静态方法获取对象中所有属性</p>\n</li>\n</ol>\n<pre><code class=\"js\">const o = &#123;uname:&#39;pink&#39;,age:18&#125;\n// 获得所有的属性名\nconsole.log(Object.keys(o))  //=&gt;返回数组 [&#39;uname&#39;, &#39;age&#39;]\n</code></pre>\n<p>  <strong>注意:</strong>  返回的是一个数组</p>\n<ol start=\"4\">\n<li><p><code>Object.values</code> 表态方法获取对象中所有属性值</p>\n<pre><code class=\"js\">const o = &#123;uname:&#39;pink&#39;,age:18&#125;\n// 获得所有的属性值\nconsole.log(Object.values(o)) //=&gt;返回数组 [&#39;pink&#39;, 18]\n</code></pre>\n<p><strong>注意:</strong>  返回的是一个数组</p>\n</li>\n</ol>\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><p><code>Array</code> 是内置的构造函数，用于创建数组。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 构造函数创建数组\n  let arr = new Array(5, 7, 8);\n\n  // 字面量方式创建数组\n  let list = [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]\n\n&lt;/script&gt;\n</code></pre>\n<p>数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">作用</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">forEach</td>\n<td align=\"center\"><span style=\"color:red\">遍历</span>数组</td>\n<td align=\"center\">不返回数组，经常用于<span style=\"color:red\">查找遍历数组元素</span></td>\n</tr>\n<tr>\n<td align=\"center\">filter</td>\n<td align=\"center\"><span style=\"color:red\">过滤</span>数组</td>\n<td align=\"center\"><span style=\"color:red\">返回新数组</span>，返回的是<span style=\"color:red\">筛选满足条件</span>的数组元素</td>\n</tr>\n<tr>\n<td align=\"center\">map</td>\n<td align=\"center\"><span style=\"color:red\">迭代</span>数组</td>\n<td align=\"center\"><span style=\"color:red\">返回新数组，</span>返回的是<span style=\"color:red\">处理之后</span>的数组元素，想要使用返回的新数组</td>\n</tr>\n<tr>\n<td align=\"center\">reduce</td>\n<td align=\"center\"><span style=\"color:red\">累计器</span></td>\n<td align=\"center\">返回累计处理的结果，经常用于求和等</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>总结：</p>\n<ol>\n<li><p>推荐使用字面量方式声明数组，而不是 <code>Array</code> 构造函数</p>\n</li>\n<li><p>实例方法 <code>forEach</code> 用于遍历数组，替代 <code>for</code> 循环 (重点)</p>\n</li>\n<li><p>实例方法 <code>filter</code> 过滤数组单元值，生成新数组(重点)</p>\n</li>\n<li><p>实例方法 <code>map</code> 迭代原数组，生成新数组(重点)</p>\n</li>\n<li><p>实例方法 <code>join</code> 数组元素拼接为字符串，返回字符串(重点)</p>\n</li>\n<li><p>实例方法  <code>find</code>  查找元素， 返回符合测试条件的<span style=\"color:red\">第一个数组元素值</span>，如果没有符合条件的则返回 undefined(重点)</p>\n<pre><code class=\"js\">// const arr = [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;]\n// const re = arr.find(function(item)&#123;\n//     return item === &#39;blue&#39;\n// &#125;)\n// console.log(re) //=&gt;blue\n\nconst arr = [\n    &#123;\n        name: &#39;小米&#39;,\n        price: 1999\n    &#125;,\n    &#123;\n        name: &#39;华为&#39;,\n        price: 3999\n    &#125;\n]\n// 找小米 这个对象，并且返回这个对象\nconst mi = arr.find(item =&gt; item.name === &#39;小米&#39;)\nconsole.log(mi) //=&gt;&#123;name: &#39;小米&#39;, price: 1999&#125;\n</code></pre>\n</li>\n<li><p>实例方法<code>every</code> 检测数组所有元素是否都符合指定条件，如果<strong>所有元素</strong>都通过检测返回 true，否则返回 false(重点)</p>\n</li>\n<li><p>实例方法<code>some</code> 检测数组中的元素是否满足指定条件   <strong>如果数组中有</strong>元素满足条件返回 true，否则返回 false</p>\n</li>\n<li><p>实例方法 <code>concat</code>  合并两个数组，返回生成新数组</p>\n</li>\n<li><p>实例方法 <code>sort</code> 对原数组单元值排序</p>\n</li>\n<li><p>实例方法 <code>splice</code> 删除或替换原数组单元</p>\n</li>\n<li><p>实例方法 <code>reverse</code> 反转数组</p>\n</li>\n<li><p>实例方法 <code>findIndex</code>  查找元素的索引值</p>\n</li>\n</ol>\n<p><code>reduce</code></p>\n<ul>\n<li><p><strong>作用</strong>: <code>reduce</code> 返回<span style=\"color:red\">累计处理的结果</span>，经常用于<span style=\"color:red\">求和等</span></p>\n</li>\n<li><p><strong>基本语法:</strong> <code>arr.reduce(function()&#123;&#125;, 起始值)</code></p>\n<p><code>arr.reduce(function(上一次值, 当前值)&#123;&#125;, 初始值)</code></p>\n</li>\n<li><p><strong>参数:</strong></p>\n<ol>\n<li>如果<span style=\"color:red\">有起始值</span>，则把初始值累加到里面</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">const arr = [1, 5, 8]\n\n// 1. 没有初始值\nconst total = arr.reduce(function (prev, current) &#123;\n        return prev + current\n&#125;)\nconsole.log(total)  //=&gt;14\n// 2.有初始值\nconst total1 = arr.reduce(function (prev, current) &#123;\n        return prev + current\n&#125;, 10)\nconsole.log(total1) //=&gt;24\n// 3. 箭头函数的写法\nconst total2 = arr.reduce((prev, current) =&gt; prev + current, 10)\nconsole.log(total2) //=&gt;24\n</code></pre>\n<ul>\n<li>reduce 执行过程<ol>\n<li>如果<span style=\"color:red\">没有起始值</span>，则<span style=\"color:red\">上一次值以</span>数组的<span style=\"color:red\">第一个数组元素的值</span></li>\n<li>每一次循环，把<span style=\"color:red\">返回值</span>给做为 下一次循环的<span style=\"color:red\">上一次值</span></li>\n<li>如果<span style=\"color:red\">有起始值</span>，则起始值做为<span style=\"color:red\">上一次值</span></li>\n</ol>\n</li>\n</ul>\n<p><code>Array.from()</code></p>\n<blockquote>\n<p>把伪数组转换为真数组</p>\n</blockquote>\n<pre><code class=\"js\">// Array.from(lis) 把伪数组转换为真数组\nconst lis = document.querySelectorAll(&#39;ul li&#39;)\n// console.log(lis)\n// lis.pop()  //报错\nconst liss = Array.from(lis)\nliss.pop()\nconsole.log(liss)\n</code></pre>\n<h3 id=\"包装类型\"><a href=\"#包装类型\" class=\"headerlink\" title=\"包装类型\"></a>包装类型</h3><p>在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 字符串类型\n  const str = &#39;hello world!&#39;\n     // 统计字符的长度（字符数量）\n  console.log(str.length)\n  \n  // 数值类型\n  const price = 12.345\n  // 保留两位小数\n  price.toFixed(2) // 12.34\n&lt;/script&gt;\n</code></pre>\n<p>之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。</p>\n<h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h4><p><code>String</code> 是内置的构造函数，用于创建字符串。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 使用构造函数创建字符串\n  let str = new String(&#39;hello world!&#39;);\n\n  // 字面量创建字符串\n  let str2 = &#39;你好，世界！&#39;;\n\n  // 检测是否属于同一个构造函数\n  console.log(str.constructor === str2.constructor); // true\n  console.log(str instanceof String); // false\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><p>实例属性 <code>length</code> 用来获取字符串的度长(重点)</p>\n</li>\n<li><p>实例方法 <code>split(&#39;分隔符&#39;)</code> 用来将字符串拆分成数组(重点)</p>\n<pre><code class=\"js\">// split 把字符串 转换为 数组  和 join()  相反\nconst str = &#39;pink,red&#39;\nconst arr = str.split(&#39;,&#39;)\nconsole.log(arr)   //=&gt; [&#39;pink&#39;, &#39;red&#39;]\nconst str1 = &#39;2023-2-26&#39;\nconst arr1 = str1.split(&#39;-&#39;)\nconsole.log(arr1)  //=&gt; [&#39;2023&#39;, &#39;2&#39;, &#39;26&#39;]\n</code></pre>\n</li>\n<li><p>实例方法 <code>substring（需要截取的第一个字符的索引[,结束的索引号]）</code> 用于字符串截取(重点)</p>\n<pre><code class=\"js\">// 字符串的截取  substring(开始的索引号[,借宿的索引号])\n// 1. 如果省略 结束索引号，默认取到最后\nconst str = &#39;今天又要做核酸了&#39;\nconsole.log(str.substring(5))  //=&gt;核酸了\n// 2. 结束的索引号不包含想要截取的部分\nconsole.log(str.substring(5,6))  //=&gt;核\n</code></pre>\n</li>\n<li><p>实例方法 <code>startsWith(检测字符串[, 检测位置索引号])</code> 检测是否以某字符开头(重点)</p>\n<pre><code class=\"js\">// startsWith 判断是不是以某个字符开头\nconst str = &#39;pink老师上课中&#39;\nconsole.log(str.startsWith(&#39;pink&#39;))  //=&gt;true\n</code></pre>\n</li>\n<li><p>实例方法 <code>includes(搜索的字符串[, 检测位置索引号])</code> 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点)</p>\n<pre><code class=\"js\">// includes 判断某个字符是不是包含在一个字符里面\nconst str = &#39;我是pink老师&#39;\nconsole.log(str.includes(&#39;pink&#39;)) //=&gt;true\n</code></pre>\n</li>\n<li><p>实例方法 <code>toUpperCase</code> 用于将字母转换成大写</p>\n</li>\n<li><p>实例方法 <code>toLowerCase</code> 用于将就转换成小写</p>\n</li>\n<li><p>实例方法 <code>indexOf</code>  检测是否包含某字符</p>\n</li>\n<li><p>实例方法 <code>endsWith</code> 检测是否以某字符结尾</p>\n</li>\n<li><p>实例方法 <code>replace</code> 用于替换字符串，支持正则匹配</p>\n</li>\n<li><p>实例方法 <code>match</code> 用于查找字符串，支持正则匹配</p>\n</li>\n</ol>\n<p>注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。</p>\n<ul>\n<li>转换为字符串 <code>String()</code>  <code>xxx.toString()</code></li>\n</ul>\n<pre><code class=\"js\">const num = 10\nconsole.log(String(num))  //=&gt;&#39;10&#39;\nconsole.log(num.toString()) //=&gt;&#39;10&#39;\n</code></pre>\n<h4 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h4><p><code>Number</code> 是内置的构造函数，用于创建数值。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 使用构造函数创建数值\n  let x = new Number(&#39;10&#39;)\n  let y = new Number(5)\n\n  // 字面量创建数值\n  let z = 20\n\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><p>推荐使用字面量方式声明数值，而不是 <code>Number</code> 构造函数</p>\n</li>\n<li><p>实例方法 <code>toFixed</code> 用于设置保留小数位的长度</p>\n<pre><code class=\"js\">// 数值类型\nconst price = 12.345\n// 保留2位小数   四舍五入\nconsole.log(price.toFixed(2))   // 12.35\n// toFixed 方法可以让数字指定保留的小数位数\nconst num = 10.123\nconsole.log(num.toFixed()) //=&gt;10\nconst num1 = 10.923\nconsole.log(num1.toFixed()) //=&gt;11\nconsole.log(num1.toFixed(2)) //=&gt;10.92\nconst num2 = 10\nconsole.log(num2.toFixed(2))  //=&gt; 10.00\n</code></pre>\n</li>\n</ol>\n<h1 id=\"JavaScript-进阶-第3天笔记\"><a href=\"#JavaScript-进阶-第3天笔记\" class=\"headerlink\" title=\"JavaScript 进阶 - 第3天笔记\"></a>JavaScript 进阶 - 第3天笔记</h1><blockquote>\n<p>了解构造函数原型对象的语法特征，掌握 JavaScript 中面向对象编程的实现方式，基于面向对象编程思想实现 DOM 操作的封装。</p>\n</blockquote>\n<ul>\n<li>了解面向对象编程的一般特征</li>\n<li>掌握基于构造函数原型对象的逻辑封装</li>\n<li>掌握基于原型对象实现的继承</li>\n<li>理解什么原型链及其作用</li>\n<li>能够处理程序异常提升程序执行的健壮性</li>\n</ul>\n<h2 id=\"编程思想\"><a href=\"#编程思想\" class=\"headerlink\" title=\"编程思想\"></a>编程思想</h2><blockquote>\n<p>学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。</p>\n</blockquote>\n<h3 id=\"面向过程\"><a href=\"#面向过程\" class=\"headerlink\" title=\"面向过程\"></a>面向过程</h3><p><span style=\"color:red\">面向过程</span>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p>\n<p> 举个栗子：蛋炒饭</p>\n<p><img data-src=\"/./assets/14bda17553a6194cece2f5a77a64de961cf09568.png\" alt=\"67679290689\"></p>\n<h3 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h3><p><span style=\"color:red\">面向对象</span>是把事务分解成为一个个对象，然后由对象之间分工与合作。</p>\n<p><img data-src=\"/./assets/e21855e43c8f34c5fea9bad603b6783b6ec7b734.png\" alt=\"67679293032\"></p>\n<p><span style=\"color:red\">面向对象是以对象功能来划分问题，而不是步骤</span></p>\n<ul>\n<li><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。</p>\n</li>\n<li><p>面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</p>\n</li>\n<li><p>面向对象的特性：</p>\n<ul>\n<li>封装性</li>\n<li>继承性</li>\n<li>多态性</li>\n</ul>\n<img data-src=\"./assets/50db4fbd7ed6cedec6f0470c957382a5a7c5a6f7.png\" alt=\"image-20230312190436206\" style=\"zoom:67%;\" />\n\n\n\n<p><img data-src=\"/./assets/a5d69da6775129eaeb31b57fd0576ef586fc9c1d.png\" alt=\"/images/image-20230312190839380\"></p>\n</li>\n</ul>\n<h2 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>对比以下通过面向对象的构造函数实现的封装：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  function Person() &#123;\n    this.name = &#39;佚名&#39;\n    // 设置名字\n    this.setName = function (name) &#123;\n      this.name = name\n    &#125;\n    // 读取名字\n    this.getName = () =&gt; &#123;\n      console.log(this.name)\n    &#125;\n  &#125;\n\n  // 实例对像，获得了构造函数中封装的所有逻辑\n  let p1 = new Person()\n  p1.setName(&#39;小明&#39;)\n  console.log(p1.name)\n\n  // 实例对象\n  let p2 = new Person()\n  console.log(p2.name)\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li><p>封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。</p>\n</li>\n<li><p>同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的</p>\n</li>\n</ul>\n<blockquote>\n<p>总结：</p>\n<ol>\n<li>构造函数体现了面向对象的封装特性</li>\n<li>构造函数实例创建的对象彼此独立、互不影响</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。</p>\n</li>\n<li><p>前面我们学过的构造函数方法很好用，但是 <span style=\"color:red\">存在浪费内存的问题</span></p>\n</li>\n</ul>\n<h2 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h2><blockquote>\n<p>构造函数通过原型分配的函数是所有对象所 <span style=\"color:red\">共享的</span>。</p>\n</blockquote>\n<ul>\n<li>JavaScript 规定，<span style=\"color:red\">每一个构造函数都有一个 prototype 属性</span>，指向另一个对象，所以我们也称为原型对象</li>\n<li>这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存</li>\n<li><span style=\"color:red\">我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</span></li>\n<li><span style=\"color:red\">构造函数和原型对象中的this 都指向 实例化的对象</span></li>\n</ul>\n<pre><code class=\"html\">&lt;script&gt;\n  function Person() &#123;\n    \n  &#125;\n\n  // 每个函数都有 prototype 属性\n  console.log(Person.prototype)\n&lt;/script&gt;\n</code></pre>\n<p>了解了 JavaScript 中构造函数与原型对象的关系后，再来看原型对象具体的作用，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  function Person() &#123;\n    // 此处未定义任何方法\n  &#125;\n\n  // 为构造函数的原型对象添加方法\n  Person.prototype.sayHi = function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n    \n  // 实例化\n  let p1 = new Person();\n  p1.sayHi(); // 输出结果为 Hi~\n&lt;/script&gt;\n</code></pre>\n<p>构造函数 <code>Person</code> 中未定义任何方法，这时实例对象调用了原型对象中的方法 <code>sayHi</code>，接下来改动一下代码：</p>\n<pre><code class=\"html\">&lt;script&gt;\n    // 1. 公共的属性写到 构造函数里面\n    function Person() &#123;\n        // 此处定义同名方法 sayHi\n        this.sayHi = function () &#123;\n            console.log(&#39;嗨!&#39;);\n        &#125;\n    &#125;\n\n    // 为构造函数的原型对象添加方法\n    // 2. 公共的方法写到原型对象身上\n    Person.prototype.sayHi = function () &#123;\n        console.log(&#39;Hi~&#39;);\n    &#125;\n\n    let p1 = new Person();\n    p1.sayHi(); // 输出结果为 嗨!\n&lt;/script&gt;\n</code></pre>\n<p>构造函数 <code>Person</code> 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 <code>sayHi</code>。</p>\n<p>通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：<strong>当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。</strong></p>\n<pre><code class=\"html\">&lt;script&gt;\n    function Person() &#123;\n    // 此处定义同名方法 sayHi\n    this.sayHi = function () &#123;\n      console.log(&#39;嗨!&#39; + this.name)\n    &#125;\n  &#125;\n\n  // 为构造函数的原型对象添加方法\n  Person.prototype.sayHi = function () &#123;\n    console.log(&#39;Hi~&#39; + this.name)\n  &#125;\n  // 在构造函数的原型对象上添加属性\n  Person.prototype.name = &#39;小明&#39;\n\n  let p1 = new Person()\n  p1.sayHi(); // 输出结果为 嗨!\n  \n  let p2 = new Person()\n  p2.sayHi()\n&lt;/script&gt;\n</code></pre>\n<p>总结：<strong>结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。</strong></p>\n<h3 id=\"constructor-属性\"><a href=\"#constructor-属性\" class=\"headerlink\" title=\"constructor 属性\"></a>constructor 属性</h3><p><strong>在哪里？</strong> 每个原型对象里面都有个constructor 属性（constructor 构造函数）</p>\n<p><strong>作用：</strong>该属性<span style=\"color:red\">指向</span>该原型对象的<span style=\"color:red\">构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子</span></p>\n<p><img data-src=\"/./assets/10b6985c6b63efeb93ebed57e6af7b5d9ffec8d4.png\" alt=\"/images/image-20230313133307629\"></p>\n<p><strong>使用场景：</strong></p>\n<p>如果有多个对象的方法，我们可以给原型对象采取对象形式赋值.</p>\n<p>但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了</p>\n<p>此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p>\n<pre><code class=\"js\">// constructor 单词 构造函数\nfunction Star() &#123;\n\n&#125;\n// Star.prototype.sing = function()&#123;\n//   console.log(&#39;唱歌&#39;)\n// &#125;\n// Star.prototype.dance = function()&#123;\n//   console.log(&#39;跳舞&#39;)\n// &#125;\nconsole.log(Star.prototype)\n\nStar.prototype = &#123;\n  // 重新指回创造这个原型对象的 构造函数\n  constructor: Star,\n  sing: function () &#123;\n    console.log(&#39;唱歌&#39;)\n  &#125;,\n  dance: function () &#123;\n    console.log(&#39;跳舞&#39;)\n  &#125;\n&#125;\nconsole.log(Star.prototype)\n</code></pre>\n<h3 id=\"对象原型\"><a href=\"#对象原型\" class=\"headerlink\" title=\"对象原型\"></a>对象原型</h3><p><img data-src=\"/./assets/184b0e68c0d40752b14cd1dc98a00b23f9c3d0ae.png\" alt=\"/images/image-20230313134524527\"></p>\n<p><span style=\"color:red\">对象都会有一个属性 <code>__proto__</code></span> 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <code>__proto__</code> 原型的存在。</p>\n<p>注意：</p>\n<ul>\n<li><code>__proto__</code> 是JS非标准属性</li>\n<li>[[prototype]]和<code>__proto__</code>意义相同</li>\n<li>用来表明当前实例对象指向哪个原型对象prototype</li>\n<li><code>__proto__</code>对象原型里面也有一个 constructor属性，<span style=\"color:red\">指向创建该实例对象的构造函数</span></li>\n</ul>\n<p><img data-src=\"/./assets/b68304e0222a56ad4b7b10a992a782ac66f6e434.png\" alt=\"/images/image-20230313140005994\"></p>\n<h3 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h3><p>继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。</p>\n<p>龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义。</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // 继续抽取   公共的部分放到原型上\n    // const Person1 = &#123;\n    //   eyes: 2,\n    //   head: 1\n    // &#125;\n    // const Person2 = &#123;\n    //   eyes: 2,\n    //   head: 1\n    // &#125;\n    // 构造函数  new 出来的对象 结构一样，但是对象不一样\n    function Person() &#123;\n      this.eyes = 2\n      this.head = 1\n    &#125;\n    // console.log(new Person)\n    // 女人  构造函数   继承  想要 继承 Person\n    function Woman() &#123;\n\n    &#125;\n    // Woman 通过原型来继承 Person\n    // 父构造函数（父类）   子构造函数（子类）\n    // 子类的原型 =  new 父类  \n    Woman.prototype = new Person()   // &#123;eyes: 2, head: 1&#125; \n    // 指回原来的构造函数\n    Woman.prototype.constructor = Woman\n\n    // 给女人添加一个方法  生孩子\n    Woman.prototype.baby = function () &#123;\n      console.log(&#39;宝贝&#39;)\n    &#125;\n    const red = new Woman()\n    console.log(red)\n    // console.log(Woman.prototype)\n    // 男人 构造函数  继承  想要 继承 Person\n    function Man() &#123;\n\n    &#125;\n    // 通过 原型继承 Person\n    Man.prototype = new Person()\n    Man.prototype.constructor = Man\n    const pink = new Man()\n    console.log(pink)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链。</p>\n<p><img data-src=\"/./assets/178d2b04cfc677d701530b37f70eb2925fe1cba0.png\" alt=\"67679338869\"></p>\n<ul>\n<li><p>只要是对象就有<code>__proto__</code>对象原型 指向原型对象</p>\n</li>\n<li><p>只要是原型对象就有<code>constructor</code>指回 创造该原型对象的构造函数</p>\n</li>\n</ul>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // function Objetc() &#123;&#125;\n    console.log(Object.prototype)\n    console.log(Object.prototype.__proto__)\n\n    function Person() &#123;\n\n    &#125;\n    const ldh = new Person()\n    // console.log(ldh.__proto__ === Person.prototype)\n    // console.log(Person.prototype.__proto__ === Object.prototype)\n    console.log(ldh instanceof Person)\n    console.log(ldh instanceof Object)\n    console.log(ldh instanceof Array)\n    console.log([1, 2, 3] instanceof Array)\n    console.log(Array instanceof Object)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><span style=\"color:red\">查找规则</span></p>\n<p>① 当访问一个对象的属性（包括方法）时，首先查找这个<span style=\"color:red\">对象自身</span>有没有该属性。</p>\n<p>② 如果没有就查找它的原型（也就是 <code>__proto__</code>指向的<span style=\"color:red\"> prototype 原型对象</span>）</p>\n<p>③ 如果还没有就查找原型对象的原型（<span style=\"color:red\">Object的原型对象</span>）</p>\n<p>④ 依此类推一直找到 Object 为止（<span style=\"color:red\">null</span>）</p>\n<p>⑤ <code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</p>\n<p>⑥ 可以使用 <code>instanceof</code> 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p>\n<pre><code class=\"js\">function Person() &#123;\n\n&#125;\nconst ldh = new Person()\nconsole.log(ldh instanceof Person)  //=&gt;true\nconsole.log(ldh instanceof Object)  //=&gt;true\nconsole.log(ldh instanceof Array)   //=&gt;false\nconsole.log([1, 2, 3] instanceof Array) //=&gt;true\nconsole.log(Array instanceof Object)  //=&gt;true\n</code></pre>\n<p>原型链其实就是一个查找规则，为对象成员查找机制提供一个方向。因为构造函数的 prototype 和其实例的 <code>__proto__</code> 都是指向原型对象的，所以可以通过 <code>__proto__</code> 查找当前的原型对象有没有该属性 ,没有就找原型的原型 , 依次类推一直找到 Object( null ) 为止，这种链式查找过程称之为原型链</p>\n<h1 id=\"JavaScript-进阶-第4天\"><a href=\"#JavaScript-进阶-第4天\" class=\"headerlink\" title=\"JavaScript 进阶 - 第4天\"></a>JavaScript 进阶 - 第4天</h1><h2 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h2><h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>首先浅拷贝和深拷贝只针对引用类型</p>\n<p>浅拷贝：拷贝的是地址</p>\n<p><strong>常见方法：</strong></p>\n<ol>\n<li>拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象</li>\n<li>拷贝数组：Array.prototype.concat() 或者 […arr]</li>\n</ol>\n<blockquote>\n<p>如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)</p>\n</blockquote>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>首先浅拷贝和深拷贝只针对引用类型</p>\n<p>深拷贝：拷贝的是对象，不是地址</p>\n<p><strong>常见方法：</strong></p>\n<h6 id=\"通过递归实现深拷贝\"><a href=\"#通过递归实现深拷贝\" class=\"headerlink\" title=\"通过递归实现深拷贝\"></a>通过递归实现深拷贝</h6><h6 id=\"通过JSON-stringify-实现\"><a href=\"#通过JSON-stringify-实现\" class=\"headerlink\" title=\"通过JSON.stringify()实现\"></a>通过JSON.stringify()实现</h6><p>限制和缺点：<br>1 .循环引用： JSON.stringify() 无法处理具有循环引用的对象。如果一个对象的属性直接或间接引<br>用了自身， JSON.stringify() 将抛出一个错误，表示存在循环引用。<br>2 .undefined 、函数和Symbol忽略： JSON.stringify() 不会序列化对象中的 undefined 、函数和<br>Symbol类型的属性。这些属性将被忽略，不会出现在生成的JSON字符串中，单独转换则会返回<br>undefined 。<br>3 .丢失原型链：在对象序列化后，原型链上的属性和方法将丢失。只有对象自身的可枚举属性会被序<br>列化。因此，在反序列化（使用 JSON.parse() ）后，原始对象的原型链信息将不复存在。<br>4 .日期对象处理：当使用 JSON.stringify() 序列化日期对象时，日期对象会被转换为它们的ISO字<br>符串表示形式。在反序列化时，这些日期将被视为普通字符串，而不是日期对象。<br>5 .非数组和非对象的值：对于不是数组或对象的顶层值（例如：字符串、数字、布尔值等），<br>JSON.stringify() 会直接返回其对应的JSON表示，而不会将其包装在对象或数组中。</p>\n<h4 id=\"递归实现深拷贝\"><a href=\"#递归实现深拷贝\" class=\"headerlink\" title=\"递归实现深拷贝\"></a>递归实现深拷贝</h4><p><strong>函数递归：</strong></p>\n<p><span style=\"color:red\">如果一个函数在内部可以调用其本身，那么这个函数就是递归函数</span></p>\n<ul>\n<li>简单理解:函数内部自己调用自己, 这个函数就是递归函数</li>\n<li>递归函数的作用和循环效果类似</li>\n<li>由于递归很容易发生“栈溢出”错误（stack overflow），所以<span style=\"color:red\">必须要加退出条件 return</span></li>\n</ul>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    const o = &#123;&#125;\n    // 拷贝函数\n    function deepCopy(newObj, oldObj) &#123;\n      debugger\n      for (let k in oldObj) &#123;\n        // 处理数组的问题  一定先写数组 在写 对象 不能颠倒\n        if (oldObj[k] instanceof Array) &#123;\n          newObj[k] = []\n          //  newObj[k] 接收 []  hobby\n          //  oldObj[k]   [&#39;乒乓球&#39;, &#39;足球&#39;]\n          deepCopy(newObj[k], oldObj[k])\n        &#125; else if (oldObj[k] instanceof Object) &#123;\n          newObj[k] = &#123;&#125;\n          deepCopy(newObj[k], oldObj[k])\n        &#125;\n        else &#123;\n          //  k  属性名 uname age    oldObj[k]  属性值  18\n          // newObj[k]  === o.uname  给新对象添加属性\n          newObj[k] = oldObj[k]\n        &#125;\n      &#125;\n    &#125;\n    deepCopy(o, obj) // 函数调用  两个参数 o 新对象  obj 旧对象\n    console.log(o)\n    o.age = 20\n    o.hobby[0] = &#39;篮球&#39;\n    o.family.baby = &#39;老pink&#39;\n    console.log(obj)\n    console.log([1, 23] instanceof Object)\n    // 复习\n    // const obj = &#123;\n    //   uname: &#39;pink&#39;,\n    //   age: 18,\n    //   hobby: [&#39;乒乓球&#39;, &#39;足球&#39;]\n    // &#125;\n    // function deepCopy(&#123; &#125;, oldObj) &#123;\n    //   // k 属性名  oldObj[k] 属性值\n    //   for (let k in oldObj) &#123;\n    //     // 处理数组的问题   k 变量\n    //     newObj[k] = oldObj[k]\n    //     // o.uname = &#39;pink&#39;\n    //     // newObj.k  = &#39;pink&#39;\n    //   &#125;\n    // &#125;\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h4 id=\"js库lodash里面cloneDeep内部实现了深拷贝\"><a href=\"#js库lodash里面cloneDeep内部实现了深拷贝\" class=\"headerlink\" title=\"js库lodash里面cloneDeep内部实现了深拷贝\"></a>js库lodash里面cloneDeep内部实现了深拷贝</h4><pre><code class=\"html\">&lt;body&gt;\n  &lt;!-- 先引用 --&gt;\n  &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    const o = _.cloneDeep(obj)\n    console.log(o)\n    o.family.baby = &#39;老pink&#39;\n    console.log(obj)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h4 id=\"H5新增structuredClone\"><a href=\"#H5新增structuredClone\" class=\"headerlink\" title=\"H5新增structuredClone\"></a>H5新增structuredClone</h4><p>结构化克隆解决了该JSON.stringify()技术的许多（尽管不是全部）缺点。结构化克隆可以处理循环依赖，支持许多内置数据类型，并且更健壮且速度更快。<br>但是，它仍然有一些限制：</p>\n<p>原型：如果你使用structuredClone()类实例，你将获得一个普通对象作为返回值，因为结构化克隆会丢弃对象的原型链。<br>函数：如果你的对象包含函数，它们将被悄悄丢弃。<br>不可克隆：有些值不是结构化可克隆的，尤其是Error、 DOM 节点 和 Function。尝试这样做将引发 DataCloneError 异常。<br>属性描述符：setter和getter(以及类似元数据的功能)不会被复制。例如，如果使用属性描述符将对象标记为只读，则复制后的对象中是可读写(默认配置)。<br>RegExp：RegExp对象的lastIndex字段不会保留。</p>\n<h4 id=\"JSON序列化\"><a href=\"#JSON序列化\" class=\"headerlink\" title=\"JSON序列化\"></a>JSON序列化</h4><pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    // 把对象转换为 JSON 字符串\n    // console.log(JSON.stringify(obj))\n    const o = JSON.parse(JSON.stringify(obj))\n    console.log(o)\n    o.family.baby = &#39;123&#39;\n    console.log(obj)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><blockquote>\n<p>了解 JavaScript 中程序异常处理的方法，提升代码运行的健壮性。</p>\n</blockquote>\n<h3 id=\"throw\"><a href=\"#throw\" class=\"headerlink\" title=\"throw\"></a>throw</h3><p>异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行</p>\n<p>总结：</p>\n<ol>\n<li>throw 抛出异常信息，程序也会终止执行</li>\n<li>throw 后面跟的是错误提示信息</li>\n<li>Error 对象配合 throw 使用，能够设置更详细的错误信息</li>\n</ol>\n<pre><code class=\"html\">&lt;script&gt;\n  function counter(x, y) &#123;\n\n    if(!x || !y) &#123;\n      // throw &#39;参数不能为空!&#39;;\n      throw new Error(&#39;参数不能为空!&#39;)\n    &#125;\n\n    return x + y\n  &#125;\n\n  counter()\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>throw</code> 抛出异常信息，程序也会终止执行</li>\n<li><code>throw</code> 后面跟的是错误提示信息</li>\n<li><code>Error</code> 对象配合 <code>throw</code> 使用，能够设置更详细的错误信息</li>\n</ol>\n<h3 id=\"try-…-catch\"><a href=\"#try-…-catch\" class=\"headerlink\" title=\"try … catch\"></a>try … catch</h3><pre><code class=\"html\">&lt;script&gt;\n   function foo() &#123;\n      try &#123;\n        // 查找 DOM 节点\n        const p = document.querySelector(&#39;.p&#39;)\n        p.style.color = &#39;red&#39;\n      &#125; catch (error) &#123;\n        // 拦截错误，提示浏览器提供的错误信息，但是不中断程序的执行\n        // try 代码段中执行有错误时，会执行 catch 代码段\n        // 查看错误信息\n        console.log(error.message)\n        // 终止代码继续执行\n        return\n\n      &#125;\n      finally &#123;\n          // 不管你程序对不对，一定会执行的代码\n          alert(&#39;执行&#39;)\n      &#125;\n      console.log(&#39;如果出现错误，我的语句不会执行&#39;)\n    &#125;\n    foo()\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>try...catch</code> 用于捕获错误信息</li>\n<li>将预估可能发生错误的代码写在 <code>try</code> 代码段中</li>\n<li>如果 <code>try</code> 代码段中出现错误后，会执行 <code>catch</code> 代码段，并截获到错误信息</li>\n<li><code>finally</code> 不管是否有错误，都会执行</li>\n</ol>\n<h3 id=\"debugger\"><a href=\"#debugger\" class=\"headerlink\" title=\"debugger\"></a>debugger</h3><p>相当于断点调试</p>\n<h2 id=\"处理this\"><a href=\"#处理this\" class=\"headerlink\" title=\"处理this\"></a>处理this</h2><blockquote>\n<p>了解函数中 this 在不同场景下的默认值，知道动态指定函数 this 值的方法。</p>\n</blockquote>\n<p><code>this</code> 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 <code>this</code> 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 <code>this</code> 默认的取值】情况进行归纳和总结。</p>\n<h3 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h3><p><strong>普通函数</strong>的调用方式决定了 <code>this</code> 的值，即【谁调用 <code>this</code> 的值指向谁】，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)  \n  &#125;\n  // 函数表达式\n  const sayHello = function () &#123;\n    console.log(this)\n  &#125;\n  // 函数的调用方式决定了 this 的值\n  sayHi() // window\n  window.sayHi()\n    \n\n// 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    walk: function () &#123;\n      console.log(this)\n    &#125;\n  &#125;\n  // 动态为 user 添加方法\n  user.sayHi = sayHi\n  uesr.sayHello = sayHello\n  // 函数调用方式，决定了 this 的值\n  user.sayHi()\n  user.sayHello()\n&lt;/script&gt;\n</code></pre>\n<p>注： 普通函数没有明确调用者时 <code>this</code> 值为 <code>window</code>，严格模式下没有调用者时 <code>this</code> 的值为 <code>undefined</code>。</p>\n<h3 id=\"箭头函数-1\"><a href=\"#箭头函数-1\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p><strong>箭头函数</strong>中的 <code>this</code> 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 <code>this</code> ！箭头函数中访问的 <code>this</code> 不过是箭头函数所在作用域的 <code>this</code> 变量。</p>\n<ol>\n<li>箭头函数会默认帮我们绑定外层 <code>this</code> 的值，所以在箭头函数中 <code>this</code> 的值和外层的 <code>this</code> 是一样的</li>\n<li>箭头函数中的 <code>this</code> 引用的就是最近作用域中的 <code>this</code></li>\n<li>向外层作用域中，一层一层查找 <code>this</code>，直到有 <code>this</code> 的定义</li>\n</ol>\n<pre><code class=\"html\">&lt;script&gt;\n    \n  console.log(this) // 此处为 window\n  // 箭头函数\n  const sayHi = function() &#123;\n    console.log(this) // 该箭头函数中的 this 为函数声明环境中 this 一致\n  &#125;\n  // 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    // 该箭头函数中的 this 为函数声明环境中 this 一致\n    walk: () =&gt; &#123;\n      console.log(this)\n    &#125;,\n    \n    sleep: function () &#123;\n      let str = &#39;hello&#39;\n      console.log(this)\n      let fn = () =&gt; &#123;\n        console.log(str)\n        console.log(this) // 该箭头函数中的 this 与 sleep 中的 this 一致\n      &#125;\n      // 调用箭头函数\n      fn();\n    &#125;\n  &#125;\n\n  // 动态添加方法\n  user.sayHi = sayHi\n  \n  // 函数调用\n  user.sayHi()\n  user.sleep()\n  user.walk()\n&lt;/script&gt;\n</code></pre>\n<p>在开发中【使用箭头函数前需要考虑函数中 <code>this</code> 的值】，<strong>事件回调函数</strong>使用箭头函数时，<code>this</code> 为全局的 <code>window</code>，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // DOM 节点\n  const btn = document.querySelector(&#39;.btn&#39;)\n  // 箭头函数 此时 this 指向了 window\n  btn.addEventListener(&#39;click&#39;, () =&gt; &#123;\n    console.log(this)\n  &#125;)\n  // 普通函数 此时 this 指向了 DOM 对象\n  btn.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(this)\n  &#125;)\n&lt;/script&gt;\n</code></pre>\n<p>同样由于箭头函数 <code>this</code> 的原因，<strong>基于原型的面向对象也不推荐采用箭头函数</strong>，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  function Person() &#123;\n  &#125;\n  // 原型对像上添加了箭头函数\n  Person.prototype.walk = () =&gt; &#123;\n    console.log(&#39;人都要走路...&#39;)\n    console.log(this); // window\n  &#125;\n  const p1 = new Person()\n  p1.walk()\n&lt;/script&gt;\n</code></pre>\n<p><strong>总结:</strong></p>\n<ol>\n<li>函数内不存在 <code>this</code>，沿用上一级的，过程: 向外层作用域中，一层一层查找this，直到有this的定义</li>\n<li>不适用<ul>\n<li>构造函数，原型函数，dom 事件函数等等</li>\n</ul>\n</li>\n<li>适用<ul>\n<li>需要使用上层 <code>this</code> 的地方</li>\n</ul>\n</li>\n<li>使用正确的话，它会在很多地方带来方便，后面我们会大量使用慢慢体会</li>\n</ol>\n<h3 id=\"改变this指向\"><a href=\"#改变this指向\" class=\"headerlink\" title=\"改变this指向\"></a>改变this指向</h3><p>以上归纳了普通函数和箭头函数中关于 <code>this</code> 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 <code>this</code> 的指向，有 3 个方法可以动态指定普通函数中 <code>this</code> 的指向：</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h4><blockquote>\n<p>使用 <code>call</code> 方法调用函数，同时指定函数中 <code>this</code> 的值</p>\n</blockquote>\n<p><strong>语法:</strong> <code>fun.call(thisArg, arg1, arg2, ...)</code></p>\n<ul>\n<li>thisArg: 在 fun 函数运行时指定的 this 值</li>\n<li>arg1，arg2: 传递的其它参数</li>\n<li>返回值就是函数的返回值，因为它就是调用函数</li>\n</ul>\n<p>使用方法如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this);\n  &#125;\n\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student = &#123;\n    name: &#39;小红&#39;,\n    age: 16\n  &#125;\n\n  // 调用函数并指定 this 的值\n  sayHi.call(user); // this 值为 user\n  sayHi.call(student); // this 值为 student\n\n  // 求和函数\n  function counter(x, y) &#123;\n    return x + y;\n  &#125;\n\n  // 调用 counter 函数，并传入参数\n  let result = counter.call(null, 5, 10);\n  console.log(result);\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>call</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li>\n<li>使用 <code>call</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li>\n<li><code>call</code> 方法的其余参数会依次自动传入函数做为函数的参数</li>\n</ol>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><blockquote>\n<p> 使用 <code>apple</code> 方法<strong>调用函数</strong>，同时指定函数中 <code>this</code> 的值</p>\n</blockquote>\n<p><strong>语法:</strong> <code>fun.apply(thisArg, [argsArray])</code></p>\n<ul>\n<li>thisArg: 在fun函数运行时指定的 <code>this</code> 的值</li>\n<li>argsArray: 传递的值，必须包含在<code>数组</code>里面</li>\n<li>返回值就是函数的返回值，因为它就是调用函数</li>\n<li>因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</li>\n</ul>\n<p>使用方法如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student = &#123;\n    name: &#39;小红&#39;,\n    age: 16\n  &#125;\n\n  // 调用函数并指定 this 的值\n  sayHi.apply(user) // this 值为 user\n  sayHi.apply(student) // this 值为 student\n\n  // 求和函数\n  function counter(x, y) &#123;\n    return x + y\n  &#125;\n  // 调用 counter 函数，并传入参数\n  let result = counter.apply(null, [5, 10])\n  console.log(result)\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>apply</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li>\n<li>使用 <code>apply</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li>\n<li><code>apply</code> 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数</li>\n</ol>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h4><blockquote>\n<p><code>bind</code>方法并<strong>不会调用函数</strong>，而是创建一个指定了<code>this</code>值的新函数，能改变函数内部<code>this</code>指向</p>\n</blockquote>\n<p><strong>语法:</strong> <code>fun.bind(thisArg, arg1, arg2, ...)</code></p>\n<ul>\n<li>thisArg: 在 fun 函数运行时指定的 this 值</li>\n<li>arg1，arg2: 传递的其它参数</li>\n<li>返回由指定的 this 值和初始化参数改造的 <code>原函数拷贝 (新函数)</code></li>\n<li>因此当我们只是想改变 this 指向，并不想调用这个函数的时候，可以使用bind，比如改变定时器内部的 this 指向</li>\n</ul>\n<p>使用方法如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n  // 调用 bind 指定 this 的值\n  let sayHello = sayHi.bind(user);\n  // 调用使用 bind 创建的新函数\n  sayHello()\n&lt;/script&gt;\n</code></pre>\n<p>注：<code>bind</code> 方法创建新的函数，与原函数的唯一的变化是改变了 <code>this</code> 的值。</p>\n<h2 id=\"防抖节流\"><a href=\"#防抖节流\" class=\"headerlink\" title=\"防抖节流\"></a>防抖节流</h2><h3 id=\"防抖（debounce）\"><a href=\"#防抖（debounce）\" class=\"headerlink\" title=\"防抖（debounce）\"></a>防抖（debounce）</h3><blockquote>\n<p>单位时间内，频繁触发事件，<span style=\"color:red\">只执行最后一次</span></p>\n</blockquote>\n<p>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</p>\n<p><img data-src=\"/./assets/17e1df201247e0e8932960349141428cedc4a0a3.png\" alt=\"/images/image-20230314171133289\"></p>\n<p><strong>利用lodash实现防抖</strong></p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // 利用防抖实现性能优化\n    // 需求: 鼠标在盒子上移动，里面的数字就会变化 + 1\n    const box = document.querySelector(&#39;.box&#39;)\n    let i = 1\n    function mouseMove() &#123;\n      box.innerHTML = i++\n      // 如果里面存在大量消耗性能的代码，比如 dom 操作，比如数据处理，可能造成卡顿\n\n    &#125;\n    // 添加事件\n    // box.addEventListener(&#39;mousemove&#39;, mouseMove)\n\n    // 利用lodash库实现防抖 - 500ms 之后采取 +1\n    // 语法: _.debounce(fun, 时间)\n    box.addEventListener(&#39;mousemove&#39;, _.debounce(mouseMove, 500))\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>手写一个防抖函数</strong></p>\n<p><strong>核心思路:</strong> 防抖的核心就是利用定时器(<code>setTimeout</code>)来实现</p>\n<ol>\n<li>声明一个定时器<span style=\"color:red\">变量</span></li>\n<li>当鼠标每次滑动都先判断<span style=\"color:red\">是否有定时器</span>了，如果有定时器先<span style=\"color:red\">清除以前</span>的定时器</li>\n<li>如果没有定时器则<span style=\"color:red\">开启</span>定时器，记得<span style=\"color:red\">存到变量</span>里面</li>\n<li>在<span style=\"color:red\">定时器里面调用</span>要执行的函数</li>\n</ol>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // 利用防抖实现性能优化\n    // 需求: 鼠标在盒子上移动，里面的数字就会变化 + 1\n    const box = document.querySelector(&#39;.box&#39;)\n    let i = 1\n    function mouseMove() &#123;\n      box.innerHTML = i++\n      // 如果里面存在大量消耗性能的代码，比如 dom 操作，比如数据处理，可能造成卡顿\n\n    &#125;\n    // 手写防抖函数\n    // 核心是利用 setTimeout 定时器 来实现\n    // 1. 声明定时器变量\n    // 2. 每次鼠标移动 (事件触发) 的时候要先判断是否有定时器，如果有先清除以前的定时器\n    // 3. 如果没有定时器，则开启定时器，存入到定时器变量里面\n    // 4. 定时器里面写函数调用\n    function debounce(fn, t) &#123;\n      // 1\n      let timer\n      // return 返回一个匿名函数\n      return function () &#123; //=&gt;debounce(mouseMove,500) = function()&#123;&#125;\n        // 2,3,4\n        if (timer) clearTimeout(timer)\n        timer = setTimeout(function () &#123;\n          fn()  // 加小括号调用 fn 函数 \n        &#125;, t)\n      &#125;\n    &#125;\n    box.addEventListener(&#39;mousemove&#39;, debounce(mouseMove, 500))\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h3 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h3><blockquote>\n<p>单位时间内，频繁触发事件，<span style=\"color:red\">只执行一次</span></p>\n</blockquote>\n<p>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数</p>\n<img data-src=\"./assets/4e7441c2dccb471fb3909eae14bf976377d82003.png\" alt=\"image-20230314203247627\" style=\"zoom:67%;\" />\n\n<p><strong>利用lodash实现节流</strong></p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // 利用防抖实现性能优化\n    // 需求: 鼠标在盒子上移动，里面的数字就会变化 + 1\n    const box = document.querySelector(&#39;.box&#39;)\n    let i = 1\n    function mouseMove() &#123;\n      box.innerHTML = i++\n      // 如果里面存在大量消耗性能的代码，比如 dom 操作，比如数据处理，可能造成卡顿\n\n    &#125;\n    // 添加事件\n    // box.addEventListener(&#39;mousemove&#39;, mouseMove)\n\n    // 利用lodash库实现节流 - 500ms 之后采取 +1\n    // 语法: _.throttle(fun, 时间)\n    box.addEventListener(&#39;mousemove&#39;, _.throttle(mouseMove, 500))\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>手写一个节流函数</strong></p>\n<p><strong>核心思路:</strong> 节流的核心就是利用定时器(<code>setTimeout</code>)来实现</p>\n<ol>\n<li>声明一个定时器<span style=\"color:red\">变量</span></li>\n<li>当鼠标每次滑动都先判断<span style=\"color:red\">是否有定时器</span>了，如果有定时器则<span style=\"color:red\">不开启</span>新定时器</li>\n<li>如果没有定时器则<span style=\"color:red\">开启</span>定时器，记得<span style=\"color:red\">存到变量</span>里面<ul>\n<li>定时器里面<span style=\"color:red\">调用</span>执行的函数</li>\n<li>定时器里面要把定时器<span style=\"color:red\">清空</span></li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // 利用防抖实现性能优化\n    // 需求: 鼠标在盒子上移动，里面的数字就会变化 + 1\n    const box = document.querySelector(&#39;.box&#39;)\n    let i = 1\n    function mouseMove() &#123;\n      box.innerHTML = i++\n      // 如果里面存在大量消耗性能的代码，比如 dom 操作，比如数据处理，可能造成卡顿\n\n    &#125;\n    // 手写节流函数\n    // 核心是利用 setTimeout 定时器 来实现\n    // 1. 声明一个定时器变量\n    // 2. 当鼠标每次滑动都先判断是否有定时器了，如果有定时器则不开启新定时器\n    // 3. 如果没有定时器，则开启定时器，记得存到变量里面\n    //    3.1 定时器里面调用执行的函数\n    //    3.2 定时器里面要把定时器清空\n    function throttle(fn, t) &#123;\n      let timer = null\n      // return 返回一个匿名函数\n      return function () &#123; //=&gt;debounce(mouseMove,500) = function()&#123;&#125;\n        // 2,3,4\n        if (!timer) &#123;\n          timer = setTimeout(function () &#123;\n            fn()  // 加小括号调用 fn 函数 \n            // 清空定时器\n            timer = null\n          &#125;, t)\n        &#125;\n      &#125;\n    &#125;\n    box.addEventListener(&#39;mousemove&#39;, throttle(mouseMove, 500))\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img data-src=\"/./assets/6f9421c1f81e9a4f171f98cc467654db79381b38.png\" alt=\"/images/image-20230315000258205\"></p>\n","categories":["JS进阶"],"tags":["JS进阶"]},{"title":"three.js","url":"/2023/10/24/ThreeJS/","content":"<h1 id=\"Three-js使用\"><a href=\"#Three-js使用\" class=\"headerlink\" title=\"Three.js使用\"></a>Three.js使用</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTk3MzI0Mzc3OTQzMDgxMDE5\">https://juejin.cn/post/7197324377943081019</span></p>\n<p><img data-src=\"/images/image-20240116092346688.png\" alt=\"/images/image-20240116092346688\"></p>\n<p><img data-src=\"/images/image-20240116091152273.png\" alt=\"/images/image-20240116091152273\"></p>\n<p><img data-src=\"/images/image-20240116091215611.png\" alt=\"/images/image-20240116091215611\"></p>\n<p><img data-src=\"/images/image-20240116091230059.png\" alt=\"/images/image-20240116091230059\"></p>\n<p><img data-src=\"/images/image-20240116091339847.png\" alt=\"/images/image-20240116091339847\"></p>\n<p><img data-src=\"/images/image-20240116091604079.png\" alt=\"/images/image-20240116091604079\"></p>\n<p><img data-src=\"/images/image-20240116091713722.png\" alt=\"/images/image-20240116091713722\"></p>\n","categories":["three.js"],"tags":["three.js","三维"]},{"title":"NaN历史遗留问题","url":"/2023/12/08/NaN/","content":"<p>#NaN历史遗留问题<br>由于历史遗留问题，NaN的内部做了hash处理，使得每一次NaN返回的结果都不同。</p>\n<pre><code class=\"js\">NaN === NaN //false;\nObject.is(NaN,NaN) //true\n//除此之外，延申:\n+0 === -0 //返回true\nObject.is(+0 , -0) //返回false\n</code></pre>\n","categories":["JS"],"tags":["JS","NaN问题"]},{"title":"TDD测试驱动开发","url":"/2024/03/29/TDD/","content":"<h1 id=\"TDD-test-drive-development-测试驱动开发\"><a href=\"#TDD-test-drive-development-测试驱动开发\" class=\"headerlink\" title=\"TDD(test drive development)测试驱动开发\"></a>TDD(test drive development)测试驱动开发</h1><h3 id=\"测试驱动开发的口号：\"><a href=\"#测试驱动开发的口号：\" class=\"headerlink\" title=\"测试驱动开发的口号：\"></a>测试驱动开发的口号：</h3><p>测试先行</p>\n<h3 id=\"测试驱动开发的目标：\"><a href=\"#测试驱动开发的目标：\" class=\"headerlink\" title=\"测试驱动开发的目标：\"></a>测试驱动开发的目标：</h3><p>保证代码的简洁可用</p>\n<h3 id=\"TDD-的规则\"><a href=\"#TDD-的规则\" class=\"headerlink\" title=\"TDD 的规则\"></a>TDD 的规则</h3><p>在 TDD 的过程中，需要遵循两条简单的规则：</p>\n<p>仅在自动测试失败时才编写新代码。<br>消除重复设计（去除不必要的依赖关系），优化设计结构（逐渐使代码一般化）。</p>\n<p>第一条规则的言下之意是每次只编写刚刚好使测试通过的代码，并且只在测试运行失败的时候才编写新的代码，因为每次增加的代码少，即使有问题定位起来也非常快，确保我们可以遵循小步快跑的节奏；第二条规则就是让小步快跑更加踏实，在自动化测试的支撑下，通过重构环节消除代码的坏味道来避免代码日渐腐烂，为接下来编码打造一个舒适的环境。<br>关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“简洁”目标，每次只关注一件事</p>\n<h3 id=\"采用-TDD-的动机\"><a href=\"#采用-TDD-的动机\" class=\"headerlink\" title=\"采用 TDD 的动机\"></a>采用 TDD 的动机</h3><p>控制编程过程中的忧虑感。</p>\n<p>有一个有趣的想象，当我感觉压力越大，自身就越不想去做足够多的测试。当知道自己做的测试不够时，就会增加自身的压力，因为我担心自己写的代码有 BUG，对自己编写的代码不够自信，这是一种心态上的变化。此时测试是开发人员的试金石，可以将对压力的恐惧变为平日的琐事，采用自动化测试，就有机会选择恐惧的程度。</p>\n<p>把控编程过程中的反馈与决策之间的差距。</p>\n<p>如果我做了一周的规划，并且量化成一个个可操作的任务写到 to-do list，然后使用测试驱动编码，把完成的任务像这样划掉，那么我的工作目标将变得非常清晰，因为我明确工期，明确待办事项，明确难点，可以在持续细微的反馈中有意识地做一些适当的调整，比如添加新的任务，删除冗余的测试；还有一点更加让人振奋，我可以知道我大概什么时候可以完工。项目经理对软件开发进度可以更精确的把握。</p>\n<p>标注：本文摘抄自：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzgwOTcwOTIxOTkx\">https://juejin.cn/post/6844903780970921991</span><br>感兴趣可自行进行查看</p>\n","categories":["开发模式"],"tags":["开发模式"]},{"title":"typeScript笔记","url":"/2023/12/11/TS/","content":"<h1 id=\"TS\"><a href=\"#TS\" class=\"headerlink\" title=\"TS\"></a>TS</h1><h3 id=\"定义数据类型\"><a href=\"#定义数据类型\" class=\"headerlink\" title=\"定义数据类型\"></a>定义数据类型</h3><pre><code class=\"ts\">/**\n * 定义数据类型\n */\nlet num:number=1\nlet bool:boolean=false\n/**\n * 定义固定类型数组\n */\nlet arr1:number[]=[1,2,3]\nlet arr2:string[]=[&#39;1&#39;,&#39;2&#39;]\n/**\n * 使用泛型定义固定类型数组\n */\nlet arr3:Array&lt;number&gt;=[1,2,3]\n/**\n * 不声明类型定义数组\n */\n// 此时不生命类型则自动分配好了类型，不能赋值数组中不存在的类型\n// ts中数组中的类型默认声明好了，不能添加原本数组中不存在的类型\nlet arr4=[1,2,3]\nlet arr5 =[1,&#39;2&#39;]\n/**\n * 定义混合类型any数组\n */\n// 定义混合类型any的数组可以存放任何类型的值\nlet arr6:any[]=[1,&#39;ds&#39;,false]\n</code></pre>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><pre><code class=\"ts\">/**\n * 元组（类型写在数组外面，元组类型写在数组里面）\n */\n// 一旦定义了元组，其类型和固定顺序位置的数据类型就确定了\nlet arr7:[number,boolean]=[1,false]\n// 但是其长度可以通过push方法改变，但不能直接赋值改变\narr7.push(2)\n// arr7 =[1,false,2]  //报错\n</code></pre>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><pre><code class=\"ts\">/**\n * 联合类型\n */\nlet a : number | string =0\n</code></pre>\n<h3 id=\"字面量类型\"><a href=\"#字面量类型\" class=\"headerlink\" title=\"字面量类型\"></a>字面量类型</h3><pre><code class=\"ts\">/**\n * 字面量类型（字面量类型声明的值中只能赋值为指定的）\n */\nlet a1 : 1 | 0 =0;\n</code></pre>\n<p>枚举类型</p>\n<pre><code class=\"ts\">/**\n * 枚举类型 enum\n */\nenum Color&#123;\n    red ,green,blue\n&#125;\nlet a2 = Color.blue\nconsole.log(a2);  //默认情况下赋值为0,1,2\nenum Color&#123;\n    red1=1,green1,blue1\n&#125;\nconsole.log(Color.blue1); //改变后为1，2，3\nenum Color&#123;\n    red2=&#39;red&#39;,green2=&#39;green&#39;,blue2=&#39;blue&#39;\n&#125;\nconsole.log(Color.blue2);  //赋值给其中一项的如果不是可迭代的（number），则需要为每一个都赋值\n</code></pre>\n<h3 id=\"any和unknown类型\"><a href=\"#any和unknown类型\" class=\"headerlink\" title=\"any和unknown类型\"></a>any和unknown类型</h3><pre><code class=\"ts\">/**\n * any类型和unkonwn类型的区别\n * unkonwn类型表示强制类型检查（可以通过赋值改变类型,只有类型明确时才能使用对应属性或方法）\n * any类型表示不进行类型检查\n */\nlet a3:unknown=1;\na3=&#39;1&#39;\na3=&#123;a1:&#39;dsf&#39;&#125;\n// a3.a1\n// a3()\n// a3.toString() 当定义unknown未知类型时，在类型未知的情况下不能使用方法\nif(typeof a3 === &#39;function&#39;)&#123;\n    a3()\n&#125;\nif(typeof a3 === &#39;string&#39;)&#123;\n    a3.toUpperCase()\n&#125;\n</code></pre>\n<h3 id=\"void、undefined和never类型\"><a href=\"#void、undefined和never类型\" class=\"headerlink\" title=\"void、undefined和never类型\"></a>void、undefined和never类型</h3><pre><code class=\"ts\">/**\n * void类型、undefined类型 和 never类型\n * void类型一般用于表示函数无返回值\n * undefined类型一般用于表示函数直接return或者return undefined\n * never类型一般用于表示函数死循环，永远无法return\n */\n// 1 undefined类型，此时函数返回时将返回undefined（undefined类型表示未赋值、为初始化）\nfunction a4():undefined&#123;\n    console.log(&#39;a4&#39;);\n    return\n&#125;\n// 2 void类型，表示变量本身就不存在，当函数没有返回值时，返回值就是void\nfunction a5()&#123;\n    console.log(&#39;a5&#39;);\n&#125;\n// 2 never类型，表示一个函数永远执行不完（报错或无限循环）\nfunction throwErr(message:string,errCode:number):never&#123;\n    throw&#123;\n        message,errCode\n    &#125;\n&#125;\nfunction whileLoop():never&#123;\n    while(true)&#123;\n        console.log(&#39;永远为真&#39;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><pre><code class=\"ts\">/**\n * 类型适配（类型断言）as\n */\nlet message:any;\nmessage=&#39;1cf&#39; //即使这个时候赋值为字符串，类型仍然是any\nlet a6 = (&lt;string&gt;message).endsWith(&#39;c&#39;)    //使用尖括号对变量进行类型断言\nlet a7 = (message as string).endsWith(&#39;f&#39;)  //使用as关键字对变量进行类型断言\n</code></pre>\n<h3 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h3><pre><code class=\"ts\">/**\n * 函数的声明\n */\n// 1 ts中函数形参的个数和传参时的个数必须要保持一致\nlet a8 = (message:string,code:number)=&gt;&#123;  \n    console.log(message,code);\n&#125;\na8(&#39;a8&#39;,8)\n// 2 可选参数，用 ?表示可选参数（可选参数必须要在必选参数之后）\nlet a9 =(message:string,code?:number)=&gt;&#123;\n    console.log(message,code);\n&#125;\na9(&#39;你好&#39;)\n// 3 默认参数，与ES6相似\nlet a10=(message:string=&#39;你好&#39;,code:number=1)=&gt;&#123;\n    console.log(message,code);\n&#125;\na10(&#39;嗨&#39;)\n</code></pre>\n<h3 id=\"具体对象类型\"><a href=\"#具体对象类型\" class=\"headerlink\" title=\"具体对象类型\"></a>具体对象类型</h3><pre><code class=\"ts\">/**\n * 具体对象类型\n */\nlet person1 :&#123;\n    name:string,\n    age:number\n&#125;=&#123;\n    name:&#39;张三&#39;,\n    age:18\n&#125;\nlet person2=&#123;\n    name:&#39;李四&#39;,age:20\n&#125;\n// person2.nicname 此时会报错，不能使用对象没有的属性和方法\nlet person3:any=&#123;name:&#39;王五&#39;,age:22&#125;\nconsole.log(person3.nickname); //如果将对象的类型改为any，则可以使用任意类型（相当于原生js对象）\n</code></pre>\n<h3 id=\"接口interface\"><a href=\"#接口interface\" class=\"headerlink\" title=\"接口interface\"></a>接口interface</h3><pre><code class=\"ts\">/**\n * 定义接口interface\n */\ninterface Point&#123;\n    x:number,y:number\n&#125;\nlet drawPoint = (point:Point)=&gt;&#123;\n    console.log(&#123;x:point.x,y:point.y&#125;);\n&#125;\n// drawPoint(&#123;x:&#39;1&#39;,y:1&#125;)  这时候不满足接口就会报错.同时这样讲函数和接口分开写不利于代码的高内聚低耦合原则\ninterface Person&#123;\n    age:number;name:string;\n    say:()=&gt;void  //用接口表示对应的类型生命，讲函数和接口放在一起提高代码的高内聚低耦合\n&#125;\n</code></pre>\n<h3 id=\"类和接口\"><a href=\"#类和接口\" class=\"headerlink\" title=\"类和接口\"></a>类和接口</h3><pre><code class=\"ts\">/**\n * 类 class （ES6中也有类的概念）\n */\nclass PersonClass implements Person&#123;  //使用类实现接口\n    age:number;name:string;\n    constructor(age:number=10,name:string=&#39;张三&#39;)&#123;  //js中的函数不可以重载，一个类中有且只能有一个构造函数\n        this.age=age;\n        this.name=name\n    &#125;\n    say=()=&gt;&#123;console.log(`我是：$&#123;this.name&#125;,今年$&#123;this.age&#125;碎了`)&#125;;\n&#125;\nconst person4 = new PersonClass()\nperson4.say()\n</code></pre>\n<h3 id=\"类的访问修饰符\"><a href=\"#类的访问修饰符\" class=\"headerlink\" title=\"类的访问修饰符\"></a>类的访问修饰符</h3><pre><code class=\"ts\">/**\n * 构造函数中访问修饰符：public、private、protected\n */\n// 1 public访问修饰符 （没有书写时默认为：public）\nclass PersonClass2 implements Person&#123;  //使用类实现接口\n    // age:number;name:string;\n    constructor(public age:number,public name:string)&#123;  //js中的函数不可以重载，一个类中有且只能有一个构造函数\n        // 使用关键字public之后，将自动构造出静态属性，不用在赋值\n        // this.age=age;this.name=name\n    &#125;\n    say=()=&gt;&#123;console.log(`我是：$&#123;this.name&#125;,今年$&#123;this.age&#125;碎了`)&#125;;\n&#125;\nconst person5 = new PersonClass2(100,&#39;活活&#39;)\nperson5.say()\n// 2 private访问修饰符\ninterface pp&#123;  \n    say:()=&gt;void,\n    // 添加getter和setter，用于给私有变量赋值\n    getAge:()=&gt;number,\n    getName:()=&gt;string,\n    setAge:(val:number)=&gt;void,\n    setName:(val:string)=&gt;void\n&#125;\nclass PersonClass3 implements pp&#123;  //使用类实现接口\n    constructor(private age:number,private name:string)&#123;  //js中的函数不可以重载，一个类中有且只能有一个构造函数\n        // 使用private访问修饰符后，同样不用自动注册\n    &#125;\n    say=()=&gt;&#123;console.log(`我是：$&#123;this.getName&#125;,今年$&#123;this.getAge&#125;碎了`)&#125;;\n    // 定义setter方法\n    getName=()=&gt;&#123;\n        return this.name\n    &#125;\n    getAge= () =&gt; &#123;\n        return this.age\n    &#125;\n    setName=(val:string)=&gt;&#123;\n        this.name=val\n    &#125;\n    setAge=(val:number)=&gt;&#123;\n        this.age=val\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"泛型-lt-T-gt\"><a href=\"#泛型-lt-T-gt\" class=\"headerlink\" title=\"泛型&lt; T &gt;\"></a>泛型&lt; T &gt;</h3><h4 id=\"泛型是什么\"><a href=\"#泛型是什么\" class=\"headerlink\" title=\"泛型是什么\"></a>泛型是什么</h4><p>泛型是程序设计语言的一种风格或范式，它允许我们使用一些以后才指定的类型。在定义函数接口或者类时，不预先定义好具体的类型，而在使用的时候才去指定类型的一种特性。</p>\n<pre><code class=\"ts\">/**\n * 泛型&lt;T&gt;\n * 泛型定义了函数中需要使用的类型（可以动态变化，写在变量名之后，括号之前）\n * 不止函数，类和接口中都可以使用泛型\n */\n// 动态泛型保证函数返回值和参数的类型一致\nlet lastInArray = &lt;T&gt;(arr:Array&lt;T&gt;)=&gt;&#123;\n    return arr[arr.length-1]\n&#125;\nconst L1 = lastInArray([1,2,3])\nconsole.log(L1);\nconst L2 = lastInArray([&#39;a&#39;,&#39;b&#39;])\nconsole.log(L2);\n// 显示指明类型\nlet L3 = lastInArray&lt;string | number&gt;([&#39;1&#39;,&#39;2&#39;])\n// 多泛型表达\nlet L4 = &lt;T,Y&gt;(x:T,y:Y)=&gt;[x,y]\nconst v1 = L4(1,&#39;one&#39;)\n//声明泛型接口\ninterface ReturnItemFn&lt;T&gt; &#123;\n    (para: T): T\n&#125;\nconst returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para\n//声明泛型类\n\nclass Stack&lt;T&gt; &#123;\n    private arr: T[] = []\n \n    public push(item: T) &#123;\n        this.arr.push(item)\n    &#125;\n \n    public pop() &#123;\n        this.arr.pop()\n    &#125;\n&#125;\nconst stack = new Stack&lt;number&gt;();\n</code></pre>\n<h3 id=\"类型type\"><a href=\"#类型type\" class=\"headerlink\" title=\"类型type\"></a>类型type</h3><pre><code class=\"ts\">/**\n * 类型type\n */\ntype Square = &#123;\n    size:number\n&#125;\ntype Rectangle = &#123;\n    width:number;\n    height:number;\n&#125;\ntype Shape = Square | Rectangle; //联合类型\nfunction area(shape:Shape)&#123;\n    if(&#39;size&#39; in shape)&#123;  //如果shape中有size属性，说明是正方形\n        return shape.size ** 2\n    &#125;\n    if(&#39;width&#39; in shape)&#123;\n        return shape.width * shape.height\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"类型守护-is\"><a href=\"#类型守护-is\" class=\"headerlink\" title=\"类型守护 is\"></a>类型守护 is</h3><pre><code class=\"ts\">/**\n * 类型守护\n * 类型判断：typeof,实例判断：instanceof，属性判断:in，字面量相等判断(==等)\n * 自定义类型判断，通过：&#123;形参&#125; is &#123;类型&#125;\n */\n// 将判断变为返回boolean的函数时，类型守护失效，这时候就需要使用自定义类型判断\ntype Square1 = &#123;\n    size:number\n&#125;\ntype Rectangle1 = &#123;\n    width:number;\n    height:number;\n&#125;\nfunction isSquare(shape1:Shape1):boolean&#123;\n    return &#39;size&#39; in shape1\n&#125;\nfunction isRectangle(shape1:Shape1):boolean&#123;\n    return &#39;width&#39; in shape1\n&#125;\ntype Shape1 = Square1 | Rectangle1;\nfunction area1(shape1:Shape1)&#123;\n    if(isSquare(shape1))&#123;  //如果shape中有size属性，说明是正方形\n        return shape1.size ** 2\n    &#125;\n    if(isRectangle(shape1))&#123;\n        return shape1.width * shape1.height\n    &#125;\n&#125;\n/**\n * 应该将判断函数定义为类型（而不是布尔值），这样类型守卫才不会失效\n */\ntype Square1 = &#123;\n    size:number\n&#125;\ntype Rectangle1 = &#123;\n    width:number;\n    height:number;\n&#125;\nfunction isSquare(shape1:Shape1):shape1 is Square1&#123;  //将boolean判断上升到类型判断中，使类型一致\n    return &#39;size&#39; in shape1\n&#125;\nfunction isRectangle(shape1:Shape1):shape1 is Rectangle1&#123;\n    return &#39;width&#39; in shape1\n&#125;\ntype Shape1 = Square1 | Rectangle1;\nfunction area1(shape1:Shape1)&#123;\n    if(isSquare(shape1))&#123;  //如果shape中有size属性，说明是正方形\n        return shape1.size ** 2\n    &#125;\n    if(isRectangle(shape1))&#123;\n        return shape1.width * shape1.height\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><pre><code class=\"ts\">/**\n * 函数重载（TS的函数重载发生在编译时而不是运行时，因为js不支持函数重载）\n */\n// 使用函数重载将会明确函数的签名，大大提升对函数使用的准确性\nfunction makeDate(timeStamp:number):Date;\nfunction makeDate(year:number,month:number,day:number):Date;\nfunction makeDate(timeStampOrYear:number,month?:number,day?:number)&#123;\n    if(month != null &amp;&amp; day != null)&#123;\n        return new Date(timeStampOrYear,month-1,day)\n    &#125;else&#123;\n        return new Date(timeStampOrYear)\n    &#125;\n&#125;\n//当调用函数时，ts编译器会根据传入的参数类型和数量来确定应该调用哪个函数\nconsole.log(makeDate(123923892));\n</code></pre>\n<h3 id=\"函数签名\"><a href=\"#函数签名\" class=\"headerlink\" title=\"函数签名\"></a>函数签名</h3><pre><code class=\"ts\">/**\n * 调用签名（签名是函数重载中的概念，描述了函数所需的参数类型和返回值类型）\n */\n//定义了一个类型（函数类型），其中类型别名包含一个debugName属性，然后包含一个函数重载\ntype Add=&#123;\n    (a:number,b:number):number;\n    debugName:string;  //添加debugName附加信息\n    (a:number,b:number,c:number):number;  //进行函数的重载\n&#125;\nconst add:Add = (a:number,b:number,c?:number)=&gt;&#123;\n    return a+b+(c != null ? c : 0);\n&#125;;\nadd.debugName=&#39;附加信息&#39;\n/**\n * new构造函数进行签名\n */\ntype Poit=&#123;\n    new (x:number,y:number):&#123;x:number;y:number&#125;;\n    new (x:number,y:number,z:number):&#123;x:number;y:number,z:number&#125;;\n&#125;\nconst point = class&#123;\n    constructor(public x:number,public y :number,public z?:number)&#123;&#125;\n&#125;\n/**\n * 索引签名\n */\n// 定义字典类型\ntype Dictionary = &#123;\n    [key:string]:any;\n&#125;\n// 定义Person类型\ntype Person1 = &#123;\n    name:string;\n    age:number;\n&#125;\n// 定义字典对象类型\ntype PersonDictionary = &#123;\n    [username:string]:Person1\n&#125;\nconst persons :PersonDictionary=&#123;\n    alex:&#123;\n        name:&#39;阿莱克斯&#39;,\n        age:18\n    &#125;,\n    michal:&#123;\n        name:&#39;jackson&#39;,\n        age:20\n    &#125;\n&#125;\nconst alex=persons[&#39;alex&#39;]\npersons[&#39;张三&#39;]=&#123;\n    name:&#39;张三&#39;,\n    age:100\n&#125;\ndelete persons[&#39;张三&#39;]\n// 注意：当访问不存在的属性时，ts不会报错\nconst aa = persons[&#39;不存在&#39;] //undefined\n// aa.name  //ts书写时不会报错，编译时报错\n</code></pre>\n<h3 id=\"函数副作用\"><a href=\"#函数副作用\" class=\"headerlink\" title=\"函数副作用\"></a>函数副作用</h3><pre><code class=\"ts\">/**\n * 函数的副作用\n */\nfunction reverseSorted(input:number[]):number[]&#123;\n    return input.sort().reverse()\n&#125;\nlet arr8 = [1,2,3,4]\nconst result = reverseSorted(arr8)\nconsole.log(result,arr8); //可以观察到两个数组都变化了，函数出现了副作用\n</code></pre>\n<h3 id=\"函数参数修饰符\"><a href=\"#函数参数修饰符\" class=\"headerlink\" title=\"函数参数修饰符\"></a>函数参数修饰符</h3><pre><code class=\"ts\">/**\n * 修饰符：public,private,readonly,protected\n */\n/**\n * readonly只读属性\n */\n// 添加readonly之后，值只可以被读取，一旦被改写就会报错\nfunction reverseSorted2(input:readonly number[]):number[]&#123;\n    // return input.slice().sort().reverse()\n    return [...input].sort().reverse()\n&#125;\nlet arr9 = [1,2,3,4]\nconst result2 = reverseSorted2(arr9)\nconsole.log(result2,arr9);\n</code></pre>\n<h3 id=\"双重断言\"><a href=\"#双重断言\" class=\"headerlink\" title=\"双重断言\"></a>双重断言</h3><pre><code class=\"ts\">/**\n * 双重断言\n */\n// 断言：\ntype T2D = &#123;x:number;y:number&#125;;\ntype T3D = &#123;x:number;y:number,z:number&#125;;\nlet P2D : T2D=&#123;x:1,y:1&#125;\nlet P3D : T3D=&#123;x:10,y:10,z:10&#125;\nP2D=P3D  //多出属性的值可以赋值给少属性的值\n// P3D=P2D  //这样会报错，少属性的值不能付给多属性的值，此时可用类型断言\nP3D = P2D as T3D; //使用类型断言，表示P2D为T3D类型的值，这样就可以赋值\n// 双重类型断言 （如果两个值连类型都不一致）\ntype PersonT = &#123;name:string,age:number&#125;\nlet person6 : PersonT = &#123;name:&#39;张三&#39;,age:18&#125;\n// P3D = person6 报错\n// P3D = person6 as T3D 单重断言仍报错，因为数据类型都不对\nP3D = person6 as any as T3D  //双重断言\n</code></pre>\n<h3 id=\"字符串不可更改\"><a href=\"#字符串不可更改\" class=\"headerlink\" title=\"字符串不可更改\"></a>字符串不可更改</h3><pre><code class=\"ts\">/**\n * js中的字符串不可更改 immutable\n */\nlet king = &#39;elvis&#39;\nking = &#39;james&#39; //这里虽然变量变了，但是其实elvis字符串还在\nking[2] //字符串通过索引可以访问到对应字母\n// king[2] = &#39;b&#39;  //报错，js中字符串不可修改\n</code></pre>\n<h3 id=\"常量断言-as-const\"><a href=\"#常量断言-as-const\" class=\"headerlink\" title=\"常量断言 as const\"></a>常量断言 as const</h3><pre><code class=\"ts\">/**\n * 常量断言（js中对象类型的值可以修改）\n */\nconst obj = &#123;\n    name:&#39;张三&#39;,\n    age:19\n&#125; \nobj.name=&#39;李四&#39; //此时对象中的值可以任意修改\nconst obj2 = &#123;\n    name:&#39;王五&#39;,\n    age:100,\n    arr:[1,2,3]\n&#125; as const\n// obj2.name=&#39;张三&#39; //此时报错，使用常量断言之后不能修改\n// 延展：常量断言可以断言任何一个类型（包括数组），将任何类型的成员变量都转换为readonly只读属性\n// 应用场景2：（常量断言会将值变为字面量类型）\nfunction layout(setting:&#123;align:&#39;left&#39; | &#39;center&#39;;&#125;)&#123;\n    console.log(&#39;align为：&#39;,setting.align);\n&#125;\n// const test = &#123;align:&#39;left&#39;&#125;\n// layout(test) //此时会报错，因为test中的值是字符串，不是符合条件的字面量类型\nconst test = &#123; align:&#39;left&#39; &#125; as const\nlayout(test)  //使用常量类型断言，将值变为字面量类型了\n</code></pre>\n<h3 id=\"非空断言\"><a href=\"#非空断言\" class=\"headerlink\" title=\"非空断言 !\"></a>非空断言 !</h3><pre><code class=\"ts\">/**\n * 非空断言：（变量后加: ！）\n */\nlet str: string | null = &quot;hello&quot;;\nconsole.log(str.length); // 报错，str 可能为 null\nconsole.log(str!.length); // 不报错，使用非空断言操作符 ! 告诉编译器 str 不为 null\n</code></pre>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h3><pre><code class=\"ts\">/**\n * this关键字\n */\nfunction double(this:&#123;value:number&#125;)&#123; //this必须是参数的第一位（假的）\n    this.value = this.value * 2\n&#125;\nconst valid = &#123;\n    value:10,\n    double\n&#125;\nvalid.double() //得到20\nconst valid2 = &#123;\n    val:1,\n    double\n&#125;\n// valid2.double() 此时报错，因为balid2中对象没有value属性\n</code></pre>\n<h3 id=\"typeof操作符\"><a href=\"#typeof操作符\" class=\"headerlink\" title=\"typeof操作符\"></a>typeof操作符</h3><pre><code class=\"ts\">/**\n * typeof操作符，提取已有变量的类型\n */\nconst center = &#123;\n    x:0,y:0,z:0\n&#125;\n// type position = &#123;\n//     x:number,y:number,z:number\n// &#125;\ntype position = typeof center //这里使用typeof操作符就不用重新定义\nconst unit:position=&#123;   \n    x:center.x+1,y:center.y+1,z:center.z+1\n&#125;\n</code></pre>\n<h3 id=\"keyof操作符\"><a href=\"#keyof操作符\" class=\"headerlink\" title=\"keyof操作符\"></a>keyof操作符</h3><pre><code class=\"ts\">/**\n * keyof操作符，拿到全部的成员变量作为联合类型\n */\ntype Person3 = &#123;\n    name:string,\n    age:number\n&#125;\nconst person7 : Person3 =&#123;\n    name:&#39;张三&#39;,age:18\n&#125;\nfunction getValueByKey(obj:Person3,key:keyof Person3)&#123;  //keyof操作符得到联合类型\n    const value = obj[key];\n    return value;\n&#125;\nconst age = getValueByKey(person7,&#39;age&#39;)\n// const email = getValueByKey(person7,&#39;email&#39;) 这样会报错，不能得到不存在的key\n</code></pre>\n<h3 id=\"类型查找\"><a href=\"#类型查找\" class=\"headerlink\" title=\"类型查找\"></a>类型查找</h3><pre><code class=\"ts\">/**\n * 类型查找\n */\ntype res = &#123;\n    user:&#123;\n        name:string,\n        age:number\n    &#125;,\n    data:&#123;\n        info:string,\n        msg:string\n    &#125;\n&#125;\n// 通过定义的类型中的某一项进行类型查找\nfunction getInfo():res[&#39;data&#39;]&#123;\n    return &#123;\n        info:&#39;info&#39;,msg:&#39;msg&#39;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"类型映射\"><a href=\"#类型映射\" class=\"headerlink\" title=\"类型映射\"></a>类型映射</h3><pre><code class=\"ts\">/**\n * 类型映射\n */\ntype Point2 = &#123;\n    x:number,y:number,z:number\n&#125;\n//定义Readonly类型，用于将变量中每一项变为只读属性\nexport type Readonly&lt;T&gt;=&#123;  //使用export的原因是Readonly是TS内置好的函数\n    readonly [item in keyof T] : T[item]\n&#125;\nconst center2 : Readonly&lt;Point2&gt;=&#123;\n    x:1,y:1,z:1\n&#125;\n// center2.x = 100  此时会报错\n</code></pre>\n<h3 id=\"类型修饰符\"><a href=\"#类型修饰符\" class=\"headerlink\" title=\"类型修饰符\"></a>类型修饰符</h3><pre><code class=\"ts\">/**\n * 映射修饰符，readonly、?等\n */\ntype Point3 = &#123;\n    readonly x:number;\n    y?:number\n&#125;\ntype Mapped&lt;T&gt; = &#123;\n    // readonly [item in keyof T] ? : T[item]\n    -readonly [item in keyof T] -? : T[item]\n&#125;\ntype Result3 = Mapped&lt;Point3&gt;\n// 实际使用案例\nexport class State&lt;T&gt;&#123;\n    constructor(public current:T)&#123;&#125;\n    update(next:Partial&lt;T&gt;)&#123;\n        this.current = &#123;...this.current,...next&#125;\n    &#125;\n&#125;\nexport type Partial&lt;T&gt; = &#123;\n    [item in keyof T]?:T[item];\n&#125;\nconst state = new State(&#123;x:0,y:0&#125;)\nstate.update(&#123;y:124&#125;);\nconsole.log(state.current);\n</code></pre>\n<h3 id=\"interface和type的区别\"><a href=\"#interface和type的区别\" class=\"headerlink\" title=\"interface和type的区别\"></a>interface和type的区别</h3><p>1、实现对象和类一般使用<strong>interface</strong>，</p>\n<p>而实现联合类型、元组类型、交叉类型一般使用<strong>type</strong></p>\n<pre><code class=\"ts\">// 1 类型别名可以用于其它类型 （联合类型、元组类型、交叉类型），\n// interface不支持这些，interface支持对象类型定义更好。\ntype PartialPointX = &#123; x: number &#125;;\ntype PartialPointY = &#123; y: number &#125;;\n// union(联合)\ntype PartialPoint = PartialPointX | PartialPointY;\n// tuple(元祖)\ntype Data = [PartialPointX, PartialPointY];\n//primitive(原始值)\ntype Name = Number;\n// typeof的返回值\nlet div = document.createElement(&#39;div&#39;);\ntype B = typeof div;\n</code></pre>\n<p>2 、 interface 可以多次定义 并被视为合并所有声明成员 type 不支持</p>\n<pre><code class=\"ts\">interface Point &#123;\n  x: number;\n&#125;\ninterface Point &#123;\n  y: number;\n&#125;\nconst point1: Point = &#123; x: 1, y: 2 &#125;;\n</code></pre>\n<p>3 、 type 能使用 in 关键字生成映射类型，但 interface 不行。</p>\n<pre><code class=\"ts\">type Keys = &#39;firstname&#39; | &#39;surname&#39;;\ntype DudeType = &#123;\n\n[key in Keys]: string;\n\n&#125;;\nconst test1: DudeType = &#123;\n  firstname: &#39;Pawel&#39;,\n  surname: &#39;Grzybek&#39;,\n&#125;;\n</code></pre>\n<p>4 、 默认导出方式不同</p>\n<pre><code class=\"ts\">// inerface 支持同时声明，默认导出 而type必须先声明后导出\nexport default interface Config &#123;\n  name: string;\n&#125;\n// 同一个js模块只能存在一个默认导出哦\n type Config2 = &#123;name: string&#125;\n  export default Config2\n//   type或者interface使用指南\n//   在选择使用 type 还是 interface 时，你可以根据具体情况来决定。通常来说，如果你需要定义对象的结构，或者要求类实现某个结构，使用 interface 是一个不错的选择。\n//   而如果你需要复杂的联合类型或交叉类型，或者仅仅是为了给某个类型起一个别名以提高可读性，那么使用 type 是更合适的\n</code></pre>\n","categories":["typeScript"],"tags":["typeScript"]},{"title":"Sass笔记","url":"/2023/01/10/Sass/","content":"<h1 id=\"Scss相关介绍\"><a href=\"#Scss相关介绍\" class=\"headerlink\" title=\"Scss相关介绍\"></a>Scss相关介绍</h1><h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"#目录\"></a>#目录</h3><blockquote>\n<p>[TOC]</p>\n</blockquote>\n<h3 id=\"一、CSS预处理器出现的原因\"><a href=\"#一、CSS预处理器出现的原因\" class=\"headerlink\" title=\"一、CSS预处理器出现的原因\"></a>一、CSS预处理器出现的原因</h3><ol>\n<li>无法嵌套书写导致代码繁重、冗杂、逻辑混乱。</li>\n<li>没有变量和样式复用机制，属性值只能以字面量的形式重复输出。</li>\n</ol>\n<pre><code class=\"shell\"># 总结：代码复用性低；不易于维护\n# 注：现在，现在的CSS是可以定义变量的！！！\n</code></pre>\n<pre><code class=\"css\">:root&#123;\n    --red: #f3e1e1;\n&#125;\n</code></pre>\n<hr>\n<h3 id=\"二、出名的CSS预处理器介绍\"><a href=\"#二、出名的CSS预处理器介绍\" class=\"headerlink\" title=\"二、出名的CSS预处理器介绍\"></a>二、出名的CSS预处理器介绍</h3><h3 id=\"1-SCSS-x2F-SASS\"><a href=\"#1-SCSS-x2F-SASS\" class=\"headerlink\" title=\"1. SCSS&#x2F;SASS\"></a>1. SCSS&#x2F;SASS</h3><p>SASS (.scss)。于2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。</p>\n<h3 id=\"2-LESS\"><a href=\"#2-LESS\" class=\"headerlink\" title=\"2. LESS\"></a>2. LESS</h3><p>LESS (.less)。于2009年诞生，借鉴了SASS的长处，并兼容了CSS语法，使得开发者使用起来更为方便顺手，但是相比于SASS，其编程功能不够丰富，反而促使SASS进化成为了SCSS。</p>\n<h3 id=\"3-Stylus\"><a href=\"#3-Stylus\" class=\"headerlink\" title=\"3. Stylus\"></a>3. Stylus</h3><p>Stylus (.styl)。于2010年诞生，出自Node.js社区，主要用来给Node项目进行CSS预处理支持，人气较前两者偏低。</p>\n<hr>\n<h3 id=\"三、SCSS和SASS之间的关系\"><a href=\"#三、SCSS和SASS之间的关系\" class=\"headerlink\" title=\"三、SCSS和SASS之间的关系\"></a>三、SCSS和SASS之间的关系</h3><p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706194107318.png\" alt=\"/images/image-20200706194107318\"></p>\n<p>简而言之：</p>\n<pre><code>Sass有两套语法：\n\n1.第一种或更新的语法被称为SCSS。它是CSS语法的扩展。这意味着每个有效的CSS样式表都是具有相同含义的有效SCSS文件。下文描述的Sass功能增强了此语法。使用此语法的文件扩展名为.scss。\n\n2.第二种或更旧的语法被称为SASS。提供了一种更为简洁的CSS编写方式。它使用缩进而不是方括号来表示选择器的嵌套，并使用换行符而不是分号来分隔属性。使用此语法的文件扩展名为.sass。\n\n任何一种格式可以直接 导入 (@import) 到另一种格式中使用，或者通过 sass-convert 命令行工具转换成另一种格式\n</code></pre>\n<hr>\n<h3 id=\"四、使用CSS预处理器的优劣\"><a href=\"#四、使用CSS预处理器的优劣\" class=\"headerlink\" title=\"四、使用CSS预处理器的优劣\"></a>四、使用CSS预处理器的优劣</h3><h3 id=\"1-优点\"><a href=\"#1-优点\" class=\"headerlink\" title=\"1.优点\"></a>1.优点</h3><pre><code>CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题。支持嵌套、变量和逻辑等。可以让CSS更加简洁、提高代码复用性、逻辑分明等等\n</code></pre>\n<h3 id=\"2-缺点\"><a href=\"#2-缺点\" class=\"headerlink\" title=\"2.缺点\"></a>2.缺点</h3><pre><code>css的文件体积和复杂度不可控；增加了调试难度和成本等。\n</code></pre>\n<h3 id=\"五、选择SCSS的原因\"><a href=\"#五、选择SCSS的原因\" class=\"headerlink\" title=\"五、选择SCSS的原因\"></a>五、选择SCSS的原因</h3><ol>\n<li><p>官方介绍</p>\n<pre><code>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。\n</code></pre>\n</li>\n<li><p>特色功能</p>\n<ul>\n<li>完全兼容 CSS3</li>\n<li>在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能</li>\n<li>通过函数进行颜色值与属性值的运算</li>\n<li>提供控制指令 (control directives)等高级功能</li>\n<li>自定义输出格式</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><pre><code>less、scss(sass)和stylus代码并不能被浏览器直接解析，所以必须先将它们编译成css代码\n\n现有框架已经提供了css预处理器选项，编译相关配置会自动帮我们生成！所以只有在&quot;练习&quot;情况下才有必要安装该环境\n</code></pre>\n<h3 id=\"一、安装分类\"><a href=\"#一、安装分类\" class=\"headerlink\" title=\"一、安装分类\"></a>一、安装分类</h3><h3 id=\"1-不依赖编辑器\"><a href=\"#1-不依赖编辑器\" class=\"headerlink\" title=\"1.不依赖编辑器\"></a>1.不依赖编辑器</h3><pre><code class=\"shell\"># 全局安装scss预处理器，使用终端命令实现编译\n\na. Node环境下的node-sass模块\nb. Node环境下的dart-sass模块\nc. Ruby环境下的sass模块\nd. Dart环境下的sass模块\n\n# 注：这里的推荐顺序针对的是&quot;练习&quot;场景，而开发环境下推荐使用的是dart-sass\n# 本质：某个语言的第三方库或者命令行工具\n</code></pre>\n<h3 id=\"2-依赖编辑器\"><a href=\"#2-依赖编辑器\" class=\"headerlink\" title=\"2.依赖编辑器\"></a>2.依赖编辑器</h3><pre><code>a. IDE代表：Webstrom\t前提是安装上述&quot;1&quot;中的命令行编译工具，配置自动命令，另安装一个代码提示插件scss\nb. 编辑器代表：vscode   安装Easy Sass（编译）和Sass（代码提示）两个插件\n</code></pre>\n<h3 id=\"二、安装步骤\"><a href=\"#二、安装步骤\" class=\"headerlink\" title=\"二、安装步骤\"></a>二、安装步骤</h3><h3 id=\"1-不依赖编辑器-1\"><a href=\"#1-不依赖编辑器-1\" class=\"headerlink\" title=\"1.不依赖编辑器\"></a>1.不依赖编辑器</h3><h4 id=\"😀-Node环境\"><a href=\"#😀-Node环境\" class=\"headerlink\" title=\"😀 Node环境\"></a>😀 Node环境</h4><h5 id=\"node-sass\"><a href=\"#node-sass\" class=\"headerlink\" title=\"- node-sass\"></a>- node-sass</h5><h6 id=\"a-安装\"><a href=\"#a-安装\" class=\"headerlink\" title=\"a.安装\"></a>a.安装</h6><pre><code class=\"shell\">1. 安装node  https://nodejs.org(官网) 或 https://npm.taobao.org/mirrors/node(镜像)\n2. *安装cnpm(不推荐直接将源换为淘宝镜像!!) $npm i -g cnpm --registry=https://registry.npm.taobao.org\n3. 安装node-sass $npm i -g node-sass  或  $cnpm i -g node-sass\n4. 检查是否安装成功$node-sass -v\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706124420782.png\" alt=\"/images/image-20200706124420782\"></p>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706132832305.png\" alt=\"/images/image-20200706132832305\"></p>\n<h6 id=\"b-使用\"><a href=\"#b-使用\" class=\"headerlink\" title=\"b.使用\"></a>b.使用</h6><ol>\n<li><p>单文件编译</p>\n<pre><code class=\"shell\">$node-sass  原有的scss文件 生成的css文件\n$node-sass  原有的scss文件 -o 生成目录\n\n# example:\n$node-sass a.scss b.css\n$node-sass a.scss css_files\n</code></pre>\n</li>\n<li><p>多文件编译</p>\n<pre><code class=\"shell\">$node-sass 原有的scss文件目录 -o 生成的css文件目录\n\n# example:\n$node-sass c -o d\n</code></pre>\n</li>\n<li><p>文件监听模式</p>\n<pre><code class=\"shell\"># 在&quot;1&quot;和&quot;2&quot;的基础上填加&quot;-w&quot;命令行参数即可\n$node-sass -w 原有的scss文件 -o 生成目录\n$node-sass -w 原有的scss文件目录 -o 生成的css文件目录\n\n# example:\n$node-sass -w scss -o css\n\n# 效果：编译进程不结束，监听文件内容\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706134612609.png\" alt=\"/images/image-20200706134612609\"></p>\n</li>\n</ol>\n<h5 id=\"dart-sass\"><a href=\"#dart-sass\" class=\"headerlink\" title=\"- dart-sass\"></a>- dart-sass</h5><h6 id=\"a-安装-1\"><a href=\"#a-安装-1\" class=\"headerlink\" title=\"a.安装\"></a>a.安装</h6><pre><code class=\"shell\">1. 安装node  https://nodejs.org(官网) 或 https://npm.taobao.org/mirrors/node(镜像)\n2. *安装cnpm(不推荐直接将源换为淘宝镜像!!) $npm i -g cnpm --registry=https://registry.npm.taobao.org\n3. 安装dart-sass $npm i -g sass  或  $cnpm i -g sass\n\n\n# 注：该模块为第三方库，所以可以考虑使用cnpm i sass -D(-D == --save-dev)仅对某个小项目当做开发时依赖进行使用\n</code></pre>\n<h6 id=\"b-使用-1\"><a href=\"#b-使用-1\" class=\"headerlink\" title=\"b.使用\"></a>b.使用</h6><pre><code class=\"js\">/* 该模块的官方文档：https://sass-lang.com/documentation/js-api */\n\n\nconst sass = require(&#39;sass&#39;);\n\nsass.render(&#123;file: scss_filename&#125;, function(err, result) &#123; /* ... */ &#125;);\n// OR\nconst result = sass.renderSync(&#123;file: scss_filename&#125;);\n\n// 注：默认情况下renderSync()的速度是render()的两倍以上，这是由于异步回调所带来的开销而导致的\n</code></pre>\n<hr>\n<h4 id=\"😀-Ruby环境\"><a href=\"#😀-Ruby环境\" class=\"headerlink\" title=\"😀 Ruby环境\"></a>😀 Ruby环境</h4><h5 id=\"a-安装-2\"><a href=\"#a-安装-2\" class=\"headerlink\" title=\"a.安装\"></a>a.安装</h5><pre><code class=\"shell\">1.安装Ruby\thttps://rubyinstaller.org/downloads\n2.*配置镜像\t$gem sources -a https://gems.ruby-china.com/ -r https://rubygems.org/\n3.*查看源 $gem sources -l # 确保只有gems.ruby-china.com一个源\n4.安装scss $gem install sass\n5.检查是否安装成功 $sass -v\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706141653304.png\" alt=\"/images/image-20200706141653304\"></p>\n<pre><code class=\"shell\">#注：如果出现了SSL错误，修改 ~/.gemrc 文件，增加 ssl_verify_mode: 0 配置\n# ~表示用户根目录，windows的文件位置为C:\\Users\\用户名\\.gemrc\n\n---\n:sources:\n- https://gems.ruby-china.com\n:ssl_verify_mode: 0\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706142100322.png\" alt=\"/images/image-20200706142100322\"></p>\n<h5 id=\"b-使用-2\"><a href=\"#b-使用-2\" class=\"headerlink\" title=\"b.使用\"></a>b.使用</h5><pre><code class=\"shell\"># 注：最好带上&quot;-C --sourcemap=none &quot;参数\n# 注：Sass 命令行工具根据文件的拓展名判断所使用的语法格式，没有文件名时 sass 命令默认编译 .sass 文件，添加 --scss 选项或者使用 scss 命令编译 SCSS 文件。\n</code></pre>\n<ol>\n<li><p>单文件编译</p>\n<pre><code class=\"shell\">$sass  原有的scss文件[:]生成的css文件\n\n# example:\n$sass a.scss b.css\n</code></pre>\n</li>\n<li><p>多文件编译</p>\n<pre><code class=\"shell\">$sass --watch 原有的scss文件目录:生成的css文件目录\n# 注：必须加&quot;--watch&quot;\n</code></pre>\n</li>\n<li><p>文件监听模式</p>\n<pre><code class=\"shell\">$sass --watch 原有的scss文件:生成的css文件\n$sass --watch 原有的scss文件目录:生成的css文件目录\n\n# example:\n$sass --watch -C --sourcemap=none scss:css\n\n# 效果：编译进程不结束，监听文件内容\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706143409397.png\" alt=\"/images/image-20200706143409397\"></p>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706164519533.png\" alt=\"/images/image-20200706164519533\"></p>\n</li>\n</ol>\n<hr>\n<h4 id=\"😀-Dart环境\"><a href=\"#😀-Dart环境\" class=\"headerlink\" title=\"😀 Dart环境\"></a>😀 Dart环境</h4><h5 id=\"a-安装-3\"><a href=\"#a-安装-3\" class=\"headerlink\" title=\"a.安装\"></a>a.安装</h5><pre><code class=\"shell\">1.安装Dart\thttps://dart.dev/tools/sdk/archive\n2.*配置镜像，添加环境变量 https://pub.flutter-io.cn 或 https://mirrors.tuna.tsinghua.edu.cn/dart-pub/\nwindows打开此电脑,添加系统变量 PUB_HOSTED_URL=https://pub.flutter-io.cn\nLinux键入$echo &#39;export PUB_HOSTED_URL=&quot;https://pub.flutter-io.cn&quot;&#39; &gt;&gt; ~/.bashrc 或 /etc/profile\n\n4.安装sass\n全局安装：$pub global activate sass\t\t\t\t(可执行文件)\n项目安装：pubspec.yaml填写好依赖后，执行 $pub get\t  (.dart代码)\n5.检查是否安装成功$sass -v\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706152755791.png\" alt=\"/images/image-20200706152755791\"></p>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706153705517.png\" alt=\"/images/image-20200706153705517\"></p>\n<h5 id=\"b-使用-3\"><a href=\"#b-使用-3\" class=\"headerlink\" title=\"b.使用\"></a>b.使用</h5><h6 id=\"全局安装模式\"><a href=\"#全局安装模式\" class=\"headerlink\" title=\"全局安装模式\"></a>全局安装模式</h6><ol>\n<li><p>单文件编译</p>\n<pre><code class=\"shell\">$sass  原有的scss文件[:]生成的css文件\n\n# example:\n$sass a.scss b.css\n</code></pre>\n</li>\n<li><p>多文件编译</p>\n<pre><code class=\"shell\">$sass 原有的scss文件目录/:生成的css文件目录/\n\n# example:\n$sass scss/:css/\n</code></pre>\n</li>\n<li><p>文件监听模式</p>\n<pre><code class=\"shell\">$sass --watch 原有的scss文件:生成的css文件\n$sass --watch 原有的scss文件目录:生成的css文件目录\n# 注：都必须加上&quot;:&quot;\n\n# example:\n$sass --watch scss:css\n\n# 效果：编译进程不结束，监听文件内容\n</code></pre>\n</li>\n</ol>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706160732312.png\" alt=\"/images/image-20200706160732312\"></p>\n<h6 id=\"局部安装模式\"><a href=\"#局部安装模式\" class=\"headerlink\" title=\"局部安装模式\"></a>局部安装模式</h6><pre><code class=\"dart\">2.运行.dart代码\n    // 前提是在pubsepc.yaml文件中添加依赖\n    // dev_dependencies:\n      //\t\tsass: lastest\n\n// main.dart\nimport &#39;package:sass/sass.dart&#39; as sass;\n\nvoid main(List&lt;String&gt; args) &#123;\n  print(sass.compile(args.first));\n&#125;\n// or\nvoid main(List&lt;String&gt; args) &#123;\n  var result = sass.compile(arguments[0]);\n  new File(arguments[1]).writeAsStringSync(result);\n&#125;\n// dart main.dart styles.scss styles.css\n</code></pre>\n<hr>\n<h3 id=\"2-依赖编辑器-1\"><a href=\"#2-依赖编辑器-1\" class=\"headerlink\" title=\"2.依赖编辑器\"></a>2.依赖编辑器</h3><h4 id=\"😀-WebStrom\"><a href=\"#😀-WebStrom\" class=\"headerlink\" title=\"😀 WebStrom\"></a>😀 WebStrom</h4><ul>\n<li>安装上述命令行工具之一（以node-sass为例演示）</li>\n<li>依次打开并点击：webstrom -&gt; Settings -&gt; Tools -&gt; Files Watchers -&gt; + -&gt; 选择SCSS文件标识</li>\n<li>Name随意写，供自己看而已</li>\n<li>File Type选择SCSS Style Sheet </li>\n<li>Scope选择All Places</li>\n<li>Program选择可执行文件的路径（这里以node-sass为例）</li>\n<li>Arguments按需选择（这里以*$FileName$:$FileNameWithoutExtension$.css*为例）</li>\n<li>Output paths to refresh按需选择（这里以*$FileNameWithoutExtension$.css*为例）</li>\n<li>点击OK，配置完成</li>\n</ul>\n<h4 id=\"😀-VSCode\"><a href=\"#😀-VSCode\" class=\"headerlink\" title=\"😀 VSCode\"></a>😀 VSCode</h4><ul>\n<li>安装Easy Sass（编译）和Sass（代码提示）两个插件（注意大小写，否则找不到）</li>\n<li>点击插件右下角的设置图标后点击”扩展设置”，最后点击”在settings.json中编辑”，开始设置关于Easy Sass的配置</li>\n<li>会自动生成下方图片内的配置</li>\n</ul>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706185328878.png\" alt=\"/images/image-20200706185328878\"></p>\n<ul>\n<li>添加*”easysass.targetDir”: $path<em>，可将编译后的css文件放入</em>$path*路径下(默认为当前路径)。例如生成到css文件下内</li>\n</ul>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706185722811.png\" alt=\"/images/image-20200706185722811\"></p>\n<h3 id=\"实战配置-安装sass\"><a href=\"#实战配置-安装sass\" class=\"headerlink\" title=\"实战配置(安装sass)\"></a>实战配置(安装sass)</h3><blockquote>\n<p>以上述方法配置会造成卡顿,这个方法安装sass进行监听</p>\n</blockquote>\n<pre><code>$FileName$ $FileNameWithoutExtension$.css\n$FileNameWithoutExtension$.css\n或者 -     sass --watch x.scss index.css\n</code></pre>\n<h1 id=\"Scss语法\"><a href=\"#Scss语法\" class=\"headerlink\" title=\"Scss语法\"></a>Scss语法</h1><blockquote>\n<p>本人笔记地址分享:<a href=\"https://gitee.com/hongjilin/hongs-study-notes\"><code>全部笔记</code></a>、<a href=\"https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Scss%E7%AC%94%E8%AE%B0\"><code>Sass所有学习笔记</code></a></p>\n</blockquote>\n<h3 id=\"目录-1\"><a href=\"#目录-1\" class=\"headerlink\" title=\"#目录\"></a>#目录</h3><blockquote>\n<p>[TOC]</p>\n</blockquote>\n<h3 id=\"SassScript\"><a href=\"#SassScript\" class=\"headerlink\" title=\"SassScript\"></a>SassScript</h3><blockquote>\n<p>在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。</p>\n<p>弱类型语言, 对语法要求没那么严格</p>\n</blockquote>\n<h4 id=\"一、注释\"><a href=\"#一、注释\" class=\"headerlink\" title=\"一、注释\"></a>一、注释</h4><blockquote>\n<ol>\n<li><p>Sass 支持标准的 CSS 多行注释 <code>/* */</code>，以及单行注释 <code>//</code>，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。</p>\n</li>\n<li><p>将 <code>!</code> 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</p>\n</li>\n<li><p>插值语句 (interpolation) 也可写进多行注释中输出变量值</p>\n</li>\n</ol>\n<p>  例如：</p>\n<pre><code class=\"scss\">// compile scss files to css\n// it&#39;s ready to do it.\n$pink: #f3e1e1;\nhtml&#123;\n   background-color: $pink;\n&#125;\n\n$author: &#39;gdream@126.com&#39;;\n/*!\nAuthor: #&#123;$author&#125;.\n*/\n</code></pre>\n<p>开发模式编译后:</p>\n<pre><code class=\"css\">/* \nhello\nworld!\n*/\nhtml&#123;\n   background-color: #f3e1e1;\n&#125;\n/*!\nAuthor: &#39;gdream@126.com&#39;.\n*/\n</code></pre>\n<p>压缩输出模式编译后：</p>\n<pre><code class=\"css\">html&#123;\n   background-color: #f3e1e1;\n&#125;\n/*!\nAuthor: &#39;gdream@126.com&#39;.\n*/\n</code></pre>\n</blockquote>\n<hr>\n<h4 id=\"二、变量\"><a href=\"#二、变量\" class=\"headerlink\" title=\"二、变量\"></a>二、变量</h4><h6 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h6><blockquote>\n<p>变量以美元符号开头，赋值方法与 CSS 属性的写法一样</p>\n</blockquote>\n<pre><code class=\"scss\">$width: 1600px;\n$pen-size: 3em;\n</code></pre>\n<h6 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h6><blockquote>\n<p>直接使用变量的名称即可调用变量</p>\n</blockquote>\n<pre><code class=\"scss\">#app &#123;\n    height: $width;\n    font-size: $pen-size;\n&#125;\n</code></pre>\n<h6 id=\"3-作用域\"><a href=\"#3-作用域\" class=\"headerlink\" title=\"3.作用域\"></a>3.作用域</h6><blockquote>\n<p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明</p>\n</blockquote>\n<pre><code class=\"scss\">#foo &#123;\n  $width: 5em !global;\n  width: $width;\n&#125;\n\n#bar &#123;\n  width: $width;\n&#125;\n</code></pre>\n<p>编译后：</p>\n<pre><code class=\"css\">#foo &#123;\n  width: 5em;\n&#125;\n\n#bar &#123;\n  width: 5em;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"三、数据类型\"><a href=\"#三、数据类型\" class=\"headerlink\" title=\"三、数据类型\"></a>三、数据类型</h4><blockquote>\n<p>SassScript 支持 7 种主要的数据类型：</p>\n<ul>\n<li>数字，<code>1, 2, 13, 10px</code></li>\n<li>字符串，有引号字符串与无引号字符串，<code>&quot;foo&quot;, &#39;bar&#39;, baz</code></li>\n<li>颜色，<code>blue, #04a3f9, rgba(255,0,0,0.5)</code></li>\n<li>布尔型，<code>true, false</code></li>\n<li>空值，<code>null</code></li>\n<li>数组 (list)，用空格或逗号作分隔符，<code>1.5em 1em 0 2em, Helvetica, Arial, sans-serif</code></li>\n<li>maps, 相当于 JavaScript 的 object，<code>(key1: value1, key2: value2)</code></li>\n</ul>\n<p>SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 <code>!important</code> 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。</p>\n<p>判断数据类型的方式：<code>type-of($value)</code></p>\n</blockquote>\n<h6 id=\"1-字符串-Strings\"><a href=\"#1-字符串-Strings\" class=\"headerlink\" title=\"1.字符串 (Strings)\"></a>1.字符串 (Strings)</h6><blockquote>\n<p>SassScript 支持 CSS 的两种字符串类型：<code>有引号字符串 (quoted strings)</code>，和<code>无引号字符串 (unquoted strings)</code>。</p>\n</blockquote>\n<pre><code class=\"scss\">$name: &#39;Tom Bob&#39;;\n$container: &quot;top bottom&quot;;\n$what: heart;\n\n// 注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#&#123;&#125;` (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名\n</code></pre>\n<h6 id=\"2-数字-Numbers\"><a href=\"#2-数字-Numbers\" class=\"headerlink\" title=\"2.数字(Numbers)\"></a>2.数字(Numbers)</h6><blockquote>\n<h6 id=\"SassScript支持两种数字类型：带单位数字和不带单位数字。（可正可负可为零，可正可浮点）\"><a href=\"#SassScript支持两种数字类型：带单位数字和不带单位数字。（可正可负可为零，可正可浮点）\" class=\"headerlink\" title=\"SassScript支持两种数字类型：带单位数字和不带单位数字。（可正可负可为零，可正可浮点）\"></a>SassScript支持两种数字类型：<code>带单位数字</code>和<code>不带单位数字</code>。（可正可负可为零，可正可浮点）</h6></blockquote>\n<pre><code class=\"scss\">$my-age: 19;\n$your-age: 19.5;\n$height: 120px;\n\n// 注：单位会和数字当做一个整体，进行算数运算\n</code></pre>\n<h6 id=\"3-空值-Null\"><a href=\"#3-空值-Null\" class=\"headerlink\" title=\"3.空值(Null)\"></a>3.空值(Null)</h6><blockquote>\n<p>只有一个取值<code>null</code></p>\n</blockquote>\n<pre><code class=\"scss\">$value: null;\n\n// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算\n</code></pre>\n<h6 id=\"4-布尔型-Booleans\"><a href=\"#4-布尔型-Booleans\" class=\"headerlink\" title=\"4.布尔型(Booleans)\"></a>4.布尔型(Booleans)</h6><blockquote>\n<p>只有两个取值：<code>true</code>和<code>false</code></p>\n</blockquote>\n<pre><code class=\"scss\">$a: true;\n$b: false;\n\n// 注：只有自身是false和null才会返回false，其他一切都将返回true\n</code></pre>\n<h6 id=\"5-数组-Lists\"><a href=\"#5-数组-Lists\" class=\"headerlink\" title=\"5.数组 (Lists)\"></a>5.数组 (Lists)</h6><blockquote>\n<p>通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从<code>1</code>开始</p>\n</blockquote>\n<pre><code class=\"scss\">$list0: 1px 2px 5px 6px;\n$list1: 1px 2px, 5px 6px;\n$list2: (1px 2px) (5px 6px);\n</code></pre>\n<blockquote>\n<p>数组中可以包含子数组，比如 <code>1px 2px, 5px 6px</code> 是包含 <code>1px 2px</code> 与 <code>5px 6px</code> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 <code>(1px 2px) (5px 6px)</code>。变化是，之前的 <code>1px 2px, 5px 6px</code> 使用逗号分割了两个子数组 (comma-separated)，而 <code>(1px 2px) (5px 6px)</code> 则使用空格分割(space-separated)。</p>\n<p>当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 <code>(1px 2px) (5px 6px)</code> 与 <code>1px 2px, 5px 6px</code> 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。</p>\n<p>用 <code>()</code> 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 <code>font-family: ()</code> Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 <code>1px 2px () 3px</code> 或 <code>1px 2px null 3px</code>。</p>\n<p>基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 <code>(1,)</code> 表示只包含 <code>1</code> 的数组，而 <code>(1 2 3,)</code> 表示包含 <code>1 2 3</code> 这个以空格分隔的数组的数组。</p>\n</blockquote>\n<h3 id=\"6-映射-Maps\"><a href=\"#6-映射-Maps\" class=\"headerlink\" title=\"6.映射(Maps)\"></a>6.映射(Maps)</h3><blockquote>\n<p>Maps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）</p>\n</blockquote>\n<pre><code class=\"scss\">$map: ( \n  $key1: value1, \n  $key2: value2, \n  $key3: value3 \n)\n</code></pre>\n<h3 id=\"7-颜色-Colors\"><a href=\"#7-颜色-Colors\" class=\"headerlink\" title=\"7.颜色 (Colors)\"></a>7.颜色 (Colors)</h3><blockquote>\n<p>CSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词</p>\n<p>SCSS提供了内置Colors函数，从而更方便地使用颜色</p>\n</blockquote>\n<pre><code class=\"scss\">$color0: green;\n$color1: lighten($color, 15%);\n$color2: darken($color, 15%);\n$color3: saturate($color, 15%);\n$color4: desaturate($color, 15%);\n$color5: (green + red);\n</code></pre>\n<hr>\n<h4 id=\"四、运算\"><a href=\"#四、运算\" class=\"headerlink\" title=\"四、运算\"></a>四、运算</h4><h3 id=\"1-数字运算符\"><a href=\"#1-数字运算符\" class=\"headerlink\" title=\"1.数字运算符\"></a>1.数字运算符</h3><blockquote>\n<p>SassScript 支持数字的加减乘除、取整等运算 (<code>+, -, *, /, %</code>)，如果必要会在不同单位间转换值</p>\n<p>如果要保留运算符号，则应该使用插值语法</p>\n</blockquote>\n<ul>\n<li><p><code>+</code></p>\n<pre><code class=\"scss\">// 纯数字\n$add1: 1 + 2;\t// 3\n$add2: 1 + 2px; // 3px\n$add3: 1px + 2; // 3px\n$add4: 1px + 2px;//3px\n\n// 纯字符串\n$add5: &quot;a&quot; + &quot;b&quot;; // &quot;ab&quot;\n$add6: &quot;a&quot; + b;\t  // &quot;ab&quot;\n$add7: a + &quot;b&quot;;\t  // ab\n$add8: a + b;\t  // ab\n\n// 数字和字符串\n$add9: 1 + a;\t// 1a\n$adda: a + 1;\t// a1\n$addb: &quot;1&quot; + a; // &quot;1a&quot;\n$addc: 1 + &quot;a&quot;; // &quot;1a&quot;\n$addd: &quot;a&quot; + 1; // &quot;a1&quot;\n$adde: a + &quot;1&quot;; // a1\n$addf: 1 + &quot;1&quot;; // &quot;11&quot;\n</code></pre>\n<pre><code class=\"scss\">// 总结：\na.纯数字：只要有单位，结果必有单位\nb.纯字符串：第一个字符串有无引号决定结果是否有引号\nc数字和字符串：第一位有引号，结果必为引号；第一位对应数字非数字且最后一位带有引号，则结果必为引号\n</code></pre>\n</li>\n<li><p><code>-</code></p>\n<pre><code class=\"scss\">$add1: 1 - 2;\t// -1\n$add2: 1 - 2px; // -1px\n$add3: 1px - 2; // -1px\n$add4: 1px - 2px;//-1px\n\n$sub1: a - 1;  // a-1\n$sub2: 1 - a;  // 1-a\n$sub3: &quot;a&quot; - 1;// &quot;a&quot;-1\n$sub4: a - &quot;1&quot;;// a-&quot;1&quot;\n</code></pre>\n<pre><code class=\"scss\">// 总结：\n每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。\n只要其中一个值首位不为数字的，结果就按顺序去除空格后拼接起来\n</code></pre>\n</li>\n<li><p><code>*</code></p>\n<pre><code class=\"scss\">$num1: 1 * 2;    // 2\n$mul2: 1 * 2px;  // 2px\n$num3: 1px * 2;  // 2px\n$num4: 2px * 2px;// 编译不通过\n\n$num5: 1 * 2abc; // 2abc\n</code></pre>\n<pre><code class=\"scss\">// 总结：\n每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。其余编译不通过\n</code></pre>\n</li>\n<li><p><code>/</code></p>\n<pre><code class=\"scss\">// 总结：\na.不会四舍五入，精确到小数点后5位\nb.每个字段必须前部分为数字，且当前者只是单纯数字无单位时，后者(除数)后部分不能有字符。其余结果就按顺序去除空格后拼接起来。\n(因为此时后缀被当被单位看待了)\n</code></pre>\n</li>\n<li><p><code>%</code></p>\n<pre><code class=\"scss\">// 总结：\na.值与&quot;%&quot;之间必须要有空格，否则会被看做字符串\n</code></pre>\n</li>\n</ul>\n<h3 id=\"2-关系运算符\"><a href=\"#2-关系运算符\" class=\"headerlink\" title=\"2.关系运算符\"></a>2.关系运算符</h3><blockquote>\n<p>大前提：两端必须为<code>数字</code> 或 <code>前部分数字后部分字符</code></p>\n<p>返回值：<code>true</code> or <code>false</code></p>\n</blockquote>\n<ul>\n<li><p><code>&gt;</code></p>\n<pre><code class=\"scss\">$a: 1 &gt; 2; // false\n</code></pre>\n</li>\n<li><p><code>&lt;</code></p>\n<pre><code class=\"scss\">$a: 1 &gt; 2; // true\n</code></pre>\n</li>\n<li><p><code>&gt;=</code></p>\n<pre><code class=\"scss\">$a: 1 &gt;= 2; // false\n</code></pre>\n</li>\n<li><p><code>&lt;=</code></p>\n<pre><code class=\"scss\">$a: 1 &lt;= 2; // true\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-相等运算符\"><a href=\"#3-相等运算符\" class=\"headerlink\" title=\"3.相等运算符\"></a>3.相等运算符</h3><blockquote>\n<p>作用范围：相等运算 <code>==, !=</code> 可用于所有数据类型</p>\n<p>返回值：<code>true</code> or <code>false</code></p>\n</blockquote>\n<pre><code class=\"scss\">$a: 1 == 1px; // true\n$b: &quot;a&quot; == a; // true\n</code></pre>\n<pre><code class=\"scss\">// 总结：\n前部分为不带引号数字时，对比的仅仅是数字部分；反之，忽略引号，要求字符一一对应\n</code></pre>\n<h3 id=\"4-布尔运算符\"><a href=\"#4-布尔运算符\" class=\"headerlink\" title=\"4.布尔运算符\"></a>4.布尔运算符</h3><blockquote>\n<p>SassScript 支持布尔型的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算。</p>\n</blockquote>\n<pre><code class=\"scss\">$a: 1&gt;0 and 0&gt;=5; // fasle\n</code></pre>\n<pre><code class=\"scss\">// 总结：\n值与&quot;and&quot;、&quot;or&quot;和&quot;not&quot;之间必须要有空格，否则会被看做字符串\n</code></pre>\n<h3 id=\"5-颜色值运算\"><a href=\"#5-颜色值运算\" class=\"headerlink\" title=\"5.颜色值运算\"></a>5.颜色值运算</h3><blockquote>\n<p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值</p>\n</blockquote>\n<ul>\n<li><p><code>颜色值与颜色值</code></p>\n<pre><code class=\"scss\">p &#123;\n  color: #010203 + #040506;\n&#125;\n\n// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为\n// p &#123;\n  color: #050709; &#125;\n</code></pre>\n</li>\n<li><p><code>颜色值与数字</code></p>\n<pre><code class=\"scss\">p &#123;\n  color: #010203 * 2;\n&#125;\n\n// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为\n// p &#123;\n  color: #020406; &#125;\n</code></pre>\n</li>\n<li><p><code>RGB和HSL</code></p>\n<pre><code class=\"scss\">// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。\n\np &#123;\n  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);\n&#125;\n\n// p &#123;\n  color: rgba(255, 255, 0, 0.75); &#125;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"6-运算优先级\"><a href=\"#6-运算优先级\" class=\"headerlink\" title=\"6.运算优先级\"></a>6.运算优先级</h3><ol start=\"0\">\n<li><p><code>()</code></p>\n</li>\n<li><p><code>*</code>、<code>/</code>、<code>%</code></p>\n</li>\n<li><p><code>+</code>、<code>-</code></p>\n</li>\n<li><p><code>&gt;</code> 、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>\n</li>\n</ol>\n<hr>\n<h4 id=\"五、嵌套语法\"><a href=\"#五、嵌套语法\" class=\"headerlink\" title=\"五、嵌套语法\"></a>五、嵌套语法</h4><blockquote>\n<p>此部分不计入笔记</p>\n</blockquote>\n<hr>\n<h4 id=\"六、杂货语法\"><a href=\"#六、杂货语法\" class=\"headerlink\" title=\"六、杂货语法\"></a>六、杂货语法</h4><h3 id=\"1-插值语法\"><a href=\"#1-插值语法\" class=\"headerlink\" title=\"1.插值语法\"></a>1.<code>插值语法</code></h3><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器、属性名和属性值中使用变量。</p>\n<p>但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p>\n<pre><code class=\"scss\">$name: foo;\n$attr: border;\np.#&#123;$name&#125; &#123;\n  #&#123;$attr&#125;-color: $name;\n&#125;\n\n// 编译后：\np.foo &#123;\n  border-color: foo;\n&#125;\n</code></pre>\n<h3 id=\"2-amp-in-SassScript\"><a href=\"#2-amp-in-SassScript\" class=\"headerlink\" title=\"2.&amp; in SassScript\"></a>2.<code>&amp; in SassScript</code></h3><p><code>&amp;</code>为父选择器</p>\n<pre><code class=\"scss\">a &#123;\n    color: yellow;\n    &amp;:hover&#123;\n        color: green;\n    &#125;\n    &amp;:active&#123;\n        color: blank;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-default\"><a href=\"#3-default\" class=\"headerlink\" title=\"3.!default\"></a>3.<code>!default</code></h3><p>可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p>\n<pre><code class=\"scss\">$content: &quot;First content&quot;;\n$content: &quot;Second content?&quot; !default;\n$new_content: &quot;First time reference&quot; !default;\n\n#main &#123;\n  content: $content;\n  new-content: $new_content;\n&#125;\n\n// 编译为：\n#main &#123;\n  content: &quot;First content&quot;;\n  new-content: &quot;First time reference&quot;; &#125;\n</code></pre>\n<p>注意：变量是 null 空值时将视为未被 <code>!default</code> 赋值。</p>\n<h3 id=\"3-global\"><a href=\"#3-global\" class=\"headerlink\" title=\"3.!global\"></a>3.<code>!global</code></h3><p>将局部变量提升为全局变量</p>\n<h3 id=\"4-optional\"><a href=\"#4-optional\" class=\"headerlink\" title=\"4.!optional\"></a>4.<code>!optional</code></h3><p>如果 <code>@extend</code> 失败会收到错误提示，比如，这样写 <code>a.important &#123;@extend .notice&#125;</code>，当没有 <code>.notice</code> 选择器时，将会报错，只有 <code>h1.notice</code> 包含 <code>.notice</code> 时也会报错，因为 <code>h1</code> 与 <code>a</code> 冲突，会生成新的选择器。</p>\n<p>如果要求 <code>@extend</code> 不生成新选择器，可以通过 <code>!optional</code> 声明达到这个目的.</p>\n<p>简而言之：当<code>@extend</code>相关代码出现语法错误时，编译器可能会给我们”乱”编译为css，我们加上这个参数可以在出现问题后不让他编译该部分代码</p>\n<hr>\n<h4 id=\"七、-Rules与指令\"><a href=\"#七、-Rules与指令\" class=\"headerlink\" title=\"七、@-Rules与指令\"></a>七、@-Rules与指令</h4><h3 id=\"1-import\"><a href=\"#1-import\" class=\"headerlink\" title=\"1.@import\"></a>1.<code>@import</code></h3><blockquote>\n<p>Sass 拓展了 <code>@import</code> 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p>\n<p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。</p>\n<ul>\n<li>文件拓展名是 <code>.css</code>；</li>\n<li>文件名以 <code>http://</code> 开头；</li>\n<li>文件名是 <code>url()</code>；</li>\n<li><code>@import</code> 包含 media queries。</li>\n</ul>\n<p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p>\n</blockquote>\n<pre><code class=\"scss\">@import &quot;foo.scss&quot;;\n@import &quot;foo&quot;;\n// 以上两种方式均可\n\n\n// 以下方式均不可行\n@import &quot;foo.css&quot;;\n@import &quot;foo&quot; screen;\n@import &quot;http://foo.com/bar&quot;;\n@import url(foo);\n</code></pre>\n<blockquote>\n<p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p>\n</blockquote>\n<pre><code class=\"scss\">@import &quot;rounded-corners&quot;, &quot;text-shadow&quot;;\n</code></pre>\n<blockquote>\n<p>导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 <code>url()</code> 导入方式：</p>\n</blockquote>\n<pre><code class=\"scss\">$family: unquote(&quot;Droid+Sans&quot;);\n@import url(&quot;http://fonts.googleapis.com/css?family=\\#&#123;$family&#125;&quot;);\n\n// 编译为：\n@import url(&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;);\n</code></pre>\n<blockquote>\n<p>如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p>\n<p>除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 <code>@import</code>。</p>\n</blockquote>\n<h3 id=\"2-media\"><a href=\"#2-media\" class=\"headerlink\" title=\"2.@media\"></a>2.<code>@media</code></h3><blockquote>\n<p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p>\n</blockquote>\n<pre><code class=\"scss\">.sidebar &#123;\n  width: 300px;\n  @media screen and (orientation: landscape) &#123;\n    width: 500px;\n  &#125;\n&#125;\n// 编译为\n.sidebar &#123;\n  width: 300px;\n  @media screen and (orientation: landscape) &#123;\n    width: 500px;\n  &#125;\n&#125;\n</code></pre>\n<blockquote>\n<p><code>@media</code>的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code></p>\n</blockquote>\n<pre><code class=\"scss\">@media screen &#123;\n  .sidebar &#123;\n    @media (orientation: landscape) &#123;\n      width: 500px;\n    &#125;\n  &#125;\n&#125;\n// 编译为：\n@media screen and (orientation: landscape) &#123;\n  .sidebar &#123;\n    width: 500px; &#125; &#125;\n</code></pre>\n<blockquote>\n<p><code>@media</code> 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值</p>\n</blockquote>\n<pre><code class=\"scss\">$media: screen;\n$feature: -webkit-min-device-pixel-ratio;\n$value: 1.5;\n\n@media #&#123;$media&#125; and ($feature: $value) &#123;\n  .sidebar &#123;\n    width: 500px;\n  &#125;\n&#125;\n// 编译为：\n@media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123;\n  .sidebar &#123;\n    width: 500px; &#125; &#125;\n</code></pre>\n<h3 id=\"3-extend\"><a href=\"#3-extend\" class=\"headerlink\" title=\"3.*@extend\"></a>3.<code>*@extend</code></h3><blockquote>\n<p><code>@extend</code>即<code>继承</code>。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。</p>\n<p>总的来看：支持层叠继承、多继承、允许延伸任何定义给单个元素的选择器（但是允许不一定好用）</p>\n</blockquote>\n<p>a. <code>基本延伸</code></p>\n<pre><code class=\"scss\">.error &#123;\n  border: 1px #f00;\n  background-color: #fdd;\n&#125;\n.seriousError &#123;\n  @extend .error;\n  border-width: 3px;\n&#125;\n// 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。\n</code></pre>\n<blockquote>\n<p><code>@extend</code> 的作用是将重复使用的样式 (<code>.error</code>) 延伸 (extend) 给需要包含这个样式的特殊样式（<code>.seriousError</code>）</p>\n</blockquote>\n<p>注意理解以下情况：</p>\n<pre><code class=\"scss\">.error &#123;\n  border: 1px #f00;\n  background-color: #fdd;\n&#125;\n.error.intrusion &#123;\n  background-image: url(&quot;/image/hacked.png&quot;);\n&#125;\n.seriousError &#123;\n  @extend .error;\n  border-width: 3px;\n&#125;\n// .error, .seriousError &#123;\n  border: 1px #f00;\n  background-color: #fdd; &#125;\n\n.error.intrusion, .seriousError.intrusion &#123;\n  background-image: url(&quot;/image/hacked.png&quot;); &#125;\n\n.seriousError &#123;\n  border-width: 3px; &#125;\n</code></pre>\n<blockquote>\n<p>当合并选择器时，<code>@extend</code> 会很聪明地避免无谓的重复，<code>.seriousError.seriousError</code> 将编译为 <code>.seriousError</code>，不能匹配任何元素的选择器也会删除。</p>\n</blockquote>\n<p>b.  <code>延伸复杂的选择器</code>：Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 <code>.special.cool</code>，<code>a:hover</code> 或者 <code>a.user[href^=&quot;http://&quot;]</code> 等</p>\n<p>c. <code> 多重延伸</code>：同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器</p>\n<p>d. <code>继续延伸</code>：当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个</p>\n<p>e.<code>*选择器列</code>：暂时不可以将选择器列 (Selector Sequences)，比如 <code>.foo .bar</code> 或 <code>.foo + .bar</code>，延伸给其他元素，但是，却可以将其他元素延伸给选择器列。</p>\n<p>尽量不使用<code>合并选择器列</code>，因为如果凭个人推理的话，会出现排列组合的情况，所以SASS编译器只会保留有用的组合形式，但依旧会存在排列组合的情况，有可能会留下隐患。</p>\n<ol>\n<li><p>当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前</p>\n<pre><code class=\"scss\">#admin .tabbar a &#123;\n  font-weight: bold;\n&#125;\n#demo .overview .fakelink &#123;\n  @extend a;\n&#125;\n// 编译为：\n#admin .tabbar a,\n#admin .tabbar #demo .overview .fakelink,\n#demo .overview #admin .tabbar .fakelink &#123;\n  font-weight: bold; &#125;\n</code></pre>\n</li>\n<li><p>如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出</p>\n<pre><code class=\"scss\">#admin .tabbar a &#123;\n  font-weight: bold;\n&#125;\n#admin .overview .fakelink &#123;\n  @extend a;\n&#125;\n// 编译为\n#admin .tabbar a,\n#admin .tabbar .overview .fakelink,\n#admin .overview .tabbar .fakelink &#123;\n  font-weight: bold; &#125;\n</code></pre>\n</li>\n</ol>\n<p>f. <code>在指令中延伸</code></p>\n<p>在指令中使用 <code>@extend</code> 时（比如在 <code>@media</code> 中）有一些限制：Sass 不可以将 <code>@media</code> 层外的 CSS 规则延伸给指令层内的 CSS.</p>\n<p>g.  <code>%placeholder</code>为选择器占位符，配合<code>@extend-Only选择器</code>使用。</p>\n<p>效果：只定义了样式，但不会对原有选择器匹配的元素生效</p>\n<pre><code class=\"scss\">// example1:\n%img &#123;\n    color: red;\n&#125;\n.path&#123;\n    @extend %img;\n&#125;\n// 编译后：\n.path &#123;\n  color: red;\n&#125;\n</code></pre>\n<pre><code class=\"scss\">// example2:\n#context a%extreme &#123;\n  color: blue;\n  font-weight: bold;\n  font-size: 2em;\n&#125;\n// 编译后：\n.notice &#123;\n  @extend %extreme;\n&#125;\n\n// 注：必须是&quot;.&quot;和&quot;#&quot;选择器\n</code></pre>\n<h3 id=\"4-at-root\"><a href=\"#4-at-root\" class=\"headerlink\" title=\"4.@at-root\"></a>4.<code>@at-root</code></h3><blockquote>\n<p>The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector</p>\n<p>译文：@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用</p>\n<p>且@at-root 使多个规则跳出嵌套</p>\n<p>@at-root默认情况下并不能使规则或者选择器跳出指令，通过使用without和with可以解决该问题</p>\n<p>了解即可</p>\n</blockquote>\n<h3 id=\"5-debug\"><a href=\"#5-debug\" class=\"headerlink\" title=\"5.@debug\"></a>5.<code>@debug</code></h3><p>用于调试，按标准错误输出流输出</p>\n<pre><code class=\"scss\">$size: 9px;\n\n.file&#123;\n  @debug $size;\n&#125;\n</code></pre>\n<h3 id=\"6-warn\"><a href=\"#6-warn\" class=\"headerlink\" title=\"6.@warn\"></a>6.<code>@warn</code></h3><p>用于警告，按标准错误输出流输出</p>\n<h3 id=\"7-error\"><a href=\"#7-error\" class=\"headerlink\" title=\"7.@error\"></a>7.<code>@error</code></h3><p>用于报错，按标准错误输出流输出</p>\n<table>\n<thead>\n<tr>\n<th>序列</th>\n<th>@-rules</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>@import</td>\n<td>导入sass或scss文件</td>\n</tr>\n<tr>\n<td>2</td>\n<td>@media</td>\n<td>用于将样式规则设置为不同的媒体类型</td>\n</tr>\n<tr>\n<td>3</td>\n<td>@extend</td>\n<td>以继承的方式共享选择器</td>\n</tr>\n<tr>\n<td>4</td>\n<td>@at-root</td>\n<td>转到根节点</td>\n</tr>\n<tr>\n<td>5</td>\n<td>@debug</td>\n<td>用于调试，按标准错误输出流输出</td>\n</tr>\n<tr>\n<td>6</td>\n<td>@warn</td>\n<td>用于警告，按标准错误输出流输出</td>\n</tr>\n<tr>\n<td>7</td>\n<td>@error</td>\n<td>用于报错，按标准错误输出流输出</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"八、控制指令\"><a href=\"#八、控制指令\" class=\"headerlink\" title=\"八、控制指令\"></a>八、控制指令</h4><h3 id=\"1-if\"><a href=\"#1-if\" class=\"headerlink\" title=\"1.if()\"></a>1.<code>if()</code></h3><p><em>三元运算符</em></p>\n<p>表达式：<code>if(expression, value1, value2)</code></p>\n<pre><code class=\"scss\">p &#123;\n    color: if(1 + 1 = 2, green, yellow);\n&#125;\n\n// compile:\np&#123;\n    color: green;&#125;\n</code></pre>\n<h3 id=\"2-if\"><a href=\"#2-if\" class=\"headerlink\" title=\"2.@if\"></a>2.<code>@if</code></h3><p><em>条件语句</em></p>\n<p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码</p>\n<p><code>@if</code> 声明后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明。如果 <code>@if</code> 声明失败，Sass 将逐条执行 <code>@else if</code> 声明，如果全部失败，最后执行 <code>@else</code> 声明</p>\n<ul>\n<li><p><code>单@if</code></p>\n<pre><code class=\"scss\">  p &#123;\n      @if 1 + 1 == 2 &#123;\n          color: red;\n      &#125;\n  &#125;\n\n  // compile:\n  p &#123;\n    color: red;\n  &#125;\n</code></pre>\n</li>\n<li><p><code>@if - @else</code></p>\n<pre><code class=\"scss\">p &#123;\n    @if 1 + 1 != 2 &#123;\n        color: red;\n    &#125; @else &#123;\n        color: blue;\n    &#125;\n&#125;\n\n// compile:\np &#123;\n  color: blue;\n&#125;\n</code></pre>\n</li>\n<li><p><code>@if - @else if - @else</code></p>\n<pre><code class=\"scss\">$age: 19;\n\np &#123;\n    @if $age == 18 &#123;\n        color: red;\n    &#125; @else if $age == 19 &#123;\n        color: blue;\n    &#125; @else &#123;\n        color: green;\n    &#125;\n&#125;\n\n// compile:\np &#123;\n  color: blue;\n&#125;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-for\"><a href=\"#3-for\" class=\"headerlink\" title=\"3.@for\"></a>3.<code>@for</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 或 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code></p>\n<p>through 和 to 的相同点与不同点：</p>\n<ul>\n<li>相同点：两者均包含<start>的值</li>\n<li>不同点：through包含<end>的值，但to不包含<end>的值</li>\n</ul>\n<pre><code class=\"scss\">@for $i from 1 through 3 &#123;\n  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;\n&#125;\n\n// compile:\n.item-1 &#123;\n  width: 2em; &#125;\n.item-2 &#123;\n  width: 4em; &#125;\n.item-3 &#123;\n  width: 6em; &#125;\n</code></pre>\n<h3 id=\"4-while\"><a href=\"#4-while\" class=\"headerlink\" title=\"4.@while\"></a>4.<code>@while</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>@while expression</code></p>\n<p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code> 更复杂的循环，只是很少会用到</p>\n<pre><code class=\"scss\">$i: 6;\n@while $i &gt; 0 &#123;\n  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;\n  $i: $i - 2;\n&#125;\n\n// compile:\n.item-6 &#123;\n  width: 12em; &#125;\n.item-4 &#123;\n  width: 8em; &#125;\n.item-2 &#123;\n  width: 4em; &#125;\n</code></pre>\n<h3 id=\"5-each\"><a href=\"#5-each\" class=\"headerlink\" title=\"5.@each\"></a>5.<code>@each</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>$var in $vars</code></p>\n<p><code>$var</code> 可以是任何变量名</p>\n<p><code>$vars</code> 只能是<code>Lists</code>或者<code>Maps</code></p>\n<ul>\n<li><p>一维列表</p>\n<pre><code class=\"scss\">@each $animal in puma, sea-slug, egret, salamander &#123;\n  .#&#123;$animal&#125;-icon &#123;\n    background-image: url(&#39;/images/#&#123;$animal&#125;.png&#39;);\n  &#125;\n&#125;\n\n// compile:\n.puma-icon &#123;\n  background-image: url(&#39;/images/puma.png&#39;); &#125;\n.sea-slug-icon &#123;\n  background-image: url(&#39;/images/sea-slug.png&#39;); &#125;\n.egret-icon &#123;\n  background-image: url(&#39;/images/egret.png&#39;); &#125;\n.salamander-icon &#123;\n  background-image: url(&#39;/images/salamander.png&#39;); &#125;\n</code></pre>\n</li>\n<li><p>二维列表</p>\n<pre><code class=\"scss\">@each $animal, $color, $cursor in (puma, black, default),\n                                  (sea-slug, blue, pointer),\n                                  (egret, white, move) &#123;\n  .#&#123;$animal&#125;-icon &#123;\n    background-image: url(&#39;/images/#&#123;$animal&#125;.png&#39;);\n    border: 2px solid $color;\n    cursor: $cursor;\n  &#125;\n&#125;\n\n// compile:\n.puma-icon &#123;\n  background-image: url(&#39;/images/puma.png&#39;);\n  border: 2px solid black;\n  cursor: default; &#125;\n.sea-slug-icon &#123;\n  background-image: url(&#39;/images/sea-slug.png&#39;);\n  border: 2px solid blue;\n  cursor: pointer; &#125;\n.egret-icon &#123;\n  background-image: url(&#39;/images/egret.png&#39;);\n  border: 2px solid white;\n  cursor: move; &#125;\n</code></pre>\n</li>\n<li><p>maps</p>\n<pre><code class=\"scss\">@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123;\n  #&#123;$header&#125; &#123;\n    font-size: $size;\n  &#125;\n&#125;\n\n// compile:\nh1 &#123;\n  font-size: 2em; &#125;\nh2 &#123;\n  font-size: 1.5em; &#125;\nh3 &#123;\n  font-size: 1.2em; &#125;\n</code></pre>\n</li>\n</ul>\n<hr>\n<h4 id=\"九、混合指令\"><a href=\"#九、混合指令\" class=\"headerlink\" title=\"九、混合指令\"></a>九、混合指令</h4><blockquote>\n<p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left</code>。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p>\n</blockquote>\n<p>注意：这不是函数！没有返回值！！</p>\n<h3 id=\"1-定义混合指令\"><a href=\"#1-定义混合指令\" class=\"headerlink\" title=\"1.定义混合指令\"></a>1.定义混合指令</h3><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式，以及需要的参数（可选）。</p>\n<pre><code class=\"scss\">// 格式：\n@mixin name &#123;\n    // 样式....\n&#125;\n</code></pre>\n<pre><code class=\"scss\">// example：\n@mixin large-text &#123;\n  font: &#123;\n    family: Arial;\n    size: 20px;\n    weight: bold;\n  &#125;\n  color: #ff0000;\n&#125;\n</code></pre>\n<h3 id=\"2-引用混合样式\"><a href=\"#2-引用混合样式\" class=\"headerlink\" title=\"2.引用混合样式\"></a>2.引用混合样式</h3><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p>\n<pre><code class=\"scss\">// 格式：\n@include name;\n\n// 注：无参数或参数都有默认值时，带不带括号都可以\n</code></pre>\n<pre><code class=\"scss\">// example：\np &#123;\n    @include large-text;\n&#125;\n\n// compile:\np &#123;\n  font-family: Arial;\n  font-size: 20px;\n  font-weight: bold;\n  color: #ff0000;\n&#125;\n</code></pre>\n<h3 id=\"3-参数\"><a href=\"#3-参数\" class=\"headerlink\" title=\"3.参数\"></a>3.参数</h3><p>格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里</p>\n<p>支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参</p>\n<h4 id=\"a-位置传参\"><a href=\"#a-位置传参\" class=\"headerlink\" title=\"a. 位置传参\"></a>a. 位置传参</h4><pre><code class=\"scss\">@mixin mp($width) &#123;\n    margin: $width;\n&#125;\n\nbody &#123;\n    @include mp(300px);\n&#125;\n</code></pre>\n<h4 id=\"b-关键词传参\"><a href=\"#b-关键词传参\" class=\"headerlink\" title=\"b.关键词传参\"></a>b.关键词传参</h4><pre><code class=\"scss\">@mixin mp($width) &#123;\n    margin: $width;\n&#125;\n\nbody &#123;\n    @include mp($width: 300px);\n&#125;\n</code></pre>\n<h4 id=\"c-参数默认值\"><a href=\"#c-参数默认值\" class=\"headerlink\" title=\"c.参数默认值\"></a>c.参数默认值</h4><pre><code class=\"scss\">@mixin mp($width: 500px) &#123;\n    margin: $width;\n&#125;\n\nbody &#123;\n    @include mp($width: 300px);\n    // or\n    @include mp(300px);\n&#125;\n</code></pre>\n<h4 id=\"d-不定参数\"><a href=\"#d-不定参数\" class=\"headerlink\" title=\"d.不定参数\"></a>d.不定参数</h4><blockquote>\n<p>官方：Variable Arguments</p>\n<p>译文：参数变量</p>\n<p>有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理</p>\n</blockquote>\n<pre><code class=\"scss\">@mixin mar($value...) &#123;\n    margin: $value;\n&#125;\n</code></pre>\n<h3 id=\"4-向混合样式中导入内容\"><a href=\"#4-向混合样式中导入内容\" class=\"headerlink\" title=\"4.向混合样式中导入内容\"></a>4.向混合样式中导入内容</h3><p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 <code>@content</code> 标志的地方</p>\n<p>可以看作参数的升级版</p>\n<pre><code class=\"scss\">@mixin example &#123;\n    html &#123;\n        @content;\n    &#125;\n&#125;\n@include example&#123;\n    background-color: red;\n    .logo &#123;\n        width: 600px;\n    &#125;\n&#125;\n\n// compile:\nhtml &#123;\n  background-color: red;\n&#125;\n\nhtml .logo &#123;\n  width: 600px;\n&#125;\n</code></pre>\n<h3 id=\"5-混合指令用例\"><a href=\"#5-混合指令用例\" class=\"headerlink\" title=\"5.混合指令用例\"></a>5.混合指令用例</h3><blockquote>\n<p><img data-src=\"/A_SassScript%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%E7%94%A8%E4%BE%8B.png\" alt=\"混合指令用例\"></p>\n</blockquote>\n<hr>\n<h4 id=\"十、函数指令\"><a href=\"#十、函数指令\" class=\"headerlink\" title=\"十、函数指令\"></a>十、函数指令</h4><h3 id=\"1-内置函数\"><a href=\"#1-内置函数\" class=\"headerlink\" title=\"1.内置函数\"></a>1.内置函数</h3><h4 id=\"a-字符串函数\"><a href=\"#a-字符串函数\" class=\"headerlink\" title=\"a. 字符串函数\"></a>a. 字符串函数</h4><blockquote>\n<p>索引第一个为1，最后一个为-1；切片两边均为闭区间</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">quote($string)</td>\n<td align=\"center\">添加引号</td>\n</tr>\n<tr>\n<td align=\"left\">unquote($string)</td>\n<td align=\"center\">除去引号</td>\n</tr>\n<tr>\n<td align=\"left\">to-lower-case($string)</td>\n<td align=\"center\">变为小写</td>\n</tr>\n<tr>\n<td align=\"left\">to-upper-case($string)</td>\n<td align=\"center\">变为大写</td>\n</tr>\n<tr>\n<td align=\"left\">str-length($string)</td>\n<td align=\"center\">返回$string的长度(汉字算一个)</td>\n</tr>\n<tr>\n<td align=\"left\">str-index($string，$substring)</td>\n<td align=\"center\">返回$substring在$string的位置</td>\n</tr>\n<tr>\n<td align=\"left\">str-insert($string, $insert, $index)</td>\n<td align=\"center\">在$string的$index处插入$insert</td>\n</tr>\n<tr>\n<td align=\"left\">str-slice($string, $start-at, $end-at）</td>\n<td align=\"center\">截取$string的$start-at和$end-at之间的字符串</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-数字函数\"><a href=\"#b-数字函数\" class=\"headerlink\" title=\"b. 数字函数\"></a>b. 数字函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>percentage($number)</td>\n<td align=\"center\">转换为百分比形式</td>\n</tr>\n<tr>\n<td>round($number)</td>\n<td align=\"center\">四舍五入为整数</td>\n</tr>\n<tr>\n<td>ceil($number)</td>\n<td align=\"center\">数值向上取整</td>\n</tr>\n<tr>\n<td>floor($number)</td>\n<td align=\"center\">数值向下取整</td>\n</tr>\n<tr>\n<td>abs($number)</td>\n<td align=\"center\">获取绝对值</td>\n</tr>\n<tr>\n<td>min($number…)</td>\n<td align=\"center\">获取最小值</td>\n</tr>\n<tr>\n<td>max($number…)</td>\n<td align=\"center\">获取最大值</td>\n</tr>\n<tr>\n<td>random($number?:number)</td>\n<td align=\"center\">不传入值：获得0-1的随机数；传入正整数n：获得0-n的随机整数（左开右闭）</td>\n</tr>\n</tbody></table>\n<h4 id=\"c-数组函数\"><a href=\"#c-数组函数\" class=\"headerlink\" title=\"c. 数组函数\"></a>c. 数组函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>length($list)</td>\n<td align=\"center\">获取数组长度</td>\n</tr>\n<tr>\n<td>nth($list, n)</td>\n<td align=\"center\">获取指定下标的元素</td>\n</tr>\n<tr>\n<td>set-nth($list, $n, $value)</td>\n<td align=\"center\">向$list的$n处插入$value</td>\n</tr>\n<tr>\n<td>join($list1, $list2, $separator)</td>\n<td align=\"center\">拼接$list1和list2；$separator为新list的分隔符，默认为auto，可选择comma、space</td>\n</tr>\n<tr>\n<td>append($list, $val, $separator)</td>\n<td align=\"center\">向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space</td>\n</tr>\n<tr>\n<td>index($list, $value)</td>\n<td align=\"center\">返回$value值在$list中的索引值</td>\n</tr>\n<tr>\n<td>zip($lists…)</td>\n<td align=\"center\">将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的</td>\n</tr>\n</tbody></table>\n<h4 id=\"d-映射函数\"><a href=\"#d-映射函数\" class=\"headerlink\" title=\"d. 映射函数\"></a>d. 映射函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>map-get($map, $key)</td>\n<td align=\"center\">获取$map中$key对应的$value</td>\n</tr>\n<tr>\n<td>map-merge($map1, $map2)</td>\n<td align=\"center\">合并$map1和$map2，返回一个新$map</td>\n</tr>\n<tr>\n<td>map-remove($map, $key)</td>\n<td align=\"center\">从$map中删除$key，返回一个新$map</td>\n</tr>\n<tr>\n<td>map-keys($map)</td>\n<td align=\"center\">返回$map所有的$key</td>\n</tr>\n<tr>\n<td>map-values($map)</td>\n<td align=\"center\">返回$map所有的$value</td>\n</tr>\n<tr>\n<td>map-has-key($map, $key)</td>\n<td align=\"center\">判断$map中是否存在$key，返回对应的布尔值</td>\n</tr>\n<tr>\n<td>keywords($args)</td>\n<td align=\"center\">返回一个函数的参数，并可以动态修改其值</td>\n</tr>\n</tbody></table>\n<h4 id=\"e-颜色函数\"><a href=\"#e-颜色函数\" class=\"headerlink\" title=\"e. 颜色函数\"></a>e. 颜色函数</h4><ul>\n<li><p><strong>RGB函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rgb($red, $green, $blue)</td>\n<td align=\"center\">返回一个16进制颜色值</td>\n</tr>\n<tr>\n<td>rgba($red,$green,$blue,$alpha)</td>\n<td align=\"center\">返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入</td>\n</tr>\n<tr>\n<td>red($color)</td>\n<td align=\"center\">从$color中获取其中红色值</td>\n</tr>\n<tr>\n<td>green($color)</td>\n<td align=\"center\">从$color中获取其中绿色值</td>\n</tr>\n<tr>\n<td>blue($color)</td>\n<td align=\"center\">从$color中获取其中蓝色值</td>\n</tr>\n<tr>\n<td>mix($color1,$color2,$weight?)</td>\n<td align=\"center\">按照$weight比例，将$color1和$color2混合为一个新颜色</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>HSL函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th>函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hsl($hue,$saturation,$lightness)</td>\n<td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td>\n</tr>\n<tr>\n<td>hsla($hue,$saturation,$lightness,$alpha)</td>\n<td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td>\n</tr>\n<tr>\n<td>saturation($color)</td>\n<td>从一个颜色中获取饱和度（saturation）值</td>\n</tr>\n<tr>\n<td>lightness($color)</td>\n<td>从一个颜色中获取亮度（lightness）值</td>\n</tr>\n<tr>\n<td>adjust-hue($color,$degrees)</td>\n<td>通过改变一个颜色的色相值，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>lighten($color,$amount)</td>\n<td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>darken($color,$amount)</td>\n<td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>hue($color)</td>\n<td>从一个颜色中获取亮度色相（hue）值</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>Opacity函数</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>alpha($color)&#x2F;opacity($color)</td>\n<td>获取颜色透明度值</td>\n</tr>\n<tr>\n<td>rgba($color,$alpha)</td>\n<td>改变颜色的透明度</td>\n</tr>\n<tr>\n<td>opacify($color, $amount) &#x2F; fade-in($color, $amount)</td>\n<td>使颜色更不透明</td>\n</tr>\n<tr>\n<td>transparentize($color, $amount) &#x2F; fade-out($color, $amount)</td>\n<td>使颜色更加透明</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"f-Introspection函数\"><a href=\"#f-Introspection函数\" class=\"headerlink\" title=\"f. Introspection函数\"></a>f. Introspection函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type-of($value)</td>\n<td align=\"center\">返回$value的类型</td>\n</tr>\n<tr>\n<td>unit($number)</td>\n<td align=\"center\">返回$number的单位</td>\n</tr>\n<tr>\n<td>unitless($number)</td>\n<td align=\"center\">判断$number是否带单位，返回对应的布尔值</td>\n</tr>\n<tr>\n<td>comparable($number1, $number2)</td>\n<td align=\"center\">判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-自定义函数\"><a href=\"#2-自定义函数\" class=\"headerlink\" title=\"2.自定义函数\"></a>2.自定义函数</h3><blockquote>\n<p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用</p>\n<p>Params: 与Mixin一致</p>\n<p>支持返回值</p>\n</blockquote>\n<p><strong>基本格式：</strong></p>\n<pre><code class=\"scss\">@function fn-name($params...) &#123;\n    @return $params;\n&#125;\n</code></pre>\n<pre><code class=\"scss\">// example:\n@function fn-name($params...) &#123;\n    @return nth($params, 1);\n&#125;\np &#123;\n    height: fn-name(1px);\n&#125;\n\n// compiled:\np &#123;\n  height: 1px;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"十一、-extend、-Mixin和-function的选择\"><a href=\"#十一、-extend、-Mixin和-function的选择\" class=\"headerlink\" title=\"十一、@extend、@Mixin和@function的选择\"></a>十一、@extend、@Mixin和@function的选择</h4><blockquote>\n<p>本部分来自csswizardry的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jc3N3aXphcmRyeS5jb20vMjAxNi8wMi9taXhpbnMtYmV0dGVyLWZvci1wZXJmb3JtYW5jZS8=\">原文链接</span></p>\n</blockquote>\n<h3 id=\"1、为何有这个问题\"><a href=\"#1、为何有这个问题\" class=\"headerlink\" title=\"1、为何有这个问题\"></a>1、为何有这个问题</h3><blockquote>\n<p>当谈到预处理器时，我被问到的最常见的问题之一是 Mixins 或<code>@extend</code>? 关于这个话题，我坚信你应该避免<code>@extend</code>的一些原因：</p>\n<ol>\n<li>它改变了你的源顺序，这在 CSS 中总是有风险的。</li>\n<li>它会在您的代码中创建笨拙的分组，将不相关的选择器放在一起。</li>\n<li>它非常贪婪，<code>@extend</code>对给定主题的每个实例进行处理，而不仅仅是您真正想要的那个。</li>\n<li>它<span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9kcm9vYi9zdGF0dXMvNTYxMTYxNzgzMjM5Mzg5MTg1\">真的会失控</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9nYWVsbWV0YWlzL3N0YXR1cy81NjQxMDk3NzU5OTU0MzcwNTc=\">真的很快</span>。</li>\n</ol>\n<p><code>@extend</code> 现在被广泛认为是一种反模式，所以它的使用正在逐渐消失，但我们还没有完全到那里。</p>\n<p>昨天我正在与一个客户进行研讨会，并被问及 mixin 与 <code>@extend</code>情况，对此我给出了我通常的回答“永远不要使用” <code>@extend</code>！，作为回报，我被问到但是<code>@extend</code>性能不是更好吗？它生成的代码更少。</p>\n<p>确实<code>@extend</code>（如果使用得当）会产生更少的 CSS，但我的回答是坚决不：<strong>mixin 对性能更好</strong>。</p>\n<p>尽管实际上从未做过任何测试，但我还是很有信心地回答了这个问题。我有信心的原因是我有一个非常可靠的理论：</p>\n<p><strong>因为 gzip 有利于重复，所以如果我们共享完全相同的声明，比如 1000 次，肯定会比我们共享 1000 个独特的类两次获得更好的压缩率。</strong></p>\n<p>你看，当人们谈论 mixin 的性能时，他们通常会考虑文件系统上的文件大小。但是因为我们启用了 gzip（您 <em>确实</em>启用了 gzip，对吧？），我们应该考虑<em>网络上的</em>文件大小</p>\n</blockquote>\n<h3 id=\"2、操作实践\"><a href=\"#2、操作实践\" class=\"headerlink\" title=\"2、操作实践\"></a>2、操作实践</h3><blockquote>\n<ol>\n<li><p>我创建了两个 CSS 文件。</p>\n</li>\n<li><p>每个文件都有 1000 个独特的类，使用 Sass 生成：</p>\n</li>\n</ol>\n<pre><code class=\"scss\">@for $i from 1 through 1000 &#123;\n  .#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;\n    ...\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>我给了每个类一个唯一的声明，通过使用父选择器简单地重复使用形成名称本身的相同随机字符串，并且我在其两侧放置了一些无意义的字符串：</li>\n</ol>\n<pre><code class=\"scss\">@for $i from 1 through 1000 &#123;\n  .#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;\n    content: &quot;ibf#&#123;&amp;&#125;jaslbw&quot;;\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>然后我选择了三个简单的声明，它们在所有 1000 个类中都保持不变：</li>\n</ol>\n<pre><code class=\"scss\">color: red;\nfont-weight: bold;\nline-height: 2;\n</code></pre>\n<ol start=\"5\">\n<li>在一个文件中，我通过 mixin 共享了这些声明：</li>\n</ol>\n<pre><code class=\"scss\">@mixin foo &#123;\n  color: red;\n  font-weight: bold;\n  line-height: 2;\n&#125;\n\n.#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;\n  @include foo;\n  content: &quot;ibf#&#123;&amp;&#125;jaslbw&quot;;\n&#125;\n</code></pre>\n<ol start=\"6\">\n<li>在另一个中，我通过<code>@extend</code>以下方式分享了它们：</li>\n</ol>\n<pre><code class=\"scss\">%foo &#123;\n  color: red;\n  font-weight: bold;\n  line-height: 2;\n&#125;\n\n.#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;\n  @extend %foo;\n  content: &quot;ibf#&#123;&amp;&#125;jaslbw&quot;;\n&#125;\n</code></pre>\n<p>所有这些测试文件（以及更多）都可以<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nzc3dpemFyZHJ5L2V4dGVuZC12cy1taXhpbg==\">在 GitHub 上找到</span>。</p>\n<p>这给我留下了两个由完全独特的类和 1000 个独特声明组成的文件，以及以两种不同方式共享的三个相同声明。</p>\n<p>这些文件大小丝毫不会让您感到惊讶：</p>\n<ul>\n<li><code>mixin.css</code>进来<strong>108K</strong>。</li>\n<li><code>extend.css</code>进来<strong>72K</strong>。</li>\n<li>这导致文件大小的差异为<strong>36K</strong>。</li>\n<li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li>\n</ul>\n<p>这正是我所期待的，混入<em>不</em>产生更多的CSS比<code>@extend</code> 呢。</p>\n<p>但！我们必须记住，我们不应该担心文件系统上的文件大小——我们只关心我们的 gzip 文件的大小。</p>\n<p>我缩小并压缩了这两个文件并得到了我预期的结果：</p>\n<ul>\n<li><code>mixin.css</code>进来<strong>12K</strong>。</li>\n<li><code>extend.css</code>进来<strong>18K</strong>。</li>\n<li>这导致文件大小的差异为<strong>6K</strong>。</li>\n<li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li>\n</ul>\n<p>惊人！我们已经从 mixin 比 using 大 1.5 倍<code>@extend</code>，到 mixin比 using<strong>小 0.3 倍</strong><code>@extend</code>。我的理论似乎是正确的！</p>\n</blockquote>\n<h3 id=\"3、让事情更现实\"><a href=\"#3、让事情更现实\" class=\"headerlink\" title=\"3、让事情更现实\"></a>3、让事情更现实</h3><blockquote>\n<p>我确实觉得测试文件很公平——为类名创建唯一的字符串是为了阻碍压缩，这样我们就可以更准确地测试 gzip 对我们实际主题的影响：共享声明。</p>\n<p>也就是说，测试文件非常不切实际，所以我决定让事情变得更合理一些。</p>\n<p>我从现有项目中获取编译好的 CSS，制作了两份副本，并将我的<code>@import</code>每个测试文件分别放入每个项目中。这意味着我的测试文件被大约 1794 行真实的 CSS 包围着。</p>\n<p>我编译了每个新的测试文件，结果如下：</p>\n<ul>\n<li><code>mixin.css</code>进来<strong>16K</strong>。</li>\n<li><code>extend.css</code>进来了<strong>22K</strong>。</li>\n<li>这导致文件大小的差异为<strong>6K</strong>。</li>\n<li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li>\n</ul>\n<p>绝对数字似乎微不足道（仅 6K），但相对而言，我们可以通过选择使用 mixin 一遍又一遍地重复声明，而不是使用<code>@extend</code>重复少数选择器来实现 27% 的网络节省。</p>\n</blockquote>\n<h3 id=\"4、总结\"><a href=\"#4、总结\" class=\"headerlink\" title=\"4、总结\"></a>4、总结</h3><p><strong>所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上</strong></p>\n<blockquote>\n<p>定义方式不同： <code>@function</code> 需要调用<code>@return</code>输出结果。而 @mixin则不需要。</p>\n<p>使用方式不同：<code>@mixin</code> 使用<code>@include</code>引用，而 <code>@function</code> 使用小括号执行函数。</p>\n</blockquote>\n<h4 id=\"十二、项目中实战\"><a href=\"#十二、项目中实战\" class=\"headerlink\" title=\"十二、项目中实战\"></a>十二、项目中实战</h4><h3 id=\"Ⅰ-Scss混入\"><a href=\"#Ⅰ-Scss混入\" class=\"headerlink\" title=\"Ⅰ-Scss混入\"></a>Ⅰ-Scss混入</h3><blockquote>\n<p>在工作中提出的对于同事代码的优化–&gt;使用<code>sass混合指令知识</code>,方便后期维护</p>\n<p><img data-src=\"/A_SassScript%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%E7%94%A8%E4%BE%8B.png\" alt=\"混合指令用例\"></p>\n</blockquote>\n","categories":["Sass"],"tags":["Sass"]},{"title":"Travis和Docker的持续集成","url":"/2023/12/02/Travis%20CI%E5%92%8CDocker%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/","content":"<h2 id=\"所使用的基础组件\"><a href=\"#所使用的基础组件\" class=\"headerlink\" title=\"所使用的基础组件\"></a>所使用的基础组件</h2><p>代码托管在Github上，使用github集成的Travis CI自动触发CI流程。在CI中自动build新的image上传到Docker Hub。然后通过sshpass远程登录server触发部署脚本。部署脚本pull新的image然后部署。</p>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><p>由于项目都是基于python的，所以dockerfile比较简单：</p>\n<pre><code>FROM ubuntu:latest\nMAINTAINER Shaobo Liu &lt;shaobo@mkdef.com&gt;\nLABEL Description=&quot;This image is used to flask-kraken&quot;\nRUN apt-get update -y\nRUN apt-get install -y python3-pip python3-dev build-essential\nCOPY src /app\nCOPY requirements.txt /app\nWORKDIR /app\nRUN pip3 install -r requirements.txt\nENTRYPOINT [&quot;python3&quot;]\nCMD [&quot;app.py&quot;]\n</code></pre>\n<p>分解一下：</p>\n<pre><code>FROM ubuntu:latest\nMAINTAINER Shaobo Liu &lt;shaobo@mkdef.com&gt;\nLABEL Description=&quot;This image is used to flask-kraken&quot;\n</code></pre>\n<p>首先申明使用的基础镜像，然后写上大名表示我是维护这个镜像的作者和这个镜像的用途。</p>\n<pre><code>RUN apt-get update -y\nRUN apt-get install -y python3-pip python3-dev build-essential\n</code></pre>\n<p>安装python3，如果有其他的工具或者lib，也要写在这里。</p>\n<pre><code>COPY src /app\nCOPY requirements.txt /app\nWORKDIR /app\nRUN pip3 install -r requirements.txt\n</code></pre>\n<p>复制源代码到docker里，然后切换工作目录，安装三方依赖。 有时候这里需要安装一些系统级的依赖，比如lxml或者psycopg2之类的，就需要加到前面<code>apt-get install</code>里去。</p>\n<pre><code>ENTRYPOINT [&quot;python3&quot;]\nCMD [&quot;app.py&quot;]\n</code></pre>\n<p>最后是需要执行的命令。根据docker的userguide，一个image最好只干一件事。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><p>在项目根目录添加<code>.travis.yml</code>来定义CI流程</p>\n<pre><code>sudo: required\n\nlanguage: python\n\nservices:\n  - docker\n\npython:\n    - &quot;3.5&quot;\n\nbefore_install:\n  - sudo apt-get update\n  - sudo apt-get install sshpass\n\ninstall: &quot;pip install -r requirements.txt&quot;\n\nscript: \n  - python --version\n\nafter_success:\n  - docker login -u=&quot;$DOCKER_USERNAME&quot; -p=&quot;$DOCKER_PASSWORD&quot;\n  - docker build -t shaobol/kraken:$TRAVIS_BRANCH-$TRAVIS_BUILD_ID . \n  - docker push shaobol/kraken:$TRAVIS_BRANCH-$TRAVIS_BUILD_ID;\n  - sshpass -p $VPS_PASSWORD ssh -o stricthostkeychecking=no root@45.32.137.234 &quot;sudo /home/saukymo/kraken/deploy.sh $TRAVIS_BRANCH-$TRAVIS_BUILD_ID&quot;\n</code></pre>\n<p>这里就不一一分解了，具体可以参考Travis的官方文档。</p>\n<p>主要介绍一下这个部分和其他部分是怎么联动的。首先Travis和Github是有集成服务的，在<code>Setting -&gt; integrations &amp; services</code>里选择添加Travis就可以了。然后在Travis上就可以设置相应的CI流程了，默认是master有新的commit就会自动触发一次CI。</p>\n<p>每次CI结束后的结果可以通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmF2aXMtY2kub3JnL3NhdWt5bW8vb2Rlcy5zdmc/YnJhbmNoPW1hc3Rlcg==\">badge</span>查看。</p>\n<p>重点在于测试完成后build和push docker image的过程</p>\n<pre><code>after_success:\n  - docker login -u=&quot;$DOCKER_USERNAME&quot; -p=&quot;$DOCKER_PASSWORD&quot;\n  - docker build -t shaobol/kraken:$TRAVIS_BRANCH-$TRAVIS_BUILD_ID . \n  - docker push shaobol/kraken:$TRAVIS_BRANCH-$TRAVIS_BUILD_ID;\n</code></pre>\n<p>敏感信息这里全部通过Travis的Environment Variables。这样可以避免因为公开而泄露。</p>\n<p>如果需要将一些敏感信息传递到image里面去，可以通过<code>--build-arg</code>参数传递进去，然后保存为环境变量，参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9idWlsZGVyLyNsYWJlbA==\">reference</span></p>\n<p>最后通过<code>sshpass</code>执行部署脚本，这一步也可以使用<code>ansible</code>代替。</p>\n<h2 id=\"docker-部署脚本\"><a href=\"#docker-部署脚本\" class=\"headerlink\" title=\"docker 部署脚本\"></a>docker 部署脚本</h2><pre><code>#!/bin/bash\n\ndocker pull shaobol/odes:$1\n\nif docker ps -a | grep -q odes; then\n    docker rm -f odes\nfi\n\ndocker run -d --name odes -p 9000:9000 --link postgres:postgres shaobol/odes:$1\n</code></pre>\n<p>脚本很简单，接收CI传过来的参数(image tag)，pull新的image，然后干掉之前的container，run一个新的。这样就完成了update整个过程。</p>\n","categories":["Travis和Docker"],"tags":["Travis","Docker"]},{"title":"ajax","url":"/2023/01/08/ajax/","content":"<h1 id=\"HTTP协议请求报文、响应\"><a href=\"#HTTP协议请求报文、响应\" class=\"headerlink\" title=\"HTTP协议请求报文、响应\"></a>HTTP协议请求报文、响应</h1><p>一个HTTP请求报文可以由请求行、请求头、空行和请求体4个部分组成。<br>一个HTTP响应报文是由响应行、响应头、空行和响应体4个部分组成。<br>（报文(message)是网络中交换与传输的数据单元）</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzMyODQwMzU=\">https://zhuanlan.zhihu.com/p/533284035</span>  （超详细的HTTP协议请求报文、响应报文教程）</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h1><h2 id=\"什么是json\"><a href=\"#什么是json\" class=\"headerlink\" title=\"什么是json\"></a>什么是json</h2><p> JSON是一种轻量级的数据交互格式。可以按照JSON指定的格式去组织和封装数据</p>\n<p>JSON本质上是一个带有特定格式的字符串</p>\n<p>主要功能：json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互. 类似于：<br>国际通用语言-英语<br>中国56个民族不同地区的通用语言-普通话</p>\n<h2 id=\"json有什么用\"><a href=\"#json有什么用\" class=\"headerlink\" title=\"json有什么用\"></a>json有什么用</h2><p>各种编程语言存储数据的容器不尽相同,在Python中有字典dict这样的数据类型, 而其它语言可能没有对应的字典。<br>为了让不同的语言都能够相互通用的互相传递数据，JSON就是一种非常良好的中转数据格式。</p>\n<h2 id=\"json格式数据转化\"><a href=\"#json格式数据转化\" class=\"headerlink\" title=\"json格式数据转化\"></a>json格式数据转化</h2><pre><code class=\"json\"># json数据的格式可以是： \n&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125;  是&#123;&#125;括起来的键值对\n# 也可以是：  \n[&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;root&quot;,&quot;age&quot;:16&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:20&#125;] \n是[]括起来的元素\n可以嵌套\n</code></pre>\n<pre><code class=\"java\">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;2.0.39&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Java中：java转json字符串</p>\n<pre><code class=\"java\">String jsonStr = JSON.toJSONString(objs);\n</code></pre>\n<p>JS中：json字符串转JavaScript对象</p>\n<pre><code class=\"java\">  JSON.parse(this.responseText)\n</code></pre>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a>Ajax</h1><p>Ajax（Asynchronous JavaScript And XML）即异步 JavaScript 和 XML，是一组用于在网页上进行异步数据交换的Web开发技术，可以在不刷新整个页面的情况下向服务器发起请求并获取数据，然后将数据插入到网页中的某个位置。这种技术能够实现增量式更新页面，提高用户交互体验，减少响应时间和带宽的消耗。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>提升用户体验（通过减少页面的重载和刷新，使得网站变得更加灵活和的动态）</li>\n<li>减轻服务器压力（通过Ajax可以有效减少服务器接收到的请求次数和需要响应的数据量）</li>\n<li>提高响应速度（异步获得数据并更新页面）</li>\n<li>增加交互性（页面变得动态性和交互性）</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>Ajax对SEO（搜索引擎优化不友好）</li>\n<li>使用Ajax时，需要考虑数据安全性和网络安全性，并采取相应的措施防范</li>\n</ul>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a>XMLHttpRequest</h1><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>使用 <code>XMLHttpRequest</code> 可以通过 JavaScript 发起HTTP请求，接收来自服务器的响应，并动态地更新网页中的内容。这种异步通信方式不会阻塞用户界面，有利于增强用户体验。</p>\n<pre><code class=\"js\">// 发送get请求\nconst xhr = new XMLHttpRequest();\nxhr.open(&#39;GET&#39;, &#39;http://localhost:3000/api/txt&#39;)\nxhr.onload = function() &#123;\n  if (xhr.status === 200) &#123;\n        document.querySelector(&#39;#result&#39;).innerText = xhr.responseText;\n    &#125;\n    else &#123;\n       console.log(&#39;Request failed.  Returned status of &#39; + xhr.status);\n   &#125;\n&#125;;\nxhr.send(null);\n// 发送post请求\nconst xhr = new XMLHttpRequest();\nxhr.open(&#39;POST&#39;, &#39;http://localhost:3000/api/post&#39;)\nxhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);\nxhr.onload = function() &#123;\n  if (xhr.status === 200) &#123;\n        document.querySelector(&#39;#result&#39;).innerText = xhr.responseText;\n    &#125;\n    else &#123;\n       console.log(&#39;Request failed.  Returned status of &#39; + xhr.status);\n   &#125;\n&#125;;\nxhr.send(JSON.stringify(&#123;name: &#39;zhangsan&#39;, age: 18&#125;));\n</code></pre>\n<h3 id=\"中断请求\"><a href=\"#中断请求\" class=\"headerlink\" title=\"中断请求\"></a>中断请求</h3><p>xhr通过addEventListener事件监听的机制来进行请求的中断和超时处理。</p>\n<pre><code class=\"js\">xhr.addEventListener(&#39;abort&#39;, function (event) &#123;\n    console.log(&#39;我被中断了&#39;);\n&#125;);\n</code></pre>\n<h3 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h3><pre><code class=\"js\">xhr.addEventListener(&#39;timeout&#39;, function (event) &#123;\n     console.log(&#39;超时啦&#39;);\n&#125;);\n</code></pre>\n<h3 id=\"监听进度\"><a href=\"#监听进度\" class=\"headerlink\" title=\"监听进度\"></a>监听进度</h3><p>xhr中的监听进度可以获得全过程的进行进度，这是fetch这个api所没有的</p>\n<pre><code class=\"js\">xhr.addEventListener(&#39;progress&#39;, function (event) &#123;\ndocument.querySelector(&#39;#progress&#39;).innerText = `$&#123;(event.loaded / event.total * 100).toFixed(2)&#125;%`;\n&#125;);\n</code></pre>\n<h1 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h1><h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p><strong>fetch返回格式：</strong></p>\n<ul>\n<li><p>text(): 将响应体解析为纯文本字符串并返回。</p>\n</li>\n<li><p>json(): 将响应体解析为JSON格式并返回一个JavaScript对象。</p>\n</li>\n<li><p>blob(): 将响应体解析为二进制数据并返回一个Blob对象。</p>\n</li>\n<li><p>arrayBuffer(): 将响应体解析为二进制数据并返回一个ArrayBuffer对象。</p>\n</li>\n<li><p>formData(): 将响应体解析为FormData对象。</p>\n</li>\n</ul>\n<pre><code class=\"js\">// get请求\nfetch(&#39;http://localhost:3000/api/txt&#39;).then(res =&gt; &#123;\n    console.log(res);\n    return res.text()\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n&#125;)\n// post请求\nfetch(&#39;http://localhost:3000/api/post&#39;,&#123;\n    method:&#39;POST&#39;,\n    headers:&#123;\n        &#39;Content-Type&#39;:&#39;application/json&#39;\n    &#125;,\n    body:JSON.stringify(&#123;\n        name:&#39;zhangsan&#39;,\n        age:18\n    &#125;)\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n    return res.json()\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n&#125;)\n</code></pre>\n<h3 id=\"中断请求-1\"><a href=\"#中断请求-1\" class=\"headerlink\" title=\"中断请求\"></a>中断请求</h3><p>使用 <code>AbortController</code> 的 <code>abort</code>方法中断</p>\n<pre><code class=\"js\">const abort = new AbortController()\nfetch(&#39;http://localhost:3000/api/post&#39;,&#123;\n    method:&#39;POST&#39;,\n    headers:&#123;\n        &#39;Content-Type&#39;:&#39;application/json&#39;\n    &#125;,\n    signal:abort.signal,\n    body:JSON.stringify(&#123;\n        name:&#39;zhangsan&#39;,\n        age:18\n    &#125;)\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n    return res.json()\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n&#125;)\n\ndocument.querySelector(&#39;#stop&#39;).addEventListener(&#39;click&#39;, () =&gt; &#123;\n        console.log(&#39;stop&#39;);\n        abort.abort()\n&#125;)\n</code></pre>\n<h3 id=\"获取进度\"><a href=\"#获取进度\" class=\"headerlink\" title=\"获取进度\"></a>获取进度</h3><p>使用data.clone()方法复制了响应对象data，然后使用getReader()方法获取数据流中的reader对象，接着通过读取数据流并计算已加载字节数，实现了一个基于原生JavaScript的进度条功能。</p>\n<pre><code class=\"js\">const btn = document.querySelector(&#39;#send&#39;)\nconst sendFetch = async () =&gt; &#123;\n    const data = await fetch(&#39;http://localhost:3000/api/txt&#39;,&#123;\n        signal:abort.signal\n    &#125;)\n    //fetch 实现进度条\n    const response = data.clone()\n    const reader = data.body.getReader()\n    const contentLength = data.headers.get(&#39;Content-Length&#39;)\n    let loaded = 0\n    while (true) &#123;\n        const &#123; done, value &#125; = await reader.read()\n        if (done) &#123;\n            break\n        &#125;\n        loaded += value?.length || 0;\n        const progress = document.querySelector(&#39;#progress&#39;)\n        progress.innerHTML = (loaded / contentLength * 100).toFixed(2) + &#39;%&#39;\n    &#125;\n    const text = await response.text()\n    console.log(text);\n&#125;\nbtn.addEventListener(&#39;click&#39;, sendFetch)\n</code></pre>\n<h3 id=\"携带cookie\"><a href=\"#携带cookie\" class=\"headerlink\" title=\"携带cookie\"></a>携带cookie</h3><pre><code class=\"js\">const data = await fetch(&#39;http://localhost:3000/api/txt&#39;,&#123;\n    signal:abort.signal,\n    //cookie\n    credentials:&#39;include&#39;,\n&#125;)\n</code></pre>\n<h1 id=\"Fetch和XMLHTTPRequest对比\"><a href=\"#Fetch和XMLHTTPRequest对比\" class=\"headerlink\" title=\"Fetch和XMLHTTPRequest对比\"></a>Fetch和XMLHTTPRequest对比</h1><p><code>fetch</code> 和 <code>XMLHttpRequest</code>（XHR）都是前端与服务器进行数据交互的常用方式，它们各有优缺点，下面是它们的比较：</p>\n<ul>\n<li>API 设计和使用方式</li>\n</ul>\n<p><code>fetch</code> 的 API 设计更加现代化、简洁和易于使用，使用起来更加直观和方便。相比之下，XHR 的 API 设计比较繁琐，需要进行多个参数的配置和回调函数的处理。</p>\n<ul>\n<li>支持的请求方法</li>\n</ul>\n<p><code>fetch</code> API 默认只支持 GET 和 POST 请求方法，而 XHR 则支持所有标准的 HTTP 请求方法。</p>\n<ul>\n<li>请求头部</li>\n</ul>\n<p>在 <code>fetch</code> 中设置请求头部的方式更加清晰和直接，可以通过 <code>Headers</code> 对象进行设置，而 XHR 的方式相对较为繁琐。</p>\n<ul>\n<li>请求体</li>\n</ul>\n<p>在发送 POST 请求时，<code>fetch</code> API 要求将请求体数据作为参数传递给 <code>fetch</code> 方法中的 <code>options</code> 对象，而 XHR 可以直接在 <code>send()</code> 方法中设置请求体数据。</p>\n<ul>\n<li>支持的数据类型</li>\n</ul>\n<p>在解析响应数据时，<code>fetch</code> API 提供了多种方法，包括 <code>.json()</code>, <code>.blob()</code>, <code>.arrayBuffer()</code> 等，而 XHR 只支持文本和二进制数据两种数据类型。</p>\n<ul>\n<li>跨域请求</li>\n</ul>\n<p>在进行跨域请求时，<code>fetch</code> API 提供了一种简单而强大的解决方案——使用 CORS（跨域资源共享）头部实现跨域请求，而 XHR 则使用了一个叫做 <code>XMLHttpRequest Level 2</code> 的规范，在代码编写上相对较为繁琐。</p>\n<p>总的来说，<code>fetch</code> API 与 XHR 各有优缺点，具体选择哪种方式还需要根据具体情况进行考虑。平时开发中使用较多的是 <code>fetch</code> ，因为它使用方便、API 简洁、语法清晰，同时也支持了大多数常用的功能，可以有效地简化前端开发流程。</p>\n<h1 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h1><p>专注与网络请求的库<br>相比于原生的XMLHttpRequest对象，axios简单易用<br>相比与jQuery，axios更加轻量化，只专注与网络数据请求</p>\n<h2 id=\"axios发起GET请求：\"><a href=\"#axios发起GET请求：\" class=\"headerlink\" title=\"axios发起GET请求：\"></a><strong>axios发起GET请求：</strong></h2><pre><code class=\"javascript\">var url=&#39;&#39;\nvar paramsObj=&#123;name:&#39;zs&#39;,age:20&#125;\naxios.get(url,&#123;params:paramsObj&#125;)\n    .then(function(res)&#123;\n        console.log(res)\n        //res.data 服务器响应的数据\n        console.log(res.data)\n    &#125;)\n</code></pre>\n<h2 id=\"axios发起POST请求：\"><a href=\"#axios发起POST请求：\" class=\"headerlink\" title=\"axios发起POST请求：\"></a><strong>axios发起POST请求：</strong></h2><pre><code class=\"javascript\">var url=&#39;http://&#39;\nvar dataObj=&#123;location:&#39;Beijing&#39;,address:&#39;haidian&#39;&#125;\naxios.post(url,dataObj)\n    .then(function(res)&#123;\n        console.log(res)\n        //res.data 服务器响应的数据\n        console.log(res.data)\n    &#125;)\n</code></pre>\n<h2 id=\"直接使用axios发起请求：\"><a href=\"#直接使用axios发起请求：\" class=\"headerlink\" title=\"直接使用axios发起请求：\"></a><strong>直接使用axios发起请求：</strong></h2><p>axios页提供了类似于jQuery中的$.ajax()的函数，语法如下：</p>\n<pre><code class=\"javascript\">axios(&#123;\n    method:&#39;GET&#39;\n    url:&#39;&#39;\n    //GET参数要通过params属性提供\n    params:&#123;name:&#39;zs&#39;,age:20&#125;\n&#125;)\n    .then(function(res)&#123;\n        console.log(res.data)\n    &#125;)\n-------------------------------------\naxios(&#123;\n    method:&#39;POST&#39;\n    url:&#39;&#39;\n    //POST参数要通过data属性提供\n    data:&#123;bookname:&#39;thinking java&#39;,price:20&#125;\n&#125;)\n    .then(function(res)&#123;\n        console.log(res.data)\n    &#125;)\n</code></pre>\n<h1 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"navigator-sendBeacon\"><a href=\"#navigator-sendBeacon\" class=\"headerlink\" title=\"navigator.sendBeacon\"></a>navigator.sendBeacon</h1><pre><code class=\"js\">//性能中继器，使用不同指标来衡量和分析应用程序的性能\n//当页面上任何指标值完成计算时，将传递计算出的结果并触发这个函数\n//可以使用它将结果记录到控制台或者发送到特定端点\nfunction sendTo(metric)&#123;\n    const content = JSON.stringify(metric);\n    if(navigator.sendBeacon)&#123;\n        navigator.sendBeacon(&#39;http://test&#39;,content); //navigator.sendBeacon的作用是\n    &#125;else&#123;\n        fetch(&#39;http://test.com&#39;,&#123;\n        content,\n        method:&#39;POST&#39;,\n        keepAlive:true //fetch中的keepAlice保证了即使页面刷新或者关闭，发出的请求仍然存在并进行，而不是进行到一半的请求突然停止\n    &#125;).then(()=&gt;&#123;\n    console.log(&#39;发送成功&#39;);\n    &#125;).catch((e)=&gt;&#123;\n        console.error(e);\n    &#125;)\n    &#125;\n&#125;\nreportWebVitals(sendTo); //每一次得到计算结果都会执行一次\n</code></pre>\n<h3 id=\"对比-Ajax-fetch\"><a href=\"#对比-Ajax-fetch\" class=\"headerlink\" title=\"对比 Ajax fetch\"></a>对比 Ajax fetch</h3><h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li><strong>不受页面卸载过程的影响，确保数据可靠发送</strong>。</li>\n<li><strong>异步执行，不阻塞页面关闭或跳转</strong>。</li>\n<li><strong>能够发送跨域请求</strong>。</li>\n</ol>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ol>\n<li>fetch 和 ajax 都可以发送任意请求 而 sendBeacon <strong>只能发送POST</strong></li>\n<li>fetch 和 ajax 可以传输任意字节数据 而 <strong>sendBeacon 只能传送少量数据</strong>（64KB 以内）</li>\n<li>fetch 和 ajax 可以定义任意请求头 而  <strong>sendBeacon 无法自定义请求头</strong></li>\n<li>sendBeacon 只能传输 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>ArrayBufferView</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\"><code>Blob</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\"><code>DOMString</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\"><code>FormData</code></a> 或 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams\"><code>URLSearchParams</code></a> 类型的数据</li>\n<li><code>如果处于危险的网络环境，或者开启了广告屏蔽插件 此请求将无效</code></li>\n</ol>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ol>\n<li>发送心跳包：可以使用 <code>navigator.sendBeacon</code> 发送心跳包，以保持与服务器的长连接，避免因为长时间没有网络请求而导致连接被关闭。</li>\n<li>埋点：可以使用 <code>navigator.sendBeacon</code> 在页面关闭或卸载时记录用户在线时间，pv uv，以及错误日志上报 按钮点击次数。</li>\n<li>发送用户反馈：可以使用 <code>navigator.sendBeacon</code> 发送用户反馈信息，如用户意见、bug 报告等，以便进行产品优化和改进</li>\n</ol>\n","categories":["ajax"],"tags":["ajax"]},{"title":"esbuild","url":"/2024/05/17/esbuild/","content":"<p>关于打包工具：esbuild、webpack和rollup三者的介绍推荐<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjI0MDk4NDIyOTM5MjU0ODIx\">这里</span>：</p>\n<p>简单来说就是esbuild打包更快；rollup打包产物更纯净、体积更小，但不支持热更新；webpack功能更全，生态更完善，支持文件类型更多。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>Esbuild是一个类webpack的打包工具，速度是webpack的几十倍。其底层基于go语言进行编写，不使用AST，优化了构建流程。js是单线程串行，esbuild是新开了一个进程，使用多线程并行，充分发挥了多核的优势。</p>\n<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>esbuild最显著的作用就是：快。它也是vite和snowpack底层的打包工具。同时也可以将esbuild打包工具集成到webpack中（使用plugin）。之所以esbuild没有流行起来是因为它绕过了AST，而直接进行构建，使没有很好的过渡到基于babel-loader这样通过AST进行打包的上层工具中。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><pre><code class=\"js\">const esbuild = require(&#39;esbuild&#39;);\n/**\n * 利用esbuild生成文件\n */\nesbuild.buildSync(&#123;\n    entryPoints:[&#39;vite.config.js&#39;],\n    outfile: &#39;out.js&#39;\n&#125;)\n/**\n * 利用esbuild处理jsx语法\n */\nconsole.log(\n    esbuild.transformSync(&#39;&lt;div&gt;利用esbuild处理jsx语法&lt;/div&gt;&#39;,&#123;\n        jsxFragment:&#39;Fragment&#39;,\n        loader:&#39;jsx&#39;\n    &#125;)\n);\n/**\n * 利用esbuld压缩代码体积\n */\nconsole.log(\n    esbuild.transformSync(&#39;const a = &quot;你好世界&quot;&#39;,&#123;\n        minify: true\n    &#125;)\n);\n/**\n * esbuild内置了一些loader，使用时会根据文件后缀自动执行loader，也可以手动确定loader\n * 支持：js,jsx,ts,tsx,css,text,binary,dataurl,file\n */\nconsole.log(\n    esbuild.buildSync(&#123;\n        entryPoints: [&#39;vite.config.js&#39;],\n        bundle:true,\n        loader: &#123;&#39;.js&#39;:&#39;jsx&#39;&#125;, //默认使用js loader，手动改为jsx-loader\n        outfile: &#39;out.js&#39;,\n    &#125;)\n);\n/**\n * 使用esbuild启动一个web server用于调试（热更新）\n */\nesbuild.serve(&#123;&#125;,&#123;\n    entryPoints: [&#39;vite.config.js&#39;],\n    bundle: true,\n    outfile: &#39;bundle.js&#39;,\n&#125;).then(serve=&gt;&#123;\n    serve.stop();\n&#125;)\n</code></pre>\n","categories":["esbuild"],"tags":["esbuild","打包工具"]},{"title":"eslint源码","url":"/2024/05/17/eslint%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","content":"<h1 id=\"eslint知识点\"><a href=\"#eslint知识点\" class=\"headerlink\" title=\"eslint知识点\"></a>eslint知识点</h1><h3 id=\"extends与plugins\"><a href=\"#extends与plugins\" class=\"headerlink\" title=\"extends与plugins\"></a>extends与plugins</h3><ol>\n<li>plugins本质是为了加强eslint的扩展性，使我们可以直接使用别人写好的eslint规则，方便快速用于项目中。</li>\n<li>官方规定npm包的扩展必须以eslint-config-开头，插件以eslint-plugin-开头，在使用过程中可以省略这个开头。</li>\n<li>eslint-config-文件是我们共享的一些配置文件，里面就是一个JS对象，其中包含一些配置信息，而eslint-plugin-文件是我们自定义的集合规则，可以导入和使用。</li>\n<li>一个插件能带来：<ul>\n<li>额外的规则，如<code>&#123;&quot;rules&quot;: &#123;&quot;react/boolean-prop-naming&quot;: &quot;warning&quot;&#125;&#125;</code>。</li>\n<li>环境，如<code>&#123;&quot;env&quot;: &#123;&quot;jest/global&quot;: true&#125;&#125;</code>。</li>\n<li>配置，如<code>&#123;&quot;extends&quot;: [&quot;plugin:react/recommended&quot;]&#125;</code>。</li>\n<li>预处理器，如<code>&#123;&quot;process&quot;: &quot;a-plugin/a-processor&quot;&#125;</code>。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"eslint配置大全\"><a href=\"#eslint配置大全\" class=\"headerlink\" title=\"eslint配置大全\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODU5NDg4MjkyODcx\">eslint配置大全</span></h1><h1 id=\"eslint源码分析\"><a href=\"#eslint源码分析\" class=\"headerlink\" title=\"eslint源码分析\"></a>eslint源码分析</h1>","categories":["eslint"],"tags":["eslint","源码"]},{"title":"git与github","url":"/2023/04/02/git%E5%92%8Cgithub/","content":"<h1 id=\"———————————–git\"><a href=\"#———————————–git\" class=\"headerlink\" title=\"———————————–git\"></a>———————————–git</h1><h2 id=\"https-zhuanlan-zhihu-com-p-389814854\"><a href=\"#https-zhuanlan-zhihu-com-p-389814854\" class=\"headerlink\" title=\"https://zhuanlan.zhihu.com/p/389814854\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODk4MTQ4NTQ=\">https://zhuanlan.zhihu.com/p/389814854</span></h2><p>网址：git命令大全</p>\n<h4 id=\"git全局配置文件，配置一次即可生效\"><a href=\"#git全局配置文件，配置一次即可生效\" class=\"headerlink\" title=\"git全局配置文件，配置一次即可生效\"></a>git全局配置文件，配置一次即可生效</h4><p>（C:user&#x2F;用户名文件夹&#x2F;.gitconfig）</p>\n<h3 id=\"一、git-init\"><a href=\"#一、git-init\" class=\"headerlink\" title=\"一、git init\"></a>一、<code>git init</code></h3><h4 id=\"（初始化，创建本地仓库）\"><a href=\"#（初始化，创建本地仓库）\" class=\"headerlink\" title=\"（初始化，创建本地仓库）\"></a>（初始化，创建本地仓库）</h4><h3 id=\"二、git-add\"><a href=\"#二、git-add\" class=\"headerlink\" title=\"二、git add\"></a>二、<code>git add</code></h3><h4 id=\"（添加到本地仓库）\"><a href=\"#（添加到本地仓库）\" class=\"headerlink\" title=\"（添加到本地仓库）\"></a>（添加到本地仓库）</h4><h3 id=\"三、git-commit-m-“注释”\"><a href=\"#三、git-commit-m-“注释”\" class=\"headerlink\" title=\"三、git commit -m “注释”\"></a>三、<code>git commit -m</code> “注释”</h3><h4 id=\"（添加注释）\"><a href=\"#（添加注释）\" class=\"headerlink\" title=\"（添加注释）\"></a>（添加注释）</h4><h3 id=\"四、git-remote-add-origin-仓库地址\"><a href=\"#四、git-remote-add-origin-仓库地址\" class=\"headerlink\" title=\"四、git remote add origin 仓库地址\"></a>四、<code>git remote add origin</code> 仓库地址</h3><h4 id=\"（连接远程仓库）\"><a href=\"#（连接远程仓库）\" class=\"headerlink\" title=\"（连接远程仓库）\"></a>（连接远程仓库）</h4><h3 id=\"五、git-pull-rebase-origin-master\"><a href=\"#五、git-pull-rebase-origin-master\" class=\"headerlink\" title=\"五、git pull --rebase origin master\"></a>五、<code>git pull --rebase origin master</code></h3><h4 id=\"仓库地址（同步仓库内容）\"><a href=\"#仓库地址（同步仓库内容）\" class=\"headerlink\" title=\"仓库地址（同步仓库内容）\"></a>仓库地址（同步仓库内容）</h4><h3 id=\"六、git-push-u-origin-master\"><a href=\"#六、git-push-u-origin-master\" class=\"headerlink\" title=\"六、git push -u origin master\"></a>六、<code>git push -u origin master</code></h3><h4 id=\"（上传到远程仓库）\"><a href=\"#（上传到远程仓库）\" class=\"headerlink\" title=\"（上传到远程仓库）\"></a>（上传到远程仓库）</h4><h3 id=\"①获得git帮助命令（浏览器中）\"><a href=\"#①获得git帮助命令（浏览器中）\" class=\"headerlink\" title=\"①获得git帮助命令（浏览器中）\"></a>①获得git帮助命令（浏览器中）</h3><p><code>git help config</code>（获取参考）<br><code>git config -h</code>（获取更简明的快速参考）</p>\n<h3 id=\"②获得git配置信息\"><a href=\"#②获得git配置信息\" class=\"headerlink\" title=\"②获得git配置信息\"></a>②获得git配置信息</h3><p> <code>git config --list --global</code>（查看全局配置项）<br><code>git config user.name</code>(查看某一项)</p>\n<h3 id=\"③配置用户信息\"><a href=\"#③配置用户信息\" class=\"headerlink\" title=\"③配置用户信息\"></a>③配置用户信息</h3><p><code>git config --global user.name &#39;name&#39;</code><br><code>git config --global user.email &#39;email&#39;</code><br>（使用了–global选项，那么该命令只需要运行一次即可永久生效）</p>\n<h3 id=\"④获取帮助信息\"><a href=\"#④获取帮助信息\" class=\"headerlink\" title=\"④获取帮助信息\"></a>④获取帮助信息</h3><p>git help <verb>(获取某个命令的帮助手册)</p>\n<h3 id=\"⑤将目录转换成Git仓库（项目的git-Bash中使用git-init）\"><a href=\"#⑤将目录转换成Git仓库（项目的git-Bash中使用git-init）\" class=\"headerlink\" title=\"⑤将目录转换成Git仓库（项目的git Bash中使用git init）\"></a>⑤将目录转换成Git仓库（项目的git Bash中使用git init）</h3><h3 id=\"⑥从其他服务器上克隆一个仓库\"><a href=\"#⑥从其他服务器上克隆一个仓库\" class=\"headerlink\" title=\"⑥从其他服务器上克隆一个仓库\"></a>⑥从其他服务器上克隆一个仓库</h3><h3 id=\"⑦四种状态：：工作区（未修改），暂存区（已修改），仓库（已暂存）\"><a href=\"#⑦四种状态：：工作区（未修改），暂存区（已修改），仓库（已暂存）\" class=\"headerlink\" title=\"⑦四种状态：：工作区（未修改），暂存区（已修改），仓库（已暂存）\"></a>⑦四种状态：：工作区（未修改），暂存区（已修改），仓库（已暂存）</h3><h3 id=\"⑧git目标：将工作区的文件都处于未修改的状态\"><a href=\"#⑧git目标：将工作区的文件都处于未修改的状态\" class=\"headerlink\" title=\"⑧git目标：将工作区的文件都处于未修改的状态\"></a>⑧git目标：将工作区的文件都处于未修改的状态</h3><h3 id=\"⑨查看文件出于什么状态：（git-status命令（git-status-s-精简显示），查看那些文件被跟踪，哪些没有）\"><a href=\"#⑨查看文件出于什么状态：（git-status命令（git-status-s-精简显示），查看那些文件被跟踪，哪些没有）\" class=\"headerlink\" title=\"⑨查看文件出于什么状态：（git status命令（git status -s 精简显示），查看那些文件被跟踪，哪些没有）\"></a>⑨查看文件出于什么状态：（git status命令（git status -s 精简显示），查看那些文件被跟踪，哪些没有）</h3><p>??：未被 Git 跟踪的新文件。<br>A：新增文件。<br>M：文件已被修改。<br>D：文件已被删除。<br>R：文件已被重命名。<br>C：文件已被拷贝。<br>X：文件状态没有更改。<br>M：文件被修改并且已经暂存。<br>A：文件已经添加到 Git 并且还没有被暂存。<br>D：文件被删除了。<br>R：文件被重命名了。<br>C：文件被拷贝（复制）了。</p>\n<h3 id=\"⑩跟踪文件，跟踪后Git会记录文件的所有变化，并管理和恢复（git-add-文件名-）\"><a href=\"#⑩跟踪文件，跟踪后Git会记录文件的所有变化，并管理和恢复（git-add-文件名-）\" class=\"headerlink\" title=\"⑩跟踪文件，跟踪后Git会记录文件的所有变化，并管理和恢复（git add 文件名 ）\"></a>⑩跟踪文件，跟踪后Git会记录文件的所有变化，并管理和恢复（git add 文件名 ）</h3><p>取消跟踪文件：<code>git rm --cached &lt;file&gt;</code>  （需要执行一次提交才生效）</p>\n<h3 id=\"十一、提交到git仓库中\"><a href=\"#十一、提交到git仓库中\" class=\"headerlink\" title=\"十一、提交到git仓库中\"></a>十一、提交到git仓库中</h3><p>（<code>git commit -m</code> ‘描述信息’）</p>\n<h3 id=\"十二、修改已提交的文件，其状态为红色M\"><a href=\"#十二、修改已提交的文件，其状态为红色M\" class=\"headerlink\" title=\"十二、修改已提交的文件，其状态为红色M\"></a>十二、修改已提交的文件，其状态为红色M</h3><h3 id=\"十三、git-add命令的三个功能：①跟踪新文件②将已跟踪且修改的文件放到暂存区③将有冲突的文件标记为以解决状态\"><a href=\"#十三、git-add命令的三个功能：①跟踪新文件②将已跟踪且修改的文件放到暂存区③将有冲突的文件标记为以解决状态\" class=\"headerlink\" title=\"十三、git add命令的三个功能：①跟踪新文件②将已跟踪且修改的文件放到暂存区③将有冲突的文件标记为以解决状态\"></a>十三、git add命令的三个功能：①跟踪新文件②将已跟踪且修改的文件放到暂存区③将有冲突的文件标记为以解决状态</h3><h3 id=\"十四、撤销对文件的修改谨慎操作\"><a href=\"#十四、撤销对文件的修改谨慎操作\" class=\"headerlink\" title=\"十四、撤销对文件的修改谨慎操作\"></a>十四、撤销对文件的修改<em>谨慎操作</em></h3><p>*（<code>git checkout -- 文件名</code>），本质是Git仓库中保存的文件，覆盖工作区中指定的文件</p>\n<h3 id=\"十五、向暂存区中一次性添加目录下所有文件\"><a href=\"#十五、向暂存区中一次性添加目录下所有文件\" class=\"headerlink\" title=\"十五、向暂存区中一次性添加目录下所有文件\"></a>十五、向暂存区中一次性添加目录下所有文件</h3><p>*（<code>git add .</code>）</p>\n<h3 id=\"十六、从暂存区移除暂存的文件\"><a href=\"#十六、从暂存区移除暂存的文件\" class=\"headerlink\" title=\"十六、从暂存区移除暂存的文件\"></a>十六、从暂存区移除暂存的文件</h3><p>*（<code>git reset HEAD 文件名</code>）文件名为 .号表明移除全部</p>\n<h3 id=\"十七、Git工作流程：工作区—-暂存区—-Git仓库\"><a href=\"#十七、Git工作流程：工作区—-暂存区—-Git仓库\" class=\"headerlink\" title=\"十七、Git工作流程：工作区—-暂存区—-Git仓库\"></a>十七、Git工作流程：工作区—-暂存区—-Git仓库</h3><h3 id=\"十八、跳过使用暂存区\"><a href=\"#十八、跳过使用暂存区\" class=\"headerlink\" title=\"十八、跳过使用暂存区\"></a>十八、跳过使用暂存区</h3><p>*（<code>git commit -a -m</code> “描述消息”）</p>\n<h3 id=\"十九、从Git仓库中移除文件\"><a href=\"#十九、从Git仓库中移除文件\" class=\"headerlink\" title=\"十九、从Git仓库中移除文件\"></a>十九、从Git仓库中移除文件</h3><p>*（<code>git rm -f</code> 文件名   ，从Git仓库和工作区中同时移除index.js文件②git rm –cached 文件名  ， 只从Git仓库中移除文件，用于不用更改的固定文件不用记录）</p>\n<h3 id=\"二十、忽略文件\"><a href=\"#二十、忽略文件\" class=\"headerlink\" title=\"二十、忽略文件\"></a>二十、忽略文件</h3><p>*（新建一个名为.gitignore配置文件，列出要忽略的文件的匹配模式）①以#开头的是注释②以&#x2F;结尾的是目录③以&#x2F;开头防止递归④以！开头表示取反⑤可以使用glob模式进行文件和文件夹的匹配（glob指简化了的正则表达式）</p>\n<h3 id=\"二十一、glob模式：\"><a href=\"#二十一、glob模式：\" class=\"headerlink\" title=\"二十一、glob模式：\"></a>二十一、glob模式：</h3><p><em>①</em>:匹配零个或多个任意字符</p>\n<p>②[abc]匹配任何一个列在方括号中的字符</p>\n<p>③？：匹配一个任意字符</p>\n<p>④[0-9]匹配所有0到9的数字</p>\n<p>⑤**表示匹配任意中间目录</p>\n<h3 id=\"二十二、输出Git提交日志\"><a href=\"#二十二、输出Git提交日志\" class=\"headerlink\" title=\"二十二、输出Git提交日志\"></a>二十二、输出Git提交日志</h3><p><code>（git log）git log -n</code>提交最近n条历史信息</p>\n<h3 id=\"二十三、回退指定版本：\"><a href=\"#二十三、回退指定版本：\" class=\"headerlink\" title=\"二十三、回退指定版本：\"></a>二十三、回退指定版本：</h3><p>（<code>git log --pretty=onlin</code>查看提交历史，获得对应标识id 、</p>\n<p> <code>git reset --hard &lt;CommitID&gt;</code>根据指定的提交ID回退到指定版本 、</p>\n<p><code>git reflog --pretty=online</code>旧版本中使用，查看命令操作的历史 、</p>\n<p> <code>git reset --hard &lt;CommitID&gt;</code>再次根据最新的提交ID，跳转到最新的版本）</p>\n<h1 id=\"—————————————-github\"><a href=\"#—————————————-github\" class=\"headerlink\" title=\"—————————————-github\"></a>—————————————-github</h1><h2 id=\"一、远程仓库使用\"><a href=\"#一、远程仓库使用\" class=\"headerlink\" title=\"一、远程仓库使用\"></a>一、远程仓库使用</h2><p>HTTPS:零配置，每次范围问需要重新输入密码</p>\n<p>SSH:需要额外配置,配置后不必重复输入密码（推荐使用）</p>\n<h2 id=\"二、基于HTTPS、SSH将本地仓库上传到Github\"><a href=\"#二、基于HTTPS、SSH将本地仓库上传到Github\" class=\"headerlink\" title=\"二、基于HTTPS、SSH将本地仓库上传到Github\"></a>二、基于HTTPS、SSH将本地仓库上传到Github</h2><p><code>echo &quot;# project 02&quot; &gt;&gt; README.md</code>       使用终端创建内容为#project 02的md文件</p>\n<p><code>git init</code>初始化本地仓库（git打开）</p>\n<p><code>git add README.md</code></p>\n<p><code>git commit -m &quot;first commit&quot;</code> 文件修改并提交到本地仓库</p>\n<p><code>git remote add </code> 仓库地址（HTTP或SSH） 链接远程仓库</p>\n<p><code>git push -u 仓库地址 master</code> 将本地仓库推送到远程仓库（第一次推送 以后直接<code>git push</code>）</p>\n<h2 id=\"三、生成SSH-key\"><a href=\"#三、生成SSH-key\" class=\"headerlink\" title=\"三、生成SSH key\"></a>三、生成SSH key</h2><p>git Bash中 使用： <code>ssh-keygen -t rsa -b 4096  -C &quot;邮箱地址&quot;</code></p>\n<p>连续三次回车，即可在C:\\Users\\dmq \\ .ssh目录中生成id_rsa 和 id_rsa.pub两个文件</p>\n<h4 id=\"SSH-key的好处\"><a href=\"#SSH-key的好处\" class=\"headerlink\" title=\"SSH key的好处\"></a>SSH key的好处</h4><p>实现本地仓库和Github之间免登录的加密数据传输</p>\n<h4 id=\"SSH-key两部分\"><a href=\"#SSH-key两部分\" class=\"headerlink\" title=\"SSH key两部分\"></a>SSH key两部分</h4><p>①id_rsa(私钥文件，存放于客户端的电脑中)</p>\n<p>②id_rsa.pub(公钥文件，需要配置到Github中)</p>\n<h4 id=\"配置SSH-key\"><a href=\"#配置SSH-key\" class=\"headerlink\" title=\"配置SSH key\"></a>配置SSH key</h4><p>①记事本打开id_rsa.pub 文件，复制里面的内容</p>\n<p>②在浏览器中登录Github，点击头像 -&gt;Settings -&gt;SSH and GPG Keys -&gt; New SSH key</p>\n<p>③将id_rsa.pub文件中的内容，粘贴到Key对应的文本框中</p>\n<p>④在Title文本框中任意填写一个名称，来标识这个Key从何而来</p>\n<h4 id=\"检测远程仓库中SSH是否配置成功\"><a href=\"#检测远程仓库中SSH是否配置成功\" class=\"headerlink\" title=\"检测远程仓库中SSH是否配置成功\"></a>检测远程仓库中SSH是否配置成功</h4><p>Git Bash中：</p>\n<p> <code>ssh -T git@github.com </code>(github)</p>\n<p><code>ssh -T git@gitee.com</code> (gitee)</p>\n<p>输入yes</p>\n<h2 id=\"四、将远程仓库克隆到本地\"><a href=\"#四、将远程仓库克隆到本地\" class=\"headerlink\" title=\"四、将远程仓库克隆到本地\"></a>四、将远程仓库克隆到本地</h2><p>Git Bash 中输入 <code>git clone  远程仓库地址</code></p>\n","categories":["git"],"tags":["git","github"]},{"title":"git笔记","url":"/2023/05/02/git%20github%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89/","content":"<!--Ctrl+[ 提升列表等级；Ctrl+1 一级标题-->\n\n\n\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003049.png\" alt=\"/images/image-20220202212355012\"></p>\n<h1 id=\"一、用于版本控制\"><a href=\"#一、用于版本控制\" class=\"headerlink\" title=\"一、用于版本控制\"></a>一、用于版本控制</h1><ol>\n<li><p>版本控制工具需要的功能</p>\n<p>协同修改、数据备份、版本管理、权限控制、历史记录、分支管理</p>\n<p><img data-src=\"D:\\AMYCode\\220202testGithub\\images\\image-20220130110013784.png\" alt=\"/images/image-20220130110013784\"></p>\n</li>\n<li><p>分布式版本控制 vs 集中式版本控制</p>\n<p>集中式版本控制需联网才能需要</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003434.png\"></p>\n</li>\n</ol>\n<h1 id=\"二、Git简介\"><a href=\"#二、Git简介\" class=\"headerlink\" title=\"二、Git简介\"></a>二、Git简介</h1><ol>\n<li><p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003455.png\" alt=\"/images/image-20220130112357773\"></p>\n</li>\n<li><p>本地库和远程库</p>\n<ul>\n<li><p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003509.png\"></p>\n<p>团队内成员操作</p>\n</li>\n<li><p>想找不是团队内的成员 东方不败 来帮忙，那就需要他fork一下，这样对于修改可以进行pull request，经过审核后可以merge到原来的远程仓库</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003535.png\" alt=\"/images/image-20220130113228007\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"三、Git命令行操作\"><a href=\"#三、Git命令行操作\" class=\"headerlink\" title=\"三、Git命令行操作\"></a>三、Git命令行操作</h1><p>主体内容：<img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003525.png\" alt=\"/images/image-20220130120329440\"></p>\n<h2 id=\"本地库初始化\"><a href=\"#本地库初始化\" class=\"headerlink\" title=\"本地库初始化\"></a>本地库初始化</h2><ul>\n<li><p>git init</p>\n</li>\n<li><p>初始化后效果：会生成一个.git隐藏文件。使用ll .git&#x2F;可以查看</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003546.png\" alt=\"/images/image-20220130120928612\"></p>\n</li>\n<li><p>注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不能胡乱修改</p>\n</li>\n</ul>\n<h2 id=\"设置签名\"><a href=\"#设置签名\" class=\"headerlink\" title=\"设置签名\"></a>设置签名</h2><ul>\n<li><p>形式  例如：</p>\n<p>用户名：tom</p>\n<p>Email地址：<span class=\"exturl\" data-url=\"bWFpbHRvOiYjMTAzOyYjMTA1OyYjeDc0OyYjNjQ7JiM5ODsmI3g2MTsmIzEwODsmI3g2MTsmI3gyZTsmI3g2MzsmI3g2ZjsmI3g2ZDs=\">&#103;&#105;&#x74;&#64;&#98;&#x61;&#108;&#x61;&#x2e;&#x63;&#x6f;&#x6d;</span></p>\n</li>\n<li><p>作用：区分不同开发人员的身份</p>\n</li>\n<li><p>辨析：这里设置的签名和登录远程库（代码托管中心）的账户、密码没有任何关系</p>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>项目级别&#x2F;仓库级别：仅在当前本地库范围内有效</p>\n<ul>\n<li><p>git config user.name tom</p>\n</li>\n<li><p>git config user.email <span class=\"exturl\" data-url=\"bWFpbHRvOiYjMTE2OyYjeDZmOyYjMTA5OyYjNjQ7JiN4NjI7JiM5NzsmIzEwODsmI3g2MTsmIzQ2OyYjeDYzOyYjeDZmOyYjMTA5Ow==\">&#116;&#x6f;&#109;&#64;&#x62;&#97;&#108;&#x61;&#46;&#x63;&#x6f;&#109;</span></p>\n</li>\n<li><p>设置后，信息会保存到 .git&#x2F;config [下面用cat命令查看这个文件]</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003600.png\" alt=\"/images/image-20220130123501964\"></p>\n</li>\n</ul>\n</li>\n<li><p>系统用户级别：登录当前操作系统的用户范围</p>\n<ul>\n<li>git config –global user.name tom</li>\n<li>git config –global user.email <span class=\"exturl\" data-url=\"bWFpbHRvOiYjMTE2OyYjeDZmOyYjeDZkOyYjeDQwOyYjOTg7JiN4NjE7JiMxMDg7JiN4NjE7JiN4MmU7JiN4NjM7JiN4NmY7JiN4NmQ7\">&#116;&#x6f;&#x6d;&#x40;&#98;&#x61;&#108;&#x61;&#x2e;&#x63;&#x6f;&#x6d;</span></li>\n<li>信息保存位置：.&#x2F;.git&#x2F;config 文件</li>\n</ul>\n</li>\n<li><p>级别优先级</p>\n<ul>\n<li>就近原则：项目级别优先于用户级别，二者都有时采用项目级别的签名</li>\n<li>如果只有系统用户级别的签名，就以系统用户级别的签名为准</li>\n<li>二者都没有不允许</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"操作命令\"><a href=\"#操作命令\" class=\"headerlink\" title=\"操作命令\"></a>操作命令</h2><ol>\n<li><p>状态查看操作 <strong>git</strong> <strong>status</strong> 【该命令特别常用】</p>\n</li>\n<li><p>添加操作 <strong>git add 文件名</strong>   </p>\n<p>把untrack的文件加入到暂存区。将工作区的“新建&#x2F;修改”添加到暂存区</p>\n</li>\n<li><p>提交操作 <strong>git commit 文件名</strong></p>\n</li>\n</ol>\n<ul>\n<li><p>把文件从暂存区提交到本地库</p>\n</li>\n<li><p>执行该命令后需要输入 commit message，即这次commit的相关注释。</p>\n<p>因为使用的是vim编辑器，可以i键进入编辑模式，ESC进入命令模式，命令模式下输入：wq进行保存并退出</p>\n</li>\n</ul>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003720.png\" alt=\"/images/image-20220130125343078\"></p>\n<p> 图片展示中的2 insertions代表两行，新加的good.txt文件确实里边只有两行文字。</p>\n<ul>\n<li>执行git commit命令后会进入vim文本编辑器，需要输注释。下面是一种更简单的方法</li>\n</ul>\n<p>  <code>git commit -m &quot;这里写注释&quot; goood.txt</code></p>\n<ol start=\"4\">\n<li><p>查看历史记录操作</p>\n<p><code>git log</code> </p>\n<ul>\n<li><p>查看历史操作<img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003738.png\" alt=\"/images/image-20220130131345836\"></p>\n</li>\n<li><p>如果提交次数特别多，历史记录会一屏放不下。多屏显示控制方式</p>\n<p>空格向下翻页；b向上翻页；q退出</p>\n</li>\n<li><p>可以使用–pretty增加参数</p>\n<p><code>git log --pretty=oneline</code> 显示一行</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003846.png\" alt=\"/images/image-20220130132306271\"></p>\n</li>\n<li><p><code>git log --oneline</code> 也是每次提交仅显示一行，与上面的命令相比，hash值会变短</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003854.png\" alt=\"/images/image-20220130132333516\"></p>\n</li>\n<li><p><code>git reflog</code> 可以增加显示要移动几次指针来回复到对应版本</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003822.png\" alt=\"/images/image-20220130132048569\"></p>\n</li>\n</ul>\n</li>\n<li><p>版本前进和后退</p>\n<ul>\n<li><p>基于索引值操作（推荐）</p>\n<p><code>git reset --hard 索引值</code>【索引值可以通过git reflog获得，选中索引，然后粘贴】</p>\n</li>\n<li><p>使用^符号</p>\n<ul>\n<li><p>该命令只能后退</p>\n</li>\n<li><p><code>git reset --hard HEAD^^</code> 几个<strong>^</strong>代表退几步</p>\n</li>\n</ul>\n</li>\n<li><p>使用~符号</p>\n<p>该命令也只能后退</p>\n<ul>\n<li><p><code>git reset --hard HEAD~n</code> </p>\n</li>\n<li><p>n代表后退n步</p>\n</li>\n</ul>\n</li>\n<li><p>reset命令的三个参数对比</p>\n<ul>\n<li><p>–soft 参数  仅仅在本地库移动HEAD指针</p>\n</li>\n<li><p>–mixed参数 在本地库移动HEAD指针；重置暂存区</p>\n</li>\n<li><p>–hard参数   在本地库移动HEAD指针；重置暂存区；重置工作区</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>git help 命令</code></p>\n</li>\n<li><p>永久删除文件后找回</p>\n<p>在工作区删除后，提交到本地库，可以通过reset回到之前的版本，之前版本还保留该文件</p>\n<ul>\n<li>前提：删除前，文件存在时的状态提交到本地库</li>\n<li>操作：git reset –hard [指针位置]<ul>\n<li>删除操作已经提交到本地库，则指针位置指向历史记录</li>\n<li>删除操作没有提交到本地库，指针使用head</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>比较文件差异</p>\n<ul>\n<li>git diff [文件名]<ul>\n<li>将工作区中的文件和暂存区进行比较</li>\n</ul>\n</li>\n<li>git diff [本地库中的历史版本] [文件名]<ul>\n<li>将工作区中的文件和本地库历史记录比较</li>\n</ul>\n</li>\n<li>不带文件名则可以比较多个文件</li>\n</ul>\n</li>\n<li><p>分支管理</p>\n<ol>\n<li><p>分支：在版本控制过程中，使用多条线同时推进多个任务</p>\n</li>\n<li><p>分支的好处：</p>\n<ul>\n<li>同时并行推进多个功能的开发，提高开发效率</li>\n<li>如果发现某个分支有问题，可以删除该分支不影响主干</li>\n</ul>\n</li>\n<li><p>如何查看分支</p>\n<p><code>git branch -v</code></p>\n</li>\n<li><p>如何创建分支</p>\n<p><code>git branch [新的分支名字]</code></p>\n</li>\n<li><p>切换分支</p>\n<p><code>git checkout [分支名字]</code>  切换到某个分支</p>\n</li>\n<li><p>合并分支</p>\n<p><code>git branch -v</code> </p>\n<ul>\n<li><p>第一步，切换到接受修改的分支（被合并，增加新内容）上</p>\n<p><code>git checkout master</code> 到接受修改的分支，比如合并到主分支</p>\n</li>\n<li><p>第二步，执行merge</p>\n<p><code>git merge [被合并的分支名]</code></p>\n</li>\n</ul>\n</li>\n<li><p>解决冲突</p>\n<ul>\n<li><p>冲突的表现</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003919.png\" alt=\"/images/image-20220202183828366\"></p>\n</li>\n<li><p>冲突的解决</p>\n<ul>\n<li>第一步：编辑文件，删除特殊符号</li>\n<li>第二步：把文件修改到满意的程度，保存退出</li>\n<li>第三步：git add[文件名]</li>\n<li>第四步：git commit -m “日志信息”<ul>\n<li>注意：此时commit 一定不能带具体文件名</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"四、Git基本原理\"><a href=\"#四、Git基本原理\" class=\"headerlink\" title=\"四、Git基本原理\"></a>四、Git基本原理</h1><ol>\n<li><p>Hash</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003934.png\" alt=\"/images/image-20220202184334597\"></p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003941.png\" alt=\"/images/image-20220202184638546\"></p>\n</li>\n</ol>\n<p>2.创建分支—&gt;创建指针；</p>\n<p>切换分支—&gt;切换指针；</p>\n<h1 id=\"五、Github\"><a href=\"#五、Github\" class=\"headerlink\" title=\"五、Github\"></a>五、Github</h1><ol>\n<li><p>首先创建一个Github账号，然后创建一个repository。复制这个仓库对应的地址，然后在本地添加一下这个地址（这样就不用每次都写它了）</p>\n<ul>\n<li>这里初始化仓库 <code>git init</code></li>\n<li>添加远程仓库，&#96;之后可以使用别名origin指代该仓库</li>\n</ul>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003953.png\" alt=\"/images/image-20220202192116825\"></p>\n<ul>\n<li>向该仓库推送  <code>git push origin master</code> 格式：git push 仓库地址（名） 分支名</li>\n</ul>\n</li>\n</ol>\n<p><code>git remote add  地址别名  地址</code></p>\n<p><code>git push 地址别名  分支名</code></p>\n</li>\n<li><p>克隆</p>\n<ul>\n<li>直接使用命令<code>git  clone [远程地址]</code></li>\n<li>效果<ul>\n<li>完整地把远程库下载到本地</li>\n<li>创建origin远程地址别名</li>\n<li>初始化本地库</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拉取</p>\n<ul>\n<li>pull &#x3D; fetch+merge</li>\n<li>git fetch 【远程库地址别名】【远程分支名】</li>\n<li>git merge 【远程库地址别名&#x2F;远程分支名】</li>\n<li>git pull 【远程库地址别名】【远程分支名】</li>\n</ul>\n<p>如果没冲突，就直接从远程pull；如果不确定，可以先fetch下来看看，再决定merge</p>\n</li>\n<li><p>协同开发时冲突的解决</p>\n<ul>\n<li>要点<ul>\n<li>如果不是基于Github远程库的最新版所作的修改，不能推送，必须先拉取。</li>\n<li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>跨团队协作</p>\n</li>\n</ol>\n<ul>\n<li>Fork</li>\n<li>pull requestes</li>\n</ul>\n<ol start=\"6\">\n<li><p>Eclipse 中Git使用 </p>\n<p>介绍了在Eclipse使用Git 。 应该pycharm或者VSCode也可以？</p>\n</li>\n</ol>\n<h1 id=\"六、Git工作流\"><a href=\"#六、Git工作流\" class=\"headerlink\" title=\"六、Git工作流\"></a>六、Git工作流</h1><p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003050.png\" alt=\"/images/image-20220202210632324\"></p>\n<p>这里安装Gitlab为啥？？？？</p>\n<h1 id=\"七、Gitee\"><a href=\"#七、Gitee\" class=\"headerlink\" title=\"七、Gitee\"></a>七、Gitee</h1><p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003051.png\" alt=\"/images/image-20220203000544636\"></p>\n","categories":["git"],"tags":["git","github"]},{"title":"forEach","url":"/2023/07/02/forEach/","content":"<p>手动实现一个类似forEach的效果:<br>前端开发过程中经常会遇到使用forEach的场景,那么它的原理究竟是什么呢?下面我手动写了一个类似的效果,不同的是函数可能会改变原始值.</p>\n<p>代码如下:</p>\n<pre><code class=\"js\">function myEach(obj,fn,context=window)&#123;\n    //类型判断\n    if(typeof obj !== &#39;object&#39;)&#123;\n        throw (&#39;必须要是对象&#39;)\n    &#125;\n    if(obj === null)&#123;\n        throw (&#39;必要不为空对象&#39;)\n    &#125;\n    if(typeof fn !== &#39;function&#39;)&#123;\n        throw (&#39;第二个参数，必须要是函数&#39;)\n    &#125;\n    //如果是数组\n    if(isArrayLike(obj))&#123;\n        for(let i=0;i&lt;obj.length;i++)&#123;\n            let res = fn.call(context,obj[i],i);\n            //res为什么会为false（如果函数内部return了，那么这里就需要跳出循环）\n            if(res===false)&#123;\n                break;\n            &#125;\n            //如果返回值不是undefined,有返回值,就替换掉这一项\n            if(res !== undefined)&#123;\n                obj[i] = res;                \n            &#125;\n        &#125;\n    &#125;else&#123;\n        //如果是对象\n        for(let key in obj)&#123;\n            if(!obj.hasOwnProperty(key)) break;\n            const res = fn.call(context,obj[key],key);\n            if(res ===false)&#123;\n                break;\n            &#125;\n            if(res !==undefined)&#123;\n                obj[key] = res;\n            &#125;\n        &#125;\n    &#125;\n    return obj;\n&#125;\n</code></pre>\n","categories":["JS"],"tags":["JS","forEach"]},{"title":"Vue使用笔记","url":"/2023/01/12/Vue%E6%9D%82%E8%AE%B0/","content":"<h2 id=\"Vue注意事项\"><a href=\"#Vue注意事项\" class=\"headerlink\" title=\"Vue注意事项\"></a>Vue注意事项</h2><p>一、使用watch监听数组时：</p>\n<p>当使用watch监听数组时，要将deep设置为true，这样才能监听到数组内部的操作，而不是只监听引用是否变化，当需要使用newValue和oldValue时，监听部分需要写数组的拷贝而不是数组本身（否则当数组引用不变而堆数据变化时，oldValue和newValue都是变化之后的数值。）</p>\n<h2 id=\"Vue项目创建过程：\"><a href=\"#Vue项目创建过程：\" class=\"headerlink\" title=\"Vue项目创建过程：\"></a>Vue项目创建过程：</h2><p>（<br>①创建项目 <code>vue create 项目名</code><br>②安装开发依赖：<code>yarn add 包名@版本号 -D</code><br>③安装生产依赖: <code>yarn add 包名</code>，并在main.js中引入和全局属性</p>\n<p>）<br>css选择器和权重的计算<br>font-size和字体详解（小写x为基准）<br>小黑记事本案例<br>vue中结合网络数据库开发应用（axios网络请求库）、<br>前端避雷技术：Jequry、Angular js、php、rubian rails构建应用程序<br>form-serialize插件获取表单的各项</p>\n<h2 id=\"Vue知识点\"><a href=\"#Vue知识点\" class=\"headerlink\" title=\"Vue知识点\"></a>Vue知识点</h2><p>{</p>\n<p>Vue文件分类：将Vue文件分为页面文件和可复用的文件</p>\n<h6 id=\"一、vue项目初始化：\"><a href=\"#一、vue项目初始化：\" class=\"headerlink\" title=\"一、vue项目初始化：\"></a>一、vue项目初始化：</h6><p>（①vue create文件名②cd进入文件夹③yarn add添加引用包④main.js引入样式(引用方式)⑤vue.config.js中禁用eslint检查)</p>\n<h6 id=\"二、vue组件使用：\"><a href=\"#二、vue组件使用：\" class=\"headerlink\" title=\"二、vue组件使用：\"></a>二、vue组件使用：</h6><p>（①在components文件夹下添加vue文件组件②在App.vue中import组件form’路径’③在export default的componets下注册组件，有些可简写④div中用组件名使用组件）</p>\n<h6 id=\"三、vue中export-default中的属性：\"><a href=\"#三、vue中export-default中的属性：\" class=\"headerlink\" title=\"三、vue中export default中的属性：\"></a>三、vue中export default中的属性：</h6><p>（name,components,props,created,mounted,data,methods，watch,computed,activated,deactivated）</p>\n<h6 id=\"四、vue中使用axios\"><a href=\"#四、vue中使用axios\" class=\"headerlink\" title=\"四、vue中使用axios\"></a>四、vue中使用axios</h6><p>（①下载axios包（yarn add axios）②在main.js中引入(impoort axios from ‘axios’)③配置基础地址（axios.defaults.baseURL&#x3D;”<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZXNjb29rLmNu\">https://www.escook.cn&quot;）④将axios挂载到Vue原型上，作为全局属性（在main.js中添加：Vue.prototype.$axios=axios），⑤App.vue的created中使用全局属性axios⑥接口地址为/api/cart⑦进行数据渲染）</span> </p>\n<h6 id=\"五、动态组件：\"><a href=\"#五、动态组件：\" class=\"headerlink\" title=\"五、动态组件：\"></a>五、动态组件：</h6><p>（①创建要被切换的组件样式②引入到要展示的vue文件中，注册③变量承载要显示的组件名④设置承载点<component :is=\"变量\"></component>⑤点击按钮，切换comName的值为要显示的组件名⑥使用vue内置的keep-alive组件，将抱起来的组件缓存起来<keep-alive></keep-alive>  )</p>\n<h6 id=\"六、组件插槽\"><a href=\"#六、组件插槽\" class=\"headerlink\" title=\"六、组件插槽\"></a>六、组件插槽</h6><p>（①通过slot标签占位，让组件内可以接受不同的标签结构样式，为了让封装的组件显示不同的标签结构（灵活），②使用：在模板中添加<slot>默认内容</slot>占位，引入模板时在模板内添加占位标签里的内容③具名插槽：子组件，在slot上绑定name&#x3D;”name值”，在使用组件，传入自定义标签，用template标签内加v-slot&#x3D;”name值”）④作用域插槽：使用子组件时在template中使用scope</p>\n<h6 id=\"七、自定义指令\"><a href=\"#七、自定义指令\" class=\"headerlink\" title=\"七、自定义指令\"></a>七、自定义指令</h6><p>（①全局注册：Vue.directive(“指令名”,{“inserted” (el,binding){对el标签扩展额外的功能②局部注册：export.default中添加配置项directives:{“指令名”:{inserted(el,binding){对el进行操作}}}})③使用：在标签内添加属性:v-指令名&#x3D;”binding.value”(将自定义传值与指令操作相关联)）自定义指令中除了inserted方法还有update方法</p>\n<h6 id=\"八、父子组件数据交互\"><a href=\"#八、父子组件数据交互\" class=\"headerlink\" title=\"八、父子组件数据交互\"></a>八、父子组件数据交互</h6><p>（①在父组件中引入和注册并使用②子组件定义好props属性，设定值得类型与校验③子组件中使用设定的props数据④父组件data中定义好子组件中props属性中的相应类型的值⑤父组件中使用时:绑定子组件props中的数据）</p>\n<h6 id=\"九、切换组件显示\"><a href=\"#九、切换组件显示\" class=\"headerlink\" title=\"九、切换组件显示\"></a>九、切换组件显示</h6><p>（①）</p>\n<h6 id=\"十、vue组件之间传值\"><a href=\"#十、vue组件之间传值\" class=\"headerlink\" title=\"十、vue组件之间传值\"></a>十、vue组件之间传值</h6><p>（一、父组件给子组件传值：①父组件使用子组件时，:绑定值，并在data中注册②子组件props中注册相同名称的值）<br>（二、子组件给父组件传值：①在子组件中使用this.$emit方法自定义一个事件并传值②在父组件中使用该事件通过函数操作传来的值）</p>\n<h2 id=\"十一、Vue-router\"><a href=\"#十一、Vue-router\" class=\"headerlink\" title=\"十一、Vue-router\"></a>十一、Vue-router</h2><p>①安装npm i vue-router@(vue2用3的版本,vue3用4版本)</p>\n<p>②安装：运行命令yarn add vue-router安装</p>\n<p>③配置：src下新建router文件夹，下面的index.js中进行配置：</p>\n<pre><code class=\"js\">imprt Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\nVue.use(VueRouter)\n</code></pre>\n<p>④创建路由组件：src下的views文件夹下新建vue页面</p>\n<p>⑤创建路由组件：在router里index.js中引入：</p>\n<pre><code class=\"js\">import Home from &#39;../views/Home.vue&#39;\n</code></pre>\n<p>⑥配置路由表：将路由与组件进行映射：</p>\n<pre><code class=\"js\">const routes = [\n  &#123; path: &#39;/&#39;, component: Home &#125;,\n  &#123; path: &#39;/about&#39;, component: About &#125;,\n  // 更多路由配置...\n]\n</code></pre>\n<p>⑦创建router实例</p>\n<pre><code class=\"js\">const router = new VueRouter(&#123;\n  routes\n&#125;);\n</code></pre>\n<p>⑧Vue中挂载router</p>\n<pre><code class=\"js\">new Vue(&#123;\n  router,\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;);\n</code></pre>\n<h6 id=\"十二、跨组件传值（没有引用关系）\"><a href=\"#十二、跨组件传值（没有引用关系）\" class=\"headerlink\" title=\"十二、跨组件传值（没有引用关系）\"></a>十二、跨组件传值（没有引用关系）</h6><p>（①创建文件夹EventBus，下面创建index.js文件，文件中引入Vue，并默认导出空对象②）<br>十三、this.$refs获取组件 , 通过组件中ref属性，调用组件中的函数（①组件使用时添加ref属性，使用时通过this.$refs.ref属性.函数名()  ）<br>十四、this.$nextTick(fn(){})方法中等待DOM更新后触发$nextTick中的函数（ref中的函数会在DOM更新之前触发，DOM更新是异步任务），他可以保证我们在调用子组件的方法时使用到的数据是最新的数据。$nextTick函数原地返回一个Promise对象，主动在js中触发标签事件：获取DOM对象，调用事件方法<br>十五、name属性的作用：注册时可以定义自己的名字<br>十六、组件缓存<keep-alive></keep-alive>组件，<br>十七、动态组件：<component :is=\" \"></component><br>十八、组件插槽（具名插槽）：①目的：为了让封装的组件显示不同的标签结构    ②使用：&lt;slot #name值&#x3D;“子组件传值的属性”     或   v-slot:name值&#x3D;“子组件传值的属性”&gt;     </slot>占位(**注意vue2中，只能使用v-slot，vue3中只能使用#name值)  ③使用定义的组件，传入具体的标签替换到slot<br>             ③插槽默认内容，子组件slot内部书写默认内容④作用域插槽：使用子组件内的变量：(方法:在slot上绑定属性和子组件内的值，在使用组件，传入自定义标签，父组件中用template标签scope属性）<br>十九、自定义指令：一、①全局方法②局部注册  二、自定义指令传值<br>自定义指令的生命周期:①bind②inserted③update④componentUpdated⑤unbind<br>二十、Vue生命周期【创建，挂载，更新，销毁】 （1）beforeCreated 此时拿不到data中的数据（2）created data和methods初始化之后，此时可以拿到变量 （3）beforeMount 挂载之前拿不到真实的DOM （4）mounted 挂载之后，可以使用真实DOM （5）beforeUpdate 真实DOM更新之前（6）updated 更新之后，当数据发生变化并更新页面后执行，可以获取更新之后的DOM （7）beforeDestroy 销毁之前（8）destroyed 销毁之后<br>二十一、通过ref获取标签里面的对象（尤其是组件）this.$refs.值获取组件对象【组件通信，但不常用】<br>二十二、this.$nextTick(fn()) 原地返回Promise对象，使用 $nextTick 可以在下一次 DOM 更新周期结束之后执行回调函数，确保在更新后进行相关操作。<br>二十三、动态组件:<component :is=''>多个组件在同一个挂载点出现<br>二十四、组件缓存 <keep-alive></keep-alive>将包起来的组件缓存起来<br>二十三、在使用组件缓存的时候，会多出两个钩子函数：activated 激活状态 与deactivated失去激活状态<br>二十四、slot组件插槽：在组件内部不确定内容的位置设置slot标签，标签内是默认内容，父组件使用组件时中间的内容是插槽的内容<br>二十五、作用域插槽（使用插槽时，想使用子组件内的变量）①子组件在slot上bind绑定属性和值②使用组件时用v-slot&#x3D;名 获取到组件对象，进而使用组件对象中绑定的属性和值</p>\n<h2 id=\"二十六、Vue-router路由系统\"><a href=\"#二十六、Vue-router路由系统\" class=\"headerlink\" title=\"二十六、Vue-router路由系统\"></a>二十六、Vue-router路由系统</h2><p>①下载vue-router路由系统使用<br>yarn add vue-router<br>②在main.js中引入VueRouter函数,和带切换的页面<br>import VueRouter from ‘vue-router’<br>import My from ‘@&#x2F;views&#x2F;my’<br>③添加到Vue.use（）身上-注册全局RouterLinkRouterView组件<br>Vue.use(VueRouter)<br>④创建路由规则数组-路径和组件名对应关系<br>const routes &#x3D; [{path:’&#x2F;my’,component:My},{其他}]<br>⑤用规则生成路由对象<br>const router &#x3D; new VueRouter({<br>routes })<br>⑥将路由对象注入到new Vue实例中<br>new Vue({<br>  el: ‘#app’,<br>  router, &#x2F;&#x2F; 将路由对象注入到 Vue 实例中<br>  render: h &#x3D;&gt; h(App)<br>});<br>⑦App.vue中用router-view标签作为挂载点，切换不同的路由页面<br><router-view></router-view><br>—————export default router;导出之后可以全局进行引入(App.vue中export default{router,})<br>二十七、声明式导航（传参），①可以用<router-link to=\"url\"></router-link>，其中to里面不用写#号。标签来代替要跳转到指定页面的a标签（本质上相同，但是添加了自带类名，自带导航高亮）②跳转传参：方法一：在router-link中的to属性上传值 ，to&#x3D;”url&#x2F;path?参数名&#x3D;值”。在视图vue的标签中使用。方法二： 定义路由规则时添加路径{path：”&#x2F;first&#x2F;:name“ ” ,component:First}。然后传值<router-link to=\"/first/值\">&lt;&#x2F;&gt;。再使用</p>\n<p>二十八、路由重定向，在路由规则中进行匹配({path:”&#x2F;“,redirect:”&#x2F;find”})<br>二十九、路由404设置，找不到页面时进行返回404页面（404一定要在路由规则末尾），使用{path:”<em>“,component:NotFound}<br>三十、路由模式::①hash路由：url&#x2F;#&#x2F;home（哈希路由可以直接被浏览器识别）②history路由：url&#x2F;home③将hash路由更改为history路由：在new VueRouter配置项中mode:”history”（</em>注意history路由会将路径中识别为文件夹，要在服务器端进行设置）<br>三十九、路由守卫（main.js中对路由权限进行和判断）<br> <code>router.beforeEach(to,from,next)=&gt;&#123;</code><br> <code>//next是一个函数体，只有next()执行才会让路由正常跳转，next(false)则停留，next(&quot;修改到另一个路由路径&quot;，不执行则不跳转)</code><br>      <code>router.beforeEach((to,from,next)=&gt;&#123;</code><br>            <code>if(to.path === &#39;/my&#39; &amp;&amp; isLogin === false)&#123;</code><br>            <code>alert(&#39;请登录&#39;);    next(false)</code><br><code>&#125;else&#123;    next()        &#125;&#125;)&#125;</code><br>三十一、编程式导航（js方式跳转路由，先给标签添加点击事件，然后将路径作为值传进函数），接着在函数内部，方法一：this.$router.push({path:”函数中的路径值”})<br>方法二：this.$router.push({name:”路由名称”}) 注意用name跳转时，浏览器上的url不会改变（无感知跳转，方便修改）<br>三十二、编程式导航（跳转传参）方法一：①this.$router.push({path（或name）:”路由路径”,name:”路由名“，query:{“<br>参数名”：值}})②使用时用<br>方法二(使用path时会忽略params)：this.$router.push({name:”路由名称”,name:”路由名“，params:{“<br>参数名”：值}})②使用时用 <br>（可以组合但是path和params组合不能一起使用）<br>三十三、路由嵌套：①创建二级路由页面：views文件夹下新建文件夹和vue文件②main.js中配置二级路由{path:”&#x2F;first”,component:First,children:[{path:”one”,component:One},]} (*注意二级路由路径中不加&#x2F;符) ③在一级页面中设置<router-link to=\"二级路由路径\">，再设置<router-view>标签显示二级路由页面<br>三十四、router-link激活的2个类型的区别（url上的hash值包含a标签href，就添加模糊匹配的类名，若url上的hash和导航的a标签完全匹配就添加精确匹配的类名）<br>三十五、路由守卫：（main.js中，在生成路由对象之后）router.beforeEach((to,from,next)&#x3D;&gt;{ 判断和处理 })  【其中to表示要去到的url，from表示从哪里跳转的，next()调用才能让路由正常的跳转切换，next(false)在原地停留，next(‘强制修改到另一个路由路径上’)，如果不调用next,则页面留在原地 】<br>三十六、Vant组件库【Vant是一个轻量、可靠的移动端Vue组件库，开箱即用】 （注意vue版本号和vant版本号的兼容性问题）<br>三十七、支持组件自定义，在组件使用时传值，子组件中使用props接受 ，:style&#x3D;“{使用绑定的值和属性}”<br>三十八、将axios挂载到vue原型上，方便全局使用 </p>\n<p>【总结】 </p>\n<p>}</p>\n<h2 id=\"分析总结：\"><a href=\"#分析总结：\" class=\"headerlink\" title=\"****分析总结：\"></a>****分析总结：</h2><p>一、**动态组件和vue-router<br>动态组件可以根据具体的条件和状态来灵活地切换和加载组件，这种切换是在同一个组件内部进行的，不涉及 URL 的变化和页面的跳转。可以用于组件复用，条件渲染，动态加载和替换部分组件（轻量灵活，不需要路由跳转和重新渲染，组件复用减少代码重复）<br>二、编程式导航和路由式导航<br>①声明式导航（路由式导航）：</p>\n<p>声明式导航是通过在模板中使用指令（如 <router-link>）或组件（如 <router-view>）来定义和触发路由跳转的方式。</p>\n<p>它基于 Vue Router 提供的组件和指令，使得在模板中进行页面导航更加简洁和直观。</p>\n<p>②声明式导航适用于那些在模板中静态定义的导航链接，例如菜单、导航栏等。通过声明式导航，你可以直接在模板中定义导航链接，点击链接时自动触发路由跳转。<br>编程式导航：</p>\n<p>编程式导航是通过在代码中以编程方式触发路由跳转的方式。</p>\n<p>它使用路由实例的方法来进行导航，例如使用 router.push 方法进行页面跳转。</p>\n<p>编程式导航适用于那些需要根据特定条件或用户操作来触发页面跳转的场景。通过编程式导航，你可以在任何地方、任何时候根据需要进行页面的跳转。</p>\n<p>}<br>*<em><strong>注意</strong><br>&#x2F;</em> css中禁止双击选中文本 *&#x2F;<br>.element {<br>  user-select: none;<br>}</p>\n<p>原始类型的值不能直接取反，（true&amp;&amp;false）,可以使用Obj.true进行取反<br>当父亲组件给子组件传值，需要通过对象的项目引用的关系来影响对象里面的值时，需要使用props的对象方法，而不能用数组方法<br>element-ui适用于vue2项目，vue3项目需要使用element-plus<br>v-bind:“ ” ，里面是属性时直接写，里面不是属性时要加括号<br>v-for遍历对象时，加上key属性，有id绑定id，没有id绑定index<br>过滤器使用场景：①在插值语法中使用②在v-bind中value | 过滤器1 | 过滤器2<br>过滤器使用于差值表达式和动态绑定中：管道符前面是过滤器的第一个·参数，过滤器的第二个参数写在其()里面<br>计算属性：相比于函数带有缓存，减少了函数的执行<br>侦听器：①侦听值：watch:{变量名（newVal,oldVal）{改变时发生的事件}}<br>②侦听对象：watch:{“侦听的名称”：{immediate:true,deep:true,handler(newVal,oldVal){侦听值改变时的操作} }}<br>ajax ：异步请求后端的技术,基于原生ajax+Promise技术封装通用于前后端的请求库（原理是XMLHttpRequest）<br>@是vue中src的绝对路径（webpack）,#是当前页面的路径<br>props类型校验：props:{name:String,color:{type:String,required:true,default:red}} 其中有自定义校验规则(验证器validator)：validator(value){校验函数体}<br>v-model绑定input值时，只能使用简易的没有歧义的js语法，若要使用较难的js语法需要使用watch进行监听（监听对象时，需要用深度监听）<br>计算属性的get方法在访问这个计算属性时触发，当模板首次渲染，或者当计算属性所依赖的响应式数据发生变化时重新触发<br>arr.reduce((sum,obj)&#x3D;&gt;{函数体},0)  返回累加和sum，sum的初始值为0（自定义）</p>\n<h2 id=\"代码部分\"><a href=\"#代码部分\" class=\"headerlink\" title=\"代码部分\"></a>代码部分</h2><p>——————————————————————————————————————————【*】路由导航中代码：(main.js)</p>\n<p><code>import Vue from &#39;vue&#39;</code><br><code>import App from &#39;./App.vue&#39;</code><br><code>Vue.config.productionTip = false</code><br><code>// 引入</code><br><code>import VueRouter from &#39;vue-router&#39;</code><br><code>import First from &#39;@/views/First&#39;</code><br><code>import Second from &#39;@/views/Second&#39;</code><br><code>import Third from &#39;@/views/Third&#39;</code><br><code>import NotFound from &#39;@/views/NotFound&#39;</code><br><code>import ViewsOne from &#39;@/views/Second/ViewsOne&#39;</code><br><code>import ViewsTwo from &#39;@/views/Second/ViewsTwo&#39;</code><br><code>import ViewsThree from &#39;@/views/Second/ViewsThree&#39;</code></p>\n<p><code>// 注册全局组件</code><br><code>Vue.use(VueRouter)</code><br><code>// 规则数组</code><br><code>const routes = [</code><br>  <code>// 匹配默认hash值路径,重定向到页面，检测网页打开的默认路由</code><br>  <code>&#123;</code><br>    <code>path: &#39;/&#39;,</code><br>    <code>redirect: &quot;/second&quot;,</code><br>  <code>&#125;,</code><br>  <code>&#123;</code><br>    <code>path: &#39;/first&#39;,</code><br>    <code>component: First,</code><br>    <code>name: &quot;First&quot;,</code></p>\n<p>   &#96;&#96;meta:{title:”首页”}             &#x2F;&#x2F;meta元字符，用于传值，路由组件可以通过this.$route.mata.属性名 拿到&#96;</p>\n<p>  <code>&#125;,</code><br>  <code>&#123;</code><br>    <code>path: &#39;/second&#39;,</code><br>    <code>component: Second,</code><br>    <code>name: &#39;Second&#39;,</code><br>    <code>// 给页面配置二级路由</code><br>    <code>children: [</code><br>      <code>&#123;</code><br>        <code>path: &quot;viewsone&quot;,</code><br>        <code>component: ViewsOne</code><br>      <code>&#125;,</code><br>      <code>&#123;</code><br>        <code>path: &quot;viewstwo&quot;,</code><br>        <code>component: ViewsTwo</code><br>      <code>&#125;,</code><br>      <code>&#123;</code><br>        <code>path: &quot;viewsthree&quot;,</code><br>        <code>component: ViewsThree</code><br>      <code>&#125;,</code><br>    <code>]</code><br>  <code>&#125;,</code><br>  <code>&#123;</code><br>    <code>path: &#39;/third&#39;,</code><br>    <code>component: Third,</code><br>    <code>name: &quot;Third&quot;</code><br>  <code>&#125;,</code><br>  <code>// 绑定值给视图</code><br>  <code>&#123;</code><br>    <code>path: &#39;/first/:name&#39;,</code><br>    <code>component: First,</code><br>    <code>name: &#39;First&#39;</code><br>  <code>&#125;,</code><br>  <code>&#123;</code><br>    <code>path: &#39;/second/:name&#39;,</code><br>    <code>component: Second,</code><br>    <code>name: &quot;Second&quot;,</code><br>  <code>&#125;, &#123;</code><br>    <code>path: &#39;/third/:name&#39;,</code><br>    <code>component: Third,</code><br>    <code>name: &quot;Third&quot;</code><br>  <code>&#125;,</code><br>  <code>// 404一定在配置在规则数组最后</code><br>  <code>&#123;</code><br>    <code>path: &quot;*&quot;,</code><br>    <code>component: NotFound</code><br>    <code>, name: &quot;NotFound&quot;</code><br>  <code>&#125;</code></p>\n<p><code>]</code><br><code>// 生成路由对象</code><br><code>const router = new VueRouter(&#123;</code><br>  <code>// routes是固定的key，传入规则数组</code><br>  <code>routes,</code><br>  <code>// 默认不写是hash值</code><br>  <code>mode: &quot;history&quot;</code><br><code>&#125;)</code><br><code>// 路由守卫，根据路由做出判断</code><br><code>const isLogin = false</code><br><code>router.beforeEach((to, from, next) =&gt; &#123;</code><br>  <code>if (to.path === &#39;/first&#39; &amp;&amp; isLogin === false) &#123;</code><br>    <code>alert(&#39;请登录&#39;)</code><br>    <code>next(false)  //阻止路由跳转</code><br>  <code>&#125; else &#123;</code><br>    <code>next()  //正常放行</code><br>  <code>&#125;</code><br><code>&#125;)</code><br><code>new Vue(&#123;</code><br>  <code>router,</code><br>  <code>render: h =&gt; h(App),</code><br><code>&#125;).$mount(&#39;#app&#39;)</code></p>\n<h2 id=\"Vue项目工具\"><a href=\"#Vue项目工具\" class=\"headerlink\" title=\"Vue项目工具\"></a>Vue项目工具</h2><h6 id=\"1、vant组件库（移动端vue组件库）\"><a href=\"#1、vant组件库（移动端vue组件库）\" class=\"headerlink\" title=\"1、vant组件库（移动端vue组件库）\"></a>1、vant组件库（移动端vue组件库）</h6><p>一、下载安装（根据vue版本）、引入(import)和全局注册(Vue.use)（main.js中）、直接使用Vant组件名<br>二、按需引入：安装（<code>yarn add @vant/auto-import-resolver unplugin-vue-components -D</code>）、配置、使用、引入</p>\n<h6 id=\"2、element-ui（PC端vue组件库）\"><a href=\"#2、element-ui（PC端vue组件库）\" class=\"headerlink\" title=\"2、element-ui（PC端vue组件库）\"></a>2、element-ui（PC端vue组件库）</h6><h6 id=\"3、postcss-（vue项目插件，配合webpack翻译css代码）\"><a href=\"#3、postcss-（vue项目插件，配合webpack翻译css代码）\" class=\"headerlink\" title=\"3、postcss  （vue项目插件，配合webpack翻译css代码）\"></a>3、postcss  （vue项目插件，配合webpack翻译css代码）</h6><p>postcss-pxtorem （ 配合webpack , 自动将 px 转成 rem ）</p>\n<p>一、下载 postcss    和    postcss-pxtorem</p>\n<p><code>yarn  add  postcss  postcss-pxtorem</code></p>\n<p>&#96;二、文件夹 src下新建postcss.config.js</p>\n<p><code>module.exports = &#123;</code></p>\n<p><code>plugins:&#123;</code></p>\n<p><code>&#39;postcss-pxtorem&#39;:&#123;</code></p>\n<p><code>//能够将所有元素的px单位转成rem</code></p>\n<p><code>//rootValue：转换px的基准值。</code></p>\n<p><code>//例如一个元素宽是75px，转换成rem之后就是2rem 。</code></p>\n<p><code>rootValue:37.5 ,</code></p>\n<p><code>propList:[&#39;*&#39;]</code></p>\n<p><code>&#125;&#125;&#125;</code></p>\n<h2 id=\"Vuex介绍\"><a href=\"#Vuex介绍\" class=\"headerlink\" title=\"Vuex介绍\"></a>Vuex介绍</h2><pre><code class=\"js\">npm  install vuex --save\nimport  Vuex from  &#39;vuex&#39;\nVue.use(Vuex)\nconst store = new Vuex.Store(&#123; state:&#123;count:0&#125; &#125;) \nnew Vue(&#123; el:&#39;#app&#39;, render:h =&gt; h(app) , router , store &#125;)\n</code></pre>\n<h3 id=\"Vuex基础\"><a href=\"#Vuex基础\" class=\"headerlink\" title=\"Vuex基础\"></a>Vuex基础</h3><p>一、Vuex的介绍（创建store仓库，项目中大范围进行数据共享）<br>1、简介：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。<br>它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension (opens new window)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n<p>Vuex就是用来存放全局变量的，供所有组件使用</p>\n<p>2、通俗理解<br>Vuex相当于一个仓库，仓库中可以存全局变量，方法。一个项目一个仓库，Vuex充当项目的存储模块</p>\n<h4 id=\"Vuex的模块\"><a href=\"#Vuex的模块\" class=\"headerlink\" title=\"Vuex的模块\"></a>Vuex的模块</h4><h4 id=\"（store中：state、mutations（commit）、actions（dispatch）、getters（getters）、Module（-this-store-commit（’子模块名-x2F-键名‘））\"><a href=\"#（store中：state、mutations（commit）、actions（dispatch）、getters（getters）、Module（-this-store-commit（’子模块名-x2F-键名‘））\" class=\"headerlink\" title=\"（store中：state、mutations（commit）、actions（dispatch）、getters（getters）、Module（ this.$store.commit（’子模块名&#x2F;键名‘））\"></a>（store中：state、mutations（commit）、actions（dispatch）、getters（getters）、Module（ this.$store.commit（’子模块名&#x2F;键名‘））</h4><p>三大模块中  辅助函数  使用时导入：（使用辅助函数形式时，传参需要在事件发生处传值）     子组件中：</p>\n<pre><code class=\"js\">import &#123; mapState ,mapMutations,mapActions&#125; from &#39;vuex&#39;  //导入辅助函数\ncomputed:&#123;\n    ...mapState([&#39;键值&#39;])       //计算属性中使用state中的值\n    //直接使用\n&#125;\nmethods：&#123;\n    ...mapMutations([&#39;函数1&#39;，&#39;函数2&#39;])       //methods中使用Mutations中的函数\n    ...mapActions([&#39;函数1&#39;，&#39;函数2&#39;])        //methods中使用Actions中的异步函数\n    //直接使用\n&#125;\n</code></pre>\n<p>（模块中定义函数时，第一个参数为state，方便拿到其中的数据，通过state.数据名）</p>\n<h6 id=\"【1】state数据\"><a href=\"#【1】state数据\" class=\"headerlink\" title=\"【1】state数据\"></a>【1】<code>state</code>数据</h6><p>【】     共享状态数据，存数据</p>\n<p>（1）定义 （在main.js中Vuex.Store中：）</p>\n<p>（2）组件获得数据的方式：</p>\n<p>①组件通过$store.键名  获得数据</p>\n<p>②从vuex中按需导入mapState函数，将全局数据，映射为当前组件的计算属性（子组件中）</p>\n<pre><code class=\"js\">import  &#123; mapState &#125;  from  &#39;vuex&#39;\ncomputed:&#123; ...mapState([&#39;键名&#39;])  &#125;\n</code></pre>\n<h6 id=\"【2】mutaitions修改（函数）\"><a href=\"#【2】mutaitions修改（函数）\" class=\"headerlink\" title=\"【2】mutaitions修改（函数）\"></a>【2】<code>mutaitions</code>修改（函数）</h6><p>【】   修改state<strong>必须</strong>通过mutations，但其只能执行同步代码，改数据</p>\n<p>（1）定义函数，传参state，通过state.名得到state中的数据进行修改 （在main.js中Vuex.Store中：）</p>\n<p>（2）组件在组件函数中，通过如下，调用state中的函数并传参</p>\n<pre><code class=\"vue\">this.$store.commit（&#39;函数名&#39;，形参）\n//main.js中：\nmutations:&#123;函数名：&#125;\n</code></pre>\n<p>（3）<code>...mapMutations([&#39;函数名&#39;,’函数名2‘])  辅助函数</code>（***需要导入），组件函数中使用，子组件函数名与mutations中函数名保持一致，</p>\n<p>传参在事件发生处（@click&#x3D;’fn(参数)’）</p>\n<pre><code>子组件中import  &#123; mapMutations ..等 &#125;  from  &#39;vuex&#39;\nmethods中：&#123;...mapMutations([&#39;键名1，键名2&#39;]) ,\n 函数()里通过  this.键名() 调用\n</code></pre>\n<h6 id=\"【3】actions-异步\"><a href=\"#【3】actions-异步\" class=\"headerlink\" title=\"【3】actions   异步\"></a>【3】<code>actions</code>   异步</h6><p>【】执行异步操作，数据提交给<strong>mutations</strong>进行修改，从后端获取数据，更新到state中的count中（main.js中）</p>\n<p>【】注意在action中，不能直接修改state中的数据，必须通过<strong>context.commit（）函数</strong>触发某个mutation才行（main.js中）</p>\n<p>（1）在actions中定义函数并传参 （在main.js中Vuex.Store中：）</p>\n<p>（2）actions方法参数：</p>\n<p>①<code>context</code>，相当于组件中的this.$store，即获得store中的值</p>\n<p>②形参，用于传值</p>\n<p>（3）组件中调用actions（传参时，在定义actions函数时要接收）</p>\n<p>①原始形式调用：<code>this.$store.dispatch(&quot;函数名&quot;，形参)</code></p>\n<p>②辅助函数形式调用（***需要导入）：</p>\n<p>子组件中导入，methods方法中使用：</p>\n<pre><code class=\"vue\">...mapActions([&#39;函数名&#39;,&#39;函数名2&#39;]，)\n//子组件函数中调用（如下）  或者直接在子组件触发事件上使用函数 @click=&quot;函数名(形参)&quot;\n子组件函数()&#123;\nthis.函数名（形参）\nthis.函数名2(形参)  &#125;\n</code></pre>\n<h6 id=\"【4】getters计算（包装数据）\"><a href=\"#【4】getters计算（包装数据）\" class=\"headerlink\" title=\"【4】getters计算（包装数据）\"></a>【4】<code>getters</code>计算（包装数据）</h6><p>【】从state中派生出一些状态，这些状态是依赖state的（相当于计算属性，二次处理数据），此时会用到getters</p>\n<p>（1）定义getters，并传参（在main.js中Vuex.Store中：）</p>\n<p>（2）组件中调用getters  </p>\n<p>①原始形式调用：<code>this.$store.getters.函数名</code>,  接着直接在页面使用： </p>\n<p>②辅助函数调用：（***需要引入）: …mapGetters([‘函数名’，’函数名2‘])    导入到computed计算属性中，页面中    使用</p>\n<h6 id=\"【5】Module模块化\"><a href=\"#【5】Module模块化\" class=\"headerlink\" title=\"【5】Module模块化\"></a>【5】<code>Module</code>模块化</h6><p>【】所有的数据、更新、操作都在一起，项目越大，越难维护，因此推出Vuex模块化（子模块中使用）</p>\n<p>（1）定义子模块Modules （在main.js中Vuex.Store中：）</p>\n<pre><code class=\"vue\">modules:&#123;  子模块name1:&#123;state:&#123; 键：值 &#125;&#125; ， 子模块name2:&#123;state:&#123; 键：值 &#125;&#125;  &#125; \n</code></pre>\n<p>（2）组件中使用</p>\n<pre><code class=\"vue\">$store.state.子模块name.子模块键\n</code></pre>\n<p>（3）快捷使用</p>\n<p>在getters中定义，之后直接使用自定义的名称（①引入mapGetters，②在computed中扩展 ：…mapGetters([‘自定义名1’，’名2’])）</p>\n<pre><code class=\"vue\">getters:&#123;  自定义名  : state =&gt; state.子模块名.子模块键 ，    &#125;\n</code></pre>\n<h6 id=\"【6】模块化中的namespaced命名空间\"><a href=\"#【6】模块化中的namespaced命名空间\" class=\"headerlink\" title=\"【6】模块化中的namespaced命名空间\"></a>【6】模块化中的<code>namespaced</code>命名空间</h6><p>【】默认情况下，模块内部的action、mutation和getter是注册在全局命名空间的，这样使得多个模块能够对同一mutation或者action做出响应</p>\n<p>（各模块中函数中state表示子模块中的state），此时可以通过namespaced命名空间 对模块进行封锁</p>\n<p>（1）使用命名空间：</p>\n<pre><code class=\"vue\">modules:&#123;  子模块名1： namespaced:true   ,state:&#123;....&#125;,.....   &#125;\n</code></pre>\n<p>（2）调用数据的方法:</p>\n<p>开启命名空间后，组件中读取state数据：<br>①&#x2F;&#x2F;方式一：自己直接读取</p>\n<pre><code>this.$store.state.personAbout.list\n</code></pre>\n<p>②&#x2F;&#x2F;方式二：借助mapState读取：</p>\n<pre><code>...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\n</code></pre>\n<p>开启命名空间后，组件中读取getters数据：<br>&#x2F;&#x2F;方式一：自己直接读取<br>![</p>\n<pre><code>this.$store.getters[&#39;personAbout/firstPersonName&#39;]\n</code></pre>\n<p>]()</p>\n<p>&#x2F;&#x2F;方式二：借助mapGetters读取：</p>\n<pre><code>...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])\n</code></pre>\n<ol start=\"5\">\n<li>开启命名空间后，组件中调用dispatch<br> &#x2F;&#x2F;方式一：自己直接dispatch</li>\n</ol>\n<pre><code>this.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)\n</code></pre>\n<p>&#x2F;&#x2F;方式二：借助mapActions：</p>\n<pre><code>...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)\n</code></pre>\n<p>开启命名空间后，组件中调用commit<br>&#x2F;&#x2F;方式一：自己直接commit</p>\n<pre><code>this.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)\n</code></pre>\n<p>&#x2F;&#x2F;方式二：借助mapMutations：</p>\n<pre><code>...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),\n</code></pre>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"使用、配置Vuex\"><a href=\"#使用、配置Vuex\" class=\"headerlink\" title=\"使用、配置Vuex\"></a>使用、配置Vuex</h3><h4 id=\"main-js中配置，组件通过this-store获得\"><a href=\"#main-js中配置，组件通过this-store获得\" class=\"headerlink\" title=\"(main.js中配置，组件通过this.$store获得 )\"></a>(main.js中配置，组件通过this.$store获得 )</h4><p>1、安装：进入项目终端，输入<br>npm install vuex@3</p>\n<p>2、引入</p>\n<p>1）终端启动项目</p>\n<p>npm run serve<br>（2）在mian.js文件引入vuex，使用Vuex</p>\n<pre><code class=\"js\">import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\nimport Vuex from &#39;vuex&#39;    //引入\n\nVue.config.productionTip = false\n\nVue.use(Vuex)    //使用\n\nnew Vue(&#123;\n  router,\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n</code></pre>\n<p>3、创建使用实例</p>\n<pre><code class=\"js\">import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\nimport Vuex from &#39;vuex&#39;//引入\n\nVue.config.productionTip = false\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store(&#123;&#125;)    //创建实例，注意Vuex.Store的大小写\n\nnew Vue(&#123;\n  router,\n  store,    //使用\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n</code></pre>\n<p>4、代码例子</p>\n<pre><code class=\"js\">import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\nimport Vuex from &#39;vuex&#39;//引入\n\nVue.config.productionTip = false\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store(&#123;\n  state:&#123;\n    count:0,\n  &#125;,\n&#125;)\n\nnew Vue(&#123;\n  router,\n  store,\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n</code></pre>\n<p> 去任意页面获取显示count数据</p>\n<template>\n  <div class=\"home\">\n    <h1>这是count：</h1>\n  </div>\n</template>\n### 项目中使用vuex\n\n<p>一、在src文件中新建store下新建modules下新建 模块名 . js文件</p>\n<p>二、模块中结构：</p>\n<pre><code class=\"vue\">export default&#123;\nnamespaced:true , state&#123;&#125; , mutations:&#123;&#125; , actions:&#123;&#125;       &#125;\n</code></pre>\n<p>三、在store下index.js中引入定义的模块</p>\n<pre><code class=\"vue\">import  模块名  from  &#39;路径&#39;\nexport  default  new  Vuex.Store(&#123;\nstate:&#123;&#125; , mutations:&#123;&#125; , actions:&#123;&#125; , modules:&#123;模块名1，模块名2&#125;     &#125;)\n</code></pre>\n<h6 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h6><p>1、新建<br>文件夹store–&gt;在文件夹下新建store.js–&gt;进行以下配置</p>\n<p>import Vuex from ‘vuex’<br>import Vue from ‘vue’</p>\n<p>Vue.use(Vuex)</p>\n<p>const store &#x3D; new Vuex.Store({<br>    state:{<br>      count:0,<br>    },<br>  })</p>\n<p>export default store    &#x2F;&#x2F;将值导出给main.js<br> 2、main.js文件<br>import Vue from ‘vue’<br>import App from ‘.&#x2F;App.vue’<br>import router from ‘.&#x2F;router’<br>import store from ‘@&#x2F;store&#x2F;store’    &#x2F;&#x2F;引入</p>\n<p>Vue.config.productionTip &#x3D; false</p>\n<p>new Vue({<br>  router,<br>  store,    &#x2F;&#x2F;使用<br>  render: h &#x3D;&gt; h(App)<br>}).$mount(‘#app’)<br>四、state状态存放<br>1、简介<br>用于存放全局变量，供任意组件访问</p>\n<p>2、使用：$store.state.变量名<br>（1）在store.js这个封装文件，定义需要的变量</p>\n<p>import Vuex from ‘vuex’<br>import Vue from ‘vue’</p>\n<p>Vue.use(Vuex)</p>\n<p>const store &#x3D; new Vuex.Store({<br>    state:{<br>      count:0,<br>      userInfo:[<br>        {<br>            name:’申小兮’,<br>            age:18,<br>        },<br>        {<br>            name:’老墨’,<br>            age:34,<br>        },<br>      ]<br>    },<br>  })</p>\n<p>export default store</p>\n<p>（2）在任意vue文件进行输出，显示</p>\n<template>\n  <div class=\"home\">\n    <h1>这是count：</h1>\n    <h1>卖鱼的</h1>\n    <!-- <HelloWorld msg=\"Welcome to Your Vue.js App\"/> -->\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\n\nexport default {\n  name: 'HomeView',\n  created(){\n    console.log('count',this.$store.state.count);\n    console.log('userInfo',this.$store.state.userInfo);\n  }\n}\n</script>\n\n\n\n<h6 id=\"getters状态派生\"><a href=\"#getters状态派生\" class=\"headerlink\" title=\"getters状态派生\"></a>getters状态派生</h6><p>1、简介<br>有时候我们需要从 store 中的 state 中派生出一些状态，类似Vue中的computed计算属性的功能，例如：格式化数据等。</p>\n<p>处理数据：当我们想用或修改的数据，在多个组件或页面，且需要统一修改时，这个状态可以很方便进行修改。</p>\n<p>使用：$store.getters.变量名</p>\n<p>2、参数<br>（1）state参数：每个getters都是一个方法，接受 state 作为其第一个参数，用来访问vuex中的state数据</p>\n<p>import Vuex from ‘vuex’<br>import Vue from ‘vue’</p>\n<p>Vue.use(Vuex)</p>\n<p>const store &#x3D; new Vuex.Store({<br>    state:{<br>      count:0,<br>      userInfo:[<br>        {<br>            name:’申小兮’,<br>            age:18,<br>        },<br>        {<br>            name:’老墨’,<br>            age:34,<br>        },<br>      ]<br>    },<br>    getters:{<br>        info(state){<br>            console.log(state);<br>            return <code>告诉$&#123;state.userInfo[1].name&#125;，我想吃鱼了</code><br>        }<br>    }<br>  })</p>\n<p>export default store</p>\n<template>\n  <div class=\"home\">\n    <h1>这是count：</h1>\n    <h1>卖鱼的</h1>\n    <h2></h2>\n    <!-- <HelloWorld msg=\"Welcome to Your Vue.js App\"/> -->\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\n\nexport default {\n  name: 'HomeView',\n  created(){\n    // console.log('count',this.$store.state.count);\n    // console.log('userInfo',this.$store.state.userInfo);\n    console.log('getters',this.$store.getters.info);\n  }\n}\n</script>\n\n\n\n<p> （2）getter参数：获取自己本身的数据</p>\n<p>getters:{<br>    info(state,getter){<br>        console.log(‘state：’,state);<br>        console.log(‘getter：’,getter);<br>        return <code>告诉$&#123;state.userInfo[1].name&#125;，我想吃鱼了</code><br>    }<br>}</p>\n<p>3、绑定点击改值事件<br>事件的错误使用</p>\n<template>\n  <div class=\"home\">\n    <h1>这是count：</h1>\n    <div>\n      <button @click=\"add\">+</button>\n      <button @click=\"sub\">-</button>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'HomeView',\n  created(){\n    console.log('getters',this.$store.getters.info);\n  },\n  methods:{\n    add(){\n      this.$store.state.count++\n    },\n    sub(){\n\n    }\n  }\n}\n</script>\n\n\n\n<p>观察上图发现：在点击改变count值时，虽然页面跟着变化了，但是vuex检测系统并没有变化，只有鼠标去触发才会更新</p>\n<p>那么怎样才能正确修改count值呢？这时候就要介绍第三个状态mutations🧐</p>\n<h6 id=\"mutations状态修改\"><a href=\"#mutations状态修改\" class=\"headerlink\" title=\"mutations状态修改\"></a>mutations状态修改</h6><p>1、简介<br>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)，类似Vue【子向父通信】的emit</p>\n<p>每个mutations都是一个方法，接受 state 作为第一个参数，payload 作为第二个参数</p>\n<p>（1）state：用来访问vuex中的state数据</p>\n<p>（2）payload：获取此次mutation提交的数据荷载</p>\n<p>注意：mutation中不能在异步函数里修改state值，必须是同步函数</p>\n<p>2、使用<br>（1）提交形式：$store.commit(type, payload)</p>\n<p>（2）state参数</p>\n<p>mutations:{<br>    addCount(state){<br>        console.log(‘M’,state);<br>        state.count++<br>    }<br>}<br>add(){<br>    this.$store.commit(‘addCount’)<br>},<br>（3）payload参数</p>\n<p>mutations:{<br>    addCount(state,payload){<br>        console.log(‘M’,state);<br>        state.count+&#x3D;payload<br>    }<br>}<br>add(){<br>  this.$store.commit(‘addCount’,10)<br>},</p>\n<p> （4）对象写法</p>\n<p>add(){<br>  this.$store.commit({<br>    type:’addCount’,<br>    num:10<br>  })<br>},<br>mutations:{<br>    addCount(state,payload){<br>        console.log(‘M’,state);<br>        state.count+&#x3D;payload.num<br>    }<br>}<br>3、模拟接口<br>（1）例子1：接口是异步的，我们用定时器类比</p>\n<p>mutations:{<br>    getStudentInfo(state){<br>        setTimeout(()&#x3D;&gt;{<br>            let info &#x3D; {name:”张三”,age:43}<br>            state.studentInfo.push(info)<br>        })<br>    }<br>}<br>created(){<br>  this.$store.commit(‘getStudentInfo’)<br>},</p>\n<h3></h3>\n（2） 例子2：在异步中改变count\n\n<p>addCount(state,payload){<br>    console.log(‘M’,state);<br>    setTimeout(()&#x3D;&gt;{<br>        state.count+&#x3D;payload.num<br>    })<br>},</p>\n<p> 这时候发现，vue编译器每次会比实际数据慢一次，这个问题是为什么？因为mutation无法处理异步问题</p>\n<p>注意：mutation必须是同步函数，这时候就引出第四个状态actions，来解决mutation的异步问题</p>\n<h6 id=\"actions状态修改\"><a href=\"#actions状态修改\" class=\"headerlink\" title=\"actions状态修改\"></a>actions状态修改</h6><p>1、简介<br>Action 类似于 mutation，不同的是Action用于提交mutation，而不是直接变更状态；且Action 可以包含任意异步操作</p>\n<p>2、使用<br>每个Action都是一个方法，接受 context 作为第一个参数，payload 作为第二个参数</p>\n<p>（1）提交形式：$store.dispatch(type, payload)</p>\n<p>（2）参数</p>\n<p>①context参数：store实例对象，用以调用mutation、访问state</p>\n<p>②payload参数：获取此次mutation提交的数据荷载</p>\n<p>（3）解决第六大点mutations无法解决的异步问题</p>\n<p>mutations:{<br>    addCount(state,payload){<br>        console.log(‘M’,state);<br>        state.count+&#x3D;payload.num<br>    },<br>    getStudentInfo(state,payload){<br>        state.studentInfo &#x3D; payload<br>    }<br>},<br>actions:{<br>    getInfoApi(context){<br>        setTimeout(()&#x3D;&gt;{<br>            let info &#x3D; {name:”张三”,age:43}<br>            context.commit(‘getStudentInfo’,info)<br>        })<br>    },<br>    addTime(context){<br>        setTimeout(()&#x3D;&gt;{<br>            context.commit({type:’addCount’,num:10})<br>        })<br>    }<br>}</p>\n<p>methods:{<br>  add(){<br>    this.$store.dispatch(‘addTime’)<br>  },<br>  sub(){<br>    this.$store.dispatch(‘getInfoApi’)<br>  }<br>}</p>\n<template>\n  <div class=\"home\">\n    <h1>这是count：</h1>\n    <div>\n      <button @click=\"add\">+</button>\n      <button @click=\"sub\">-</button>\n    </div>\n    <h3></h3>\n  </div>\n<template>\n\n<p>（5）几个状态使用的连接</p>\n<p>①State：存储数据。调用语句$store.state.变量名<br>②Getter：更好的处理数据，但是无法实时改变后台数据。调用语句$store.getter.变量名<br>③Mutation：任意更改state的数据，但是只允许同步函数。调用语句$store.commit(type, payload)<br>④Action：不能改state数据，但是可以帮助mutation做异步操作。调用语句$store.dispatch(type, payload)</p>\n<p>八、Module模块化<br>1、简介<br>（1）原因：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>\n<p>（2）解决：为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter。</p>\n<p>2、理解<br>将 store 内的state、mutation、action、getter每个完整的对象分割成一个个单独的模块（module），然后写成一个变量导入。</p>\n<p>通常是在做大项目时候才会用上</p>\n<p>3、例子<br>这里举一个简易的例子</p>\n<p>（1）将state、mutation、action、getter单独到外面</p>\n<p>import Vuex from “vuex”;<br>import Vue from “vue”;</p>\n<p>Vue.use(Vuex);</p>\n<p>const moduleA &#x3D; {<br>  namespaced: true, &#x2F;&#x2F;命名空间<br>  state: {<br>    count: 0,<br>  },<br>};</p>\n<p>const store &#x3D; new Vuex.Store({<br>  modules: {<br>    a: moduleA,<br>  },<br>});</p>\n<p>export default store;</p>\n<p>（2）这时候获取及显示数据的写法要有所改变</p>\n<template>\n  <div class=\"about\">\n    <h1>这是count：</h1>\n    <!-- <h1>This is an about page</h1> -->\n  </div>\n</template>\n4、相关文档\n小伙伴们可以查看文档，深入学习🧐\n\n<p>Module | Vuex<br>Vue.js 的中心化状态管理方案<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly92dWV4LnZ1ZWpzLm9yZy96aC9ndWlkZS9tb2R1bGVzLmh0bWw=\">https://vuex.vuejs.org/zh/guide/modules.html</span></p>\n<p>九、拓展<br>1、关于vuex编写登录模块的思想流程</p>\n<p> 2、vue-cookie的使用，小伙伴们可以在下面这个网站进行学习<br>————————————————<br>版权声明：本文为CSDN博主「五秒法则」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNDc4NzQ1L2FydGljbGUvZGV0YWlscy8xMjk1ODI3MTc=\">https://blog.csdn.net/qq_51478745/article/details/129582717</span></p>\n","categories":["Vue"],"tags":["Vue"]},{"title":"jest","url":"/2024/03/30/jest/","content":"<h1 id=\"jest测试\"><a href=\"#jest测试\" class=\"headerlink\" title=\"jest测试\"></a>jest测试</h1><p>市面上有很多测试框架，例如：mocha 、jasmine、vue test utils、vitest、react testing library和testing frameworks for jacascript等，但语法和思想大致相同，现在依jest框架进行简单的使用</p>\n<pre><code class=\"js\">/**\n * jest简单的语法\n * expect  toBe 语法\n */\ntest(&#39;tow plus to 4&#39;,()=&gt;&#123;\n    expect(2+2).toBe(4);\n&#125;)\n/**\n * toEqual语法，递归检查对象或数组的每个字段\n */\ntest(&#39;object assignment&#39;,()=&gt;&#123;\n    const data = &#123;name:&quot;张三&quot;&#125;;\n    data[&#39;age&#39;] = 18;\n    expect(data).toEqual(&#123;name:&quot;张三&quot;,age:18&#125;)\n&#125;)\n/**\n * expect  not  toBe\n */\ntest(&#39;adding is not 0&#39;,()=&gt;&#123;\n    for(let i=0;i&lt;10;i++)&#123;\n        for(let j=0;j&lt;5;j++)&#123;\n            expect(i + j).not.toBe(-1);\n        &#125;\n    &#125;\n&#125;)\n/**\n * 检查指定空类型（null,undefined,defined，true和false）\n */\ntest(&#39;toBe null&#39;,()=&gt;&#123;\n    const n = null;\n    expect(n).toBeNull();\n&#125;)\ntest(&#39;toBe defined&#39;,()=&gt;&#123;\n    const n = 1;\n    expect(n).toBeDefined();\n&#125;)\ntest(&#39;toBe Undefined&#39;,()=&gt;&#123;\n    let n;\n    expect(n).toBeUndefined();\n&#125;)\ntest(&#39;toBe Truthy&#39;,()=&gt;&#123;\n    const n = 1;\n    const m = true;\n    expect(n &amp;&amp; m).toBeTruthy();\n&#125;)\ntest(&#39;toBe falsy&#39;,()=&gt;&#123;\n    const n = 0;\n    const m = false;\n    expect(n &amp;&amp; m).toBeFalsy();\n&#125;)\n/**\n * jest对0进行精确测试的结果\n */\ntest(&#39;zero&#39;, () =&gt; &#123;\n    const z = 0;\n    expect(z).not.toBeNull(); //非null\n    expect(z).toBeDefined(); //defined\n    expect(z).not.toBeUndefined(); \n    expect(z).not.toBeTruthy(); //非true\n    expect(z).toBeFalsy(); //false\n  &#125;);\n/**\n * jest测试数字\n */\ntest(&#39;two and two&#39;,()=&gt;&#123;\n    const value = 2 + 2;\n    expect(value).toBeGreaterThan(3);\n    expect(value).toBeGreaterThanOrEqual(4)\n    expect(value).toBeLessThanOrEqual(4.5)\n    expect(value).toBeLessThanOrEqual(4)\n    expect(value).toBe(4)\n    expect(value).toEqual(4)\n&#125;)\n/**\n * toBeCloseTo检查浮点数相等\n */\ntest(&#39;test float number&#39;,()=&gt;&#123;\n    const value = 0.1 + 0.2;\n    // expect(value).toBe(0.3)  报错，因为计算机精度的原因\n    expect(value).toBeCloseTo(0.3)\n&#125;)\n/**\n * toMatch根据正则表达式检查字符串\n */\ntest(&#39;test reg&#39;,()=&gt;&#123;\n    expect(&#39;team&#39;).not.toMatch(/I/)\n    expect(&#39;Christoph&#39;).toMatch(/stop/)\n    expect(&#39;hello world&#39;).toMatch(&#39;lo w&#39;)\n&#125;)\n/**\n * toContain测试数组和可迭代对象\n */\nconst List = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];\ntest(&#39;list to be&#39;,()=&gt;&#123;\n    expect(List).toContain(&#39;c&#39;);\n    expect(List).not.toContain(1);\n&#125;)\n/**\n * 测试异步代码\n */\nconst testPromise = Promise.resolve(&#39;hello&#39;);\n//1 使用return\ntest(&#39;return异步代码&#39;,()=&gt;&#123;\n    return testPromise.then(data=&gt;&#123;\n        expect(data).toBe(&#39;hello&#39;)\n    &#125;)\n&#125;)\n//2 使用async和await语法\nfunction fetchMessage() &#123;\n    return new Promise((resolve) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(&#39;hello&#39;);\n        &#125;, 1000);\n    &#125;);\n&#125;\ntest(&#39;async and await&#39;, async () =&gt; &#123;\n    const result = await fetchMessage();\n    expect(result).toBe(&#39;hello&#39;);\n&#125;);\n//expect.assertions验证是否调用了一定数量的断言，确保兑现的承若通过测试\n//catch捕捉（确保Promise不会被兑现）\n// test(&#39;catch fails with errors&#39;,()=&gt;&#123;\n//     return fetchData2().catch(e=&gt;expect(e).toMatch(&#39;error&#39;))\n// &#125;)\n\n// 3 使用回调函数done\ntest(&#39;done to async&#39;,(done)=&gt;&#123;\n    testPromise.then(res=&gt;&#123;\n        expect(res).toBe(&#39;hello&#39;);\n    &#125;)\n    done();\n&#125;)\n// 4 .resolves匹配器等待Promise解析（reject则失败）\ntest(&#39;.resolves匹配器&#39;,()=&gt;&#123;\n    expect(testPromise).resolves.toBe(&#39;hello&#39;)\n&#125;)\n/**\n * beforeEach和afterEach钩子函数\n * 当每一个测试之前或之后都需要调用相同的方法就可以使用这两个钩子函数\n */\n\n/**\n * describe块\n */\n\n/**\n * test.only只运行一个测试\n */\ntest.only(&#39;test only&#39;,()=&gt;&#123;\n    expect(&#39;test only&#39;).toMatch(&#39;t o&#39;)\n&#125;)\n</code></pre>\n","categories":["TDD"],"tags":["jest"]},{"title":"json-server","url":"/2023/01/09/json-server%E6%95%99%E7%A8%8B/","content":"<h4 id=\"0-json-server-搭建本地接口\"><a href=\"#0-json-server-搭建本地接口\" class=\"headerlink\" title=\"0. json-server 搭建本地接口\"></a>0. json-server 搭建本地接口</h4><h5 id=\"0-1-安装-json-server\"><a href=\"#0-1-安装-json-server\" class=\"headerlink\" title=\"0.1 安装 json-server\"></a>0.1 安装 json-server</h5><ul>\n<li><p>使用 <strong>npm</strong> &#x3D;&#x3D;全局&#x3D;&#x3D;安装 <strong>json-server</strong></p>\n<pre><code class=\"bash\">npm install -g json-server\n</code></pre>\n</li>\n<li><p>检测是否安装成功</p>\n<pre><code class=\"bash\">json-server -v\n</code></pre>\n</li>\n</ul>\n<h5 id=\"0-2-准备数据文件（已准备好，这两步不用自己做）\"><a href=\"#0-2-准备数据文件（已准备好，这两步不用自己做）\" class=\"headerlink\" title=\"0.2 准备数据文件（已准备好，这两步不用自己做）\"></a>0.2 准备数据文件（已准备好，这两步不用自己做）</h5><ol>\n<li><p>电脑方便找到的任意位置创建一个&#x3D;&#x3D;文件夹&#x3D;&#x3D;，进入到该文件夹里面，创建一个&#x3D;&#x3D;JSON文件&#x3D;&#x3D;</p>\n<ul>\n<li><p>文件夹和JSON文件的名字可以任意设计，但是&#x3D;&#x3D;不能出现中文&#x3D;&#x3D;</p>\n</li>\n<li><p>比如：文件夹名字：<code>service/</code>；JSON文件名字：<code>db.json</code></p>\n</li>\n</ul>\n</li>\n<li><p>在<code>db.json</code>文件中，准备&#x3D;&#x3D;JSON格式的数据&#x3D;&#x3D;</p>\n<pre><code class=\"json\">&#123;\n  &quot;address&quot;: [\n    &#123;\n      &quot;id&quot;: 101,\n      &quot;receiver&quot;: &quot;李白姓白&quot;,\n      &quot;mobile&quot;: &quot;13800000101&quot;,\n      &quot;province&quot;: &quot;浙江省&quot;,\n      &quot;city&quot;: &quot;杭州市&quot;,\n      &quot;area&quot;: &quot;西湖区&quot;,\n      &quot;location&quot;: &quot;西湖大道101号&quot;,\n      &quot;state&quot;: 1\n    &#125;,\n    &#123;\n      &quot;id&quot;: 102,\n      &quot;receiver&quot;: &quot;苏轼&quot;,\n      &quot;mobile&quot;: &quot;13800000102&quot;,\n      &quot;province&quot;: &quot;北京市&quot;,\n      &quot;city&quot;: &quot;北京市&quot;,\n      &quot;area&quot;: &quot;昌平区&quot;,\n      &quot;location&quot;: &quot;西湖大道102号&quot;,\n      &quot;state&quot;: 0\n    &#125;,\n    &#123;\n      &quot;receiver&quot;: &quot;韩愈&quot;,\n      &quot;mobile&quot;: &quot;13800000103&quot;,\n      &quot;province&quot;: &quot;浙江省&quot;,\n      &quot;city&quot;: &quot;杭州市&quot;,\n      &quot;area&quot;: &quot;西湖区&quot;,\n      &quot;location&quot;: &quot;西湖大道103号&quot;,\n      &quot;state&quot;: 1,\n      &quot;id&quot;: 103\n    &#125;\n  ]\n&#125;\n</code></pre>\n</li>\n</ol>\n<h5 id=\"0-3-启动-json-server-本地服务\"><a href=\"#0-3-启动-json-server-本地服务\" class=\"headerlink\" title=\"0.3 启动 json-server 本地服务\"></a>0.3 启动 json-server 本地服务</h5><ul>\n<li><p>在<code>service/</code>文件夹下，进入终端，执行启动 json-server 命令</p>\n</li>\n<li><p>&#x3D;&#x3D;第一种&#x3D;&#x3D;：<strong>默认启动方式</strong>，&#x3D;&#x3D;只能在自己的计算机中访问自己的数据，其他计算机无法访问你的数据&#x3D;&#x3D;</p>\n<pre><code class=\"bash\">json-server --watch db.json\n</code></pre>\n<blockquote>\n<p>测试访问：<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDozMDAwL2FkZHJlc3M=\">http://localhost:3000/address</span></p>\n</blockquote>\n</li>\n<li><p>&#x3D;&#x3D;第二种&#x3D;&#x3D;：<strong>自定义启动方式</strong>，在局域环境内，&#x3D;&#x3D;其他计算机也可以访问你计算机中的数据&#x3D;&#x3D;</p>\n<ul>\n<li><p>命令规范：<code>json-server --host 本机IP地址 db.json --port 端口号</code></p>\n<pre><code class=\"bash\">json-server --host 192.168.28.95 db.json --port 5000\n</code></pre>\n<blockquote>\n<p>测试访问：<span class=\"exturl\" data-url=\"aHR0cDovLzE5Mi4xNjguMjguOTU6NTAwMC9hZGRyZXNz\">http://192.168.28.95:5000/address</span></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["json-server"],"tags":["json-server"]},{"title":"jQuery","url":"/2023/01/02/jQuery%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8/","content":"<h1 id=\"jQuery基本概念\"><a href=\"#jQuery基本概念\" class=\"headerlink\" title=\"jQuery基本概念\"></a>jQuery基本概念</h1><blockquote>\n<p>学习目标：学会如何使用jQuery，掌握jQuery的常用api，能够使用jQuery实现常见的效果。</p>\n</blockquote>\n<h6 id=\"为什么要学习jQuery？\"><a href=\"#为什么要学习jQuery？\" class=\"headerlink\" title=\"为什么要学习jQuery？\"></a>为什么要学习jQuery？</h6><p>【01-让div显示与设置内容.html】</p>\n<p>使用javascript开发过程中，有许多的缺点：</p>\n<pre><code class=\"javascript\">1. 查找元素的方法太少，麻烦。\n2. 遍历伪数组很麻烦，通常要嵌套一大堆的for循环。\n3. 有兼容性问题。\n4. 想要实现简单的动画效果，也很麻烦\n5. 代码冗余。\n</code></pre>\n<h6 id=\"jQuery初体验\"><a href=\"#jQuery初体验\" class=\"headerlink\" title=\"jQuery初体验\"></a>jQuery初体验</h6><p>优点总结：</p>\n<pre><code class=\"javascript\">1. 查找元素的方法多种多样，非常灵活\n2. 拥有隐式迭代特性，因此不再需要手写for循环了。\n3. 完全没有兼容性问题。\n4. 实现动画非常简单，而且功能更加的强大。\n5. 代码简单、粗暴。\n</code></pre>\n<h6 id=\"什么是jQuery\"><a href=\"#什么是jQuery\" class=\"headerlink\" title=\"什么是jQuery?\"></a>什么是jQuery?</h6><blockquote>\n<p>jQuery的官网 <span class=\"exturl\" data-url=\"aHR0cDovL2pxdWVyeS5jb20v\">http://jquery.com/</span><br>jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。</p>\n</blockquote>\n<p>js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js、common.js）</p>\n<p>我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。</p>\n<h6 id=\"jQuery的版本\"><a href=\"#jQuery的版本\" class=\"headerlink\" title=\"jQuery的版本\"></a>jQuery的版本</h6><blockquote>\n<p>官网下载地址：<span class=\"exturl\" data-url=\"aHR0cDovL2pxdWVyeS5jb20vZG93bmxvYWQv\">http://jquery.com/download/</span><br>jQuery版本有很多，分为1.x 2.x 3.x</p>\n</blockquote>\n<h6 id=\"jQuery的入口函数\"><a href=\"#jQuery的入口函数\" class=\"headerlink\" title=\"jQuery的入口函数\"></a>jQuery的入口函数</h6><p>使用jQuery的三个步骤：</p>\n<pre><code class=\"javascript\">1. 引入jQuery文件\n2. 入口函数\n3. 功能实现\n</code></pre>\n<p>关于jQuery的入口函数：</p>\n<pre><code class=\"javascript\">//第一种写法\n$(document).ready(function() &#123;\n    \n&#125;);\n//第二种写法\n$(function() &#123;\n    \n&#125;);\n</code></pre>\n<p>jQuery入口函数与js入口函数的对比</p>\n<pre><code class=\"javascript\">1.\tJavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。\n2.\tjQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。\n</code></pre>\n<h6 id=\"jQuery对象与DOM对象的区别（重点）\"><a href=\"#jQuery对象与DOM对象的区别（重点）\" class=\"headerlink\" title=\"jQuery对象与DOM对象的区别（重点）\"></a>jQuery对象与DOM对象的区别（重点）</h6><pre><code class=\"javascript\">1. DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。\n2. jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。\n3. jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合（伪数组））\n4. DOM对象与jQuery对象的方法不能混用。\n</code></pre>\n<p>DOM对象转换成jQuery对象：【联想记忆：花钱】</p>\n<pre><code class=\"javascript\">var $obj = $(domObj);\n// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象\n</code></pre>\n<p>jQuery对象转换成DOM对象：</p>\n<pre><code class=\"javascript\">var $li = $(“li”);\n//第一种方法（推荐使用）\n$li[0]\n//第二种方法\n$li.get(0)\n</code></pre>\n<h1 id=\"jQuery框架应用\"><a href=\"#jQuery框架应用\" class=\"headerlink\" title=\"jQuery框架应用\"></a>jQuery框架应用</h1><p>jQuery是一个快速的、简洁的JavaScript框架（库），它的宗旨“ write less Do more ” 即写更少的代码做更多的事情，它会封装很多JavaScript中常用的功能代码，提供了一个简洁的JS设计模式</p>\n<ul>\n<li>优化HTML文档操作（优化DOM操作）</li>\n<li>事件处理</li>\n<li>动画设计（动画存在bug）</li>\n<li>Ajax</li>\n</ul>\n<p>要使用JQ我们需要引入对应的库文件做支持</p>\n<pre><code class=\"html\">&lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<h2 id=\"jQuery基础语法\"><a href=\"#jQuery基础语法\" class=\"headerlink\" title=\"jQuery基础语法\"></a>jQuery基础语法</h2><p>由三个部分组成</p>\n<p>1、启动符：$ ，如果该符号在语言中已经作为关键字或者预留字使用，可以替换成 jQuery</p>\n<p>2、选择器【用来选择需要操作的JQ元素】</p>\n<p>3、方法【对元素进行操作】</p>\n<h2 id=\"jQuery选择器\"><a href=\"#jQuery选择器\" class=\"headerlink\" title=\"jQuery选择器\"></a>jQuery选择器</h2><pre><code class=\"js\">$(&quot;h1&quot;)   //document.querySelectorAll()\n$(&quot;.tit&quot;)\n</code></pre>\n<h3 id=\"什么是jQuery选择器\"><a href=\"#什么是jQuery选择器\" class=\"headerlink\" title=\"什么是jQuery选择器\"></a>什么是jQuery选择器</h3><p>jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。</p>\n<p>jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。【查看jQuery文档】</p>\n<p>jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。</p>\n<h3 id=\"基本选择器\"><a href=\"#基本选择器\" class=\"headerlink\" title=\"基本选择器\"></a>基本选择器</h3><p>选择器选取到的是一个jQuery对象</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID选择器</td>\n<td>$(“#id”);</td>\n<td align=\"left\">获取指定ID的元素</td>\n</tr>\n<tr>\n<td>类选择器</td>\n<td>$(“.class”);</td>\n<td align=\"left\">获取同一类class的元素</td>\n</tr>\n<tr>\n<td>标签选择器</td>\n<td>$(“div”);</td>\n<td align=\"left\">获取同一类标签的所有元素</td>\n</tr>\n<tr>\n<td>并集选择器</td>\n<td>$(“div,p,li”);</td>\n<td align=\"left\">使用逗号分隔，只要符合条件之一就可。</td>\n</tr>\n<tr>\n<td>交集选择器</td>\n<td>$(“div.redClass”);</td>\n<td align=\"left\">获取class为redClass的div元素</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>总结：跟css的选择器用法一模一样。</p>\n</blockquote>\n<h3 id=\"层级选择器\"><a href=\"#层级选择器\" class=\"headerlink\" title=\"层级选择器\"></a>层级选择器</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>子代选择器</td>\n<td>$(“ul&gt;li”);</td>\n<td align=\"left\">使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td>\n</tr>\n<tr>\n<td>后代选择器</td>\n<td>$(“ul li”);</td>\n<td align=\"left\">使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>跟CSS的选择器一模一样。</p>\n</blockquote>\n<h3 id=\"过滤选择器\"><a href=\"#过滤选择器\" class=\"headerlink\" title=\"过滤选择器\"></a>过滤选择器</h3><blockquote>\n<p>这类选择器都带冒号:</p>\n<p>获取到的为数组，并且只匹配一次，成功后就停止匹配</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:eq（index）</td>\n<td>$(“li:eq(2)”).css(“color”, ”red”);</td>\n<td align=\"left\">获取到的li元素中，选择索引号为2的元素，索引号index从0开始。</td>\n</tr>\n<tr>\n<td>:odd</td>\n<td>$(“li:odd”).css(“color”, ”red”);</td>\n<td align=\"left\">获取到的li元素中，选择索引号为奇数的元素</td>\n</tr>\n<tr>\n<td>:even</td>\n<td>$(“li:even”).css(“color”, ”red”);</td>\n<td align=\"left\">获取到的li元素中，选择索引号为偶数的元素</td>\n</tr>\n</tbody></table>\n<p>【案例：隔行变色】</p>\n<h3 id=\"筛选选择器-方法\"><a href=\"#筛选选择器-方法\" class=\"headerlink\" title=\"筛选选择器(方法)\"></a>筛选选择器(方法)</h3><blockquote>\n<p>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>children(selector)</td>\n<td>$(“ul”).children(“li”)</td>\n<td align=\"left\">相当于$(“ul&gt;li”)，子类选择器，可以不指明selector</td>\n</tr>\n<tr>\n<td>find(selector)</td>\n<td>$(“ul”).find(“li”);</td>\n<td align=\"left\">相当于$(“ul li”),后代选择器，必须要指明selector</td>\n</tr>\n<tr>\n<td>siblings(selector)</td>\n<td>$(“#first”).siblings(“li”);</td>\n<td align=\"left\">查找所有兄弟节点，不包括自己本身，不指定selector时会包含script标签</td>\n</tr>\n<tr>\n<td>parent()</td>\n<td>$(“#first”).parent();</td>\n<td align=\"left\">查找父亲</td>\n</tr>\n<tr>\n<td>eq(index)</td>\n<td>$(“li”).eq(2);</td>\n<td align=\"left\">相当于$(“li:eq(2)”),index从0开始</td>\n</tr>\n<tr>\n<td>next()</td>\n<td>$(“li”).next()</td>\n<td align=\"left\">找下一个兄弟，包含其内容，返回的是数组</td>\n</tr>\n<tr>\n<td>prev()</td>\n<td>$(“li”).prev()</td>\n<td align=\"left\">找上一个兄弟，包含其内容，返回的是数组</td>\n</tr>\n</tbody></table>\n<pre><code class=\"javascript\">【案例：下拉菜单】this+children+mouseenter+mouseleave\n【案例：突出展示】siblings+find\n【案例：手风琴】next+parent\n【案例：淘宝精品】index+eq\n</code></pre>\n<h2 id=\"jQuery事件\"><a href=\"#jQuery事件\" class=\"headerlink\" title=\"jQuery事件\"></a>jQuery事件</h2><p>jQuery事件是把DOM当中常用的事件进行了一个封装，成了一个方法来调用</p>\n<pre><code class=\"js\">$(&quot;.tit&quot;).click(function()&#123;\n    //回调函数就是当你的事件触发的时候要执行的事情\n&#125;)\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>鼠标事件</th>\n<th>键盘事件</th>\n<th>表单事件</th>\n<th>文档&#x2F;窗口事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>click</td>\n<td>keypress</td>\n<td>submit</td>\n<td>load（窗口）</td>\n</tr>\n<tr>\n<td>dblclick</td>\n<td>keydown</td>\n<td>change</td>\n<td>resize（窗口）</td>\n</tr>\n<tr>\n<td>mouseenter</td>\n<td>keyup</td>\n<td>focus</td>\n<td>scroll（窗口）</td>\n</tr>\n<tr>\n<td>mouseleave</td>\n<td></td>\n<td>blur</td>\n<td>unload（窗口）</td>\n</tr>\n<tr>\n<td>hover</td>\n<td></td>\n<td></td>\n<td>ready（文档）</td>\n</tr>\n</tbody></table>\n<p>对于不常用的事件，jQ提供了一个on方法来实现绑定</p>\n<pre><code class=\"js\">$(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123;\n    console.log(&quot;呵呵呵呵&quot;)\n&#125;)\n</code></pre>\n<h2 id=\"jQuery事件委托\"><a href=\"#jQuery事件委托\" class=\"headerlink\" title=\"jQuery事件委托\"></a>jQuery事件委托</h2><p>jQuery事件委托通过on方法实现</p>\n<pre><code class=\"html\">&lt;ul class=&quot;ul1&quot;&gt;\n    &lt;li&gt;1&lt;/li&gt;\n    &lt;li class=&quot;active&quot;&gt;2&lt;/li&gt;\n    &lt;li&gt;3&lt;/li&gt;\n    &lt;li&gt;4&lt;/li&gt;\n    &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n    $(&quot;.ul1&quot;).on(&quot;click&quot;,&quot;li.active&quot;,function()&#123;\n        console.log(new Date());\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"jQuery事件移除\"><a href=\"#jQuery事件移除\" class=\"headerlink\" title=\"jQuery事件移除\"></a>jQuery事件移除</h2><p>jQuery使用off方法</p>\n<pre><code class=\"js\">$(&quot;css选择器&quot;).off(&quot;事件类型&quot;,函数名)\n//如果没有写函数名，就移除所有\n</code></pre>\n<h2 id=\"jQuery单次事件\"><a href=\"#jQuery单次事件\" class=\"headerlink\" title=\"jQuery单次事件\"></a>jQuery单次事件</h2><pre><code class=\"js\">//原生写法\ndocument.querySelector(&quot;#btn&quot;).addEventListener(&quot;click&quot;,function()&#123;\n    console.log(&quot;我被点了&quot;);\n    document.querySelector(&quot;#btn&quot;).removeEventListener(&quot;click&quot;,arguments.callee)\n&#125;)\n\n//jQ写法\n$(&quot;#btn&quot;).one(&quot;click&quot;,function()&#123;\n    console.log(&quot;我被点了&quot;)\n&#125;)\n</code></pre>\n<h2 id=\"jQuery动画方法\"><a href=\"#jQuery动画方法\" class=\"headerlink\" title=\"jQuery动画方法\"></a>jQuery动画方法</h2><p>1、show() &#x2F; hide() &#x2F; toggle() 执行元素的显示隐藏</p>\n<blockquote>\n<p>注意：toggle方法有版本兼容的问题，如果要使用toggle简易采用1.7.2一下的版本</p>\n</blockquote>\n<p>2、slideUp() &#x2F; slideDown() &#x2F; slideToggle() 元素执行上下滑动</p>\n<p>3、fadeIn() &#x2F; fadeOut() &#x2F; fadeTo(speed,opacity) &#x2F; fadeToggle()  渐隐渐显</p>\n<p>4、animate() 自定义动画方法</p>\n<pre><code class=\"js\">$(&quot;.switch&quot;).click(function()&#123;\n    $(&quot;.box&quot;).animate(&#123;\n        &quot;width&quot;:&quot;500px&quot;,\n        &quot;height&quot;:&quot;500px&quot;\n    &#125;,2000,function()&#123;\n        console.log(&quot;我完了&quot;)\n    &#125;)\n&#125;)\n</code></pre>\n<h2 id=\"jQuery-css方法（1）\"><a href=\"#jQuery-css方法（1）\" class=\"headerlink\" title=\"jQuery css方法（1）\"></a>jQuery css方法（1）</h2><p>1、addClass() 在选中的元素上添加一个类</p>\n<p>2、removeClass() 在选中的元素上删除一个类</p>\n<p>3、toggleClass（） 在选中的元素上替换一个类</p>\n<p>4、css() 这个方法可以在获取的元素中任意添加或者获取样式</p>\n<h4 id=\"获取样式\"><a href=\"#获取样式\" class=\"headerlink\" title=\"获取样式\"></a>获取样式</h4><pre><code class=\"js\">var a = $(&quot;.box&quot;).css(&quot;width&quot;);\n</code></pre>\n<h4 id=\"设置样式（hover时传入两个函数，移入移出事件）\"><a href=\"#设置样式（hover时传入两个函数，移入移出事件）\" class=\"headerlink\" title=\"设置样式（hover时传入两个函数，移入移出事件）\"></a>设置样式（hover时传入两个函数，移入移出事件）</h4><pre><code class=\"js\">\n$(&quot;.box&quot;).hover(function()&#123;\n    $(this).css(&#123;\n        width:&quot;500px&quot;,\n        height:&quot;500px&quot;\n    &#125;)\n&#125;,function()&#123;\n    $(this).css(&#123;\n        width:&quot;300px&quot;,\n        height:&quot;300px&quot;\n    &#125;)\n&#125;)\n</code></pre>\n<h2 id=\"css操作（2）\"><a href=\"#css操作（2）\" class=\"headerlink\" title=\"css操作（2）\"></a>css操作（2）</h2><pre><code class=\"js\">//name：需要设置的样式名称\n//value：对应的样式值\ncss(name, value);\n//使用案例\n$(&quot;#one&quot;).css(&quot;background&quot;,&quot;gray&quot;);//将背景色修改为灰色\n\n//参数是一个对象，对象中包含了需要设置的样式名和样式值\ncss(obj);\n//使用案例\n$(&quot;#one&quot;).css(&#123;\n    &quot;background&quot;:&quot;gray&quot;,\n    &quot;width&quot;:&quot;400px&quot;,\n    &quot;height&quot;:&quot;200px&quot;\n&#125;);\n\n//name:需要获取的样式名称\ncss(name);\n//案例\n$(&quot;div&quot;).css(&quot;background-color&quot;);\n</code></pre>\n<p>注意：获取样式操作只会返回第一个元素对应的样式值。<br>隐式迭代：<br>1.设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值<br>2.获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</p>\n<h2 id=\"class操作（2）\"><a href=\"#class操作（2）\" class=\"headerlink\" title=\"class操作（2）\"></a>class操作（2）</h2><pre><code class=\"js\">//name：需要添加的样式类名，注意参数不要带点.\naddClass(name);\n//例子,给所有的div添加one的样式。\n$(“div”).addClass(“one”);\n\n//name:需要移除的样式类名\nremoveClass(“name”);\n//例子，移除div中one的样式类名\n$(“div”).removeClass(“one”);\n\n//name:用于判断的样式类名，返回值为true false\nhasClass(name)\n//例子，判断第一个div是否有one的样式类\n$(“div”).hasClass(“one”);\n\n//name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。\ntoggleClass(name);\n//例子\n$(“div”).toggleClass(“one”);\n</code></pre>\n<p>、、、<br>mouseenter<br>$(“li”).mouseenter(function(){<br>    &#x2F;&#x2F;this:为当前的都dom对象， $(this)转换为jquery对象</p>\n<pre><code class=\"js\">console.log($(this).text());\n</code></pre>\n<h3 id=\"jQuery属性方法\"><a href=\"#jQuery属性方法\" class=\"headerlink\" title=\"jQuery属性方法\"></a>jQuery属性方法</h3><p>1、html() 等价原生DOM中的innerHTML属性</p>\n<pre><code class=\"js\">$(&quot;.box&quot;).html(&quot;&lt;h1&gt;哈哈&lt;/h1&gt;&quot;)  //传参表示赋值\n$(&quot;.box&quot;).html()   //取值\n</code></pre>\n<p>2、text() 等价原生DOM中的innerText属性</p>\n<p>3、val() 对表单的value属性进行操作</p>\n<blockquote>\n<p>以上三个传参就是赋值，不传参就是取值</p>\n</blockquote>\n<p>4、attr()  操作标签属性</p>\n<pre><code class=\"js\">$(&quot;input&quot;).attr(&quot;type&quot;);\n$(&quot;input&quot;).attr(&quot;type&quot;,&quot;password&quot;)   //注意低版本无法设置type属性\n</code></pre>\n<p>5、removeAttr() 移除一个属性</p>\n<p>6、prop() 对标签的单属性进行操作</p>\n<pre><code class=\"js\">$(&quot;input&quot;).prop(&quot;checked&quot;,false)\n</code></pre>\n<h3 id=\"jQuery的尺寸方法\"><a href=\"#jQuery的尺寸方法\" class=\"headerlink\" title=\"jQuery的尺寸方法\"></a>jQuery的尺寸方法</h3><p>1、width() &#x2F; height() 获取盒子的content大小</p>\n<p>2、innerWidth() &#x2F; innerHeight()  获取盒子的content+padding的大小</p>\n<p>3、outerWidth() &#x2F; outerHeight（）获取盒子的content+padding+border的大小</p>\n<p>5、outerWidth(true) &#x2F; outerHeight（true）获取盒子的content+padding+border+margin的大小</p>\n<h1 id=\"文档就绪函数\"><a href=\"#文档就绪函数\" class=\"headerlink\" title=\"文档就绪函数\"></a>文档就绪函数</h1><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n        &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            $(&quot;#btn&quot;).click(function()&#123;\n                console.log(&quot;haha&quot;)\n            &#125;)\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>代码分析：</p>\n<p>上面的代码当中，按钮是不会有事件触发的，因为它是先绑定的事件，再加载的DOM元素，再绑定事件的时候DOM元素还没有加载出来</p>\n</blockquote>\n<p>在原生JS中window中有一个事件onload，它代表所有元素已经加载完毕才会触发，所以我们可以使用这个事件</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n        &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            window.onload = function()&#123;\n                $(&quot;#btn&quot;).click(function()&#123;\n                    console.log(&quot;haha&quot;)\n                &#125;)\n            &#125;\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>代码分析：</p>\n<p>这些写其实不太好，因为它是将所有的元素加载完毕之后才会触发，如果一个页面上所有的元素已经加载好了，但是任然有一些大图片或者一些其他外部资源没有加载好，这个时候onload是不会触发的，这个从用户体验角度来讲不太好</p>\n</blockquote>\n<p>优化一下</p>\n<pre><code class=\"js\">document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;\n    $(&quot;#btn&quot;).click(function()&#123;\n        console.log(&quot;haha&quot;)\n    &#125;)\n&#125;)\n</code></pre>\n<blockquote>\n<p>代码分析：</p>\n<p>上面的写法就更优化了，把对象改成document，通过触发事件DOMContentLoaded 从而不需要等待DOM以外的东西加载好就可以触发</p>\n</blockquote>\n<p>而上面这套写法，在JQ当中有一个专门函数叫做<strong>文档就绪函数</strong></p>\n<pre><code class=\"js\">$(document).ready(function()&#123;\n    $(&quot;#btn&quot;).click(function()&#123;\n        console.log(&quot;haha&quot;)\n    &#125;)\n&#125;)\n</code></pre>\n<p>进一步简化</p>\n<pre><code class=\"js\">$(function()&#123;\n    $(&quot;#btn&quot;).click(function()&#123;\n        console.log(&quot;haha&quot;)\n    &#125;)\n&#125;)\n</code></pre>\n<h1 id=\"Ajax方法\"><a href=\"#Ajax方法\" class=\"headerlink\" title=\"Ajax方法\"></a>Ajax方法</h1><p><strong>jquery封装的Ajax方法会自动将返回的json格式数据进行序列化。</strong></p>\n<p>我们自己封装过一套ajax请求，JQ也有自己封装的</p>\n<pre><code class=\"js\">$.ajax(&#123;\n    async:true,               //是否异步，默认false\n    type:&quot;get&quot;,               //请求方法，默认是get\n    url:&quot;&quot;,                   //请求地址\n    dataType:&quot;json&quot;,          //返回的数据类型，如果是json则自动反序列化\n    success:function(data)&#123;   \n        //请求成功时，执行的回调，data相当于xhr对象中的response\n    &#125;,\n    error:function(err)&#123;\n        //请求失败时执行的回调，err错误信息\n    &#125;\n&#125;) \n</code></pre>\n<p>JQ自己也觉得上面的写法很麻烦，所以由简化了一下</p>\n<pre><code class=\"js\">$.get(url,function(data)&#123;\n\n&#125;)\n或者\n$.post(url, data, function(response) &#123;\n  // 处理响应数据\n&#125;);\n</code></pre>\n<pre><code class=\"js\">$.extend  === Array.prototype.abc\n</code></pre>\n<p>ajax的封装方法中有xhr对象，此对象指向自己，施一公xhr.upload.onprogress方法创建一个函数，可以生成进度条样式（通过e.loaded和e.total，函数事件中内置的属性）</p>\n<pre><code class=\"js\">$.extend  === Array.prototype.abc\n</code></pre>\n<h1 id=\"JQuery的其他方法\"><a href=\"#JQuery的其他方法\" class=\"headerlink\" title=\"JQuery的其他方法\"></a>JQuery的其他方法</h1><p>1、<code>each()</code> 方法</p>\n<pre><code class=\"js\">$(&quot;.ul1&gt;li&quot;).each(function(index,ele)&#123;\n    console.log(index,ele);\n&#125;)\n</code></pre>\n<p>选取元素之后，可以直接进行遍历，回调函数里面的第一个参数代表索引，第二个参数表单当前遍历的元素</p>\n<pre><code class=\"js\">var result = $(&quot;.ul1&gt;li&quot;);\n$.each(result,function(index,ele)&#123;\n    console.log(index,ele);\n&#125;)\n</code></pre>\n<p>上面的调用 <code>$.each</code> 的时候，里面的result是一个类数组，所以我们可以用这个方法来进行遍历</p>\n<p>2、<code>toArray()</code>  可以把Jquery选择操作的对象转换成一个数组</p>\n<pre><code class=\"js\">$(&quot;.ul1&gt;li&quot;).toArray();   //这个时候就变成了一个数组\n</code></pre>\n<p>刚刚上面的<code>toArray()</code> 是可以将JQuery的选择结果转化昵称真正的数组，但是这个结束是不是 JQuery选取的？</p>\n<p>3、<code>makeArray()</code> 可以将任何类数组转换成数组</p>\n<pre><code class=\"js\">var lis = document.querySeletorAll(&quot;.ul1&gt;li&quot;)    //得到是一个NodeList类型的类数组\n</code></pre>\n<p>把上面的NodeList，我们通过已经学过的方法转成数组</p>\n<p><strong>第一种</strong></p>\n<pre><code class=\"js\">var arr = Array.prototype.slice.call(lis);\n</code></pre>\n<p><strong>第二种</strong></p>\n<pre><code class=\"js\">var arr = $(lis).toArray();\n</code></pre>\n<p><strong>第三种</strong></p>\n<pre><code class=\"js\">var arr = $.makeArray(lis);\n</code></pre>\n<h3 id=\"JQuery的扩展\"><a href=\"#JQuery的扩展\" class=\"headerlink\" title=\"JQuery的扩展\"></a>JQuery的扩展</h3><p>on的使用</p>\n<p><strong>第一种方式</strong></p>\n<pre><code class=\"js\">$(&quot;#btn1&quot;).on(&quot;click&quot;,function()&#123;\n    console.log(&quot;单击事件&quot;)\n&#125;)\n\n$(&quot;#btn1&quot;).on(&quot;mousedown&quot;,function()&#123;\n    console.log(&quot;鼠标按下事件&quot;)\n&#125;)\n\n$(&quot;#btn1&quot;).on(&quot;mouseup&quot;,function()&#123;\n    console.log(&quot;鼠标松开事件&quot;)\n&#125;)\n</code></pre>\n<p><strong>第二种写法</strong></p>\n<pre><code class=\"js\">$(&quot;#btn1&quot;).on(&#123;\n    click: function()&#123;\n        console.log(&quot;单击事件&quot;)\n    &#125;,\n    mousedown: function()&#123;\n        console.log(&quot;鼠标按下事件&quot;)\n    &#125;,\n    mouseup: function()&#123;\n        console.log(&quot;鼠标松开事件&quot;)\n    &#125;\n&#125;)\n</code></pre>\n<p><strong>第三种：链式语法</strong></p>\n<h3 id=\"DOM的attribute和property\"><a href=\"#DOM的attribute和property\" class=\"headerlink\" title=\"DOM的attribute和property\"></a>DOM的attribute和property</h3><p>attribute：在web前端中指的是HTML的属性</p>\n<p>property：在web前端中指的是对象的属性</p>\n<pre><code class=\"js\">$(&quot;#input1&quot;).attr(&quot;type&quot;);\n$(&quot;#input1&quot;).prop(&quot;checked&quot;,false);\n</code></pre>\n<h4 id=\"JQuery对象于普通DOM对象的转换\"><a href=\"#JQuery对象于普通DOM对象的转换\" class=\"headerlink\" title=\"JQuery对象于普通DOM对象的转换\"></a>JQuery对象于普通DOM对象的转换</h4><pre><code class=\"html\">&lt;body&gt;\n    &lt;button type=&quot;button&quot; id=&quot;btn1&quot;&gt;按钮&lt;/button&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    var btn1 = document.querySelector(&quot;#btn1&quot;);   //btn是一个原生的DOM对象\n\n    var btn2 = $(&quot;#btn1&quot;);    //JQuery的初始化操作对象，jQuery.fn.init\n&lt;/script&gt;\n</code></pre>\n<p>首先我们要知道一点，$(选择器)它返回的是一个JQuery对象，是一个类数组形式</p>\n<p><strong>JQuery对象转换成DOM</strong></p>\n<pre><code class=\"js\">btn2[0];\n$(&quot;#btn1&quot;)[0];   //这样就得到了原生的DOM对象\n//接下来就可以操作对应的原生的js方法\n</code></pre>\n<p><strong>普通DOM对象转成JQuery对象</strong></p>\n<pre><code class=\"js\">$(btn1);   //这样就得到了JQuery的操作对象\n//只要得到了就可以使用JQ方法进行操作\n$(btn1).text();\n</code></pre>\n<h3 id=\"JQ里面的事件对象\"><a href=\"#JQ里面的事件对象\" class=\"headerlink\" title=\"JQ里面的事件对象\"></a>JQ里面的事件对象</h3><p>JQuery的事件全部都是二级事件，并且它默认执行的是事件冒泡</p>\n<p>JQuery当中的事件对象并不是原生的事件对象，而是经过JQuery自己的封装的一个对象，正是因为它是自己封装的对象，所以JQuery事件对象肯定是与原生有一些不一样的</p>\n<p>1、JQuery的事件对象不需要做兼容性的处理，因为在框架内部就已经了处理了</p>\n<pre><code class=\"js\">//原生的DOM事件对象\nevent = event || window.event;\n//而JQuery里面，直接使用event就好了\n</code></pre>\n<p>2、JQuery事件对象上面的 <code>stopPropagtion()</code> 它自己封装的方法，它不是原生的事件对象的方法，所以在停止事件冒泡与取消事件传播的时候，直接调用这一个方法就行了</p>\n<pre><code class=\"js\">//原生DOM的事件里面，取消事件传播与冒泡\nevent.cancelBubble = true；    //IE\nevent.stopPropagtion();       //W3c\n\n//在JQuery中，直接调用方法即可\nevent.stopPropagtion();\n</code></pre>\n<p>3、JQuery事件对象里面，如果要阻止事件的默认行为也是 <code>event.preventDefault()</code> ,而在原生DOM对象里面，0级使用 <code>return false</code> 2级事件使用 <code>event.preventDefault()</code></p>\n<pre><code class=\"js\">//原生DOM\n//0级事件\n//在事件方法的最后添加\nreturn false\n\n//JQuery当中，直接调用\nevent.preventDefault()\n</code></pre>\n<p>4、JQuery事件里面的 <code>return false</code> 会同时停止事件冒泡与阻止事件默认行为，相当于把 <code>stopPropagtion()</code> 与 <code>preventDefault() </code>都干了</p>\n<p>5、jQuery当中的事件对象是框架自己封装的对象，如果要找原生的事件对象可以使用 <code>originalEvent</code>这个属性</p>\n<p>6、JQuery的事件对象中 <code>which</code>属性代表鼠标的键，1代表左键，2代表中键，3代表右键</p>\n<p>7、因为JQuery事件是2级事件可以实现多次监听，这样在触发的时候会同时调用所有监听的方法，这时候会形成事件链，在JQuery当中提供了一个排他的特性，它是 <code>event.stopImmediatePropagation()</code></p>\n<pre><code class=\"js\">$(&quot;#btn1&quot;).on(&quot;click&quot;,function()&#123;\n    console.log(&quot;我是第一次&quot;)\n&#125;).on(&quot;click&quot;,function(event)&#123;\n    console.log(&quot;第二次&quot;);\n    event.stopImmediatePropagation();  //事件链到这里就断掉了，后面的事件方法不执行\n&#125;).on(&quot;click&quot;,function()&#123;\n    console.log(&quot;第三次&quot;);\n&#125;)\n</code></pre>\n<h4 id=\"JQuery事件委托拓展\"><a href=\"#JQuery事件委托拓展\" class=\"headerlink\" title=\"JQuery事件委托拓展\"></a>JQuery事件委托拓展</h4><p>在JQ里面事件委托和原生DOM里面实现的事件委托有点不一样</p>\n<p><strong>原生DOM里面</strong></p>\n<ul>\n<li><code>event.target</code> 代表事件的触发者</li>\n<li><code>event.currentTarget</code> 代表事件的绑定者</li>\n</ul>\n<p><strong>JQuery框架里面</strong></p>\n<ul>\n<li><code>event.target</code> 代表事件的触发者</li>\n<li><code>event.currentTarget</code> 代表事件的绑定者</li>\n<li><code>event.delegateTarget</code> 代表事件的委托者</li>\n</ul>\n<pre><code class=\"html\">&lt;body&gt;\n    &lt;div class=&quot;box&quot;&gt;\n        &lt;div class=&quot;small-box&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;btn1&quot;&gt;按钮&lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $(&quot;.box&quot;).on(&quot;click&quot;,&quot;.small-box&quot;,function()&#123;\n        console.log(&quot;我触发了事件&quot;,event);\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<p>当我们点击按钮的时候，会触发click事件，这个时候我们来分析下这个事件对象</p>\n<p>1、我们把事件绑定在了 <code>box</code> 身上，但是 <code>box</code> 又把事件委托给了 <code>small-box</code> 所以我们认为，事件现在实际上是在 <code>small-box</code> 身上</p>\n<p>2、当我们点击按钮按钮的时候，会触发按钮身上的click事件，但是按钮本身并没有事件方法需要执行，所以按钮本身并不会又任何的事情发生，但是事件传播的行为任然是会发生的，所以按钮的点击事件传播到了外面的small-box身上，正好触发了small-box身上委托的事件方法</p>\n<ul>\n<li><code>delegateTarget</code>  是 <code>div.box</code> </li>\n<li><code>currentTarget</code> 是 <code>div.small-box</code></li>\n<li><code>target</code> 是 <code>button.btn1</code></li>\n</ul>\n<p>总的来说，它的格式因该是如下</p>\n<pre><code class=\"js\">$(委托者).on(事件类型，事件绑定者,function()&#123;\n    //这里面可以找到真正的target触发者\n&#125;)\n</code></pre>\n<h4 id=\"JQuery-方法中的this\"><a href=\"#JQuery-方法中的this\" class=\"headerlink\" title=\"JQuery 方法中的this\"></a>JQuery 方法中的this</h4><pre><code class=\"js\">$(&quot;.box&quot;).on(&quot;click&quot;,&quot;.small-box&quot;,function()&#123;\n    console.log(this);          //small-box\n&#125;)\n    \n$(&quot;.box&quot;).on(&quot;click&quot;,function()&#123;\n    console.log(this);          //box\n&#125;)\n</code></pre>\n<p>JQuery里面的事件当中的this永远指向谁事件的绑定者  <code>event.currentTarget</code></p>\n<p>Jquery当中的this的一种特殊用法，它可以直接通过选择器选取以后再操作</p>\n<pre><code class=\"js\">$(this)   //这就相当于对当前元素选取之后再操作\n</code></pre>\n<h3 id=\"JQuery的扩展方法\"><a href=\"#JQuery的扩展方法\" class=\"headerlink\" title=\"JQuery的扩展方法\"></a>JQuery的扩展方法</h3><p>在JQuery当中，它为我们提供了很多的方法，同时也可以让我们自己来实现自定义的方法，这些自定义的方法，我们叫做jQuery的扩展方法</p>\n<p>jQuery的扩展方法有两种形式存在</p>\n<p>1、<code>$.extend()</code> ，这种情况直接在 $ 对象身上扩展方法</p>\n<p>2、<code>$.fn.extend()</code> ，这种情况是在JQuery选取的元素上面扩展方法</p>\n<pre><code class=\"html\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $.extend(&#123;\n        aaa:function()&#123;\n            console.log(&quot;我是JQuery对象上面扩展的aaa方法&quot;);\n        &#125;\n    &#125;)\n\n    $.aaa();\n\n    $.fn.extend(&#123;\n        bbb:function()&#123;\n            console.log(&quot;我是JQuery操作对象上面扩展的bbb方法&quot;)\n        &#125;\n    &#125;)\n    $(&quot;#div1&quot;).bbb();\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"JQuery扩展方法实现插件制作\"><a href=\"#JQuery扩展方法实现插件制作\" class=\"headerlink\" title=\"JQuery扩展方法实现插件制作\"></a>JQuery扩展方法实现插件制作</h4><p>index.html部分</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;css/context-menu-box.css&quot;&gt;\n        \n        &lt;style&gt;\n            .box&#123;\n                width:400px;\n                height:400px;\n                border:solid 1px #f00;\n            &#125;\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=&quot;box&quot;&gt;\n            &lt;!-- &lt;ul class=&quot;context-menu-box&quot;&gt;\n                &lt;li&gt;haha&lt;/li&gt;\n                &lt;li&gt;haha&lt;/li&gt;\n                &lt;li&gt;haha&lt;/li&gt;\n            &lt;/ul&gt; --&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;script src=&quot;js/jquery-1.7.2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;js/jQuery.contextmenu.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n        var menuList = [\n            &#123;\n                text: &quot;退回&quot;,\n                click: function()&#123;\n                    console.log(&quot;你要退回么?&quot;)\n                &#125;\n            &#125;,\n            &#123;\n                text: &quot;提交&quot;,\n                click: function()&#123;\n                    console.log(&quot;你正在提交&quot;)\n                &#125;\n            &#125;,\n            &#123;\n                text: &quot;登录&quot;,\n                click: function()&#123;\n                    console.log(&quot;你在登录&quot;)\n                &#125;\n            &#125;\n        ]\n        $(&quot;.box&quot;).addContextMenu(menuList);\n    &lt;/script&gt;\n&lt;/html&gt;\n</code></pre>\n<p>context-menu-box.css部分</p>\n<pre><code class=\"css\">*&#123;\n    padding:0;\n    margin:0;\n&#125;\nul,ol&#123;\n    list-style:none;\n&#125;\na&#123;\n    text-decoration: none;\n    color:#333;\n&#125;\n.context-menu-box&#123;\n    width:130px;\n    position: fixed;\n    left:0;\n    top:0;\n    background-color: #fff;\n    box-shadow:0 0 5px #000;\n    display:none;\n&#125;\n\n.context-menu-box&gt;li&#123;\n    line-height:35px;\n    border-bottom: solid 1px #ccc;\n    cursor: pointer;\n    text-align: center;\n&#125;\n.context-menu-box&gt;li:hover&#123;\n    font-weight: bold;\n&#125;\n</code></pre>\n<p>jQuery.contextmenu.js</p>\n<pre><code class=\"js\">(function($)&#123;\n    if(typeof $ == undefined)&#123;\n        throw new Error(&quot;jQuery is not defined&quot;);\n        return;\n    &#125;\n    $.fn.extend(&#123;\n        addContextMenu: function(menuList)&#123;\n            var menuUl = document.createElement(&quot;ul&quot;);\n            menuUl.classList.add(&quot;context-menu-box&quot;);\n            for(var i = 0;i &lt; menuList.length;i++)&#123;\n                var newli = document.createElement(&quot;li&quot;);\n                newli.innerText = menuList[i].text;\n                //判断一下是否有click事件\n                if(typeof menuList[i].click === &quot;function&quot;)&#123;\n                    $(newli).on(&quot;click&quot;,menuList[i].click);\n                &#125;\n                menuUl.appendChild(newli);\n            &#125;\n            document.body.appendChild(menuUl);\n            \n            //点击自己的时候，把自己隐藏掉\n            $(menuUl).click(function()&#123;\n                $(this).hide();\n            &#125;)\n            //绑定右键菜单事件\n            this.contextmenu(function(event)&#123;\n                event.preventDefault();\n                var x = event.clientX;\n                var y = event.clientY;\n                $(menuUl).css(&#123;\n                    left: x + &quot;px&quot;,\n                    top: y + &quot;px&quot;\n                &#125;).slideDown(&quot;fast&quot;);\n            &#125;)\n        &#125;\n    &#125;)\n&#125;)(jQuery)   \n/*\n$符号并不是jQuery独占的一个标识符，你有可以在实际的工作中\n会引入多个框架文件进行使用，有可以在其他的框架文件中也使用了$这个\n符号作为它自己的标识符使用，那么这个时候，两个框架文件之间就会\n产生冲突，jQuery在这个情况下，可以使用另外一个标识符来替代$的作用\n就是jQuery\n*/\n</code></pre>\n","categories":["jQuery"],"tags":["jQuery"]},{"title":"杂记与工具库函数","url":"/2023/06/02/learn/","content":"<h2 id=\"NaN历史遗留问题\"><a href=\"#NaN历史遗留问题\" class=\"headerlink\" title=\"NaN历史遗留问题\"></a>NaN历史遗留问题</h2><p>由于历史遗留问题，NaN的内部做了hash处理，使得每一次NaN返回的结果都不同。</p>\n<pre><code class=\"js\">NaN === NaN //false;\nObject.is(NaN,NaN) //true\n//除此之外，延申:\n+0 === -0 //返回true\nObject.is(+0 , -0) //返回false\n</code></pre>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>构造函数的prototype（原型对象）就是其实例的原型（_<em>proto</em> _）*-*</p>\n<pre><code class=\"js\">new Object().__proto__===Object.prototype\n</code></pre>\n<p>【原型链图解】</p>\n<pre><code class=\"js\">obj.__proto__------Object.prototype-------null\nfunc.__proto__--------Function.prototype-------Object.prototype----------null\n（其中：func.__proto__.__proto__ === Object.prototype   ； func也是Object的实例（instanceof））\narr.__proto__ -------------Array.prototype---------Object.prototype---------null\n</code></pre>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A8.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX3ByZWNlZGVuY2U=\">运算符优先级</span></h2><h2 id=\"产品上线流程\"><a href=\"#产品上线流程\" class=\"headerlink\" title=\"产品上线流程\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTk3MDUyMDE=\">产品上线流程</span></h2><h1 id=\"plop-js-微型生成器框架\"><a href=\"#plop-js-微型生成器框架\" class=\"headerlink\" title=\"plop.js:微型生成器框架\"></a>plop.js:微型生成器框架</h1><p>plop.js可以通过命令行生成，处理文件模板代码等</p>\n<h1 id=\"JS中字符串的存储\"><a href=\"#JS中字符串的存储\" class=\"headerlink\" title=\"JS中字符串的存储:\"></a>JS中字符串的存储:</h1><p>JS字符串以Unicode编码的方式进行存储，当声明一个字符串并赋值给一个变量时，js引擎会为该字符串创建一个对象，并将字符串的内容存储在对象内部的属性中，这个对象被称为字符串对象，然而为了提高性能和减少内存的占用，当字符串是常量时，JS引擎会将其存储在一个字符串字面量池中，而不是每一次都创建新的字符串对象。当对字符串执行修改操作时，实际上是创建了一个新的字符串对象，并将修改之后的字符串存储在新的对象中，原始字符串不变。</p>\n<h1 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob:\"></a>Blob:</h1><p><strong>Blob（Binary Large Object）对象是 JavaScript 中用来表示二进制数据的对象，通常用于存储和操作文件或其他类型的二进制数据。Blob 对象可以表示大型数据对象，比如图像、视频、音频文件等。</strong></p>\n<p><strong>Blob 对象通常由两部分组成：数据和数据的类型。数据部分包含实际的二进制数据，而类型部分描述了数据的 MIME 类型，例如 “image&#x2F;png” 或 “application&#x2F;pdf”。</strong></p>\n<p><strong>Blob 对象可以通过 <code>new Blob()</code> 构造函数创建，传入一个数组作为参数，数组中包含要存储的二进制数据。另外，你还可以通过传入一个可选的对象参数，来指定数据的 MIME 类型。例如：</strong></p>\n<pre><code class=\"js\">javascriptCopy Codevar binaryData = [0x48, 0x65, 0x6c, 0x6c, 0x6f]; // 用十六进制表示的字符串 &quot;Hello&quot;\nvar blob = new Blob([binaryData], &#123; type: &quot;text/plain&quot; &#125;);\n</code></pre>\n<p><strong>在上面的例子中，我们使用 <code>new Blob()</code> 创建了一个包含 “Hello” 文本数据的 Blob 对象，并指定了它的 MIME 类型为 “text&#x2F;plain”。</strong></p>\n<p><strong>Blob 对象可以被用于多种用途，比如：</strong></p>\n<ol>\n<li><strong>通过 URL.createObjectURL() 方法创建一个临时的 URL，用于在页面中显示或下载文件,一般配置a标签（download属性）。</strong></li>\n<li><strong>作为 XMLHttpRequest 的响应数据类型，用于接收和处理文件或二进制数据。</strong></li>\n<li><strong>作为 FormData 对象的值，用于将二进制数据发送到服务器。</strong></li>\n</ol>\n<p><strong>总之，Blob 对象在 JavaScript 中提供了一种方便的方式来处理和操作二进制数据，特别适合于文件操作和网络通信中的数据传输</strong></p>\n<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer:\"></a>ArrayBuffer:</h1><p><strong>ArrayBuffer 是 JavaScript 中用于表示通用的固定长度的二进制数据缓冲区的对象。它可以在内存中分配一块连续的内存空间，用于存储二进制数据。</strong></p>\n<p><strong>ArrayBuffer 对象本身只是一个占用了一定字节数的内存块，它没有提供直接的方法来读取或写入数据。为了操作 ArrayBuffer 中的数据，我们需要使用不同的视图（如 TypedArray 或 DataView）来读取、写入和操作底层的二进制数据。</strong></p>\n<p><strong>在内存中，ArrayBuffer 对象以连续的字节序列表示。这意味着存储在 ArrayBuffer 中的数据是紧密排列的，没有额外的空隙或填充。每个字节都有一个唯一的地址，我们可以通过偏移量来访问和操作特定位置的字节。</strong></p>\n<p>以下是一个示例，展示了如何创建和使用 ArrayBuffer：</p>\n<pre><code class=\"js\">javascriptCopy Code// 创建一个包含 16 字节的 ArrayBuffer\nconst buffer = new ArrayBuffer(16);\n\n// 使用一个 Int32Array 视图来读取和写入数据\nconst int32Array = new Int32Array(buffer);\n\n// 写入数据\nint32Array[0] = 42;\nint32Array[1] = 99;\n\n// 读取数据\nconsole.log(int32Array[0]); // 输出 42\nconsole.log(int32Array[1]); // 输出 99\n</code></pre>\n<p>在上述示例中，我们创建了一个长度为 16 字节的 ArrayBuffer。然后，我们使用 Int32Array 视图来操作这个 ArrayBuffer，将数据写入到数组中，并通过下标直接访问和读取数据。在内存中，这些数据被紧密排列在连续的字节中。</p>\n<p><strong>需要注意的是，ArrayBuffer 的长度是固定的，一旦分配了特定大小的内存空间，就无法改变它的大小。如果我们需要更改数据的长度，我们需要创建一个新的 ArrayBuffer，并将旧数据拷贝到新的 ArrayBuffer 中。</strong></p>\n<p>总之，ArrayBuffer 提供了一种在 JavaScript 中操作底层二进制数据的机制，它在内存中以连续的字节序列表示，可以用于存储和操作各种类型的二进制数据。</p>\n<h1 id=\"DataView视图：\"><a href=\"#DataView视图：\" class=\"headerlink\" title=\"DataView视图：\"></a>DataView视图：</h1><p>DataView 是 JavaScript 中的一个类型化数组视图，用于以不同的字节序（如大端序或小端序）和不同的数据类型（如整数、浮点数等）来读取和写入 ArrayBuffer 中的二进制数据。与 TypedArray 不同，DataView 可以指定任意的字节偏移量和长度，可以更加灵活地操作二进制数据。</p>\n<p>以下是一个使用 DataView 读取 ArrayBuffer 中的二进制数据的示例：</p>\n<pre><code class=\"js\">javascriptCopy Code// 创建一个包含 8 字节的 ArrayBuffer\nconst buffer = new ArrayBuffer(8);\n\n// 使用一个 DataView 视图来读取和写入数据\nconst dataView = new DataView(buffer);\n\n// 写入数据\ndataView.setInt16(0, 42); // 在第 1 和第 2 个字节中写入 42\ndataView.setInt32(2, -100); // 在第 3 到第 6 个字节中写入 -100\n\n// 读取数据\nconsole.log(dataView.getInt16(0)); // 输出 42\nconsole.log(dataView.getInt32(2)); // 输出 -100\n</code></pre>\n<p>在上述示例中，我们创建了一个长度为 8 字节的 ArrayBuffer。然后，我们使用一个 DataView 视图来操作这个 ArrayBuffer，分别在前两个字节和后四个字节中写入两个不同的数据，然后通过 DataView 的方法来读取这些数据。</p>\n<p>需要注意的是，DataView 的方法名都以数据类型名称开头，并以字节偏移量作为第一个参数。例如，<code>setInt16(offset, value)</code> 方法将一个 16 位整数值写入到指定偏移量处，而 <code>getInt32(offset)</code> 方法则从指定偏移量处读取一个 32 位整数值。这些方法还可以接受一个可选的第二个参数，用于指定字节序，以帮助正确地解释二进制数据。</p>\n<p>总之，DataView 提供了一种灵活和可定制的方式来读取和写入 ArrayBuffer 中的二进制数据，可以指定不同的字节序和数据类型，并支持任意偏移量和长度。</p>\n<h1 id=\"JS中类型化数组（typed-array）：\"><a href=\"#JS中类型化数组（typed-array）：\" class=\"headerlink\" title=\"JS中类型化数组（typed array）：\"></a>JS中类型化数组（typed array）：</h1><p><strong>JavaScript 的类型化数组是一种特殊的数组，可以存储和操作固定类型的数据，如整数、浮点数、字节等。相比于普通的 JavaScript 数组，类型化数组有以下几个优点：</strong></p>\n<ol>\n<li><strong>更加高效：类型化数组在内存中是连续存储的，这意味着它们可以更快地被读取和写入。此外，它们还允许我们直接访问底层的二进制数据，而不需要进行类型转换或拷贝操作。</strong></li>\n<li><strong>更加节省空间：由于类型化数组只能存储固定类型的数据，因此它们使用的内存空间可以更加紧凑。例如，使用 Int8Array 数组可以将每个元素压缩为 1 个字节，而使用普通的 JavaScript 数组则需要至少 8 个字节来存储一个数字。</strong></li>\n<li><strong>更加易于处理二进制数据：类型化数组可以帮助我们更加方便地处理二进制数据，如音频、视频、图像等。这些数据通常以二进制格式存储，而类型化数组可以直接读取和操作这些数据，而不需要进行复杂的解析和转换操作。</strong></li>\n</ol>\n<p><strong>总之，类型化数组可以带来更高效、更紧凑、更直接的二进制数据处理体验，是 JavaScript 中处理二进制数据时非常有用的工具。虽然普通的 JavaScript 数组也可以存储二进制数据，但它们没有类型化数组那样的高效和直接性。因此，在需要处理大量二进制数据时，使用类型化数组会更加合适。</strong></p>\n<h5 id=\"Int8Array\"><a href=\"#Int8Array\" class=\"headerlink\" title=\"Int8Array:\"></a>Int8Array:</h5><p>①只能存储8位有符号整数（-128到127），②使用固定大小的内存来存储数据，每个元素占用一个字节（8位）③元素连续存储</p>\n<pre><code class=\"js\">// 以长度参数构造对象\nvar int8 = new Int8Array(2);\nint8[0] = 42;\nconsole.log(int8[0]); // 42\nconsole.log(int8.length); // 2\nconsole.log(int8.BYTES_PER_ELEMENT); // 数组所占用的字节数\n// 以数组构造对象\nvar arr = new Int8Array([21, 31]);\nconsole.log(arr[1]); // 31\n// 从另一数组构造对象\nvar x = new Int8Array([21, 31]);\nvar y = new Int8Array(x);\nconsole.log(y[0]); // 21\n// 从 ArrayBuffer 构造对象\nvar buffer = new ArrayBuffer(8);\nvar z = new Int8Array(buffer, 1, 4);\n</code></pre>\n<h5 id=\"还有：Uint8Array等类型\"><a href=\"#还有：Uint8Array等类型\" class=\"headerlink\" title=\"还有：Uint8Array等类型\"></a>还有：Uint8Array等类型</h5><h3 id=\"forEach的回调函数中不传参数\"><a href=\"#forEach的回调函数中不传参数\" class=\"headerlink\" title=\"forEach的回调函数中不传参数\"></a>forEach的回调函数中不传参数</h3><pre><code class=\"js\">const dfs = function(root)&#123;\n    console.log(root.val,&#39;还好&#39;);\n    root.children.forEach(dfs);//forEach回调不传参数，默认传的参数就是item项\n&#125;\n</code></pre>\n<p>forEach回调函数中不传参数，默认将item项作为变量进行传递</p>\n<h2 id=\"不常见html标签：\"><a href=\"#不常见html标签：\" class=\"headerlink\" title=\"不常见html标签：\"></a>不常见html标签：</h2><p>dialog弹窗</p>\n<p><img data-src=\"/images/image-20240122101335456.png\" alt=\"/images/image-20240122101335456\"></p>\n<p>details详细</p>\n<p><img data-src=\"/images/image-20240122101339487.png\" alt=\"/images/image-20240122101339487\"></p>\n<p>刻度尺</p>\n<p><img data-src=\"/images/image-20240122101344976.png\" alt=\"/images/image-20240122101344976\"></p>\n<p>进度条</p>\n<p><img data-src=\"/images/image-20240122101352284.png\" alt=\"/images/image-20240122101352284\"></p>\n<p>时间</p>\n<p><img data-src=\"/images/image-20240122101359606.png\" alt=\"/images/image-20240122101359606\"></p>\n<p>高亮文本</p>\n<p><img data-src=\"/images/image-20240122102818128.png\" alt=\"/images/image-20240122102818128\"></p>\n<p>注解发音</p>\n<p><img data-src=\"/images/image-20240122102837759.png\" alt=\"/images/image-20240122102837759\"></p>\n<p>数据列表</p>\n<p><img data-src=\"/images/image-20240122102908520.png\" alt=\"/images/image-20240122102908520\"></p>\n<p>上标，下标</p>\n<p><img data-src=\"/images/image-20240122102926938.png\" alt=\"/images/image-20240122102926938\"></p>\n<p>虚线标识的</p>\n<p><img data-src=\"/images/image-20240122102943236.png\" alt=\"/images/image-20240122102943236\"></p>\n<p>地图标签</p>\n<p><img data-src=\"/images/image-20240122103024494.png\" alt=\"/images/image-20240122103024494\"></p>\n<h1 id=\"vue3中通过位运算进行类型判断\"><a href=\"#vue3中通过位运算进行类型判断\" class=\"headerlink\" title=\"vue3中通过位运算进行类型判断\"></a>vue3中通过位运算进行类型判断</h1><p>性能提高，可读性减小：</p>\n<ol>\n<li>快速判断：位运算是底层的二进制操作，比起其他逻辑运算符，如逻辑与 <code>&amp;&amp;</code>、逻辑或 <code>||</code>，位运算更加高效。在某些场景下，使用位运算可以对多个类型进行快速判断，避免了复杂的条件判断和函数调用。</li>\n<li>位运算的特性：位运算的特性使得它可以用较少的存储空间表示和处理多个状态或标志位。通过将多个类型的判断压缩到一个整数中，可以节省内存空间，并且减少了不必要的变量声明和赋值操作，从而提升了性能。</li>\n</ol>\n<h1 id=\"自增运算在属性中的运用\"><a href=\"#自增运算在属性中的运用\" class=\"headerlink\" title=\"自增运算在属性中的运用\"></a>自增运算在属性中的运用</h1><pre><code class=\"js\">let a = [1,2]\nlet index = 0\na[index++]=a[index] \n//相当于a[1]=a[0],自增运算符优先级大于赋值运算符，代码可以拆分为：\n//左边=a[index] index++ 左边=a[index](第二次index自增过了)\nconsole.log(a);\n</code></pre>\n<h1 id=\"类的私有属性\"><a href=\"#类的私有属性\" class=\"headerlink\" title=\"类的私有属性\"></a>类的私有属性</h1><p><strong>js中可以通过#标识私有属性，但是不是全部的js运行环境都支持。</strong></p>\n<p><strong>ts中通过private关键字来标识私有属性，可以通过ts转为兼容性代码。</strong></p>\n<pre><code class=\"js\">class ClassWithPrivateField &#123;\n    #pricateField;\n    constructor()&#123;\n        this.#pricateField=1\n    &#125;\n  &#125;\n  const aaa = new ClassWithPrivateField()\n  console.log(aaa.#pricateField); //报错：属性在类的外部不可访问\n</code></pre>\n<h1 id=\"图片上传：\"><a href=\"#图片上传：\" class=\"headerlink\" title=\"图片上传：\"></a>图片上传：</h1><p><strong>input标签中file（accetp接受类型） 、</strong></p>\n<p><strong>fileList（change事件的e.target.files[0]） 、</strong></p>\n<p><strong>Blob（二进制格式数据）、</strong></p>\n<p><strong>FileReader（将文本文件file转为字符串或者URL）、</strong></p>\n<p><strong>URL scheme 、</strong></p>\n<p><strong>拖拽事件：dragenter、dragover、drop</strong></p>\n<h1 id=\"new关键字的实现：\"><a href=\"#new关键字的实现：\" class=\"headerlink\" title=\"new关键字的实现：\"></a>new关键字的实现：</h1><pre><code class=\"js\">const mynew = function(constroctor,...argus)&#123;\n    const obj = Object.create(constroctor.prototype)\n    const res = obj.apply(obj,argus);\n    return (res &amp;&amp; typeof res === &#39;object&#39;) ?res:obj;\n&#125;\n</code></pre>\n<h1 id=\"将字符串转换为二进制形式\"><a href=\"#将字符串转换为二进制形式\" class=\"headerlink\" title=\"将字符串转换为二进制形式\"></a>将字符串转换为二进制形式</h1><pre><code class=\"js\">    function toBianary(str)&#123;\n        let res = &#39;&#39;;\n        for(let i=0;i&lt;str.length;i++)&#123;\n            let charCode = str.charCodeAt(i);\n            let binaryCharCode = charCode.toString(2);\n            res += binaryCharCode.padStart(8,&#39;0&#39;);\n        &#125;\n        return res;\n    &#125;\n</code></pre>\n","categories":["杂记","工具函数"],"tags":["杂记","工具函数"]},{"title":"new关键字的实现","url":"/2023/06/02/new%E5%85%B3%E9%94%AE%E5%AD%97/","content":"<h1 id=\"new关键字实现分为三步：\"><a href=\"#new关键字实现分为三步：\" class=\"headerlink\" title=\"new关键字实现分为三步：\"></a>new关键字实现分为三步：</h1><p>1、根据构造函数的原型创建新的对象<br>2、执行构造函数，绑定this指向为新对象，传入参数<br>3、返回执行后的结果</p>\n<pre><code class=\"js\">function myNew(constructor,...args)&#123;\n    //创建对象，原型为构造函数的原型对象\n    const obj = Object.create(constructor.prototype);\n    //执行构造函数，传入创建的对象和参数\n    const res = constructor.apply(obj,args); //注意apply方法是函数对象的方法，普通对象不可用\n    return (res &amp;&amp; typeof res === &#39;object&#39;)?res:obj;    \n&#125;\nfunction A ()&#123;\n    this.name=&#39;sdjf&#39;\n&#125;\nconst ab = myNew(A)\nconsole.log(ab);\n</code></pre>\n","categories":["JS底层"],"tags":["new关键字","JS底层"]},{"title":"Node学习笔记","url":"/2024/05/24/node/","content":"<h1 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>Node.js并不是JavaScript应用，也不是编程语言，而是JavaScript的运行时。</li>\n<li>Node.js是构建在V8引擎之上的，V8引擎由C &#x2F; C++编写，因此JavaScript语言需要编译为C &#x2F; C++代码之后才能执行。</li>\n<li>Node.js采用异步IO和事件驱动的设计理念，可以高效的处理大量并发请求，提供了非阻塞IO接口和事件循环机制，使其可以编写出高性能、高扩展的应用程序。（异步IO通过libuv库来实现）</li>\n<li>Node.js使用npm作为包管理工具</li>\n<li>Node.js适合做一些IO密集型应用，不适合做一些CPU密集型应用（事件循环机制和异步IO使得Node.js有很强的处理能力，但是因为Node.js单线程的原因，容易造成CPU占用率过高）</li>\n<li>如果非要用Node.js做CPU密集型应用，需要编写C++插件，或者Node提供的cluster模块。</li>\n</ul>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ul>\n<li>npm是Node.js的包管理工具，它基于命令行，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qaWF4aWFveGlhby5uZXRsaWZ5LmFwcC8yMDE5LzA3LzMwL25vZGUvbm9kZS1ucG0v\">npm命令大全</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTQ1NzU5ODY4MDEwMzY0OTU5\">package.json配置详解</span></li>\n</ul>\n<h4 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h4><p>执行<code>npm install</code>时，npm会通过广度优先遍历算法遍历依赖树，npm会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有的依赖被处理完成。在处理每个依赖时，npm会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本。</p>\n<p><img data-src=\"/images/Snipaste_2024-05-28_18-35-31.png\" alt=\"images\"></p>\n<h4 id=\"npmrc文件\"><a href=\"#npmrc文件\" class=\"headerlink\" title=\".npmrc文件\"></a>.npmrc文件</h4><pre><code class=\"bash\">registry=http://registry.npmjs.org/\n# 定义npm的registry，即npm的包下载源\nproxy=http://proxy.example.com:8080/\n# 定义npm的代理服务器，用于访问网络\nhttps-proxy=http://proxy.example.com:8080/\n# 定义npm的https代理服务器，用于访问网络\nstrict-ssl=true\n# 是否在SSL证书验证错误时退出\ncafile=/path/to/cafile.pem\n# 定义自定义CA证书文件的路径\nuser-agent=npm/&#123;npm-version&#125; node/&#123;node-version&#125; &#123;platform&#125;\n# 自定义请求头中的User-Agent\nsave=true\n# 安装包时是否自动保存到package.json的dependencies中\nsave-dev=true\n# 安装包时是否自动保存到package.json的devDependencies中\nsave-exact=true\n# 安装包时是否精确保存版本号\nengine-strict=true\n# 是否在安装时检查依赖的node和npm版本是否符合要求\nscripts-prepend-node-path=true\n# 是否在运行脚本时自动将node的路径添加到PATH环境变量中\n</code></pre>\n<h4 id=\"package-lock-json\"><a href=\"#package-lock-json\" class=\"headerlink\" title=\"package-lock.json\"></a>package-lock.json</h4><p>文件的作用：</p>\n<ul>\n<li><p>锁定版本号、记录依赖树详细信息</p>\n</li>\n<li><p>package-lock.json帮我们做了缓存，他会通过 <code>name + version + integrity</code> 信息生成一个唯一的key，这个key能找到对应的index-v5 下的缓存记录 （npm cache 文件夹下），如果发现有缓存记录，就会找到tar包的hash值，然后将对应的二进制文件解压到node_modeules</p>\n</li>\n</ul>\n<h4 id=\"npm-run\"><a href=\"#npm-run\" class=\"headerlink\" title=\"npm run\"></a>npm run</h4><p>读取package.json的scripts对应的脚本命令，查找的规则是：</p>\n<ol>\n<li>当前项目node_modules&#x2F;.bin查找</li>\n<li>全局node_modules&#x2F;.bin查找</li>\n<li>环境变量查找</li>\n<li>找不到，报错</li>\n</ol>\n<p>node_modules&#x2F;.bin中有三个文件（Node作为跨平台工具，需要处理平台兼容性）</p>\n<ul>\n<li>.sh文件是给Linux unix Macos 使用</li>\n<li>.cmd 给windows的cmd使用</li>\n<li>.ps1 给windows的powerShell 使用</li>\n</ul>\n<h4 id=\"npm-生命周期\"><a href=\"#npm-生命周期\" class=\"headerlink\" title=\"npm 生命周期\"></a>npm 生命周期</h4><p>在package.json中的scripts字段中，我们可以利用npm脚本命名规范使用npm的生命周期特性，例如：</p>\n<pre><code class=\"json\">    &quot;pretest&quot;: &quot;node prev.js&quot;,\n    &quot;test&quot;: &quot;node index.js&quot;,\n    &quot;posttest&quot;: &quot;node post.js&quot;\n</code></pre>\n<p>则执行：npm run test时，会最先执行pretest，最后执行posttest。</p>\n<h4 id=\"npx\"><a href=\"#npx\" class=\"headerlink\" title=\"npx\"></a>npx</h4><p>npx是一个命令行工具，它是npm 5.2.0版本中新增的功能。它允许用户在不安装全局包的情况下，运行已安装在本地项目中的包或者远程仓库中的包。</p>\n<p>npx的作用是在命令行中运行node包中的可执行文件，而不需要全局安装这些包。这可以使开发人员更轻松地管理包的依赖关系，并且可以避免全局污染的问题。它还可以帮助开发人员在项目中使用不同版本的包，而不会出现版本冲突的问题。</p>\n<p><strong>npx 的优势</strong></p>\n<ol>\n<li>避免全局安装：<code>npx</code>允许你执行npm package，而不需要你先全局安装它。</li>\n<li>总是使用最新版本：如果你没有在本地安装相应的npm package，<code>npx</code>会从npm的package仓库中下载并使用最新版。</li>\n<li>执行任意npm包：<code>npx</code>不仅可以执行在<code>package.json</code>的<code>scripts</code>部分定义的命令，还可以执行任何npm package。</li>\n<li>执行GitHub gist：<code>npx</code>甚至可以执行GitHub gist或者其他公开的JavaScript文件。</li>\n</ol>\n<p><strong>npm 和 npx 区别</strong></p>\n<ul>\n<li><p><code>npx</code>侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令</p>\n</li>\n<li><p><code>npm</code>侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。</p>\n</li>\n</ul>\n<h4 id=\"npm私服\"><a href=\"#npm私服\" class=\"headerlink\" title=\"npm私服\"></a>npm私服</h4><p><strong>优势：</strong></p>\n<ul>\n<li><strong>可以离线使用</strong>，你可以将npm私服部署到内网集群，这样离线也可以访问私有的包。</li>\n<li><strong>提高包的安全性</strong>，使用私有的npm仓库可以更好的管理你的包，避免在使用公共的npm包的时候出现漏洞。</li>\n<li><strong>提高包的下载速度</strong>，使用私有 npm 仓库，你可以将经常使用的 npm 包缓存到本地，从而显著提高包的下载速度，减少依赖包的下载时间。这对于团队内部开发和持续集成、部署等场景非常</li>\n</ul>\n<p><strong>搭建：</strong></p>\n<ul>\n<li>可以克隆npm或cnpm仓库，更改yaml配置文件为自己想要的设置即可</li>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly92ZXJkYWNjaW8ub3JnL3poLWNuLw==\">verdaccio工具</span><ul>\n<li><code>npm install verdaccio -g</code></li>\n<li><code>verdaccio</code></li>\n<li>访问localhost:4873</li>\n<li>使用npm操作时，加上<code>--registry http://localhost:4873</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Node模块化\"><a href=\"#Node模块化\" class=\"headerlink\" title=\"Node模块化\"></a>Node模块化</h2><h4 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h4><ul>\n<li><p>支持引入内置模块例如 <code>http</code> <code>os</code> <code>fs</code> <code>child_process</code> 等nodejs内置模块</p>\n</li>\n<li><p>支持引入第三方模块<code>express</code> <code>md5</code> <code>koa</code> 等</p>\n</li>\n<li><p>支持引入自己编写的模块 .&#x2F; ..&#x2F; 等</p>\n</li>\n<li><p>支持引入addon C++扩展模块 .node文件</p>\n</li>\n</ul>\n<h4 id=\"ESM\"><a href=\"#ESM\" class=\"headerlink\" title=\"ESM\"></a>ESM</h4><ul>\n<li>import静态导入需要在顶层调用</li>\n<li>import导入json文件需要添加断言（低版本node不可用）</li>\n<li>支持函数式动态导入</li>\n</ul>\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><ol>\n<li>CommonJS基于运行时的同步加载，ESM基于编译时的异步加载</li>\n<li>CommonJS是可以修改值的，ESM值并且不可修改（可读的）</li>\n<li>CommonJS不可以tree shaking，ESM支持tree shaking</li>\n<li>CommonJS中顶层的this指向这个模块本身，而ESM中顶层this指向undefined</li>\n</ol>\n<h4 id=\"require执行顺序\"><a href=\"#require执行顺序\" class=\"headerlink\" title=\"require执行顺序\"></a>require执行顺序</h4><ol>\n<li>.js文件，调用compile函数进行执行。</li>\n<li>.json文件，读取文件内容，调用JSON.parse方法处理。</li>\n<li>.node文件，通过process.dlopen方法进行处理。</li>\n</ol>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><h4 id=\"global\"><a href=\"#global\" class=\"headerlink\" title=\"global\"></a>global</h4><ul>\n<li>浏览器端的全局对象是window</li>\n<li>Node环境的全局对象是global</li>\n<li>global上定义的变量在当前环境执行任何文件时都可以访问到</li>\n<li>ES2020推出globalThis用于兼容window和global（自动切换）</li>\n</ul>\n<h4 id=\"dirname\"><a href=\"#dirname\" class=\"headerlink\" title=\"__dirname\"></a>__dirname</h4><p>当前模块所在目录的绝对路径</p>\n<h4 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"__filename\"></a>__filename</h4><p>当前模块文件所在的绝对路径，包括文件名和文件扩展名</p>\n<h4 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"require\"></a>require</h4><h4 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h4><h4 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h4><ul>\n<li><p><code>process.argv</code></p>\n<ul>\n<li>第一个参数是当前执行环境的路径</li>\n<li>第二个参数是当前执行的文件的路径</li>\n<li>剩余的参数是传递给脚本文件的命令行参数</li>\n</ul>\n</li>\n<li><p><code>process.env</code>环境变量</p>\n</li>\n<li><p><code>process.cwd()</code>返回当前工作目录路径</p>\n</li>\n<li><p><code>process.on(event,listener)</code>，监听进程变化</p>\n</li>\n<li><p><code>process.exit([code])</code>，退出Node进程，提供退出码</p>\n</li>\n<li><p><code>process.pid</code>返回进程id</p>\n</li>\n</ul>\n<h4 id=\"Buffer类\"><a href=\"#Buffer类\" class=\"headerlink\" title=\"Buffer类\"></a>Buffer类</h4><p>Node.js 6.0版本开始，<code>Buffer</code>构造函数的使用已被弃用，推荐使用<code>Buffer.alloc()</code>、<code>Buffer.from()</code>等方法来创建<code>Buffer</code>实例。</p>\n<h4 id=\"DOM、BOM\"><a href=\"#DOM、BOM\" class=\"headerlink\" title=\"DOM、BOM\"></a>DOM、BOM</h4><p>Node环境中无法操作DOM和BOM，不过可以借助一些工具进行模拟，例如：<code>jsdom</code></p>\n<pre><code class=\"js\">const fs = require(&#39;node:fs&#39;)\nconst &#123; JSDOM &#125; = require(&#39;jsdom&#39;) // jsdom模拟浏览器环境\nconst dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;`)\nconst document = dom.window.document\nconst window = dom.window\nfetch(&#39;https://api.thecatapi.com/v1/images/search?limit=10&amp;page=1&#39;).then(res =&gt; res.json()).then(data =&gt; &#123;\n    const app = document.getElementById(&#39;app&#39;)\n    data.forEach(item=&gt;&#123;\n       const img =  document.createElement(&#39;img&#39;)\n       img.src = item.url\n       img.style.width = &#39;200px&#39;\n       img.style.height = &#39;200px&#39;\n       app.appendChild(img)\n    &#125;)\n    fs.writeFileSync(&#39;./index.html&#39;, dom.serialize())\n&#125;)\n</code></pre>\n<h2 id=\"path模块\"><a href=\"#path模块\" class=\"headerlink\" title=\"path模块\"></a>path模块</h2><p>path模块在windows和posix系统中是有差异的。</p>\n<ul>\n<li>posix表示可移植操作系统接口，也就是定义了一套标准，遵守这套标准的操作系统有(unix,like unix,linux,macOs,windows wsl)，用于多个平台间相互兼容</li>\n<li>Windows 并没有完全遵循 POSIX 标准，在 Windows 系统中，路径使用反斜杠（<code>\\</code>）作为路径分隔符。这与 POSIX 系统使用的正斜杠（<code>/</code>）是不同的</li>\n</ul>\n<p><strong>差异举例：</strong></p>\n<pre><code>path.basename(&#39;C:\\temp\\myfile.html&#39;); \n// 在posix中 返回: &#39;C:\\temp\\myfile.html&#39;\n// 在windows中 返回 empmyfile.html\n</code></pre>\n<ul>\n<li>path.basename返回文件名（包括后缀）</li>\n</ul>\n<pre><code class=\"js\">path.basename(&#39;C:/fs/dmq/MI/index.html&#39;) //返回index.html\n</code></pre>\n<ul>\n<li><code>path.extname</code>返回扩展名</li>\n<li><code>path.join</code>路径拼接（路径拼接）</li>\n<li><code>path.resolve</code>解析绝对路径并且返回绝对路径（路径解析）</li>\n<li><code>path.parse</code>将路径解析为对象</li>\n<li><code>path.format</code>将对象解析为路径</li>\n</ul>\n<h2 id=\"os模块\"><a href=\"#os模块\" class=\"headerlink\" title=\"os模块\"></a>os模块</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>API</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>os.type()</strong></td>\n<td>它在 Linux 上返回 <code>&#39;Linux&#39;</code>，在 macOS 上返回 <code>&#39;Darwin&#39;</code>，在 Windows 上返回 <code>&#39;Windows_NT&#39;</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><strong>os.platform()</strong></td>\n<td>返回标识为其编译 Node.js 二进制文件的操作系统平台的字符串。 该值在编译时设置。 可能的值为 <code>&#39;aix&#39;</code>、<code>&#39;darwin&#39;</code>、<code>&#39;freebsd&#39;</code>、<code>&#39;linux&#39;</code>、<code>&#39;openbsd&#39;</code>、<code>&#39;sunos&#39;</code>、以及 <code>&#39;win32&#39;</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><strong>os.release()</strong></td>\n<td>返回操作系统的版本例如10.xxxx win10</td>\n</tr>\n<tr>\n<td>4</td>\n<td><strong>os.homedir()</strong></td>\n<td>返回用户目录 例如c:\\user\\xiaoman 原理就是 windows <code>echo %USERPROFILE% </code>posix $HOME</td>\n</tr>\n<tr>\n<td>5</td>\n<td><strong>os.arch()</strong></td>\n<td>返回cpu的架构  可能的值为 <code>&#39;arm&#39;</code>、<code>&#39;arm64&#39;</code>、<code>&#39;ia32&#39;</code>、<code>&#39;mips&#39;</code>、<code>&#39;mipsel&#39;</code>、<code>&#39;ppc&#39;</code>、<code>&#39;ppc64&#39;</code>、<code>&#39;s390&#39;</code>、<code>&#39;s390x&#39;</code>、以及 <code>&#39;x64&#39;</code></td>\n</tr>\n<tr>\n<td>6</td>\n<td><strong>os.cups()</strong></td>\n<td>获取<code>cpu线程</code>和cpu详细信息</td>\n</tr>\n<tr>\n<td>7</td>\n<td><strong>os.networkInterfaces()</strong></td>\n<td>获取<code>网络信息</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"process模块\"><a href=\"#process模块\" class=\"headerlink\" title=\"process模块\"></a>process模块</h2><ul>\n<li><p><code>process.argv</code></p>\n<ul>\n<li>第一个参数是当前执行环境的路径</li>\n<li>第二个参数是当前执行的文件的路径</li>\n<li>剩余的参数是传递给脚本文件的命令行参数</li>\n</ul>\n</li>\n<li><p><code>process.env</code>环境变量</p>\n</li>\n<li><p><code>process.cwd()</code>返回当前工作目录路径</p>\n</li>\n<li><p><code>process.on(event,listener)</code>，监听进程变化</p>\n</li>\n<li><p><code>process.exit([code])</code>，退出Node进程，提供退出码</p>\n</li>\n<li><p><code>process.pid</code>返回进程id</p>\n</li>\n<li><p><code>process.arch</code>返回操作系统CPU架构</p>\n</li>\n<li><p><code>process.memoryUsage</code>获取当前进程内存使用情况</p>\n</li>\n<li><p><code>process.kill(process.pid)</code>用于杀死一个进程</p>\n</li>\n</ul>\n<h2 id=\"child-process模块\"><a href=\"#child-process模块\" class=\"headerlink\" title=\"child_process模块\"></a>child_process模块</h2><p>子进程是Nodejs核心API，如果你会shell命令，他会有非常大的帮助，或者你喜欢编写前端工程化工具之类的，他也有很大的用处，以及处理CPU密集型应用。</p>\n<h4 id=\"创建子进程\"><a href=\"#创建子进程\" class=\"headerlink\" title=\"创建子进程\"></a>创建子进程</h4><p>Nodejs创建子进程共有<code>7个</code>API Sync同步API ，不加是异步API</p>\n<ol>\n<li>spawn  执行命令</li>\n<li>exec   执行命令</li>\n<li>execFile   执行可执行文件</li>\n<li>fork   创建node子进程</li>\n<li><code>execSync</code> 执行命令 同步执行</li>\n<li><code>execFileSync</code> 执行可执行文件 同步执行</li>\n<li><code>spawnSync</code> 执行命令 同步执行</li>\n</ol>\n<h2 id=\"ffmpeg工具\"><a href=\"#ffmpeg工具\" class=\"headerlink\" title=\"ffmpeg工具\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9mZm1wZWcucDJocC5jb20vZG93bmxvYWQuaHRtbA==\">ffmpeg工具</span></h2><p>FFmpeg 是一个开源的跨平台多媒体处理工具，可以用于处理音频、视频和多媒体流。它提供了一组强大的命令行工具和库，可以进行视频转码、视频剪辑、音频提取、音视频合并、流媒体传输等操作。</p>\n<h2 id=\"events模块\"><a href=\"#events模块\" class=\"headerlink\" title=\"events模块\"></a>events模块</h2><p>Node.js的事件模型采用发布订阅的设计思想，将发布者和订阅者之间解耦合，使得双方能够独立地扩展自己。</p>\n<pre><code class=\"js\">const EventEmitter = require(&#39;events&#39;);\nconst event = new EventEmitter()\n//监听test\nevent.on(&#39;test&#39;,(data)=&gt;&#123;\n    console.log(data)\n&#125;)\nevent.emit(&#39;test&#39;,&#39;data数据&#39;) //派发事件\n</code></pre>\n<p>event实例默认监听10个为上限，可以通过<code>setMaxListeners()</code>方法来设置监听上限。</p>\n<pre><code class=\"js\">event.setMaxListeners(20)\n</code></pre>\n<p><code>event.once方法</code>可以只订阅一次</p>\n<pre><code class=\"js\">event.once(&#39;test&#39;,(data)=&gt;&#123;\n    console.log(&#39;once取代on，只监听一次&#39;)\n&#125;)\n</code></pre>\n<p><code>event.off</code>方法取消订阅</p>\n<pre><code class=\"JS\">event.on(&#39;test&#39;, fn) // 订阅事件\nevent.off(&#39;test&#39;, fn) // 取消事件订阅\n</code></pre>\n<h4 id=\"SSE\"><a href=\"#SSE\" class=\"headerlink\" title=\"SSE\"></a>SSE</h4><ul>\n<li><p>SSE（server send events）服务端推送事件</p>\n</li>\n<li><p>是一种实现服务端向客户端推送数据的技术，也被称为事件流</p>\n</li>\n<li><p>它是基于HTTP协议，利用HTTP协议长连接的优势，实现服务端向客户端推送实时数据。</p>\n</li>\n<li><p>浏览器端需要使用<code>EventSource</code>注册api地址，服务端需要对该地址的响应头中设置Content-Type为 <code>text/event-stream </code></p>\n</li>\n</ul>\n<p><strong>node后端：</strong></p>\n<pre><code class=\"js\">import express from &#39;express&#39;;\nconst app = express();\napp.get(&#39;/api/sse&#39;, (req, res) =&gt; &#123;\n    res.writeHead(200, &#123;\n        &#39;Content-Type&#39;: &#39;text/event-stream&#39;, //核心返回数据流\n        &#39;Connection&#39;: &#39;close&#39;\n    &#125;)\n    const data = fs.readFileSync(&#39;./index.txt&#39;, &#39;utf8&#39;)\n    const total = data.length;\n    let current = 0;\n    //mock sse 数据\n    let time = setInterval(() =&gt; &#123;\n        console.log(current, total)\n        if (current &gt;= total) &#123;\n            console.log(&#39;end&#39;)\n            clearInterval(time)\n            return\n        &#125;\n        //返回自定义事件名\n        res.write(`event:name\\n`)\n        //返回数据\n        res.write(`data:$&#123;data.split(&#39;&#39;)[current]&#125;\\n\\n`)\n        current++\n    &#125;, 300)\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;Listening on port 3000&#39;);\n&#125;);\n</code></pre>\n<p><strong>客户端：</strong></p>\n<pre><code class=\"js\">const sse = new EventSource(&#39;http://localhost:3000/api/sse&#39; )\nif (sse.readyState === EventSource.CONNECTING) &#123;\n  console.log(&#39;正在连接服务器...&#39;);\n&#125; else if (sse.readyState === EventSource.OPEN) &#123;\n  console.log(&#39;已经连接上服务器！&#39;);\n&#125; else if (sse.readyState === EventSource.CLOSED) &#123;\n  console.log(&#39;连接已经关闭。&#39;);\n&#125;\nsse.onmessage = (data)=&gt;&#123;\n    console.log(data);\n&#125;\nsse.onerror = (e)=&gt;&#123;\n    sse.close(); //关闭连接\n    console.error(e);\n&#125;\nsse.addEventListener(&#39;open&#39;, (e) =&gt; &#123;\n    console.log(&#39;连接成功&#39;);\n&#125;)\n//对应后端nodejs自定义的事件名lol\nsse.addEventListener(&#39;name&#39;, (e) =&gt; &#123;\n    console.log(e.data)\n&#125;)\n</code></pre>\n<h2 id=\"util模块\"><a href=\"#util模块\" class=\"headerlink\" title=\"util模块\"></a>util模块</h2><p>Node.js内部提供的工具集模块，方便快速开发</p>\n<ul>\n<li><p><code>util.promisify</code>将函数改为promise类型的形式</p>\n</li>\n<li><p><code>util.callbackify</code>将promise类型的api改为函数形式</p>\n</li>\n<li><p><code>util.format</code>用于格式化文本</p>\n<ul>\n<li><code>%s</code>: <code>String</code> 将用于转换除 <code>BigInt</code>、<code>Object</code> 和 <code>-0</code> 之外的所有值。 <code>BigInt</code> 值将用 <code>n</code> 表示，没有用户定义的 <code>toString</code> 函数的对象使用具有选项 <code>&#123; depth: 0, colors: false, compact: 3 &#125;</code> 的 <code>util.inspect()</code> 进行检查。</li>\n<li><code>%d</code>: <code>Number</code> 将用于转换除 <code>BigInt</code> 和 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%i</code>: <code>parseInt(value, 10)</code> 用于除 <code>BigInt</code> 和 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%f</code>: <code>parseFloat(value)</code> 用于除 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%j</code>: JSON。 如果参数包含循环引用，则替换为字符串 <code>&#39;[Circular]&#39;</code>。</li>\n<li><code>%o</code>: <code>Object</code>. 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于具有选项 <code>&#123; showHidden: true, showProxy: true &#125;</code> 的 <code>util.inspect()</code>。 这将显示完整的对象，包括不可枚举的属性和代理。</li>\n<li><code>%O</code>: <code>Object</code>. 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于没有选项的 <code>util.inspect()</code>。 这将显示完整的对象，但不包括不可枚举的属性和代理。</li>\n<li><code>%c</code>: <code>CSS</code>. 此说明符被忽略，将跳过任何传入的 CSS。</li>\n<li><code>%%</code>: 单个百分号 (<code>&#39;%&#39;</code>)。 这不消费参数。</li>\n</ul>\n</li>\n<li><p>其他工具函数省略</p>\n</li>\n</ul>\n<h2 id=\"pngquant工具\"><a href=\"#pngquant工具\" class=\"headerlink\" title=\"pngquant工具\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbmdxdWFudC5vcmcv\">pngquant工具</span></h2><p><code>pngquant</code> 是一个用于压缩 PNG 图像文件的工具。它可以显著减小 PNG 文件的大小，同时保持图像质量和透明度。通过减小文件大小，可以提高网页加载速度，并节省存储空间。<code>pngquant</code> 提供命令行接口和库，可轻松集成到各种应用程序和脚本中。</p>\n<h2 id=\"fs模块\"><a href=\"#fs模块\" class=\"headerlink\" title=\"fs模块\"></a>fs模块</h2><p>在 Node.js 中，<code>fs</code> 模块是文件系统模块（File System module）的缩写，它提供了与文件系统进行交互的各种功能。通过 <code>fs</code> 模块，你可以执行诸如读取文件、写入文件、更改文件权限、创建目录等操作，<code>Node.js 核心API之一</code>。</p>\n<h4 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h4><ul>\n<li><p>fs支持同步和异步两种模式 增加了<code>Sync</code> fs 就会采用同步的方式运行代码，会阻塞下面的代码，不加Sync就是异步的模式不会阻塞。</p>\n</li>\n<li><p>fs新增了promise版本，只需要在引入包后面增加&#x2F;promise即可，fs便可支持promise回调。</p>\n</li>\n<li><p>fs返回的是一个buffer二进制数据 每两个十六进制数字表示一个字节</p>\n</li>\n</ul>\n<h4 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h4><ul>\n<li><code>fs.readFile</code>异步读取文件</li>\n<li><code>fs.writeFile</code>异步写入文件</li>\n<li><code>fs.appendFile</code>文件异步追加写入内容</li>\n<li><code>fs.copyFile</code>文件异步拷贝写入</li>\n<li><code>fs.open</code>异步打开文件</li>\n<li><code>fs.close</code>异步关闭文件</li>\n<li><code>fs.read</code>异步读取文件</li>\n<li><code>fs.write</code>异步将Buffer中的数据写入文件</li>\n<li><code>fs.access</code>异步检查文件是否可读可写</li>\n<li><code>fs.stat</code>异步获取文件目录的stats对象（文件夹信息）</li>\n<li><code>fs.mkdir</code>异步创建文件夹</li>\n<li><code>fs.readdir</code>异步读取文件夹</li>\n<li><code>fs.rmdir</code>异步删除目录</li>\n<li><code>fs.unlink</code>异步删除文件</li>\n<li>以上方法都有对应的同步执行的方法，在方法名后面加上Sync后缀即可。</li>\n</ul>\n<h4 id=\"fs-x2F-promises\"><a href=\"#fs-x2F-promises\" class=\"headerlink\" title=\"fs&#x2F;promises\"></a>fs&#x2F;promises</h4><p>node中fs模块的方法提供了Promise版本的调用形式，导入即可使用promise的使用方式调用api</p>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><p>Node.js中fs模块是由libuv来进行调度的，文件读取完成之后libuv才会将fs的结果推入V8的队列。</p>\n<h4 id=\"writeFileSync\"><a href=\"#writeFileSync\" class=\"headerlink\" title=\"writeFileSync\"></a>writeFileSync</h4><ul>\n<li>第一个参数是要写入的文件</li>\n<li>第二个参数是写入的内容</li>\n<li>第三个参数是写入方式配置项，其flag有以下配置：<ul>\n<li><code>&#39;a&#39;</code>: 打开文件进行追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;ax&#39;</code>: 类似于 <code>&#39;a&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;a+&#39;</code>: 打开文件进行读取和追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;ax+&#39;</code>: 类似于 <code>&#39;a+&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;as&#39;</code>: 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;as+&#39;</code>: 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;r&#39;</code>: 打开文件进行读取。 如果文件不存在，则会发生异常。</li>\n<li><code>&#39;r+&#39;</code>: 打开文件进行读写。 如果文件不存在，则会发生异常。</li>\n<li><code>&#39;rs+&#39;</code>: 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。</li>\n<li><code>&#39;w&#39;</code>: 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。</li>\n<li><code>&#39;wx&#39;</code>: 类似于 <code>&#39;w&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;w+&#39;</code>: 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。</li>\n<li><code>&#39;wx+&#39;</code>: 类似于 <code>&#39;w+&#39;</code> 但如果路径存在则失败。</li>\n</ul>\n</li>\n</ul>\n<p>例如追加文件内容除了可以使用<code>appendFileSync</code>之外，还可以：</p>\n<pre><code class=\"js\">fs.writeFileSync(&#39;index.txt&#39;, &#39;追加的内容&#39;,&#123;\n    flag: &#39;a&#39; //配置options中的flag\n&#125;)\n</code></pre>\n<h4 id=\"可写流\"><a href=\"#可写流\" class=\"headerlink\" title=\"可写流\"></a>可写流</h4><pre><code class=\"js\">const fs = require(&#39;node:fs&#39;)\nlet verse = [\n    &#39;待到秋来九月八&#39;,\n    &#39;我花开后百花杀&#39;,\n    &#39;冲天香阵透长安&#39;,\n    &#39;满城尽带黄金甲&#39;\n]\nlet writeStream = fs.createWriteStream(&#39;index.txt&#39;) //创建写入流\nverse.forEach(item =&gt; &#123;\n    writeStream.write(item + &#39;\\n&#39;) //写入内容\n&#125;)\nwriteStream.end()\nwriteStream.on(&#39;finish&#39;,()=&gt;&#123; //监听写入完成事件\n    console.log(&#39;写入完成&#39;)\n&#125;)\n</code></pre>\n<p>我们可以创建一个可写流 打开一个通道，可以一直写入数据，用于处理大量的数据写入，写入完成之后调用end 关闭可写流，监听finish 事件 写入完成</p>\n<h4 id=\"硬链接、软连接\"><a href=\"#硬链接、软连接\" class=\"headerlink\" title=\"硬链接、软连接\"></a>硬链接、软连接</h4><h6 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h6><ul>\n<li>文件存储在磁盘上，磁盘的最小存储单位叫做<code>扇区</code>，每个扇区存储512字节</li>\n<li>操作系统读取磁盘时，不会一个扇区一个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，多个扇区称之为<code>块</code></li>\n<li><code>块</code>是文件读取的最小单位</li>\n<li>文件数据都存储在<code>块</code>中，因此需要一个地方存储文件的元信息，这中存储文件元信息的区域就叫做<code>inode</code>，索引节点</li>\n<li>创建软链接时生成了新的<code>inode</code>，创建硬链接时没有。</li>\n</ul>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-07-39.png\" alt=\"扇区、块和inode\"></p>\n<p><strong>inode中包含信息：</strong></p>\n<ul>\n<li>文件的字节数</li>\n<li>文件拥有者ID</li>\n<li>文件的Group ID</li>\n<li>文件读、写、执行权限</li>\n<li>文件的时间戳</li>\n<li>链接数</li>\n<li>文件数据block的位置</li>\n</ul>\n<p>每一个 <code>inode</code> 都有一个唯一的标识码 ，上面的输出信息中 <code>ino</code> 就是 <code>inode</code> 的唯一标识码，在 <code>linux</code> 系统内部使用 <code>inode</code> 的标识码来识别文件，并不使用文件名。之前系的</p>\n<p>在 <code>linux</code> 系统中，目录也是一种文件。目录文件包含一系列目录项，每一个目录项由两部分组成：所包含文件的文件名，以及文件名对应的 <code>inode</code> 标识码。我们可以使用 <code>ls -i</code> 来列出目录中的文件以及所有的 <code>inde</code> 标识码。这里也可以解释可能小伙伴们觉得说不通的问题，仅修改目录的读权限，并不能实现读取目录下所有文件内容的原因，最后需要通过递归目录下的文件来进行修改。</p>\n<h6 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h6><p>软链接类似于 <code>Window</code> 中的 “快捷方式” 。创建软链接会创建一个新的 <code>inode</code>，比如为文件 <code>a</code> 创建了软链接文件 b，文件 <code>b</code> 内部会指向 <code>a</code> 的 <code>inode</code>。当我们读取文件<code>b</code>的时候，系统会自动导向文件 <code>a</code> ，文件 <code>b</code> 就是文件 <code>a</code> 软连接(或者叫符号链接)。</p>\n<ul>\n<li>访问：创建了软链接后我们就可以使用不同的文件名访问相同的内容，</li>\n<li>修改：修改文件 <code>a</code> 的内容，文件 <code>b</code> 的内容也会发生改变，对文件内容的修改向放映到所有文件。</li>\n<li>删除：当我们删除源文件 <code>a</code> 时，在访问软连接文件 b 是，会报错 <code>&quot;No such file or directory&quot;</code></li>\n</ul>\n<p>可以直接使用 <code>linux</code> 命令 <code>ln -s source target</code> 来创建软链接(注意：表示 <code>target</code> “指向” <code>source</code>）</p>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-12-05.png\" alt=\"软链接\"></p>\n<h6 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h6><p>一般情况，一个文件名”唯一”对应一个 <code>inode</code>。但是 <code>linux</code> 允许多个文件名都指向同一个 <code>inode</code>。表示我们可以使用不同对文件名访问同样的内容；对文件内容进行修改将放映到所有文件；删除一个文件不影响另一个文件对访问。这种机制就被称为”硬链接”</p>\n<p>硬链接的创建 可以直接使用 <code>linux</code> 命令 <code>ln source target</code> 来创建硬链接（注意：<code>source</code> 已存在的文件，target 是将要建立的链接）</p>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-14-11.png\" alt=\"硬链接\"></p>\n<h6 id=\"创建链接\"><a href=\"#创建链接\" class=\"headerlink\" title=\"创建链接\"></a>创建链接</h6><pre><code class=\"js\">fs.linkSync(&#39;./index.txt&#39;, &#39;./index2.txt&#39;) //硬链接\nfs.symlinkSync(&#39;./index.txt&#39;, &#39;./index3.txt&#39; ,&quot;file&quot;) //软连接\n</code></pre>\n<h6 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h6><p><strong>硬链接的作用和用途如下：</strong></p>\n<ol>\n<li>文件共享：硬链接允许多个文件名指向同一个文件，这样可以在不同的位置使用不同的文件名引用相同的内容。这样的共享文件可以节省存储空间，并且在多个位置对文件的修改会反映在所有引用文件上。</li>\n<li>文件备份：通过创建硬链接，可以在不复制文件的情况下创建文件的备份。如果原始文件发生更改，备份文件也会自动更新。这样可以节省磁盘空间，并确保备份文件与原始文件保持同步。</li>\n<li>文件重命名：通过创建硬链接，可以为文件创建一个新的文件名，而无需复制或移动文件。这对于需要更改文件名但保持相同内容和属性的场景非常有用。</li>\n</ol>\n<p><strong>软链接的一些特点和用途如下：</strong></p>\n<ol>\n<li>软链接可以创建指向文件或目录的引用。这使得你可以在不复制或移动文件的情况下引用它们，并在不同位置使用不同的文件名访问相同的内容。</li>\n<li>软链接可以用于创建快捷方式或别名，使得你可以通过一个简短或易记的路径来访问复杂或深层次的目录结构。</li>\n<li>软链接可以用于解决文件或目录的位置变化问题。如果目标文件或目录被移动或重命名，只需更新软链接的目标路径即可，而不需要修改引用该文件或目录的其他代码。</li>\n</ol>\n<h2 id=\"crypto模块\"><a href=\"#crypto模块\" class=\"headerlink\" title=\"crypto模块\"></a>crypto模块</h2><p>crypto模块的目的是为了提供通用的<code>加密和哈希算法</code>。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。nodejs用C&#x2F;C++实现这些算法后，通过crypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>\n<p>密码学是计算机科学中的一个重要领域，它涉及到加密、解密、哈希函数和数字签名等技术。Node.js是一个流行的服务器端JavaScript运行环境，它提供了强大的密码学模块，使开发人员能够轻松地在其应用程序中实现各种密码学功能。本文将介绍密码学的基本概念，并探讨Node.js中常用的密码学API。</p>\n<h4 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h4><pre><code class=\"js\">js复制代码const crypto = require(&#39;node:crypto&#39;);\n\n// 生成一个随机的 16 字节的初始化向量 (IV)\nconst iv = Buffer.from(crypto.randomBytes(16));\n\n// 生成一个随机的 32 字节的密钥\nconst key = crypto.randomBytes(32);\n\n// 创建加密实例，使用 AES-256-CBC 算法，提供密钥和初始化向量\nconst cipher = crypto.createCipheriv(&quot;aes-256-cbc&quot;, key, iv);\n\n// 对输入数据进行加密，并输出加密结果的十六进制表示\ncipher.update(&quot;小满zs&quot;, &quot;utf-8&quot;, &quot;hex&quot;);\nconst result = cipher.final(&quot;hex&quot;);\n\n// 解密\nconst de = crypto.createDecipheriv(&quot;aes-256-cbc&quot;, key, iv);\nde.update(result, &quot;hex&quot;);\nconst decrypted = de.final(&quot;utf-8&quot;);\n\nconsole.log(&quot;Decrypted:&quot;, decrypted);\n</code></pre>\n<p>对称加密是一种简单而快速的加密方式，它使用相同的密钥（称为对称密钥）来进行加密和解密。这意味着发送者和接收者在加密和解密过程中都使用相同的密钥。对称加密算法的加密速度很快，适合对大量数据进行加密和解密操作。然而，对称密钥的安全性是一个挑战，因为需要确保发送者和接收者都安全地共享密钥，否则有风险被未授权的人获取密钥并解密数据。</p>\n<h4 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h4><pre><code class=\"js\">js复制代码const crypto = require(&#39;node:crypto&#39;)\n// 生成 RSA 密钥对\nconst &#123; privateKey, publicKey &#125; = crypto.generateKeyPairSync(&#39;rsa&#39;, &#123;\n  modulusLength: 2048,\n&#125;);\n\n// 要加密的数据\nconst text = &#39;小满zs&#39;;\n\n// 使用公钥进行加密\nconst encrypted = crypto.publicEncrypt(publicKey, Buffer.from(text, &#39;utf-8&#39;));\n\n// 使用私钥进行解密\nconst decrypted = crypto.privateDecrypt(privateKey, encrypted);\n\nconsole.log(decrypted.toString());\n</code></pre>\n<p>非对称加密使用一对密钥，分别是公钥和私钥。发送者使用接收者的公钥进行加密，而接收者使用自己的私钥进行解密。公钥可以自由分享给任何人，而私钥必须保密。非对称加密算法提供了更高的安全性，因为即使公钥泄露，只有持有私钥的接收者才能解密数据。然而，非对称加密算法的加密速度相对较慢，不适合加密大量数据。因此，在实际应用中，通常使用非对称加密来交换对称密钥，然后使用对称加密算法来加密实际的数据。</p>\n<h4 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h4><pre><code class=\"js\">const crypto = require(&#39;node:crypto&#39;);\n// 要计算哈希的数据\nlet text = &#39;123456&#39;;\n// 创建哈希对象，并使用 MD5 算法\nconst hash = crypto.createHash(&#39;md5&#39;);\n// 更新哈希对象的数据\nhash.update(text);\n// 计算哈希值，并以十六进制字符串形式输出\nconst hashValue = hash.digest(&#39;hex&#39;);\nconsole.log(&#39;Text:&#39;, text);\nconsole.log(&#39;Hash:&#39;, hashValue);\n</code></pre>\n<p>哈希函数具有以下特点：</p>\n<ol>\n<li>固定长度输出：不论输入数据的大小，哈希函数的输出长度是固定的。例如，常见的哈希函数如 MD5 和 SHA-256 生成的哈希值长度分别为 128 位和 256 位。</li>\n<li>不可逆性：哈希函数是单向的，意味着从哈希值推导出原始输入数据是非常困难的，几乎不可能。即使输入数据发生微小的变化，其哈希值也会完全不同。</li>\n<li>唯一性：哈希函数应该具有较低的碰撞概率，即不同的输入数据生成相同的哈希值的可能性应该非常小。这有助于确保哈希值能够唯一地标识输入数据。</li>\n</ol>\n<p>使用场景</p>\n<ol>\n<li>我们可以避免密码明文传输 使用md5加密或者sha256</li>\n<li>验证文件完整性，读取文件内容生成md5 如果前端上传的md5和后端的读取文件内部的md5匹配说明文件是完整的</li>\n</ol>\n<h2 id=\"md转html\"><a href=\"#md转html\" class=\"headerlink\" title=\"md转html\"></a>md转html</h2><h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><ul>\n<li>ejs：模板渲染库，使用特定语法填充内容，进行模板渲染</li>\n<li>marked：用于将Markdown语法转为HTML</li>\n<li>browserSync：用于在浏览器实时预览和同步刷新</li>\n</ul>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>index.js</p>\n<pre><code class=\"js\">const ejs = require(&#39;ejs&#39;); // 导入ejs库，用于渲染模板\nconst fs = require(&#39;node:fs&#39;); // 导入fs模块，用于文件系统操作\nconst marked = require(&#39;marked&#39;); // 导入marked库，用于将Markdown转换为HTML\nconst readme = fs.readFileSync(&#39;README.md&#39;); // 读取README.md文件的内容,直接read的结果是buffer中的数据，通过toString方法变为原始内容\nconst browserSync = require(&#39;browser-sync&#39;); // 导入browser-sync库，用于实时预览和同步浏览器\nconst openBrowser =  () =&gt; &#123;\n    // 创建浏览器服务\n    const browser = browserSync.create()\n    // 初始化浏览器服务 ，传入目录和主页\n    browser.init(&#123;\n        server: &#123;\n            baseDir: &#39;./&#39;,\n            index: &#39;index.html&#39;,\n        &#125;\n    &#125;)\n    return browser\n&#125;\n// ejs模板进行渲染，传入变量\nejs.renderFile(&#39;template.ejs&#39;, &#123;\n    content: marked.parse(readme.toString()),\n    title:&#39;markdown to html&#39;\n&#125;,(err,data)=&gt;&#123;\n    if(err)&#123;\n        console.log(err)\n    &#125;\n    // 将文件内容写入到index.html\n    let writeStream = fs.createWriteStream(&#39;index.html&#39;)\n    writeStream.write(data)\n    writeStream.close()\n    writeStream.on(&#39;finish&#39;,()=&gt;&#123;\n        // index.html写入完毕之后，打开浏览器实时预览\n        openBrowser()\n    &#125;)\n&#125;)     \n</code></pre>\n<p>template.ejs</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;  &lt;!-- 引入css样式 --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%- content %&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>index.css</p>\n<pre><code class=\"css\">/* Markdown通用样式 */\n/* 设置全局字体样式 */\nbody &#123;\n    font-family: Arial, sans-serif;\n    font-size: 16px;\n    line-height: 1.6;\n    color: #333;\n  &#125;\n  /* 设置标题样式 */\n  h1,h2,h3,h4,h5,h6 &#123;\n    margin-top: 1.3em;\n    margin-bottom: 0.6em;\n    font-weight: bold;\n  &#125;\n  h1 &#123;\n    font-size: 2.2em;\n  &#125;\n  h2 &#123;\n    font-size: 1.8em;\n  &#125;\n  h3 &#123;\n    font-size: 1.6em;\n  &#125;\n  h4 &#123;\n    font-size: 1.4em;\n  &#125;\n  h5 &#123;\n    font-size: 1.2em;\n  &#125;\n  h6 &#123;\n    font-size: 1em;\n  &#125;\n  /* 设置段落样式 */\n  p &#123;\n    margin-bottom: 1.3em;\n  &#125;\n  /* 设置链接样式 */\n  a &#123;\n    color: #337ab7;\n    text-decoration: none;\n  &#125;\n  a:hover &#123;\n    text-decoration: underline;\n  &#125;\n  /* 设置列表样式 */\n  ul,\n  ol &#123;\n    margin-top: 0;\n    margin-bottom: 1.3em;\n    padding-left: 2em;\n  &#125;\n  /* 设置代码块样式 */\n  pre &#123;\n    background-color: #f7f7f7;\n    padding: 1em;\n    border-radius: 4px;\n    overflow: auto;\n  &#125;\n  code &#123;\n    font-family: Consolas, Monaco, Courier, monospace;\n    font-size: 0.9em;\n    background-color: #f7f7f7;\n    padding: 0.2em 0.4em;\n    border-radius: 4px;\n  &#125;\n  /* 设置引用样式 */\n  blockquote &#123;\n    margin: 0;\n    padding-left: 1em;\n    border-left: 4px solid #ddd;\n    color: #777;\n  &#125;\n  /* 设置表格样式 */\n  table &#123;\n    border-collapse: collapse;\n    width: 100%;\n    margin-bottom: 1.3em;\n  &#125;\n  table th,\n  table td &#123;\n    padding: 0.5em;\n    border: 1px solid #ccc;\n  &#125;\n  /* 添加一些额外的样式，如图片居中显示 */\n  img &#123;\n    display: block;\n    margin: 0 auto;\n    max-width: 100%;\n    height: auto;\n  &#125;\n  /* 设置代码行号样式 */\n  pre code .line-numbers &#123;\n    display: inline-block;\n    width: 2em;\n    padding-right: 1em;\n    color: #999;\n    text-align: right;\n    user-select: none;\n    pointer-events: none;\n    border-right: 1px solid #ddd;\n    margin-right: 0.5em;\n  &#125;\n  /* 设置代码行样式 */\n  pre code .line &#123;\n    display: block;\n    padding-left: 1.5em;\n  &#125;\n  /* 设置代码高亮样式 */\n  pre code .line.highlighted &#123;\n    background-color: #f7f7f7;\n  &#125;\n  /* 添加一些响应式样式，适应移动设备 */\n  @media only screen and (max-width: 768px) &#123;\n    body &#123;\n      font-size: 14px;\n      line-height: 1.5;\n    &#125;\n    h1 &#123;\n      font-size: 1.8em;\n    &#125;\n    h2 &#123;\n      font-size: 1.5em;\n    &#125;\n    h3 &#123;\n      font-size: 1.3em;\n    &#125;\n    h4 &#123;\n      font-size: 1.1em;\n    &#125;\n    h5 &#123;\n      font-size: 1em;\n    &#125;\n    h6 &#123;\n      font-size: 0.9em;\n    &#125;\n    table &#123;\n      font-size: 14px;\n    &#125;\n  &#125;    \n</code></pre>\n<h2 id=\"zlib模块\"><a href=\"#zlib模块\" class=\"headerlink\" title=\"zlib模块\"></a>zlib模块</h2><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ul>\n<li>Node.js中zlib模块用于对数据提供压缩和解压缩的功能，以便在应用程序中减少数据的传输大小、节省带宽和提高性能</li>\n<li>该模块包含各种压缩算法，包含Deflate、Gzip和Raw Deflate等</li>\n</ul>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><ul>\n<li><p>数据压缩，减少数据的大小，这在网络传输和磁盘存储中很有用，可以节省带宽和存储空间</p>\n</li>\n<li><p>数据解压缩</p>\n</li>\n<li><p>流压缩，zlib模块支持流式的方式进行数据的压缩和解压缩，使得可以对大型文件或者网络数据流进行逐步处理，而不需要将整个数据加载到内存中。</p>\n<pre><code class=\"js\">// 压缩文件（以Gzip为例）\nconst zlib = require(&#39;zlib&#39;)\nconst fs = require(&#39;node:fs&#39;)\nconst readStream = fs.createReadStream(&#39;./test.txt&#39;);\nconst writeStream = fs.createWriteStream(&#39;./test.txt.gz&#39;);\n// 将readStream利用zlib进行压缩,pipe到下一个管道，最后pipe到写入流\nreadStream.pipe(zlib.createGzip()).pipe(writeStream)\n// 解压缩文件\nconst reStr = fs.createReadStream(&#39;./test.txt.gz&#39;);\nconst wrStr = fs.createWriteStream(&#39;./t.txt&#39;);\nconst gunzip = zlib.createGunzip();\nreStr.pipe(gunzip).pipe(wrStr);\ngunzip.on(&#39;error&#39;, (err) =&gt; &#123;\n    console.error(&#39;Gunzip error:&#39;, err);\n&#125;);\n  reStr.on(&#39;end&#39;, () =&gt; &#123;\n    console.log(&#39;Input file has been read.&#39;);\n&#125;);\n  wrStr.on(&#39;finish&#39;, () =&gt; &#123;\n    console.log(&#39;Output file has been written.&#39;);\n&#125;);\n</code></pre>\n<h4 id=\"对比-1\"><a href=\"#对比-1\" class=\"headerlink\" title=\"对比\"></a>对比</h4><ol>\n<li>压缩算法：Gzip 使用的是 Deflate 压缩算法，该算法结合了 LZ77 算法和哈夫曼编码。LZ77 算法用于数据的重复字符串的替换和引用，而哈夫曼编码用于进一步压缩数据。</li>\n<li>压缩效率：Gzip 压缩通常具有更高的压缩率，因为它使用了哈夫曼编码来进一步压缩数据。哈夫曼编码根据字符的出现频率，将较常见的字符用较短的编码表示，从而减小数据的大小。</li>\n<li>压缩速度：相比于仅使用 Deflate 的方式，Gzip 压缩需要更多的计算和处理时间，因为它还要进行哈夫曼编码的步骤。因此，在压缩速度方面，Deflate 可能比 Gzip 更快。</li>\n<li>应用场景：Gzip 压缩常用于文件压缩、网络传输和 HTTP 响应的内容编码。它广泛应用于 Web 服务器和浏览器之间的数据传输，以减小文件大小和提高网络传输效率。</li>\n<li>deflate是一种过时的压缩方式，现代浏览器对其支持并不友好</li>\n</ol>\n</li>\n</ul>\n<p><strong>zlib模块可以用于对发送网络请求返回的数据进行压缩，节省带宽和传输速率。</strong></p>\n<h4 id=\"brotli\"><a href=\"#brotli\" class=\"headerlink\" title=\"brotli\"></a>brotli</h4><ul>\n<li>针对常见的 Web 资源内容，Brotli 的性能比 Gzip 提高了 17-25%；</li>\n<li>当 Brotli 压缩级别为 1 时，压缩率比 Gzip 的最高级别 9 还要高；</li>\n<li>在处理不同的 HTML 文档时，Brotli 依然能提供非常高的压缩率。</li>\n<li>除了 IE 和 Opera Mini 之外，几乎所有主流浏览器都已支持 Brotli 算法。</li>\n<li>尽管 Brotli 在压缩方面表现出色，但随着压缩级别的提高，Brotli 压缩所需的时间也会相应增加。换句话说，Brotli 需要更多的计算能力，这可能意味着更高的设备和软件成本。</li>\n<li>Brotli 要求浏览器必须支持 HTTPS 才能使用。</li>\n</ul>\n<h2 id=\"http模块\"><a href=\"#http模块\" class=\"headerlink\" title=\"http模块\"></a>http模块</h2><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ul>\n<li>http模块是Node.js中用于创建和处理HTTP服务器和客户端的核心模块</li>\n<li>http模块使得基于HTTP协议的应用程序更加简单和灵活</li>\n<li>http模块也可以用于创建代理服务器，用于转发客户端的请求到其他服务器，代理服务器可以用于负载均衡、缓存、安全过滤或跨域请求等场景。通过在代理服务器上添加逻辑，可以对请求和响应进行修改、记录或过滤。</li>\n<li>http模块也可以创建文件服务器，用于提供静态文件，通过读取文件并将其作为响应发送给客户端。</li>\n</ul>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code class=\"js\">const http = require(&#39;http&#39;)\nconst httpServer = http.createServer((req,res)=&gt;&#123;\n    if(req.method === &#39;POST&#39;)&#123;&#125;\n    else if(req.method === &#39;GET&#39;)&#123;&#125;\n&#125;)\nhttpServer.listen(98,()=&gt;&#123;\n    console.log(&#39;服务器启动，端口：98&#39;);\n&#125;)\n</code></pre>\n<h4 id=\"url模块\"><a href=\"#url模块\" class=\"headerlink\" title=\"url模块\"></a>url模块</h4><p>可以通过url模块来解析req的请求路径，来进一步精细化响应内容。</p>\n<pre><code class=\"js\">const http = require(&#39;node:http&#39;); // 引入 http 模块\nconst url = require(&#39;node:url&#39;); // 引入 url 模块\n// 创建 HTTP 服务器，并传入回调函数用于处理请求和生成响应\nhttp.createServer((req, res) =&gt; &#123;\n  const &#123; pathname, query &#125; = url.parse(req.url, true); // 解析请求的 URL，获取路径和查询参数\n  if (req.method === &#39;POST&#39;) &#123; // 检查请求方法是否为 POST\n    if (pathname === &#39;/post&#39;) &#123; // 检查路径是否为 &#39;/post&#39;\n      let data = &#39;&#39;;\n      req.on(&#39;data&#39;, (chunk) =&gt; &#123;\n        data += chunk; // 获取 POST 请求的数据\n        console.log(data);\n      &#125;);\n      req.on(&#39;end&#39;, () =&gt; &#123;\n        res.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); // 设置响应头的 Content-Type 为 &#39;application/json&#39;\n        res.statusCode = 200; // 设置响应状态码为 200\n        res.end(data); // 将获取到的数据作为响应体返回\n      &#125;);\n    &#125; else &#123;\n      res.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); // 设置响应头的 Content-Type 为 &#39;application/json&#39;\n      res.statusCode = 404; // 设置响应状态码为 404\n      res.end(&#39;Not Found&#39;); // 返回 &#39;Not Found&#39; 作为响应体\n    &#125;\n  &#125; else if (req.method === &#39;GET&#39;) &#123; // 检查请求方法是否为 GET\n    if (pathname === &#39;/get&#39;) &#123; // 检查路径是否为 &#39;/get&#39;\n      console.log(query.a); // 打印查询参数中的键名为 &#39;a&#39; 的值\n      res.end(&#39;get success&#39;); // 返回 &#39;get success&#39; 作为响应体\n    &#125;\n  &#125;\n&#125;).listen(98, () =&gt; &#123;\n  console.log(&#39;server is running on port 98&#39;); // 打印服务器启动的信息\n&#125;);\n</code></pre>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><ul>\n<li>动静分离是Web服务器架构中常用的优化技术，用于提高网站的性能和可伸缩性</li>\n<li>原理就是将静态资源的请求和动态内容分开处理（通过url，例如加上static后缀表示静态）</li>\n<li>好处在于：<ul>\n<li>性能优化（静态资源内容不变，可以利用缓存）</li>\n<li>负载均衡（动态内容请求分发到不同的服务器或服务上，平衡服务器的负载）</li>\n<li>安全性（动态内容往往涉及敏感信息，动静分离可以更好地管理访问控制和安全策略）</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"js\">import http from &#39;node:http&#39; // 导入http模块\nimport fs from &#39;node:fs&#39; // 导入文件系统模块\nimport path from &#39;node:path&#39; // 导入路径处理模块\nimport mime from &#39;mime&#39; // 导入mime模块\nconst server = http.createServer((req, res) =&gt; &#123;\n    const &#123; url, method &#125; = req\n    // 处理静态资源\n    if (method === &#39;GET&#39; &amp;&amp; url.startsWith(&#39;/static&#39;)) &#123;\n        const filePath = path.join(process.cwd(), url) // 获取文件路径\n        const mimeType = mime.getType(filePath) // 获取文件的MIME类型\n        console.log(mimeType) // 打印MIME类型\n        fs.readFile(filePath, (err, data) =&gt; &#123; // 读取文件内容\n            if (err) &#123;\n                res.writeHead(404, &#123;\n                    &quot;Content-Type&quot;: &quot;text/plain&quot; // 设置响应头为纯文本类型\n                &#125;)\n                res.end(&#39;not found&#39;) // 返回404 Not Found\n            &#125; else &#123;\n                res.writeHead(200, &#123;\n                    &quot;Content-Type&quot;: mimeType, // 设置响应头为对应的MIME类型\n                    &quot;Cache-Control&quot;: &quot;public, max-age=3600&quot; // 设置缓存控制头\n                &#125;)\n                res.end(data) // 返回文件内容\n            &#125;\n        &#125;)\n    &#125;\n    // 处理动态资源\n    if (url.startsWith(&#39;/api&#39;)) &#123;\n        // ...处理动态资源的逻辑\n    &#125;\n&#125;)\nserver.listen(80) // 监听端口80\n</code></pre>\n<h2 id=\"邮件服务\"><a href=\"#邮件服务\" class=\"headerlink\" title=\"邮件服务\"></a>邮件服务</h2><p>邮件服务可以用于给成员发送邮件、通知成员信息</p>\n<p><strong>工具：</strong></p>\n<ul>\n<li>js-yaml：用于将yaml转为js对象</li>\n<li>nodemailer：用于创建邮件服务</li>\n</ul>\n<p><strong>使用：</strong></p>\n<pre><code class=\"js\">// node.js发送邮件\nconst yamlTrans = require(&#39;js-yaml&#39;);\nconst fs = require(&#39;fs&#39;);\nconst nodemailer = require(&#39;nodemailer&#39;)\nconst yamlCode = fs.readFileSync(&#39;./data.yaml&#39;,&#39;utf-8&#39;);\nconst dataObj = yamlTrans.load(yamlCode);\n//nodemailer.createTransport创建transPort服务,传入auth信息和配置项\n//授权码需要到对应官网生成\nconst transPort = nodemailer.createTransport(&#123;\n    serviece:&#39;qq&#39;,\n    port:587,\n    host:&#39;smtp.qq.cmo&#39;,\n    secure:true,\n    auth:&#123;\n        pass:dataObj.pass, //授权码需要去官网申请生成\n        user:dataObj.user\n    &#125;\n&#125;)\n// sendMail方法发送邮件，传入接收方信息\ntransPort.sendMail(&#123;\n    to: send.qq.com,\n    from: dataObj.user,\n    subject: &#39;邮件标题&#39;,\n    text: &#39;邮件内容&#39;\n&#125;)\n</code></pre>\n","categories":["Node.js"],"tags":["node.js"]},{"title":"serviceWorker","url":"/2024/02/02/serviceWorker/","content":"<h2 id=\"serviceWorker-html\"><a href=\"#serviceWorker-html\" class=\"headerlink\" title=\"serviceWorker.html\"></a>serviceWorker.html</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script&gt;\n        //数据库\n        console.log(window.indexedDB);\n        //service worker\n        console.log(window.navigator.serviceWorker);\n        //service Worker是后台运行的脚本，充当一个代理服务器，拦截用户发出的网络请求。还可以修改用户的请求或者直接向用户发出回应，使得用户可以在离线情况下使用网络应用。还可以在本地缓存资源文件，加快访问速度。\n        if(&#39;serviceWorker&#39; in navigator)&#123;\n             window.addEventListener(&#39;load&#39;,()=&gt;&#123;\n             navigator.serviceWorker.register(&#39;./service-worker.js&#39;);\n            &#125;)\n        &#125;\n        navigator.serviceWorker.register(&#39;./service-worker.js&#39;).then(res=&gt;&#123;\n            console.info(&#39;注册成功&#39;);\n        &#125;).catch(err=&gt;&#123;\n            console.error(&#39;注册失败&#39;);\n        &#125;)\n        // 为了节省内存，当service-Worker不使用时是休眠的，他也不回保存数据，所以重新启动时，为了拿到数据需要将数据放在IndexedDb中\n        //服务端部署消息，监听代码\n        window.addEventListener(&#39;message&#39;,data=&gt;&#123;\n            if(data.source===&#39;service-worker&#39;)&#123;\n                console.log(data.msg,&#39;serviceWorker发送来的消息&#39;);\n            &#125;\n        &#125;)\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"serviceWorker-js\"><a href=\"#serviceWorker-js\" class=\"headerlink\" title=\"serviceWorker.js\"></a>serviceWorker.js</h2><pre><code class=\"js\">//serviceWorker是基于事件驱动的。\n//serviceWorker安装事件\nself.addEventListener(&#39;install&#39;,event=&gt;&#123;\n    console.log(event,&#39;安装事件&#39;);\n    event.waitUntil(()=&gt;&#123;\n        console.info(&#39;安装完成&#39;);\n    &#125;)\n&#125;)\n//serviceWorker激活事件（当安装完成之后就开始激活）\nself.addEventListener(&#39;active&#39;,(event)=&gt;&#123;\n    let cacheWhiteList = [&#39;product-v2&#39;];\n    event.waitUntil(\n        caches.keys().then(cacheNames=&gt;&#123;\n            return Promise.all(\n                cacheNames.map(cacheName=&gt;&#123;\n                    if(cacheWhiteList.indexOf(cacheName) === -1)&#123;\n                        return caches.delete(cacheName);\n                    &#125;\n                &#125;)\n            )\n        &#125;)\n    )\n&#125;)\n//serviceWorker与网页的通信\nself.addEventListener(&#39;active&#39;,(event)=&gt;&#123;\n    event.waitUntil(\n        self.clients.matchAll().then((client)=&gt;&#123;\n            client.postMessage(&#123;\n                msg:&quot;Hello serviceWorker&quot;,\n                source:&quot;serviceWorker&quot;\n            &#125;)\n        &#125;)\n    )\n&#125;)\n</code></pre>\n","categories":["JS"],"tags":["JS","serviceWorker"]},{"title":"Linux","url":"/2023/01/22/linux%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<h1 id=\"Linux-服务器\"><a href=\"#Linux-服务器\" class=\"headerlink\" title=\"Linux 服务器\"></a>Linux 服务器</h1><p><strong>Linux是操作系统：</strong></p>\n<p>Linux作为<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTg3JUFBJUU3JTk0JUIxJUU4JUJEJUFGJUU0JUJCJUI2\">自由软件</span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJDJTgwJUU2JTk0JUJFJUU2JUJBJTkwJUU0JUJCJUEzJUU3JUEwJTgxJUU4JUJEJUFGJUU0JUJCJUI2\">开放源代码软件</span>发展中最著名的例子，背靠社区与商业化的使用，使其得到了广泛的应用与发展。</p>\n<p><strong>Linux无处不在：</strong></p>\n<p>世界上500个最快的超级计算机90％以上运行Linux发行版或变种，包括最快的前10名超级计算机运行的都是基于Linux内核的操作系统。Linux也广泛应用在嵌入式系统上，如手机（Mobile Phone）、平板电脑（Tablet）、路由器（Router）、电视（TV）和电子游戏机等。在移动设备上广泛使用的Android操作系统就是创建在Linux内核之上。</p>\n<p><strong>学习Linux迫在眉睫：</strong></p>\n<ul>\n<li>公司都在用</li>\n<li>小伙伴们都会用</li>\n<li>关键免费啊….</li>\n</ul>\n<p><strong>本课程的主要目标：</strong></p>\n<ul>\n<li>了解Linux操作系统(版本、目录、安装等)</li>\n<li>学会使用Linux常见的命令</li>\n<li>搭建Nginx服务，给你的Web小站一个运行环境吧~~</li>\n<li>介绍HTTP(s)及免费申请SSL证书</li>\n<li>云服务器阿里云、华为云（介绍）、云数据库RDS介绍</li>\n<li>什么是负载均衡？负载均衡有什么用？阿里云SLB介绍</li>\n</ul>\n<p><strong>前置准备【下面的方式任选其一】：</strong></p>\n<ul>\n<li>使用虚拟化软件(本地安装)</li>\n<li>购买云服务器</li>\n</ul>\n<p>版本准备：linux操作系统(Centos 7.6)</p>\n<p>可选：准备一个域名</p>\n<h2 id=\"Linux简介\"><a href=\"#Linux简介\" class=\"headerlink\" title=\"Linux简介\"></a>Linux简介</h2><h3 id=\"版本介绍\"><a href=\"#版本介绍\" class=\"headerlink\" title=\"版本介绍\"></a>版本介绍</h3><p><img data-src=\"/./assets/123-3.png\" alt=\"Linux简版介绍\"></p>\n<p>Fedora是基于RHEL，CentOS，Scientific Linux, 和Oracle Linux的社区版本。相比RHEL，Fedora打包了显著的更多的软件包。其中一个原因是，多样化的社区参与Fedora的建设，它不只是一家公司。在这个过程中，CentOS用于活动，演示和实验，因为它是对最终用户免费提供的，并具有比Fedora的一个更长的发布周期(通常每隔半年左右发布一个新版本)。</p>\n<p>Debian是包括Ubuntu在内许多发行版的上游，而Ubuntu又是Linux Mint及其他发行版的上游。Debian在服务器和桌面电脑领域都有着广泛的应用。Debian是一个纯开源计划并着重在一个关键点上，稳定性。它同时也提供了最大的和完整的软件仓库给用户。</p>\n<p>Linux的发行版本可以大体分为两类，一类是商业公司维护的发行版本，如：著名的Redhat(RHEL)，一类是社区组织维护的发行版本，如：Debian。下面介绍一下各个发行版本的特点：</p>\n<h4 id=\"Centos-Redhat\"><a href=\"#Centos-Redhat\" class=\"headerlink\" title=\"Centos(Redhat)\"></a>Centos(Redhat)</h4><p>Redhat，应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区克隆版本，免费)。</p>\n<p>包管理方式：采用的是基于<code>rpm</code>包的<code>yum</code>包管理方式。</p>\n<h4 id=\"Debian\"><a href=\"#Debian\" class=\"headerlink\" title=\"Debian\"></a>Debian</h4><p>Debian是社区类Linux的典范，是迄今为止最遵循GNU规范 的Linux系统。Debian最早由Ian Murdock于1993年创建，分为三个版本分支(branch)： <code>stable</code>, <code>testing</code> 和 <code>unstable</code>。其中，<code>unstable</code>为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。<code>testing</code>的版本都经 过<code>unstable</code>中的测试，相对较为稳定，也支持了不少新技术(比如SMP等)。而<code>stable</code>一般只用于服务器，上面的软件包大部分都比较过时，但是稳定和安全性都非常的高。</p>\n<p>包管理方式：采用的是基于是<code>apt-get</code>、<code>dpkg</code>包管理方式。</p>\n<h4 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h4><p>Ubuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的<code>unstable</code>版本加强而来，可以这么说，Ubuntu就是 一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。根据选择的桌面系统不同，有三个版本可供选择，基于<code>Gnome</code>的Ubuntu，基于<code>KDE</code>的Kubuntu以及基于<code>Xfc</code>的 Xubuntu。特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。</p>\n<p>包管理方式：采用的是基于是<code>apt-get</code>、<code>dpkg</code>包管理方式。</p>\n<p>总结对比一下：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Centos</th>\n<th>Debian</th>\n<th>Ubuntu</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>包管理</td>\n<td>yum</td>\n<td>apt-get</td>\n<td>apt-get</td>\n</tr>\n<tr>\n<td>桌面应用</td>\n<td>支持</td>\n<td>需要另装</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>系统资源占用</td>\n<td>小</td>\n<td>非常小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>资料</td>\n<td>最多</td>\n<td>依赖社区</td>\n<td>多</td>\n</tr>\n<tr>\n<td>更新频次</td>\n<td>长达10年</td>\n<td>1-2年</td>\n<td>3-5年</td>\n</tr>\n<tr>\n<td>软件资源</td>\n<td>较新</td>\n<td>最新</td>\n<td>新</td>\n</tr>\n<tr>\n<td>漏洞更新</td>\n<td>慢</td>\n<td>依赖社区</td>\n<td>依赖社区</td>\n</tr>\n<tr>\n<td>默认安装</td>\n<td>非常全</td>\n<td>无</td>\n<td>非常全</td>\n</tr>\n<tr>\n<td>稳定性</td>\n<td>较稳定</td>\n<td>稳定</td>\n<td>相对稳定</td>\n</tr>\n<tr>\n<td>系统操作要求</td>\n<td>较高</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>维护要求</td>\n<td>低</td>\n<td>高</td>\n<td>较高</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>一般</td>\n<td>差</td>\n<td>较好</td>\n</tr>\n<tr>\n<td>定制化</td>\n<td>一般</td>\n<td>高</td>\n<td>差</td>\n</tr>\n</tbody></table>\n<p>CentOS是RHEL发行版对应的开源版本，通常在RedHat的发布后就会很快发行。它既稳定，占用资源又少，在网络上能方便搜索到安装配置的文档，自身的帮助文档也非常强大。所以，新人学习推荐：<strong>Centos</strong></p>\n<blockquote>\n<p>本课程，后续的操作与演示，将会使用Centos 7.6 64-bit版本进行演示</p>\n</blockquote>\n<p>参考资料：<span class=\"exturl\" data-url=\"aHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy8xLzFiL0xpbnV4X0Rpc3RyaWJ1dGlvbl9UaW1lbGluZS5zdmc=\">Linux发行版及年份</span></p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"Linux-vs-Windows\"><a href=\"#Linux-vs-Windows\" class=\"headerlink\" title=\"Linux vs Windows\"></a>Linux vs Windows</h4><p>下面我们Linux与Windows作一个对比：</p>\n<p>这里Linux是免费的版本，如Centos, Ubuntu，而Windows则是Windows10&#x2F;8&#x2F;7</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Linux</th>\n<th>Windows</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>费用</td>\n<td>免费</td>\n<td>付费</td>\n</tr>\n<tr>\n<td>软件支持</td>\n<td>社区，免费</td>\n<td>官方支持，收费</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>很安全</td>\n<td>各种漏洞</td>\n</tr>\n<tr>\n<td>使用习惯</td>\n<td>命令行与界面操作，需要学习</td>\n<td>图形界面操作，简单</td>\n</tr>\n<tr>\n<td>可定制性</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>应用范畴</td>\n<td>服务器</td>\n<td>工作、娱乐</td>\n</tr>\n<tr>\n<td>更新</td>\n<td>依赖社区</td>\n<td>官方更新</td>\n</tr>\n<tr>\n<td>系统内核</td>\n<td>透明</td>\n<td>封闭</td>\n</tr>\n</tbody></table>\n<p>Linux的优势：</p>\n<ul>\n<li><strong>稳定的系统</strong></li>\n<li>安全性和漏洞的快速修补</li>\n<li>多用户</li>\n<li>用户和用户组的规划</li>\n<li><strong>相对较少的系统资源占用</strong></li>\n<li>可定制裁剪，移植到嵌入式平台（如安卓设备）</li>\n<li>可选择的多种图形用户界面（如 GNOME，KDE）</li>\n</ul>\n<p>Windows的优势：</p>\n<ul>\n<li>特定的支持厂商</li>\n<li><strong>足够的游戏娱乐支持度</strong></li>\n<li>足够的专业软件支持度</li>\n</ul>\n<h4 id=\"Linux的GUI界面\"><a href=\"#Linux的GUI界面\" class=\"headerlink\" title=\"Linux的GUI界面\"></a>Linux的GUI界面</h4><p>这里我们选择几款比较有代表性的桌面进行简单的介绍：</p>\n<ol>\n<li><p>GNOME<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ25vbWUub3JnLw==\">[官方地址]</span></p>\n<p><img data-src=\"/./assets/image-20190602081017634.png\" alt=\"/images/image-20190602081017634\"></p>\n<blockquote>\n<p>centos6.x 上默认是gnome2，7.x默认gnome3</p>\n</blockquote>\n<p><img data-src=\"/./assets/activities-overview.jpg\" alt=\"img\"></p>\n<p>上图为：GNOME3</p>\n</li>\n<li><p>KDE <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rZGUub3JnLw==\">[官方地址]</span></p>\n<p><img data-src=\"/./assets/plasma-5.12.png\" alt=\"Plasma 5.12\"></p>\n<p>上图为：Plasma 5.12 LTS</p>\n</li>\n<li><p>Unity</p>\n<p><img data-src=\"/./assets/v2-c495dceef151f7685d5964a99c970f2b_r.jpg\" alt=\"preview\"></p>\n<p><strong>Unity</strong>是<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQ2Fub25pY2FsJUU1JTg1JUFDJUU1JThGJUI4\">Canonical公司</span>为<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR05PTUU=\">GNOME</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUExJThDJUU5JTlEJUEyJUU3JThFJUFGJUU1JUEyJTgz\">桌面环境</span>所开发的<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlCJUJFJUU1JUJEJUEyJUU3JTk0JUE4JUU2JTg4JUI3JUU3JTk1JThDJUU5JTlEJUEy\">图形用户界面</span>，用于<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVWJ1bnR1\">Ubuntu</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTkzJThEJUU0JUJEJTlDJUU3JUIzJUJCJUU3JUJCJTlG\">操作系统</span>。</p>\n<blockquote>\n<p>直到Ubuntu16.04LTS，使用的都是Unity，从 Ubuntu 18.04 LTS 开始，默认的 Ubuntu 桌面将重归 GNOME。人事调整，与钱的问题….有兴趣的同学可以看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbnNpZ2h0cy51YnVudHUuY29tLzIwMTcvMDQvMDUvZ3Jvd2luZy11YnVudHUtZm9yLWNsb3VkLWFuZC1pb3QtcmF0aGVyLXRoYW4tcGhvbmUtYW5kLWNvbnZlcmdlbmNlLw==\">这里</span></p>\n</blockquote>\n</li>\n</ol>\n<p>我们来看看<span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmVuZHMuZ29vZ2xlLmNvbS90cmVuZHMvZXhwbG9yZT9kYXRlPXRvZGF5JTIwNS15JnE9R05PTUUsS0RFLC9tLzBkc2JrMG4=\">Google Trends</span></p>\n<p>参考资料：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy51YnVudHUub3JnLmNuL2Rvd25sb2Fk\">Ubuntu官方下载地址：获取 Ubuntu</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5cWJsb2cvYXJ0aWNsZS9kZXRhaWxzLzgwMTUyMDE2\">Ubuntu18.04（Gnome桌面）主题美化</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9fc25vdy9hcnRpY2xlL2RldGFpbHMvODAxNTIwNjg=\">Ubuntu 18.04配置及美化</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxpdS5pby8yMDE4LzEyLzIyL1VidW50dTE4LjA0JUU1JUFFJThDJUU3JUJFJThFJUU5JTg1JThEJUU3JUJEJUFFLyMlRTYlOTUlODglRTYlOUUlOUMlRTklQTIlODQlRTglQTclODg=\">Ubuntu18.04完美配置优化美化</span></p>\n<h4 id=\"常见软件应用\"><a href=\"#常见软件应用\" class=\"headerlink\" title=\"常见软件应用\"></a>常见软件应用</h4><ul>\n<li>数据库：MySQL、Oracle、 MongoDB、Redis</li>\n<li>web服务器：<code>Nginx</code>、Apache</li>\n<li>浏览器：Chromium(Chrome)、Firefox</li>\n<li>编辑器：Emacs，<code>Vim</code>，Nano，Atom，VScode，IntelliJ IDEA&amp;Webstorm</li>\n<li>文档：WPS Office、LibreOffice、Calligra(Ubuntu&#x2F;Debian)</li>\n<li>下载工具：<code>Aria2</code>、uGet(Ubuntu&#x2F;Debian)、XDM、qBittorrent</li>\n<li>虚拟化：VirtualBox、VMWare、</li>\n<li>系统工具：<code>git</code>、rsync、sudo、unzip、tar</li>\n<li>其他：音乐Netease Music、图片GIMP、聊天Wine QQ、播放器VLC</li>\n</ul>\n<h3 id=\"安装方法\"><a href=\"#安装方法\" class=\"headerlink\" title=\"安装方法\"></a>安装方法</h3><h4 id=\"Centos安装方法：\"><a href=\"#Centos安装方法：\" class=\"headerlink\" title=\"Centos安装方法：\"></a>Centos安装方法：</h4><ol>\n<li><p>下载镜像</p>\n<p><img data-src=\"/./assets/image-20190602095157756.png\" alt=\"/images/image-20190602095157756\"></p>\n<p>按需选择下载：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>DVD</th>\n<th>Minimal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>图形安装</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>自带软件包</td>\n<td>全家桶，可选择</td>\n<td>无</td>\n</tr>\n<tr>\n<td>镜像大小</td>\n<td>4G+</td>\n<td>800-900M</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>制作U盘启动盘</p>\n<p>Windows参考：<a href=\"#Windows%E4%B8%AD%E5%88%B6%E4%BD%9CUSB%E5%90%AF%E5%8A%A8%E7%9B%98\">Windows中制作USB启动盘</a></p>\n<p>Mac&#x2F;Linux参考：<a href=\"#MacOS%E4%B8%AD%E5%88%B6%E4%BD%9CUSB%E5%90%AF%E5%8A%A8%E7%9B%98\">MacOS中制作USB启动盘</a></p>\n</li>\n<li><p>修改BIOS启动顺序，重启</p>\n</li>\n<li><p>安装配置。€</p>\n</li>\n</ol>\n<p>参考资料</p>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmNlbnRvcy5vcmcvemgvSG93VG9zL0luc3RhbGxGcm9tVVNCa2V5\">官方U盘安装说明</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2VudG9zLm9yZy9kb3dubG9hZC8=\">镜像下载</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTgwNDgtMS5odG1s\">Centos7安装教程</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90dXRvcmlhbHMudWJ1bnR1LmNvbS90dXRvcmlhbC90dXRvcmlhbC1pbnN0YWxsLXVidW50dS1kZXNrdG9wIzA=\">Ubuntu官方安装教程</span></li>\n</ol>\n<p>常见问题：</p>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmppbmNodWFuZy5vcmcvMjA2Mi5odG1s\">centos7 U盘安装卡在 starting dracut initqueue hook </span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pncmprZmxta3ljL2FydGljbGUvZGV0YWlscy83ODI5MzUwNA==\">U盘安装CentOS7遇到：Warning: dracut-initqueue timeout - starting timeout scripts</span></li>\n</ol>\n<h4 id=\"Windows中制作USB启动盘\"><a href=\"#Windows中制作USB启动盘\" class=\"headerlink\" title=\"Windows中制作USB启动盘\"></a>Windows中制作USB启动盘</h4><p>操作步骤：</p>\n<ol>\n<li><p>格式化U盘(FAT32格式)</p>\n</li>\n<li><p>下载ISO镜像</p>\n</li>\n<li><p>下载资源文件中的写入程序</p>\n</li>\n<li><p>写入镜像(工具见后文)</p>\n</li>\n</ol>\n<p><img data-src=\"/./assets/1559440057311.jpg\" alt=\"1559440057311\"></p>\n<p>资源下载：</p>\n<p>Centos官网推荐：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvdXNid3JpdGVyLw==\">USBwriter</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvd2luMzJkaXNraW1hZ2VyLw==\">Win32 Disk Imager</span></p>\n<p>Ubuntu官网推荐：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ydWZ1cy5pZS8=\">rufus</span></p>\n<p><img data-src=\"/./assets/SouthEast.png\" alt=\"rufus\"></p>\n<h4 id=\"MacOS中制作USB启动盘\"><a href=\"#MacOS中制作USB启动盘\" class=\"headerlink\" title=\"MacOS中制作USB启动盘\"></a>MacOS中制作USB启动盘</h4><ol>\n<li><p>格式化U盘</p>\n<p><img data-src=\"/./assets/image-20190602094231784.png\" alt=\"/images/image-20190602094231784\"></p>\n</li>\n<li><p>使用 <code>diskutil list</code> 查看U的设备名</p>\n<pre><code>$ diskutil list\n/dev/disk0 (internal):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                         500.3 GB   disk0\n   1:                        EFI EFI                     314.6 MB   disk0s1\n   2:                 Apple_APFS Container disk1         500.0 GB   disk0s2\n\n/dev/disk1 (synthesized):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      APFS Container Scheme -                      +500.0 GB   disk1\n                                 Physical Store disk0s2\n   1:                APFS Volume APPLE SSD               342.6 GB   disk1s1\n   2:                APFS Volume Preboot                 47.6 MB    disk1s2\n   3:                APFS Volume Recovery                509.7 MB   disk1s3\n   4:                APFS Volume VM                      4.3 GB     disk1s4\n\n/dev/disk2 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:     FDisk_partition_scheme                        *123.0 GB   disk2\n   1:               Windows_NTFS LIWEI                   123.0 GB   disk2s1\n</code></pre>\n<p>上图中，&#x2F;dev&#x2F;disk2就是U盘</p>\n</li>\n<li><p>卸载U盘(不是推出) : <code>diskutil umountDisk /dev/disk2</code> (假如U盘是 &#x2F;dev&#x2F;disk2)</p>\n<pre><code>$ diskutil umountDisk /dev/disk2\nUnmount of all volumes on disk1 was successful\n</code></pre>\n</li>\n<li><p>镜像DMG写入到U盘: <code>sudo dd if=~/Downloads/ubuntu-16.04-desktop-amd64.iso of=/dev/disk2 bs=1m</code> (假如U盘是 &#x2F;dev&#x2F;disk1, 千万别搞错了)</p>\n<pre><code>$ sudo dd if=~/Downloads/ubuntu-17.04-desktop-amd64.iso of=/dev/disk2 bs=1m\nPassword:\n2151+1 records in\n2151+1 records out\n2256076800 bytes transferred in 90.277905 secs (24990354 bytes/sec)\n</code></pre>\n</li>\n<li><p>写入完成后会提示:“此电脑不能读取能插入的磁盘”, 这里选择直接推出即可</p>\n</li>\n</ol>\n<h3 id=\"Linux目录结构\"><a href=\"#Linux目录结构\" class=\"headerlink\" title=\"Linux目录结构\"></a>Linux目录结构</h3><p><img data-src=\"/./assets/linux-operation-system.jpeg\" alt=\"Linux目录结构\"></p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;bin</td>\n<td>常用二进制命令</td>\n<td>ls, cp, rm, mkdir</td>\n</tr>\n<tr>\n<td>&#x2F;usr</td>\n<td>系统程序目录</td>\n<td>命令、帮助文件、系统配置</td>\n</tr>\n<tr>\n<td>&#x2F;var</td>\n<td>这个目录中存放着在不断扩充着的东西</td>\n<td>日志</td>\n</tr>\n<tr>\n<td>&#x2F;lib</td>\n<td>系统最基本的动态连接共享库</td>\n<td>类似于Windows中的DLL</td>\n</tr>\n<tr>\n<td>&#x2F;srv</td>\n<td>存放一些服务启动之后需要提取的数据</td>\n<td>通常是空的</td>\n</tr>\n<tr>\n<td>&#x2F;home</td>\n<td>用户主目录</td>\n<td>通常是空的</td>\n</tr>\n<tr>\n<td>&#x2F;boot</td>\n<td>Linux内核及系统引导文件目录</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;dev</td>\n<td>设备文件的目录</td>\n<td>声卡，磁盘，光驱等</td>\n</tr>\n<tr>\n<td>&#x2F;etc</td>\n<td>二进制软件包配置文件的默认路径</td>\n<td>系统信息，网络配置</td>\n</tr>\n<tr>\n<td>&#x2F;lost+found</td>\n<td>系统崩溃时，产生的一些碎片文件</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;mnt</td>\n<td>临时挂载存储设备</td>\n<td>U盘</td>\n</tr>\n<tr>\n<td>&#x2F;opt</td>\n<td>软件可选的安装目录</td>\n<td>通常是空的</td>\n</tr>\n<tr>\n<td>&#x2F;proc</td>\n<td>操作系统进程信息目录</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;sbin</td>\n<td>管理员命令，系统级命令</td>\n<td>sudo用户</td>\n</tr>\n<tr>\n<td>&#x2F;tmp</td>\n<td>临时文件目录</td>\n<td>重启后，被清空</td>\n</tr>\n<tr>\n<td>&#x2F;run</td>\n<td>临时文件系统，存储系统启动以来的信息</td>\n<td>重启后，被清空</td>\n</tr>\n<tr>\n<td>&#x2F;sys</td>\n<td>系统中的设备组织成层次结构</td>\n<td>通过文件查看硬件信息</td>\n</tr>\n</tbody></table>\n<p>需要掌握的目录路径知识：</p>\n<ol>\n<li><p>查看系统内核信息</p>\n<pre><code class=\"bash\"># Centos\n$ cat /proc/version\nLinux version 3.10.0-957.10.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Mon Mar 18 15:06:45 UTC 2019\n\n# Ubuntu\n$ cat /proc/version\nLinux version 4.15.7-041507-generic (kernel@gloin) (gcc version 7.2.0 (Ubuntu 7.2.0-8ubuntu3.2)) #201802280530 SMP Wed Feb 28 10:31:47 UTC 2018\n</code></pre>\n</li>\n<li><p>查看网络信息</p>\n<pre><code class=\"bash\"># Centos DHCP\n$ cat /etc/sysconfig/network-scripts/ifcfg-eth0\nDEVICE=eth0\nBOOTPROTO=dhcp\nONBOOT=yes\n\n# 或者指定IP\n$ cat /etc/sysconfig/network-scripts/ifcfg-em1\nTYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=none\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=em1\nUUID=fa335568-27db-47fd-a055-424173c42430\nDEVICE=em1\nONBOOT=yes\nIPADDR=192.168.4.252\nPREFIX=24\nGATEWAY=192.168.4.50\nDNS1=192.168.4.50\nIPV6_PRIVACY=no\nZONE=public\n\n# Ubuntu\n$ vi /etc/network/interfaces\n# This file describes the network interfaces available on your system\n# and how to activate them. For more information, see interfaces(5).\n\nsource /etc/network/interfaces.d/*\n\n# The loopback network interface\nauto lo\niface lo inet loopback\n\n# The primary network interface\nauto ens3\niface ens3 inet static\n        address 192.168.4.60\n        netmask 255.255.255.0\n        network 192.168.4.0\n        broadcast 192.168.4.255\n        gateway 192.168.4.50\n        # dns-* options are implemented by the resolvconf package, if installed\n        dns-nameservers 192.168.4.50\n        dns-search itheima\n</code></pre>\n<p>通常使用<code>ifconfig</code>来查看网卡的信息</p>\n</li>\n<li><p>DNS配置</p>\n<pre><code class=\"bash\">$ cat /etc/resolv.conf\noptions timeout:2 attempts:3 rotate single-request-reopen\n; generated by /usr/sbin/dhclient-script\nnameserver 100.100.2.136\nnameserver 100.100.2.138\n</code></pre>\n</li>\n<li><p>host文件</p>\n<pre><code class=\"bash\">$ cat /etc/hosts\n127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4\n::1         localhost localhost.localdomain localhost6 localhost6.localdomain6\n</code></pre>\n</li>\n<li><p>用户&#x2F;组</p>\n<p>查看用户：</p>\n<pre><code class=\"bash\">$ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\n....\n</code></pre>\n<p>查看组：</p>\n<pre><code class=\"bash\">$ cat /etc/group\nroot:x:0:\ndaemon:x:1:\nbin:x:2:\nsys:x:3:\nadm:x:4:syslog,bttech\ntty:x:5:\ndisk:x:6:\nlp:x:7:\nmail:x:8:\nnews:x:9:\nuucp:x:10:\nman:x:12:\nproxy:x:13:\n....\n</code></pre>\n</li>\n<li><p>查看内存&#x2F;CPU</p>\n<pre><code class=\"bash\"># 查看CPU\n$ cat /proc/cpuinfo\nprocessor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 45\nmodel name\t: Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\nstepping\t: 7\nmicrocode\t: 0x714\ncpu MHz\t\t: 2117.419\ncache size\t: 20480 KB\n...\n\n# 查看内存\n$ cat /proc/meminfo\nMemTotal:       131812048 kB\nMemFree:          460820 kB\nMemAvailable:   36657836 kB\nBuffers:               0 kB\nCached:         34910784 kB\nSwapCached:      1051944 kB\nActive:         95183532 kB\nInactive:       32382012 kB\nActive(anon):   77764844 kB\nInactive(anon): 15015220 kB\nActive(file):   17418688 kB\n...\n</code></pre>\n</li>\n<li><p>其他</p>\n<ul>\n<li>&#x2F;etc&#x2F;fstab（开机自动挂载列表）</li>\n<li>&#x2F;etc&#x2F;rc.local（开机自启动文件，自启动命令，脚本）</li>\n<li>&#x2F;etc&#x2F;init.d(服务启动命令脚本目录)</li>\n<li>&#x2F;etc&#x2F;profile(全局环境变量)</li>\n<li>&#x2F;usr&#x2F;local(编译安装软件默认安装目录)</li>\n<li>&#x2F;var&#x2F;log&#x2F;message（系统日志）</li>\n<li>&#x2F;var&#x2F;log&#x2F;secure（系统安全日志）</li>\n<li><em>&#x2F;proc&#x2F;mounts</em>（系统挂载信息）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Linux启动过程\"><a href=\"#Linux启动过程\" class=\"headerlink\" title=\"Linux启动过程\"></a>Linux启动过程</h3><p>Linux启动过程：</p>\n<ul>\n<li><p>内核的引导</p>\n<p>首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>\n<p>主要是一些驱动、基本的操作指令，用来接管所有的硬件</p>\n</li>\n<li><p>运行 init</p>\n<p>就跟main函数一样，有一个起点，初始一个服务进程daemon，跟windows中的服务一样。</p>\n</li>\n<li><p>系统初始化</p>\n<p>用户及软件服务自启动</p>\n</li>\n<li><p>建立终端 </p>\n<p>Linux的多用户管理。</p>\n<p>针对对用户，登录方式有三种：</p>\n<ul>\n<li>命令行登录</li>\n<li>ssh登录</li>\n<li>图形界面登录</li>\n</ul>\n</li>\n<li><p>用户登录系统</p>\n</li>\n</ul>\n<p><img data-src=\"/./assets/bg2013081707.png\" alt=\"img\"></p>\n<h3 id=\"常用命令介绍-重点\"><a href=\"#常用命令介绍-重点\" class=\"headerlink\" title=\"常用命令介绍(重点)\"></a>常用命令介绍(重点)</h3><h4 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h4><ol>\n<li>目录相关<ul>\n<li><p><code>ls</code>: 列出目录</p>\n<p>-la 可以查看隐藏文件，文件一些基础属性</p>\n</li>\n<li><p><code>cd</code>：切换目录</p>\n<p>使用绝对路径<code>/</code>，也可以使用<code>./</code>相对路径，回到上级目录<code>cd ..</code></p>\n</li>\n<li><p><code>pwd</code>：显示目前的目录</p>\n</li>\n<li><p><code>mkdir</code>：创建一个新的目录</p>\n</li>\n<li><p><code>rmdir</code>：删除一个空的目录</p>\n</li>\n<li><p><code>cp</code>: 复制文件或目录</p>\n<pre><code class=\"bash\">cp source target\n</code></pre>\n</li>\n<li><p><code>rm</code>: 移除文件或目录</p>\n<pre><code class=\"bash\"># 删除目录\nrm -r dirpath\n\n# 强制删除，要特别注意\nrm -rf dirpath€\n</code></pre>\n</li>\n<li><p><code>mv</code>: 移动文件与目录，或修改文件与目录的名称</p>\n<pre><code>mv source target\n</code></pre>\n</li>\n<li><p><code>cat</code>用来查看文件内的内容，<code>touch</code>命令来创建文件，<code>echo</code>命令往文件里面写入内容，<code>more</code>命令来查看显示长文件内容</p>\n</li>\n</ul>\n</li>\n<li>基本属性：<ul>\n<li><p>权限管理<code>chmod</code></p>\n<p>文件基本属性分为10个字符 <code>drwxrwxrwx</code></p>\n<p><code>r</code> 代表着read读权限</p>\n<p><code>w</code>代表着write写权限</p>\n<p><code>x</code>代表着execute执行权限</p>\n<p><code>d</code>代表着目录</p>\n<p><code>chmod -R</code>递归执行，相当于是把目录下所有的文件都修改对应的权限</p>\n<p><code>chmod +x</code> 给文件一个执行&#x2F;读&#x2F;写权限</p>\n<p>修改权限的两种方式：</p>\n<p><strong>方式1： 数字方式</strong></p>\n<p><code>7</code>-<code>rwx</code></p>\n<p><code>6</code>-<code>-rw-</code></p>\n<p><code>4</code>-<code>r--</code></p>\n<p><code>0</code>-<code>---</code> 什么权限都没有，</p>\n<p>前面的3个是所有者用户的权限，</p>\n<p>中间的3个是组用户的权限，</p>\n<p>后面的3个是其他用户的权限。</p>\n<p>举例说明：</p>\n<pre><code class=\"bash\"># 对所属用户有读写权限\nchmod 600 ...\n\n# 对应 -rwxrw-rw-，相当于是取消了组与其他用户的执行权限\nchmod 755 ...\n</code></pre>\n<p><strong>方式2：</strong></p>\n<p><code>a</code>代表all所有，<code>u</code>代表user，<code>g</code>代表group，<code>o</code>代表other。</p>\n<p><code>+</code>代表增加，<code>-</code>代表减少</p>\n<p>举例说明：</p>\n<pre><code class=\"bash\"># 增加所有用户的读的权限\nchmod a+r ...\n\n# 增加用户与组的写的权限\nchmod ug+w ..\n</code></pre>\n<blockquote>\n<p>个人比较推荐数字的方式，比较好记！！</p>\n</blockquote>\n</li>\n<li><p>用户&#x2F;组权限管理<code>chown</code></p>\n<p>修改文件&#x2F;文档所属&#x2F;所属组</p>\n<pre><code>chown &lt;所属用户&gt;:&lt;所属组&gt; &lt;文件&gt;\n</code></pre>\n<p>目录：</p>\n<pre><code>chown -R &lt;所属用户&gt;:&lt;所属组&gt; &lt;文件&gt;\n</code></pre>\n<p><code>-R</code> 代表着递归</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"用户管理-x2F-登录\"><a href=\"#用户管理-x2F-登录\" class=\"headerlink\" title=\"用户管理&#x2F;登录\"></a>用户管理&#x2F;登录</h4><ol>\n<li>添加用户<code>useradd</code></li>\n<li>删除用户<code>userdel</code></li>\n<li>用户口令修改 <code>passwd</code></li>\n<li>（扩展）用户组<code>groupadd</code>&#x2F;<code>groupdel</code>&#x2F;<code>groupmod</code></li>\n</ol>\n<h4 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h4><ol>\n<li><p>远程连接<code>ssh</code></p>\n<p>配置文件的路径是在<code>/etc/ssh/sshd_config</code>目录下</p>\n<p>如果需要修改port：</p>\n<ul>\n<li>修改<code>sshd_config</code>中的<code>Port</code>参数</li>\n<li>(Centos)还需要使用<code>semanage port -a -t ssh_port_t -p tcp &lt;Port&gt;</code></li>\n<li><code>service sshd restart</code> (Centos) &#x2F; <code>service ssh restart</code> (Debian、Ubuntu)</li>\n</ul>\n<blockquote>\n<p>在测试的时候，可以关闭服务器的防火墙，但是生产系统中不推荐这么去做。</p>\n<p>如果提示没有semanage这个命令，则可以使用如下方式来安装：</p>\n<p><code>sudo yum install -y policecoreutils-python</code></p>\n<p>或者使用<code>yum whatprovides semange</code>来反查</p>\n</blockquote>\n<p>ssh登录命令的格式：<code>ssh -p Port &lt;用户名&gt;@&lt;服务器的地址&gt;</code></p>\n<p>如： </p>\n<pre><code class=\"bash\">$ ssh -p 10022 root@192.168.0.1\n</code></pre>\n<blockquote>\n<p>window推荐使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmV0c2FyYW5nLmNvbS96aC94ZnRwLw==\">xftp</span>终端</p>\n<p>mac推荐使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXRlcm0yLmNvbS8=\">iterm</span></p>\n</blockquote>\n</li>\n<li><p>查看网卡配置<code>ifconfig</code></p>\n<p> 如果说没有这个命令，可以使用<code>yum install net-tools</code>进行安装</p>\n<pre><code class=\"bash\">ifconfig eth0 &lt;ip&gt; netmask 255.255.255.0\n</code></pre>\n<p>对网口进行禁用&#x2F;启用</p>\n<pre><code class=\"bash\">ifconfig eth0 down/up\n</code></pre>\n</li>\n<li><p>查看网络<code>netstat</code></p>\n<ul>\n<li><code>-t</code>：列出TCP协议端口</li>\n<li><code>-u</code>：列出UDP协议端口</li>\n<li><code>-n</code>:不使用域名与服务名，而使用IP地址和端口号</li>\n<li><code>-l</code>：仅列出在监听状态网络服务</li>\n<li><code>-a</code>：列出所有的网络连接</li>\n<li><code>-p</code>：列出所对应的进程信息</li>\n</ul>\n<pre><code class=\"bash\">netstat -anpl | grep ssh\n</code></pre>\n<p>当使用<code>netstat | more</code>进行滚屏，<code>ctrl+f/b</code>进行翻上&#x2F;下页</p>\n</li>\n<li><p>路由命令<code>route</code></p>\n<p>route查看路由</p>\n<pre><code class=\"bash\"># add/del添加删除路由\n\nroute add -net 192.168.0.0 netmask 255.255.0.0 dev etho\n\n# del删除\nroute del -net 192.168.0.0 netmask 255.255.0.0\n\n# reject\nroute add -net 192.168.0.0 netmask 255.255.0.0 reject\n</code></pre>\n</li>\n<li><p>IP命令<code>ip</code></p>\n<pre><code>ip addr show\nip route show\nip link set eth0 up/down\n</code></pre>\n<p><code>ip &lt;命令&gt; help</code>去查看命令的一些参数 </p>\n</li>\n<li><p>DNS解析：<code>nslookup</code></p>\n<p>Centos中如果没有该命令，可以使用如下的方式进行安装</p>\n<pre><code>sudo yum install bind-utils\n</code></pre>\n</li>\n<li><p>查看本机IP</p>\n<pre><code class=\"bash\">curl [链接]\n</code></pre>\n<p>几个网址也非常好记忆</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2lwLmNuLw==\">ip.cn</span> (推荐)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2lwaW5mby5pby8=\">ipinfo.io</span> (推荐)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2NpcC5jYy8=\">cip.cc</span> (推荐)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2lmY29uZmlnLm1lLw==\">ifconfig.me</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL215aXAuaXBpcC5uZXQv\">myip.ipip.net</span></li>\n</ul>\n</li>\n</ol>\n<p>GUI网络配置操作（图形化大法好啊）：</p>\n<p><code>nmtui</code></p>\n<blockquote>\n<p>如果提示<code>not found</code>命令的话，可以<code>yum install -y NetworkManager-tui</code>进行安装</p>\n</blockquote>\n<p><img data-src=\"/./assets/nmtui.png\" alt=\"nmtui\"></p>\n<h4 id=\"性能-x2F-硬件\"><a href=\"#性能-x2F-硬件\" class=\"headerlink\" title=\"性能&#x2F;硬件\"></a>性能&#x2F;硬件</h4><ol>\n<li><p><code>top</code>命令：</p>\n<p>top命令替代命令：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTEwMzIzLTEuaHRtbA==\">参考1</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly90dXRvcmlhbHMudWJ1bnR1LmNvbS90dXRvcmlhbC90dXRvcmlhbC1pbnN0YWxsLXVidW50dS1kZXNrdG9wIzA=\">参考2</span></p>\n<pre><code>top\n\n# m切换显示内存信息\n# t切换显示CPU信息\n# M对内存倒序排序显示\n# P根据CPU的使用百分比进行排序\n</code></pre>\n</li>\n<li><p>性能测试</p>\n<ul>\n<li><p>Bench.sh: </p>\n<p>使用方法：</p>\n<pre><code class=\"bash\">wget -qO- bench.sh | bash\n\n# 或者 \n\ncurl -Lso- bench.sh | bash\n</code></pre>\n<p>Github地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RlZGR5c3VuL2Fjcm9zcy9ibG9iL21hc3Rlci9iZW5jaC5zaA==\">https://github.com/teddysun/across/blob/master/bench.sh</span></p>\n</li>\n<li><p>LemonBench</p>\n<p>使用方法：</p>\n<pre><code class=\"bash\">wget -qO- https://ilemonrain.com/download/shell/LemonBench.sh | bash\n\n# 或者\n\ncurl -fsSL https://ilemonrain.com/download/shell/LemonBench.sh | bash\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Nginx服务\"><a href=\"#Nginx服务\" class=\"headerlink\" title=\"Nginx服务\"></a>Nginx服务</h2><p>nginx [发音：engine x]是一个HTTP和反向代理服务器，一个邮件代理服务器和一个通用的TCP &#x2F; UDP代理服务器，最初由<span class=\"exturl\" data-url=\"aHR0cDovL3N5c29ldi5ydS9lbi8=\">Igor Sysoev</span>编写。</p>\n<p>据Netcraft称，nginx 在2019年5月服务或代理了 26.43％最繁忙的网站。以下是一些成功案例： Dropbox， Netflix， Wordpress.com， FastMail.FM。</p>\n<blockquote>\n<p>nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP&#x2F;UDP proxy server, originally written by Igor Sysoev. For a long time, it has been running on many heavily loaded Russian sites including Yandex, Mail.Ru, VK, and Rambler. According to Netcraft, nginx served or proxied 26.43% busiest sites in May 2019. Here are some of the success stories: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9ncy5kcm9wYm94LmNvbS90ZWNoLzIwMTcvMDkvb3B0aW1pemluZy13ZWItc2VydmVycy1mb3ItaGlnaC10aHJvdWdocHV0LWFuZC1sb3ctbGF0ZW5jeS8=\">Dropbox</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuY29ubmVjdC5uZXRmbGl4LmNvbS9lbi9zb2Z0d2FyZS8=\">Netflix</span>,<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmdpbnguY29tL2Nhc2Utc3R1ZGllcy9uZ2lueC13b3JkcHJlc3MtY29tLw==\">Wordpress.com</span>, <span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuZmFzdG1haWwuZm0vMjAwNy8wMS8wNC93ZWJpbWFwcG9wLWZyb250ZW5kLXByb3hpZXMtY2hhbmdlZC10by1uZ2lueC8=\">FastMail.FM</span>.</p>\n</blockquote>\n<p>从下面的当下技术架构图中，可以看出Nginx在网络中的位置与重要性。Nginx的轻量级、内存占用少、启动极快，高并发能力强的特性，使它在互联网项目中广泛应用。</p>\n<p><img data-src=\"/./assets/v2-e1826bab1d07df8e97d61aa809b94a10_hd.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>Service-Oriented Architecture，<strong>SOA</strong>面向服务的架构</p>\n</blockquote>\n<h3 id=\"Nginx简介\"><a href=\"#Nginx简介\" class=\"headerlink\" title=\"Nginx简介\"></a>Nginx简介</h3><h4 id=\"什么是反向代理\"><a href=\"#什么是反向代理\" class=\"headerlink\" title=\"什么是反向代理\"></a>什么是反向代理</h4><p>正向代理 ：</p>\n<p><img data-src=\"/./assets/v2-c8ac111c267ae0745f984e326ef0c47f_hd.jpg\" alt=\"img\"></p>\n<p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，<strong>正向代理“代理”的是客户端</strong>，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</p>\n<p>反向代理：</p>\n<p><img data-src=\"/./assets/v2-4787a512240b238ebf928cd0651e1d99_hd.jpg\" alt=\"img\"></p>\n<p>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即<strong>反向代理“代理”的是服务器端</strong>，而且这一个过程对于客户端而言是透明的。</p>\n<h4 id=\"Nginx的技术架构\"><a href=\"#Nginx的技术架构\" class=\"headerlink\" title=\"Nginx的技术架构\"></a>Nginx的技术架构</h4><p><img data-src=\"/./assets/v2-b24eb2b29b48f59883232a58392ddae3_hd.jpg\" alt=\"img\"></p>\n<p>Master进程的作用是<strong>读取并验证配置文件nginx.conf；管理worker进程；</strong></p>\n<p>Worker进程的作用:<strong>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；</strong></p>\n<blockquote>\n<p>注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</p>\n</blockquote>\n<p>特点：</p>\n<ul>\n<li><p>主进程Master</p>\n<p><code>Nginx</code> 启动时，会生成两种类型的 <strong>进程</strong>*，一个是 <strong>主进程</strong>（<code>master</code>），<strong>一个</strong>（<code>windows</code> 版本的目前只有一个）或 <strong>多个工作进程</strong>（<code>worker</code>）。<strong>主进程</strong> 并不处理网络请求，主要负责 <strong>调度工作进程</strong>，也就是图示的 <code>3</code> 项：<strong>加载配置</strong>、<strong>启动工作进程</strong> 及 <strong>非停升级</strong>。所以，<code>Nginx</code> 启动以后，查看操作系统的进程列表，我们就能看到 <strong>至少有两个</strong> <code>Nginx</code> 进程。</p>\n</li>\n<li><p>工作进程Worker</p>\n<p>服务器实际 <strong>处理网络请求</strong> 及 <strong>响应</strong> 的是 <strong>工作进程</strong>（<code>worker</code>），在类 <code>unix</code> 系统上，<code>Nginx</code> 可以配置 <strong>多个</strong> <code>worker</code>，而每个 <code>worker</code> <strong>进程</strong> 都可以同时处理 <strong>数以千计</strong> 的 <strong>网络请求</strong>。</p>\n</li>\n<li><p>模块化设计</p>\n<p>标准HTTP模块、可选的HTTP模块(gzip等)、邮件服务、第三方(Lua)</p>\n<p><code>Nginx</code> 的 <code>worker</code> 进程，包括 <strong>核心</strong> 和 <strong>功能性模块</strong>，<strong>核心模块</strong> 负责维持一个 <strong>运行循环</strong>（<code>run-loop</code>），执行网络请求处理的 <strong>不同阶段</strong> 的模块功能，比如：<strong>网络读写</strong>、<strong>存储读写</strong>、<strong>内容传输</strong>、<strong>外出过滤</strong>，以及 <strong>将请求发往上游服务器</strong> 等。而其代码的 <strong>模块化设计</strong>，也使得我们可以根据需要对 <strong>功能模块</strong> 进行适当的 <strong>选择</strong> 和 <strong>修改</strong>，编译成具有 <strong>特定功能</strong> 的服务器。</p>\n</li>\n<li><p>事件驱动模型</p>\n<p>基于 <strong>异步及非阻塞</strong> 的 <strong>事件驱动模型</strong>，可以说是 <code>Nginx</code> 得以获得 <strong>高并发</strong>、<strong>高性能</strong> 的关键因素，同时也得益于对 <code>Linux</code>、<code>Solaris</code> 及类 <code>BSD</code> 等操作系统内核中 <strong>事件通知</strong> 及 <code>I/O</code> <strong>性能增强功能</strong> 的采用，如 <code>kqueue</code>、<code>epoll</code> 及 <code>event ports</code>。</p>\n</li>\n<li><p>代理设计</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<ol>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjRiZGI1NGU1MWQ0NTE5MWUwY2Q3NzQ=\">浅谈Nginx服务器的内部核心架构设计</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9uZ2lueC5vcmcvZW4vI2FyY2hpdGVjdHVyZV9hbmRfc2NhbGFiaWxpdHk=\">Architecture and scalability</span></p>\n</li>\n</ol>\n<h4 id=\"Nginx高可用\"><a href=\"#Nginx高可用\" class=\"headerlink\" title=\"Nginx高可用\"></a>Nginx高可用</h4><p><img data-src=\"/./assets/v2-ec3208d1ea659d126fe2a008ec5ae927_hd.jpg\" alt=\"img\"></p>\n<p><strong>VRRP（Virtual Router Redundancy Protocol）</strong>，即<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tLz90PWh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVlJSUA==\">虚拟路由冗余协议</span>。可以认为它是实现路由器高可用的容错协议，即将多台提供相同功能的路由器组成一个路由器组(Router Group)，这个组里面有一个master和多个backup，但在外界看来就像一台一样，构成虚拟路由器，拥有一个虚拟IP（vip，也就是路由器所在局域网内其他机器的默认路由），占有这个IP的master实际负责ARP相应和转发IP数据包，组中的其它路由器作为备份的角色处于待命状态。master会发组播消息，当backup在超时时间内收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master，保证路由器的高可用。</p>\n<p>Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，类似的工具还有heartbeat、corosync、pacemaker。但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。</p>\n<p>KeepAlived + Nginx来组成高可用的方案：</p>\n<p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p>\n<p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</p>\n<h3 id=\"Nginx服务安装\"><a href=\"#Nginx服务安装\" class=\"headerlink\" title=\"Nginx服务安装\"></a>Nginx服务安装</h3><h4 id=\"Centos安装方式\"><a href=\"#Centos安装方式\" class=\"headerlink\" title=\"Centos安装方式\"></a>Centos安装方式</h4><p>推荐使用在线安装方式：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>yum方式</th>\n<th>源码安装</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>网络</td>\n<td>需要</td>\n<td>可以不需要</td>\n</tr>\n<tr>\n<td>安装位置</td>\n<td>&#x2F;etc&#x2F;nginx配置文件，&#x2F;usr&#x2F;sbin&#x2F;nginx</td>\n<td>&#x2F;usr&#x2F;local&#x2F;nginx目录</td>\n</tr>\n<tr>\n<td>管理命令</td>\n<td>提供</td>\n<td>不提供</td>\n</tr>\n<tr>\n<td>启动</td>\n<td>service nginx start</td>\n<td>执行绝对路径&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</td>\n</tr>\n<tr>\n<td>删除</td>\n<td>yum remove nginx或者rpm -e nginx</td>\n<td>rm -rf &#x2F;usr&#x2F;local&#x2F;nginx</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>在线安装</p>\n<p>添加nginx的repo：</p>\n<pre><code class=\"bash\">$ vim /etc/yum.repos.d/nginx.repo\n</code></pre>\n<p>输入以下内容：</p>\n<pre><code class=\"bash\">[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=0\nenabled=1\n</code></pre>\n<p><code>:wq</code>保存后，使用<code>yum update</code>，接下来就是安装了。</p>\n<pre><code class=\"bash\">yum install -y nginx\n\n# 管理命令:\n# 启动/停止/重启\nservice nginx start/stop/restart\n\n# 卸载\nyum remove -y nginx\n# 或者强制卸载，不考虑依赖\nrpm -e nginx\n</code></pre>\n</li>\n<li><p>源码安装</p>\n</li>\n</ol>\n<ul>\n<li><p>安装对应的依赖：</p>\n<pre><code>yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel\n</code></pre>\n</li>\n<li><p>下载源码包：</p>\n<pre><code class=\"bash\">wget -O /tmp/nginx.tar.gz http://nginx.org/download/nginx-&lt;version&gt;.tar.gz\n</code></pre>\n<p>比如：</p>\n<pre><code class=\"bash\">wget -O /tmp/nginx.tar.gz http://nginx.org/download/nginx-1.17.0.tar.gz\n</code></pre>\n</li>\n<li><p>解压</p>\n<pre><code class=\"bash\">cd /tmp/\ntar zxvf nginx.tar.gz\n</code></pre>\n</li>\n<li><p>编译</p>\n<pre><code class=\"bash\">$ ./configure\nConfiguration summary\n\n- using system PCRE library\n- OpenSSL library is not used\n- using system zlib library\n\n  nginx path prefix: &quot;/usr/local/nginx&quot;\n  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;\n  nginx modules path: &quot;/usr/local/nginx/modules&quot;\n  nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;\n  nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;\n  nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;\n  nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;\n  nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;\n  nginx http client request body temporary files: &quot;client_body_temp&quot;\n  nginx http proxy temporary files: &quot;proxy_temp&quot;\n  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;\n  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;\n  nginx http scgi temporary files: &quot;scgi_temp&quot;\n</code></pre>\n</li>\n<li><p>安装</p>\n<pre><code class=\"bash\">make &amp;&amp; make install\n</code></pre>\n</li>\n<li><p>管理方法：</p>\n<p>直接可以使用可执行文件进行启动&#x2F;停止&#x2F;重启</p>\n<pre><code class=\"bash\"># 启动\n/usr/local/nginx/sbin/nginx\n\n# 停止\n/usr/local/nginx/sbin/nginx -s stop\n\n# 重启\n/usr/local/nginx/sbin/nginx -s reload\n</code></pre>\n</li>\n<li><p>管理脚本</p>\n<pre><code class=\"bash\">$ vi /etc/init.d/nginx\n</code></pre>\n<p>输入如下内容:</p>\n<pre><code class=\"bash\">#!/bin/sh\n#\n# nginx - this script starts and stops the nginx daemon\n#\n# chkconfig:   - 85 15\n# description:  NGINX is an HTTP(S) server, HTTP(S) reverse \\\n#               proxy and IMAP/POP3 proxy server\n# processname: nginx\n# config:      /usr/local/nginx/conf/nginx.conf\n# config:      /etc/sysconfig/nginx\n# pidfile:     /usr/local/nginx/logs/nginx.pid\n# Source function library.\n. /etc/rc.d/init.d/functions\n# Source networking configuration.\n. /etc/sysconfig/network\n# Check that networking is up.\n[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0\nnginx=&quot;/usr/local/nginx/sbin/nginx&quot;\nprog=$(basename $nginx)\nNGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot;\n[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx\nlockfile=/var/lock/subsys/nginx\nmake_dirs() &#123;\n   # make required directories\n   user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &#39;s/[^*]*--user=\\([^ ]*\\).*/\\1/g&#39; -`\n   if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then\n       useradd -M -s /bin/nologin $user\n   fi\n   options=`$nginx -V 2&gt;&amp;1 | grep &#39;configure arguments:&#39;`\n   for opt in $options; do\n       if [ `echo $opt | grep &#39;.*-temp-path&#39;` ]; then\n           value=`echo $opt | cut -d &quot;=&quot; -f 2`\n           if [ ! -d &quot;$value&quot; ]; then\n               # echo &quot;creating&quot; $value\n               mkdir -p $value &amp;&amp; chown -R $user $value\n           fi\n       fi\n   done\n&#125;\nstart() &#123;\n    [ -x $nginx ] || exit 5\n    [ -f $NGINX_CONF_FILE ] || exit 6\n    make_dirs\n    echo -n $&quot;Starting $prog: &quot;\n    daemon $nginx -c $NGINX_CONF_FILE\n    retval=$?\n    echo\n    [ $retval -eq 0 ] &amp;&amp; touch $lockfile\n    return $retval\n&#125;\nstop() &#123;\n    echo -n $&quot;Stopping $prog: &quot;\n    killproc $prog -QUIT\n    retval=$?\n    echo\n    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile\n    return $retval\n&#125;\nrestart() &#123;\n    configtest || return $?\n    stop\n    sleep 1\n    start\n&#125;\nreload() &#123;\n    configtest || return $?\n    echo -n $&quot;Reloading $prog: &quot;\n    killproc $nginx -HUP\n    RETVAL=$?\n    echo\n&#125;\nforce_reload() &#123;\n    restart\n&#125;\nconfigtest() &#123;\n  $nginx -t -c $NGINX_CONF_FILE\n&#125;\nrh_status() &#123;\n    status $prog\n&#125;\nrh_status_q() &#123;\n    rh_status &gt;/dev/null 2&gt;&amp;1\n&#125;\ncase &quot;$1&quot; in\n    start)\n        rh_status_q &amp;&amp; exit 0\n        $1\n        ;;\n    stop)\n        rh_status_q || exit 0\n        $1\n        ;;\n    restart|configtest)\n        $1\n        ;;\n    reload)\n        rh_status_q || exit 7\n        $1\n        ;;\n    force-reload)\n        force_reload\n        ;;\n    status)\n        rh_status\n        ;;\n    condrestart|try-restart)\n        rh_status_q || exit 0\n            ;;\n    *)\n        echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot;\n        exit 2\nesac\n</code></pre>\n<p>添加开机启动：</p>\n<pre><code class=\"bash\"># 给予执行权限\nchmod a+x /etc/init.d/nginx\n\n# 设置开机启动\nchkconfig nginx on\n\n# 启动\nsystemctl start nginx\n</code></pre>\n</li>\n</ul>\n<h4 id=\"Ubuntu安装方式\"><a href=\"#Ubuntu安装方式\" class=\"headerlink\" title=\"Ubuntu安装方式\"></a>Ubuntu安装方式</h4><ol>\n<li><p>在线方式</p>\n<pre><code class=\"bash\">sudo apt-get install nginx\n</code></pre>\n</li>\n<li><p>源码方式</p>\n<p>安装依赖</p>\n<pre><code class=\"bash\"># 安装gcc g++\nsudo apt-get install build-essential\nsudo apt-get install libtool\n\n# 安装pcre依赖库（http://www.pcre.org/）\nsudo apt-get update\nsudo apt-get install libpcre3 libpcre3-dev\n\n# 安装zlib依赖库（http://www.zlib.net）\nsudo apt-get install zlib1g-dev\n\n# 安装SSL依赖库（16.04默认已经安装了）\nsudo apt-get install openssl\n</code></pre>\n<p>下载源码启动:</p>\n<pre><code class=\"bash\"># 下载最新版本：\n# 下面的version可以改为对应的版本\n# http://nginx.org/download/nginx-1.17.0.tar.gz\nwget -O /tmp/nginx.tar.gz http://nginx.org/download/nginx-&lt;version&gt;.tar.gz\n\n# 解压：\ncd /tmp/\ntar -zxvf nginx.tar.gz\n\n# 进入解压目录：\ncd nginx-1.13.6\n\n# 配置：\n./configure --prefix=/usr/local/nginx \n\n# 编译：\nmake\n\n# 安装：\nsudo make install\n\n# 启动：\n#注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件，可以通过-h查看帮助命令。\n#查看进程：\nsudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n\n# 查看进程启动状态\nps -ef | grep nginx\n</code></pre>\n</li>\n</ol>\n<h3 id=\"Nginx配置及优化\"><a href=\"#Nginx配置及优化\" class=\"headerlink\" title=\"Nginx配置及优化\"></a>Nginx配置及优化</h3><ol>\n<li>配置文件结构</li>\n</ol>\n<pre><code class=\"bash\">...              #全局块\n\nevents &#123;         #events块\n   ...\n&#125;\n\nhttp      #http块\n&#123;\n    ...   #http全局块--start\n    server        #server块\n    &#123; \n        ...       #server全局块\n        location [PATTERN]   #location块\n        &#123;\n            ...\n        &#125;\n        location [PATTERN] \n        &#123;\n            ...\n        &#125;\n    &#125;\n    server\n    &#123;\n      ...\n    &#125;\n    ...     #http全局块--end\n&#125;\n</code></pre>\n<ul>\n<li><strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>\n<li><strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>\n<li><strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>\n<li><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li>\n<li><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li>\n</ul>\n<ol start=\"2\">\n<li><p>配置优化</p>\n<p>配置文件：</p>\n<pre><code class=\"bash\">user www-data;\npid /run/nginx.pid;\n\n# worker_processes用来设置Nginx服务的进程数。推荐是CPU内核数或者内核数的倍数，推荐使用CPU内核数\nworker_processes 4;\n# 默认情况下，Nginx的多个进程有可能跑在某一个CPU或CPU的某一核上，导致Nginx进程使用硬件的资源不均\nworker_cpu_affinity 0001 0010 0100 1000;\n# 设置一个进程理论允许的最大连接数，理论上越大越好，但不可以超过worker_rlimit_nofile的值\nworker_rlimit_nofile 65535;\n\nevents &#123;\n                # 设置事件驱动模型，是内核2.6以上支持\n        use epoll;\n        worker_connections 65535;\n        accept_mutex off;\n        multi_accept off;\n&#125;\n\nhttp &#123;\n        ##\n        # Basic Settings\n        ##\n        sendfile on;\n        tcp_nopush on;\n        tcp_nodelay on;\n        keepalive_timeout 60 50;\n        send_timeout 10s;\n        types_hash_max_size 2048;\n        client_header_buffer_size 4k;\n        client_max_body_size 8m;\n        include /etc/nginx/mime.types;\n        default_type application/octet-stream;\n\n        ##\n        # Logging Settings\n        ##\n        access_log /var/log/nginx/access.log;\n        error_log /var/log/nginx/error.log;\n\n        ##\n        # Gzip Settings\n        ##\n        gzip on;\n        gzip_disable &quot;msie6&quot;;\n        gzip_min_length 1024;\n        gzip_vary on;\n        gzip_comp_level 2;\n        gzip_buffers 32 4k;\n        gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n\n\n        ##\n        # Virtual Host Configs\n        ##\n        include /etc/nginx/conf.d/*.conf;\n        include /etc/nginx/sites-enabled/*;\n&#125;\n</code></pre>\n</li>\n</ol>\n<p>nginxs配置说明：</p>\n<ul>\n<li><code>worker_connections</code></li>\n</ul>\n<p>设置一个进程理论允许的最大连接数，理论上越大越好，但不可以超过worker_rlimit_nofile的值。还有个问题，linux系统中有个指令open file resource limit，它设置了进程可以打开的文件句柄数量，可以用下面的指令查看你的linux系统中open file resource limit指令的值，<code>cat /proc/sys/fs/file-max</code><br>   可以将该指令设置为23900251</p>\n<pre><code class=\"bash\">   echo &quot;2390251&quot; &gt; /proc/sys/fs/file-max\n   \n   sysctl -p\n</code></pre>\n<ol start=\"3\">\n<li><p>压测工具Apache ab</p>\n<p>我们要测试 nginx 的负载能力，需要借助压力测试工具。本博客是使用 Apache 服务器自带的一个 web 压力测试工具 ApacheBench ，简称 ab。ab 是一个命令行工具，即通过 <code>ab</code> 命令行，模拟多个请求同时对某一 URL 地址进行访问，因此可以用来测试目标服务器的负载压力。</p>\n<pre><code class=\"bash\">yum -y install httpd-tools\n\n# 查看安装结果\nab -V\n\n# 简单的使用\n# -c：一次并发请求的数量；-n：请求总次数\nab -c 5000 -n 200000 http://10.211.55.6：80/index.html\n</code></pre>\n</li>\n<li><p>其他优化</p>\n<pre><code class=\"bash\">net.ipv4.ip_forward = 0\nnet.ipv4.conf.default.rp_filter = 1\nnet.ipv4.conf.default.accept_source_route = 0\nkernel.sysrq = 0\nkernel.core_uses_pid = 1\n\n# 开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。\nnet.ipv4.tcp_syncookies = 1\nkernel.msgmnb = 65536\nkernel.msgmax = 65536\nkernel.shmmax = 68719476736\nkernel.shmall = 4294967296\n\n# timewait的数量，默认是180000\nnet.ipv4.tcp_max_tw_buckets = 6000\nnet.ipv4.tcp_sack = 1\nnet.ipv4.tcp_window_scaling = 1\nnet.ipv4.tcp_rmem = 4096        87380   4194304\nnet.ipv4.tcp_wmem = 4096        16384   4194304\nnet.core.wmem_default = 8388608\nnet.core.rmem_default = 8388608\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\n\n# # 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。\nnet.core.netdev_max_backlog = 262144\n\n# web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义 的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值\nnet.core.somaxconn = 262144\n\n# 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅 是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。\nnet.ipv4.tcp_max_orphans = 3276800\n\n# 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。\nnet.ipv4.tcp_max_syn_backlog = 262144\n\n# 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。\nnet.ipv4.tcp_timestamps = 0\n\n# 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。\nnet.ipv4.tcp_synack_retries = 1\n\n# 在内核放弃建立连接之前发送SYN包的数量。\nnet.ipv4.tcp_syn_retries = 1\n\n# 启用timewait快速回收\nnet.ipv4.tcp_tw_recycle = 1\n\n# 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。\nnet.ipv4.tcp_tw_reuse = 1\nnet.ipv4.tcp_mem = 94500000 915000000 927000000\n\n# 如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。 2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。\nnet.ipv4.tcp_fin_timeout = 1\n\n# 当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时\nnet.ipv4.tcp_keepalive_time = 30\n\n# 允许系统打开的端口范围\nnet.ipv4.ip_local_port_range = 1024   65000\n</code></pre>\n</li>\n</ol>\n<h3 id=\"HTTP-s\"><a href=\"#HTTP-s\" class=\"headerlink\" title=\"HTTP(s)\"></a>HTTP(s)</h3><h4 id=\"HTTP-x2F-HTTPS协议\"><a href=\"#HTTP-x2F-HTTPS协议\" class=\"headerlink\" title=\"HTTP&#x2F;HTTPS协议\"></a>HTTP&#x2F;HTTPS协议</h4><p><strong>超文本传输协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>HTTP</strong>）是一种用于分布式、协作式和超媒体信息系统的应用层协议，HTTP是万维网的数据通信的基础。</p>\n<p><img data-src=\"/./assets/HTTP_Request.png\" alt=\"A basic HTTP request\"></p>\n<p>请求信息包括：请求行、请求头、空行还有其他消息体</p>\n<p><img data-src=\"/./assets/image-20190605153656594.png\" alt=\"/images/image-20190605153656594\"></p>\n<p>HTTP的特点：</p>\n<ul>\n<li><p>客户端&amp;服务端</p>\n</li>\n<li><p>简单(路径+方法+传递的类型)</p>\n<p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>\n</li>\n<li><p>灵活</p>\n<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>\n</li>\n<li><p>无连接</p>\n<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n</li>\n<li><p>无状态有会话</p>\n<p>HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。</p>\n<p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>\n<blockquote>\n<p>注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p>\n</blockquote>\n</li>\n</ul>\n<p>HTTP 的不足之处</p>\n<ul>\n<li>通信内容使用明文——内容可能被窃听</li>\n<li>不验证通信方的身份——可能遭遇伪装</li>\n<li>无法验证报文的完整性——报文有可能已遭篡改</li>\n</ul>\n<p>HTTPS协议：</p>\n<p><strong>超文本传输安全协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure，缩写：<strong>HTTPS</strong>；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL&#x2F;TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。</p>\n<p>主要作用：在不安全的网络上创建一个安全信道。</p>\n<h4 id=\"HTTPS认证原理\"><a href=\"#HTTPS认证原理\" class=\"headerlink\" title=\"HTTPS认证原理\"></a>HTTPS认证原理</h4><p>认证方式：数字证书</p>\n<p>认证机构：数字证书认证机构（Certificate Authority CA），EV SSL（Extended Validation SSL Certificate）证书，OpenSSL自认证。</p>\n<p>证书信任方式：</p>\n<ul>\n<li>操作系统和浏览器内置</li>\n<li>证书颁发机构</li>\n<li>手动指定证书</li>\n</ul>\n<p>SSL握手过程：</p>\n<p><img data-src=\"/./assets/1506390796205179.png\" alt=\"SSL\"></p>\n<h4 id=\"如何配置HTTPS\"><a href=\"#如何配置HTTPS\" class=\"headerlink\" title=\"如何配置HTTPS\"></a>如何配置HTTPS</h4><ol>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcv\">Let’s Encrypt</span>组织介绍</p>\n<p><img data-src=\"/./assets/image-20190605160738126.png\" alt=\"/images/image-20190605160738126\"></p>\n</li>\n<li><p>acme来自动化申请</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL05laWxwYW5nL2FjbWUuc2g=\">https://github.com/Neilpang/acme.sh</span></p>\n<p>前提：需要域名</p>\n</li>\n</ol>\n<p>前置条件：</p>\n<ol>\n<li><p>域名, 配置DNS解析，支持列表见下方</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL05laWxwYW5nL2FjbWUuc2gvd2lraS9kbnNhcGk=\">https://github.com/Neilpang/acme.sh/wiki/dnsapi</span></p>\n</li>\n<li><p>有<strong>公网IP</strong>的服务器(可选)</p>\n</li>\n<li><p>安装nginx, acme.sh</p>\n</li>\n</ol>\n<p>配置过程：</p>\n<ol>\n<li><p>安装nginx与acme.sh</p>\n<p>安装很简单, 一个命令:</p>\n<pre><code class=\"bash\">curl  https://get.acme.sh | sh\n</code></pre>\n<blockquote>\n<p>普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:</p>\n<p>把 acme.sh 安装到你的 <strong>home</strong> 目录下:</p>\n<pre><code>~/.acme.sh/\n</code></pre>\n<p>并创建 一个 bash 的 alias, 方便你的使用: <code>alias acme.sh=~/.acme.sh/acme.sh</code></p>\n<p>自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书</p>\n</blockquote>\n<p>使用<code>source</code>命令，使上面的安装生效</p>\n<pre><code class=\"bash\">source ~/.bashrc\n</code></pre>\n</li>\n<li><p>两种方式，激活SSL证书(推荐DNS)</p>\n<ul>\n<li><p><strong>http 方式</strong></p>\n<p>需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了</p>\n<pre><code class=\"bash\">acme.sh  --issue  -d mydomain.com -d www.mydomain.com  --webroot  /home/wwwroot/mydomain.com/\n</code></pre>\n<p>只需要指定域名, 并指定域名所在的网站根目录. <strong>acme.sh</strong> 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.</p>\n<p>如果你用的 <strong>apache</strong>服务器, <strong>acme.sh</strong> 还可以智能的从 <strong>apache</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n<pre><code class=\"bash\">acme.sh --issue  -d mydomain.com   --apache\n</code></pre>\n<p>如果你用的 <strong>nginx</strong>服务器, 或者反代, <strong>acme.sh</strong> 还可以智能的从 <strong>nginx</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n<pre><code class=\"bash\">acme.sh --issue  -d mydomain.com   --nginx\n</code></pre>\n</li>\n<li><p><strong>dns 方式</strong>(推荐)</p>\n<p>在域名上添加一条 txt 解析记录, 验证域名所有权。</p>\n<p>这种方式的好处是, 你不需要任何服务器, <strong>不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证</strong>. 坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。</p>\n<pre><code class=\"bash\">acme.sh  --issue  --dns   -d mydomain.com\n</code></pre>\n<p>然后, <strong>acme.sh</strong> 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.</p>\n<p>等待解析完成之后, 重新生成证书:</p>\n<pre><code>acme.sh  --renew   -d mydomain.com\n</code></pre>\n<p>注意第二次这里用的是 <code>--renew</code></p>\n<p>dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证.</p>\n<p><strong>acme.sh</strong> 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成.</p>\n<p>以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的. 然后:</p>\n<pre><code>export DP_Id=&quot;1234&quot;\n\nexport DP_Key=&quot;sADDsdasdgdsf&quot;\n\nacme.sh   --issue   --dns dns_dp   -d aa.com  -d www.aa.com\n</code></pre>\n<p>证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了:</p>\n<pre><code>acme.sh  --issue   -d  mydomain2.com   --dns  dns_dp\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>配置nginx配置，设置定时任务</p>\n<p>生成dhparam.pem</p>\n<pre><code class=\"shell\">$ openssl dhparam -out dhparam.pem 2048\n</code></pre>\n<p>nginx中正确的使用方法是使用 <code>--installcert</code> 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如:</p>\n<pre><code class=\"bash\">acme.sh  --installcert  -d  &lt;domain&gt;.com   \\\n        --key-file   /etc/nginx/ssl/&lt;domain&gt;.key \\\n        --fullchain-file /etc/nginx/ssl/fullchain.cer \\\n        --reloadcmd  &quot;service nginx force-reload&quot;\n</code></pre>\n<p>配置文件：</p>\n<pre><code class=\"bash\"># server部分\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    ssl on;\n    ssl_certificate         /etc/nginx/ssl/fullchain.cer;\n    ssl_certificate_key     /etc/nginx/ssl/&lt;domain&gt;.key;\n    # ssl_dhparam\n    ssl_dhparam             /etc/nginx/ssl/dhparam.pem;\n</code></pre>\n</li>\n<li><p>对网站的SSL进行检验</p>\n<p>推荐：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zc2xsYWJzLmNvbS9zc2x0ZXN0L2FuYWx5emUuaHRtbA==\">https://ssllabs.com/ssltest/analyze.html</span></p>\n</li>\n<li><p>其他需要注意的地方：</p>\n<ul>\n<li>域名备案</li>\n<li>防火墙</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"云服务器\"><a href=\"#云服务器\" class=\"headerlink\" title=\"云服务器\"></a>云服务器</h2><h3 id=\"阿里云ECS\"><a href=\"#阿里云ECS\" class=\"headerlink\" title=\"阿里云ECS\"></a>阿里云ECS</h3><h4 id=\"虚拟化技术原理\"><a href=\"#虚拟化技术原理\" class=\"headerlink\" title=\"虚拟化技术原理\"></a>虚拟化技术原理</h4><p><strong>虚拟化</strong>：在计算机技术中，虚拟化（技术）或虚拟技术（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等），予以抽象、转换后呈现出来并可供分区、组合为一个或多个电脑配置环境。</p>\n<p><img data-src=\"/./assets/img_adfcd9149ec08e90df41492ecb18b900.png\" alt=\"img\"></p>\n<p>主要的目的：降低成本，提高应用兼容性，提高服务可用性，提升资源复用率。</p>\n<p>虚拟化分类：</p>\n<p>主要有全虚拟化和半虚拟化。</p>\n<p>典型的全虚拟化软件有 —— VMWare、Hyper-V、KVM-x86(复杂指令集)。</p>\n<p>典型的半虚拟化软件有——Xen、KVM-PowerPC(简易指令集）</p>\n<p>参考资料：<span class=\"exturl\" data-url=\"aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzQ4ODY3\">虚拟化的发展历程和实现原理——图文详解</span>，<span class=\"exturl\" data-url=\"aHR0cDovL3ZpcnR1YWwuNTFjdG8uY29tL2FydC8yMDE4MDMvNTY5MjI4Lmh0bQ==\">虚拟化类型</span></p>\n<h4 id=\"如何选择云服务器\"><a href=\"#如何选择云服务器\" class=\"headerlink\" title=\"如何选择云服务器\"></a>如何选择云服务器</h4><ol>\n<li><p>从硬件</p>\n<p>使用阿里云的工具进行筛选，需要登录，链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lY3MtYnV5LmFsaXl1bi5jb20vaW5zdGFuY2VUeXBlcw==\">ECS 实例规格可购买地域总览</span></p>\n<p><img data-src=\"/./assets/image-20190604221840417.png\" alt=\"/images/image-20190604221840417\"></p>\n</li>\n<li><p>从网络</p>\n<p><img data-src=\"/./assets/eZZfERlwBRWjZOGtmwVO.png\" alt=\"Explanation\"></p>\n<p>云服务器 ECS 的入网带宽和出网带宽皆以服务器角度出发。下表给出了入网带宽和出网带宽的具体内容：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">带宽类别 （Mbit&#x2F;s）</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">入网带宽</td>\n<td align=\"left\">流入云服务器 ECS 的带宽 从云服务器 ECS 内部下载外部网络资源，或者从客户端 FTP 等方式上传资源到云服务器 ECS 都是入网带宽。</td>\n</tr>\n<tr>\n<td align=\"left\">出网带宽</td>\n<td align=\"left\">流出云服务器 ECS 的带宽 从云服务器 ECS 对外提供访问，或者从客户端 FTP 等方式下载云服务器 ECS 内部资源都是出网带宽，云服务器 ECS 出网带宽就是购买的带宽值。</td>\n</tr>\n</tbody></table>\n<p>推荐公司使用固定带宽，对于测试用户或者流量比较小的用户使用按量计费带宽。</p>\n<p>举例应用场景：公司网站展示类型(按量计费)，视频(固定带宽)</p>\n<p>后期还可以购买CDN加速，分担静态资源的流量。</p>\n</li>\n<li><p>从地域</p>\n<p>每个地域完全独立。每个可用区完全隔离，但同一个地域内的可用区之间使用低时延链路相连。地域和可用区之间的关系如下图所示。</p>\n<p><img data-src=\"/./assets/155788672444660_zh-CN.jpg\" alt=\"img\"></p>\n<ul>\n<li><p>中国大陆</p>\n<p>一般情况下建议选择和您目标用户所在地域最为接近的数据中心，可以进一步提升用户访问速度。不过，在基础设施、BGP 网络品质、服务质量、云服务器操作使用与配置等方面，阿里云中国大陆地域没有太大区别。BGP 网络可以保证中国大陆全部地域的快速访问。</p>\n</li>\n<li><p>其他国家及地区</p>\n<p>其他国家及地区提供国际带宽，主要面向非中国大陆地区用户。如果您在中国大陆，使用这些地域会有较长的访问延迟，不建议您使用。</p>\n<ul>\n<li>对香港、东南亚有需求的用户，可以选择香港地域、亚太东南 1 地域、亚太东南 3 地域或亚太东南 5 地域。</li>\n<li>对日、韩有需求的用户，可以选择亚太东北 1 地域。</li>\n<li>对印度有需求的用户，可以选择亚太南部 1 地域。</li>\n<li>对澳大利亚地区有需求的用户，可以选择亚太东南 2 地域。</li>\n<li>对美洲有需求用户，可以选择美国地域。</li>\n<li>对欧洲大陆有需求的用户，可以选择欧洲中部 1 地域。</li>\n<li>对中东地区有需求的用户，可以选择中东东部 1 地域。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>从费用</p>\n</li>\n</ol>\n<h4 id=\"云服务器购买\"><a href=\"#云服务器购买\" class=\"headerlink\" title=\"云服务器购买\"></a>云服务器购买</h4><h4 id=\"认识控制台\"><a href=\"#认识控制台\" class=\"headerlink\" title=\"认识控制台\"></a>认识控制台</h4><h3 id=\"云数据库RDS\"><a href=\"#云数据库RDS\" class=\"headerlink\" title=\"云数据库RDS\"></a>云数据库RDS</h3><h4 id=\"云数据库介绍\"><a href=\"#云数据库介绍\" class=\"headerlink\" title=\"云数据库介绍\"></a>云数据库介绍</h4><ol>\n<li><p>基本概念</p>\n<p>阿里云系产品：云数据库RDS（ApsaraDB for RDS，简称RDS）是一种稳定可靠、可弹性伸缩的在线数据库服务。基于飞天分布式系统和全SSD盘高性能存储，支持MySQL、SQL Server、PostgreSQL和PPAS（高度兼容Oracle)引擎，默认部署主备架构且提供了容灾、备份、恢复、监控、迁移等方面的全套解决方案，彻底解决数据库运维的烦恼！</p>\n<p>亚马逊系产品：Amazon Relational Database Service (Amazon RDS) 让您能够在云中轻松设置、操作和扩展关系数据库。它在自动执行耗时的管理任务（如<strong>硬件预置、数据库设置、修补和备份</strong>）的同时，可提供经济实用的可调容量。这使您能够腾出时间专注于应用程序，为它们提供所需的快速性能、高可用性、安全性和兼容性。</p>\n<p>Amazon RDS 在多种类型的数据库实例（针对内存、性能或 I&#x2F;O 进行了优化的实例）上均可用，并提供六种常用的数据库引擎供您选择，包括 Amazon Aurora、PostgreSQL、MySQL、MariaDB、Oracle Database 和 SQL Server。您可以使用 AWS Database Migration Service <strong>轻松</strong>将您现有的<strong>数据库迁移或复制到 Amazon RDS</strong>。</p>\n</li>\n<li><p>特点：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>轻松管理</td>\n<td>GUI页面，从部署到生产数据库</td>\n</tr>\n<tr>\n<td>可扩展</td>\n<td>修改CPU&#x2F;内存&#x2F;存储资源</td>\n</tr>\n<tr>\n<td>高可用</td>\n<td>自动备份、快照 、自动主机更换</td>\n</tr>\n<tr>\n<td>速度快</td>\n<td>可选SSD</td>\n</tr>\n<tr>\n<td>安全</td>\n<td>可建立专网，或者连接到使用VPN</td>\n</tr>\n<tr>\n<td>经济</td>\n<td>网络成本、运维成本都低</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<p><strong>本课程中使用亚马逊的RDS作为演示</strong></p>\n<h4 id=\"常见RDS-MySQL购买与操作\"><a href=\"#常见RDS-MySQL购买与操作\" class=\"headerlink\" title=\"常见RDS-MySQL购买与操作\"></a>常见RDS-MySQL购买与操作</h4><ol>\n<li><p>购买地址</p>\n<p>阿里云：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi5hbGl5dW4uY29tL3Byb2R1Y3QvcmRz\">https://cn.aliyun.com/product/rds</span></p>\n<p><img data-src=\"/./assets/image-20190605084317131.png\" alt=\"/images/image-20190605084317131\"></p>\n<p>亚马逊：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9jbi9yZHMv\">https://aws.amazon.com/cn/rds/</span></p>\n<p><img data-src=\"/./assets/image-20190605084341568.png\" alt=\"/images/image-20190605084341568\"></p>\n</li>\n<li><p>操作面板介绍(以亚马逊为主)</p>\n</li>\n</ol>\n<h4 id=\"备份与快照\"><a href=\"#备份与快照\" class=\"headerlink\" title=\"备份与快照\"></a>备份与快照</h4><h3 id=\"负载均衡SLB\"><a href=\"#负载均衡SLB\" class=\"headerlink\" title=\"负载均衡SLB\"></a>负载均衡SLB</h3><h4 id=\"什么是负载均衡\"><a href=\"#什么是负载均衡\" class=\"headerlink\" title=\"什么是负载均衡\"></a>什么是负载均衡</h4><p>负载均衡（Server Load Balancer）是对多台云服务器进行流量<strong>分发</strong>的负载均衡服务。负载均衡可以通过流量分发扩展应用系统对外的服务能力，通过消除单点故障提升应用系统的可用性。</p>\n<h4 id=\"SLB功能介绍\"><a href=\"#SLB功能介绍\" class=\"headerlink\" title=\"SLB功能介绍\"></a>SLB功能介绍</h4><p>负载均衡通过设置虚拟服务地址，将添加的ECS实例虚拟成一个高性能、高可用的应用服务池，并根据转发规则，将来自客户端的请求分发给云服务器池中的ECS实例。</p>\n<p>负载均衡默认检查云服务器池中的ECS实例的健康状态，自动隔离异常状态的ECS实例，消除了单台ECS实例的单点故障，提高了应用的整体服务能力。此外，负载均衡还具备抗DDoS攻击的能力，增强了应用服务的防护能力。</p>\n<p>基本的功能：</p>\n<ol>\n<li><p><strong>调度</strong></p>\n<p><strong>负载均衡支持轮询、加权轮询（WRR）、加权最小连接数（WLC）和一致性哈希（CH）调度算法。</strong></p>\n</li>\n<li><p>健康检查 </p>\n<p>负载均衡会检查后端服务器的运行状况。当探测到后端服务器运行状况不佳时，会停止向其发送流量，然后将流量转发给其他正常运行的后端服务器。</p>\n</li>\n<li><p>会话保持</p>\n<p>负载均衡提供会话保持功能。在会话的生命周期内，可以将同一客户端的请求转发到同一台后端服务器上。</p>\n</li>\n<li><p>访问控制</p>\n</li>\n<li><p>高可用</p>\n<p>负载均衡可以将流量转发给多个可用区的后端服务器。并且，负载均衡已经在大部分地域支持了多可用区部署，当主可用区出现故障时，负载均衡可自动切换到备可用区上提供服务。</p>\n<p>业务场景二：</p>\n<p><img data-src=\"/./assets/1555309011947_zh-CN.png\" alt=\"img\"></p>\n</li>\n<li><p>安全防护</p>\n<p>结合云盾，可提供5Gbps的防DDoS攻击能力。</p>\n</li>\n<li><p>监控</p>\n</li>\n<li><p>证书管理</p>\n</li>\n<li><p>重定向</p>\n</li>\n<li><p>WS&#x2F;WSS支持</p>\n</li>\n<li><p>HTTP&#x2F;2支持</p>\n<p>HTTP&#x2F;2（Hypertext Transfer Protocol Version 2）是超文本传输协议的第二版，向下兼容HTTP1.X协议版本，同时带来性能的大幅提升。</p>\n</li>\n</ol>\n<h4 id=\"SLB技术架构\"><a href=\"#SLB技术架构\" class=\"headerlink\" title=\"SLB技术架构\"></a>SLB技术架构</h4><p><img data-src=\"http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4091/1551152011936_zh-CN.png\" alt=\"img\"></p>\n<h4 id=\"阿里云SLB购买与操作\"><a href=\"#阿里云SLB购买与操作\" class=\"headerlink\" title=\"阿里云SLB购买与操作\"></a>阿里云SLB购买与操作</h4><h2 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h2><h3 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h3><p><strong>A记录</strong>： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录</p>\n<p><strong>CNAME记录</strong>： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名</p>\n<p><strong>MX记录</strong>： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录</p>\n<p><strong>NS记录</strong>： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录</p>\n<p><strong>TXT记录</strong>： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录</p>\n<p><strong>AAAA记录</strong>： 将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录</p>\n<p><strong>SRV记录</strong>： 添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。</p>\n<p><strong>SOA记录</strong>： SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器</p>\n<p><strong>PTR记录</strong>： PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</p>\n<h3 id=\"DNS解析中一些问题\"><a href=\"#DNS解析中一些问题\" class=\"headerlink\" title=\"DNS解析中一些问题\"></a>DNS解析中一些问题</h3><h4 id=\"A记录与CNAME记录\"><a href=\"#A记录与CNAME记录\" class=\"headerlink\" title=\"A记录与CNAME记录\"></a>A记录与CNAME记录</h4><p><code>A记录</code>是把一个域名解析到一个IP地址，而<code>CNAME记录</code>是把域名解析到另外一个域名，而这个域名最终会指向一个A记录，在功能实现在上<code>A记录</code>与<code>CNAME记录</code>没有区别。</p>\n<p><code>CNAME记录</code>在做IP地址变更时要比<code>A记录</code>方便。<code>CNAME记录</code>允许将多个名字映射到同一台计算机，当有多个域名需要指向同一服务器IP，此时可以将一个域名做A记录指向服务器IP，然后将其他的域名做别名(即：CNAME)到A记录的域名上。当服务器IP地址变更时，只需要更改A记录的那个域名到新IP上，其它做别名的域名会自动更改到新的IP地址上，而不必对每个域名做更改。</p>\n<h4 id=\"A记录与AAAA记录\"><a href=\"#A记录与AAAA记录\" class=\"headerlink\" title=\"A记录与AAAA记录\"></a>A记录与AAAA记录</h4><p>二者都是指向一个IP地址，但对应的IP版本不同。<code>A记录</code>指向<code>IPv4</code>地址，<code>AAAA记录</code>指向<code>IPv6</code>地址。<code>AAAA记录</code>是<code>A记录</code>的升级版本。</p>\n<h4 id=\"IPv4与IPv6\"><a href=\"#IPv4与IPv6\" class=\"headerlink\" title=\"IPv4与IPv6\"></a>IPv4与IPv6</h4><p><code>IPv4</code>，是互联网协议（Internet Protocol，IP）的第四版，也是第一个被广泛使用的版本，是构成现今互联网技术的基础协议。<code>IPv4</code> 的下一个版本就是<code>IPv6</code>，在将来将取代目前被广泛使用的<code>IPv4</code>。</p>\n<p><code>IPv4</code>中规定IP地址长度为32位（按TCP&#x2F;IP参考模型划分) ，即有2^32-1个地址。<code>IPv6</code>的提出最早是为了解决，随着互联网的迅速发展<code>IPv4</code>地址空间将被耗尽的问题。为了扩大地址空间，<code>IPv6</code>将IP地址的长度由32位增加到了128位。在<code>IPv6</code>的设计过程中除了一劳永逸地解决了地址短缺问题以外，还解决了<code>IPv4</code>中的其它问题，如：端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。</p>\n<h4 id=\"TTL值\"><a href=\"#TTL值\" class=\"headerlink\" title=\"TTL值\"></a>TTL值</h4><p><code>TTL</code>－生存时间（Time To Live），表示解析记录在DNS服务器中的缓存时间，<code>TTL</code>的时间长度单位是秒，一般为3600秒。比如：在访问<code>www.itcast.cn</code>时，如果在DNS服务器的缓存中没有该记录，就会向某个NS服务器发出请求，获得该记录后，该记录会在DNS服务器上保存<code>TTL</code>的时间长度，在<code>TTL</code>有效期内访问<code>www.itcast.cn</code>，DNS服务器会直接缓存中返回刚才的记录。</p>\n<h3 id=\"shell脚本入门\"><a href=\"#shell脚本入门\" class=\"headerlink\" title=\"shell脚本入门\"></a>shell脚本入门</h3><p>推荐：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL3NoZWxsLXF1aWNrLXN0YXJ0Lmh0bWw=\">https://www.runoob.com/w3cnote/shell-quick-start.html</span></p>\n<h3 id=\"vim编辑器入门\"><a href=\"#vim编辑器入门\" class=\"headerlink\" title=\"vim编辑器入门\"></a>vim编辑器入门</h3><p>推荐：<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDczMzA4OQ==\">https://zhuanlan.zhihu.com/p/34733089</span></p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"v8引擎编译原理","url":"/2024/05/21/v8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","content":"<h1 id=\"v8引擎介绍\"><a href=\"#v8引擎介绍\" class=\"headerlink\" title=\"v8引擎介绍\"></a>v8引擎介绍</h1><p>Blink内核用于解析HTML、DOM、CSS渲染、嵌入了v8引擎用于解析Javascript</p>\n<p>V8是谷歌的开源高性能JavaScript和WebAssembly引擎，用C++编写。它被用于Chrome和Node.js等。<strong>用于解析并执行JavaScript代码。</strong></p>\n<h1 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h1><ul>\n<li>初始化运行环境<ul>\n<li>堆栈空间</li>\n<li>全局执行上下文</li>\n<li>全局作用域</li>\n<li>事件循环系统</li>\n</ul>\n</li>\n<li>利用Scanner扫描器将输入的代码词法分析成tokens<ul>\n<li>分析的结果就是一个个的tokens对象组成的数组</li>\n<li>分析的过程利用了有限自动状态机的概念</li>\n</ul>\n</li>\n<li>利用parser解析器将tokens转化为抽象语法树<ul>\n<li>根据分析tokens构造出一种树形关系结构</li>\n<li><strong>预解析</strong>：在JS代码执行之前对代码进行可选的预处理，用于提高执行效率</li>\n<li><strong>延迟解析</strong>：只有代码执行到的部分才会去解析，节省了不必要的时间和开销，提高了JavaScript的执行效率，其中vite脚手架就是利用了这个优点（还有esbuild打包快的优势），提高了效率。</li>\n</ul>\n</li>\n<li>利用ignition解释器将AST（抽象语法树）转为字节码（不直接转为机器码？）<ul>\n<li>字节码跨平台能力强</li>\n<li>字节码更快的加载和解析执行</li>\n<li>动态优化易操作</li>\n<li>代码安全性</li>\n</ul>\n</li>\n<li>利用TurboFan编译器将字节码转为CPU和ARM识别的机器码</li>\n</ul>\n<h1 id=\"v8中的对象结构\"><a href=\"#v8中的对象结构\" class=\"headerlink\" title=\"v8中的对象结构\"></a>v8中的对象结构</h1><h3 id=\"常规属性和排序属性\"><a href=\"#常规属性和排序属性\" class=\"headerlink\" title=\"常规属性和排序属性\"></a>常规属性和排序属性</h3><ul>\n<li>v8中的对象主要分为三个指针构成的，分别是：隐藏类、常规属性和排序属性。</li>\n<li>对象的属性数字会从小到大排列，字符串会按照原创建顺序</li>\n<li>对象中数字属性被称为排序属性，字符串属性被称为常规属性</li>\n</ul>\n<h3 id=\"快属性和慢属性\"><a href=\"#快属性和慢属性\" class=\"headerlink\" title=\"快属性和慢属性\"></a>快属性和慢属性</h3><ul>\n<li>JS对象很多属性是在原型链上进行查找，这样就会很慢，v8将部分常规属性（10个）直接存储到对象本身（对象内属性），以提高属性的查询效率。</li>\n<li>快属性容量是10个。</li>\n</ul>\n<h3 id=\"封装、继承、多态\"><a href=\"#封装、继承、多态\" class=\"headerlink\" title=\"封装、继承、多态\"></a>封装、继承、多态</h3><ul>\n<li>封装就是将抽象出来的数据和对数据的操作封装在一起，数据在内部被保护，程序其他部分只有通过成员才能对数据进行操作</li>\n<li>继承：有原型链继承、寄生继承和call、apply借用法继承。</li>\n<li>多态就是函数重载：同一个函数可以根据调用的情况（参数类型和数量等）来进行不同的操作。</li>\n</ul>\n<h1 id=\"隐藏类\"><a href=\"#隐藏类\" class=\"headerlink\" title=\"隐藏类\"></a>隐藏类</h1><p>JavaScript是一门动态语言，其各种不确定性导致JavaScript的执行效率要远低于静态语言，V8为了提升JavaScript的执行效率，借鉴了很多静态语言的特性，比如：JIT机制，为了加速运算而引入了内联缓存，为了提升对象的属性访问速度而引入了隐藏类。</p>\n<p>隐藏类是V8引擎在运行时自动生成和管理的数据结构，用于跟踪对象的属性和方法，相当于提前定义好对象的形状，以便于提高操作对象的效率。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><ul>\n<li>当JavaScript运行时，例如查找对象上的某一个属性，V8引擎会通过快慢属性去查找，整个过程非常耗时，因为V8在使用一个对象时，并不知道对象的具体形状（属性方法等）</li>\n<li>而C++在声明一个对象前就需要定义该对象的结构，C++代码执行前是需要被编译的，编译时对象的结构就已经固定，也就是当代码执行时，对象的形状是无法改变</li>\n<li>所以V8引入了隐藏类的概念，用于跟踪对象的属性和方法以此在内存中快速查找对象属性</li>\n</ul>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>隐藏类就是把JavaScript的对象也进行静态化，<code>我们假设这个对象不会删除和新增</code>，这样形状就固定了</p>\n<p>满足条件之后V8就会创建隐藏类，在这个隐藏类会创建对象的基础属性</p>\n<p>在V8引擎中，每个隐藏类都有一个编号（<code>map id</code>），用于唯一标识该隐藏类</p>\n<p>举个例子，假设我们有以下两个对象：</p>\n<pre><code class=\"javaScript\">let obj1 = &#123; name: 1, age: 2 &#125;; \nlet obj2 = &#123; name: 1, age: 2, address: 3 &#125;;\n</code></pre>\n<p>这两个对象具有相同的形状，即都有属性<code>name</code>和<code>age</code>，但<code>obj2</code>还额外有一个属性<code>address</code>。V8会为它们生成两个不同的隐藏类</p>\n<pre><code class=\"sh\">// 隐藏类1：包含属性name和age\nHiddenClass_1\n├── map_id: 1\n├── property_names: [&#39;name&#39;, &#39;age&#39;]\n├── transitions: &#123;&#125;\n└── prototype: Object.prototype\n\n// 隐藏类2：包含属性name、age和address\nHiddenClass_2\n├── map_id: 2\n├── property_names: [&#39;name&#39;, &#39;age&#39;, &#39;address&#39;]\n├── transitions:\n│   ├── a: HiddenClass_1\n│   ├── b: HiddenClass_1\n│   └── c: null\n└── prototype: Object.prototype\n</code></pre>\n<p>可以看到，隐藏类1包含属性<code>name</code>和<code>age</code>，没有过渡表；而隐藏类2包含属性<code>name</code>、<code>age</code>和<code>address</code>，其中属性<code>name</code>和<code>age</code>的过渡表指向隐藏类1，属性<code>address</code>没有过渡表，表示该属性是新添加的</p>\n<p><strong>如果两个对象属性一样呢？</strong></p>\n<p>如果两个对象具有相同的属性，它们将共享同一个隐藏类。具体来说，当两个对象的属性顺序和类型都相同时，V8会为它们生成一个共享的隐藏类。</p>\n<p>举个例子，假设我们有以下两个对象：</p>\n<pre><code class=\"ini\">let obj1 = &#123; name: 1, age: 2 &#125;;\nlet obj2 = &#123; name: 1, age: 2 &#125;;\n</code></pre>\n<p>这两个对象具有相同的形状，即都有属性<code>name</code>和<code>age</code>，且属性的顺序和类型完全一致。V8会为它们生成一个共享的隐藏类，如下所示：</p>\n<pre><code class=\"javascript\">HiddenClass_1\n├── map_id: 1\n├── property_names: [&#39;name&#39;, &#39;age&#39;]\n├── transitions: &#123;&#125;\n└── prototype: Object.prototype\n</code></pre>\n<p>可以看到，隐藏类1包含属性<code>name</code>和<code>age</code>，没有过渡表，而且两个对象都<code>共享</code>这个隐藏类。</p>\n<blockquote>\n<p>这种共享隐藏类的机制可以节省内存空间，因为不同的对象可以共享相同的隐藏类结构。</p>\n</blockquote>\n<p><img data-src=\"/images/Snipaste_2024-05-28_21-49-19.png\" alt=\"JavaScript隐藏类机制\"></p>\n","categories":["v8引擎编译原理"],"tags":["v8引擎","底层原理"]},{"title":"vue-router","url":"/2024/04/12/vue-router/","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"vue-router源码\"><a href=\"#vue-router源码\" class=\"headerlink\" title=\"vue-router源码\"></a>vue-router源码</h1><h3 id=\"vue-router路由模式\"><a href=\"#vue-router路由模式\" class=\"headerlink\" title=\"vue-router路由模式\"></a>vue-router路由模式</h3><h4 id=\"hash模式（-）\"><a href=\"#hash模式（-）\" class=\"headerlink\" title=\"hash模式（#）\"></a>hash模式（#）</h4><p>SEO不友好，资源不变，不会刷新。</p>\n<h4 id=\"history模式（-x2F-）\"><a href=\"#history模式（-x2F-）\" class=\"headerlink\" title=\"history模式（&#x2F;）\"></a>history模式（&#x2F;）</h4><p>SEO友好，重新请求资源。</p>\n<p><strong>history模式发布时出现的问题：</strong></p>\n<p>发布到服务器上时，点击路由跳转正常但是刷新后路由跳转404，出现的原因刷新后跳转的根路径并不是当前项目的index.html导致资源路径不匹配单页面应用路由，采取的方法是<strong>每次请求资源都fallback到index.html文件</strong>，可以使用静态资源服务器的支持。（例如在nginx中location字段添加：<strong>try_files字段</strong>）</p>\n<h3 id=\"vue-router内部处理\"><a href=\"#vue-router内部处理\" class=\"headerlink\" title=\"vue-router内部处理\"></a>vue-router内部处理</h3><h6 id=\"vue-router主体架构：\"><a href=\"#vue-router主体架构：\" class=\"headerlink\" title=\"vue-router主体架构：\"></a>vue-router主体架构：</h6><p>当使用vue.use(vue-router)时，会执行vue-router导出的实例中的install方法，将app作为参数传入，内部会用app.component注册两个全局组件RouterLink和RouterView，接着在app.config.globalProperties上设置$route和$router属性，通过app.provide将router和currentRoute传递下去。</p>\n<h6 id=\"路由变化但不跳转原理：\"><a href=\"#路由变化但不跳转原理：\" class=\"headerlink\" title=\"路由变化但不跳转原理：\"></a>路由变化但不跳转原理：</h6><p>history.pushState和history.replaceState方法，会改变地址栏的但不进行跳转。</p>\n<h6 id=\"history模式实现路由匹配：\"><a href=\"#history模式实现路由匹配：\" class=\"headerlink\" title=\"history模式实现路由匹配：\"></a>history模式实现路由匹配：</h6><p>内部的mather函数会将routes中的path路径转为正则表达式，与当前的路由进行匹配，匹配成功就将对应的组件添加到router-view中。</p>\n<h6 id=\"router-view实现路由展示：\"><a href=\"#router-view实现路由展示：\" class=\"headerlink\" title=\"router-view实现路由展示：\"></a>router-view实现路由展示：</h6><pre><code class=\"js\">import &#123; defineComponent &#125; from vue;\nimport Home from &#39;../views/Home&#39;;  //导入默认的全部组件\nconst routerView =  defineComponent(&#123;\n    name:&quot;routerView&quot;,\n    props:&#123;&#125;,\n    setup(props , &#123; slots &#125;)&#123;\n        return ()=&gt;&#123;\n            // return h(&#39;div&#39;,&#123;        //不使用组件默认的方式\n            //     class:&#39;routerViewClass&#39;,\n            //     onClick()&#123;\n            //         //处理点击 逻辑\n            //     &#125;,\n            // &#125;,slots.default())\n            return h(Home,&#123;\n                onClick()&#123;\n                    //处理对应的逻辑\n                &#125;\n            &#125;)\n        &#125;\n    &#125;,\n&#125;)\nexport default routerView;\n</code></pre>\n<p>路由provide一个currentRoute（shallowRef对象）将当前的路由路径捆绑在一起，传递下去，当currentRoute发生变化的时候就会改变相应的router-view。</p>\n","categories":["vue-router原理"],"tags":["vue-router原理"]},{"title":"react笔记","url":"/2023/12/02/react/","content":"<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD-————\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD-————\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD# ————-\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br># ————-</h1><h1 id=\"————————————\"><a href=\"#————————————\" class=\"headerlink\" title=\"————————————\"></a>————————————</h1><h1 id=\"react官网笔记：\"><a href=\"#react官网笔记：\" class=\"headerlink\" title=\"react官网笔记：\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi95b3UtbWlnaHQtbm90LW5lZWQtYW4tZWZmZWN0\">react官网笔记：</span></h1><h1 id=\"react核心价值\"><a href=\"#react核心价值\" class=\"headerlink\" title=\"react核心价值\"></a>react核心价值</h1><p>组件化 + 数据驱动视图<br>UI &#x3D; f( state )</p>\n<h1 id=\"react快照state\"><a href=\"#react快照state\" class=\"headerlink\" title=\"react快照state\"></a>react快照state</h1><p>state就像每次渲染的快照，并且不会同步更新，react中当state状态变化时，当前快照中是获取不到更新后的内容和状态的（因为react由于优化需要集中多个进行更新），此时想要操作快照更新之后的操作只能在快照更新之后添加钩子函数。</p>\n<ul>\n<li>使用useEffect（快照更新之后自动执行钩子）</li>\n<li>类组件可以使用生命周期钩子</li>\n<li>使用条件渲染，根据条件进行不同的处理</li>\n</ul>\n<h1 id=\"组件透层级传递状态\"><a href=\"#组件透层级传递状态\" class=\"headerlink\" title=\"组件透层级传递状态\"></a>组件透层级传递状态</h1><p>使用React的Context功能，Context 让父组件可以为它下面的整个组件树提供数据，实现原理是通过发布订阅模式。</p>\n<ol>\n<li>使用react中createContext方法，创建一个context状态，传入状态初始值</li>\n<li>通过react的useContent方法，传入context名称进行状态的消费。</li>\n<li>前提是需要在需要使用到的标签外部包裹创建的context组件.Provider&lt;ContextName.Provider value&#x3D;{}&gt;&lt;&#x2F;ContextName.Provider&gt;</li>\n<li>这将导致在组件内部消费状态时，根据Provider的嵌套层级，使用最近的Provider的context内容。</li>\n</ol>\n<h1 id=\"react状态管理\"><a href=\"#react状态管理\" class=\"headerlink\" title=\"react状态管理\"></a>react状态管理</h1><h3 id=\"局部状态管理\"><a href=\"#局部状态管理\" class=\"headerlink\" title=\"局部状态管理\"></a>局部状态管理</h3><p>react提供了两种状态管理的hooks，useState和useReducer，两者使用场景为：简单的业务可以使用useState钩子完成即可，但是如果业务中状态繁琐，频繁使用useState就会导致太多状态难以阅读理解，表现和业务耦合在一起，这时使用useReducer更好。</p>\n<h3 id=\"全局状态管理\"><a href=\"#全局状态管理\" class=\"headerlink\" title=\"全局状态管理\"></a>全局状态管理</h3><p>react中已经有了useState和useReducer两种状态管理方式，那为什么还要使用redux呢？其实只是用useState和useReuder只能实现局部的状态管理，redux解决了：</p>\n<ul>\n<li>全局状态管理（多个组件共享状态）</li>\n<li>状态的可预测性（使得状态的变化更加清晰和易于追踪）</li>\n<li>结构化组织代码，提高可维护性</li>\n</ul>\n<h2 id=\"redux对比useReducer-Context\"><a href=\"#redux对比useReducer-Context\" class=\"headerlink\" title=\"redux对比useReducer+Context\"></a>redux对比useReducer+Context</h2><ul>\n<li>使用useReducer加上Context就可以实现一个简易的状态管理仓库了，可以使得子组件之间共享状态</li>\n<li>但是redux的好处在于可以集中管理状态，便于追踪</li>\n<li>此外redux插件可以帮助调试，redux的分包管理使得逻辑更加清晰</li>\n</ul>\n<h1 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h1><p>useRef返回一个普通的javascript对象，它和state一样，react会在每次渲染之间保留ref，但是设置state会重新渲染组件，更改ref不会。</p>\n<p>当一条信息用于渲染时，将他保存在state中，当一条信息用于仅仅被事件处理器需要，并且不参与渲染时，使用ref更加高效。</p>\n<h3 id=\"ref和state差异\"><a href=\"#ref和state差异\" class=\"headerlink\" title=\"ref和state差异\"></a>ref和state差异</h3><p><strong>useRef是由useState函数进一步封装得到（只使用状态，不使用方法更新视图）：</strong></p>\n<pre><code class=\"js\">function useRef(initialValue) &#123;\n  const [ref, unused] = useState(&#123; current: initialValue &#125;);\n  return ref;\n&#125;\n</code></pre>\n<p>大多数情况下，建议使用 state。ref 是一种“脱围机制”，并不会经常用到它。 以下是 state 和 ref 的对比：</p>\n<table>\n<thead>\n<tr>\n<th>ref</th>\n<th>state</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>useRef(initialValue)</code>返回 <code>&#123; current: initialValue &#125;</code></td>\n<td><code>useState(initialValue)</code> 返回 state 变量的当前值和一个 state 设置函数 ( <code>[value, setValue]</code>)</td>\n</tr>\n<tr>\n<td>更改时不会触发重新渲染</td>\n<td>更改时触发重新渲染。</td>\n</tr>\n<tr>\n<td>可变 —— 你可以在渲染过程之外修改和更新 <code>current</code> 的值。</td>\n<td>“不可变” —— 你必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。</td>\n</tr>\n<tr>\n<td>你不应在渲染期间读取（或写入） <code>current</code> 值。</td>\n<td>你可以随时读取 state。但是，每次渲染都有自己不变的 state <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi9zdGF0ZS1hcy1hLXNuYXBzaG90\">快照</span>。</td>\n</tr>\n</tbody></table>\n<p><strong>注意：ref设值（同步）不同于state快照型设值（不同步）。</strong></p>\n<h3 id=\"ref和DOM\"><a href=\"#ref和DOM\" class=\"headerlink\" title=\"ref和DOM\"></a>ref和DOM</h3><p>ref 最常见的用法是访问 DOM 元素。比如 <code>&lt;div ref=&#123;myRef&#125;&gt;</code>，React 会将相应的 DOM 元素放入 <code>myRef.current</code> 中。当元素从 DOM 中删除时，React 会将 <code>myRef.current</code> 更新为 <code>null</code>。</p>\n<p><code>useRef</code> Hook 返回一个对象，该对象有一个名为 <code>current</code> 的属性。最初，<code>myRef.current</code> 是 <code>null</code>。当 React 为这个 <code>&lt;div&gt;</code> 创建一个 DOM 节点时，React 会把对该节点的引用放入 <code>myRef.current</code>。然后，你可以从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi9yZXNwb25kaW5nLXRvLWV2ZW50cw==\">事件处理器</span> 访问此 DOM 节点，并使用在其上定义的内置<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0VsZW1lbnQ=\">浏览器 API</span>。</p>\n<p>useRef返回的ref.current中有一个remove方法，该方法执行后会将ref值为null，这样以便于ref能够被垃圾回收机制进行回收。</p>\n<p><strong>注意：ref只能使用浏览器自带的DOM元素上，而不能直接用在组件上（可以在组件内传递一下使用）。</strong></p>\n<h1 id=\"forwardRef\"><a href=\"#forwardRef\" class=\"headerlink\" title=\"forwardRef\"></a>forwardRef</h1><p>用于将一个组件的 <code>ref</code> 转发到该组件的子组件中。这在使用类组件或需要访问子组件的DOM元素时非常有用，尤其是当子组件是一个函数组件或类组件，且你希望保留对该子组件的引用时。</p>\n<h1 id=\"useImperativeHandle\"><a href=\"#useImperativeHandle\" class=\"headerlink\" title=\"useImperativeHandle\"></a>useImperativeHandle</h1><p><code>useImperativeHandle</code> 是React的一个钩子，它与 <code>forwardRef</code> 一起使用，用于在使用refs的场景中为组件提供一个<strong>可自定义的行为。</strong>当你想要在子组件中暴露给父组件一些方法或属性时，<code>useImperativeHandle</code> 就非常有用。</p>\n<p>两者可以结合使用（使用forwardRef转发ref，使用useImperativeHandle设置DOM元素方法）：</p>\n<pre><code class=\"js\">const InputComponent = React.forwardRef((props, ref) =&gt; &#123;\n  useImperativeHandle(ref, () =&gt; (&#123;\n    focus: () =&gt; inputRef.current.focus()\n  &#125;));\n  return &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;;\n&#125;);\n</code></pre>\n<h1 id=\"Effect同步\"><a href=\"#Effect同步\" class=\"headerlink\" title=\"Effect同步\"></a>Effect同步</h1><h3 id=\"React中两种逻辑类型\"><a href=\"#React中两种逻辑类型\" class=\"headerlink\" title=\"React中两种逻辑类型\"></a>React中两种逻辑类型</h3><ul>\n<li><strong>渲染逻辑代码</strong>，<strong>位于组件的顶层</strong>，在此处接受props和state，并对他们进行转换，最终返回想在屏幕上看到的JSX，渲染的代码必须是纯粹的，它只应该“计算”结果，而不做其他任何事情。</li>\n<li><strong>事件处理程序</strong>，<strong>是嵌套在组件内部的函数</strong>，而不仅仅是计算函数。事件处理程序可能会更新输入字段、提交 HTTP POST 请求以购买产品，或者将用户导航到另一个屏幕。事件处理程序包含由特定用户操作（例如按钮点击或键入）引起的“副作用”（它们改变了程序的状态）。</li>\n</ul>\n<h3 id=\"Effect作用\"><a href=\"#Effect作用\" class=\"headerlink\" title=\"Effect作用\"></a>Effect作用</h3><p>Effect允许指定由渲染本身而不是特定事件引起的副作用。（利用无论是哪种交互导致组件执行渲染，effect都会在屏幕更新后的提交阶段执行）</p>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ul>\n<li><p><strong>不要随意在你的组件中使用 Effect</strong>。记住，Effect 通常用于暂时“跳出” React 代码并与一些 <strong>外部</strong> 系统进行同步。这包括浏览器 API、第三方小部件，以及网络等等。如果你想用 Effect 仅根据其他状态调整某些状态，那么 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi95b3UtbWlnaHQtbm90LW5lZWQtYW4tZWZmZWN0\">你可能不需要 Effect</span>。</p>\n</li>\n<li><p>Effect会在每次渲染之后执行，如下代码会造成死循环：</p>\n<pre><code>const [count,setCount] = useState();\nuseEffect(()=&gt;&#123;\n    setCount(count++);\n&#125;)\n</code></pre>\n</li>\n<li><p>useEffect第二个参数不传代表<strong>每次渲染组件后都执行一次</strong>，传空数组代表<strong>只会在第一次挂载后执行</strong>，传依赖项代表在<strong>依赖项变化时执行。</strong></p>\n</li>\n<li><p>useEffect依赖项中传入ref通常是无效的，因为ref相当于不使用渲染赋值的state状态，传递过去的ref引用始终相同（不随着快照的渲染而变化）。</p>\n</li>\n<li><p>某些逻辑不能放在effect中执行，因为effect的执行是和组件渲染强绑定的（例如不能在effect中写购买商品的逻辑，这样会导致组件以任何方式被渲染都会执行购买逻辑，这样是不对的）</p>\n</li>\n<li><p>effect中return的函数会在下一次effect执行前被执行，常用于执行清理函数（清除定时器等）</p>\n</li>\n</ul>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><ul>\n<li>与事件不同，Effect 是由渲染本身，而非特定交互引起的。</li>\n<li>Effect 允许你将组件与某些外部系统（第三方 API、网络等）同步。</li>\n<li>默认情况下，Effect 在每次渲染（包括初始渲染）后运行。</li>\n<li>如果 React 的所有依赖项都与上次渲染时的值相同，则将跳过本次 Effect。</li>\n<li>不能随意选择依赖项，它们是由 Effect 内部的代码决定的。</li>\n<li>空的依赖数组（<code>[]</code>）对应于组件“挂载”，即添加到屏幕上。</li>\n<li>仅在严格模式下的开发环境中，React 会挂载两次组件，以对 Effect 进行压力测试。</li>\n<li>如果 Effect 因为重新挂载而中断，那么需要实现一个清理函数。</li>\n<li>React 将在下次 Effect 运行之前以及卸载期间这两个时候调用清理函数</li>\n</ul>\n<h1 id=\"Effect生命周期\"><a href=\"#Effect生命周期\" class=\"headerlink\" title=\"Effect生命周期\"></a>Effect生命周期</h1><p>react组件的生命周期：</p>\n<ul>\n<li>添加到屏幕（挂载）</li>\n<li>组件接收新的props或state（更新）</li>\n<li>从屏幕移除（卸载）</li>\n</ul>\n<h1 id=\"effect依赖项\"><a href=\"#effect依赖项\" class=\"headerlink\" title=\"effect依赖项\"></a>effect依赖项</h1><ul>\n<li>effect中的依赖项只能传入响应性的变量（组件props也是响应性的）</li>\n<li>组件props也是响应性的，类组件props变化会触发钩子重新执行，函数式组件props变化会重新执行</li>\n<li>组件内声明的变量可以是响应性的，每次会重新声明。</li>\n<li>effect依赖项不能传入ref.current，ref.current本身不是响应性的，不会引起视图更新（ref.current允许跟踪某些值而不触发重新渲染）</li>\n<li>effect依赖项不能传入组件内定义的对象或者函数（由于每次定义都会改变）</li>\n<li>effect依赖项不能传入可变值（包括全局变量），它不是响应性的。</li>\n</ul>\n<h1 id=\"自定义Hook\"><a href=\"#自定义Hook\" class=\"headerlink\" title=\"自定义Hook\"></a>自定义Hook</h1><ul>\n<li>use开头</li>\n<li>代码检查工具会强制use命名公约，只有Hook和组件可以调用其他Hook</li>\n<li>没有调用Hook的函数不需要变成Hook（或以use开头）</li>\n<li>自定义Hook共享的是状态逻辑，而不是状态本身，对Hook的每一个调用完全独立于对同一个Hook的其他调用。</li>\n<li>当需要在多个组件之间共享state本身时，需要将变量提升并传递下去。</li>\n</ul>\n<h1 id=\"————————————-1\"><a href=\"#————————————-1\" class=\"headerlink\" title=\"————————————\"></a>————————————</h1><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"react项目学习\"><a href=\"#react项目学习\" class=\"headerlink\" title=\"react项目学习\"></a><a href=\"\">react项目学习</a></h1><h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h1><blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>37e1bb0043140141ede69a340096e04fd5a1e194</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"react笔记\"><a href=\"#react笔记\" class=\"headerlink\" title=\"react笔记\"></a>react笔记</h1><h1 id=\"状态管理工具\"><a href=\"#状态管理工具\" class=\"headerlink\" title=\"状态管理工具\"></a>状态管理工具</h1><h2 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h2><h3 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h3><p>将store实例进行订阅，则当store实例通过dispatch进行发布时，就触发订阅函数的执行。</p>\n<pre><code class=\"react\">  // 1. 定义reducer函数 \n  // 作用: 根据不同的action对象，返回不同的新的state\n  // state: 管理的数据初始状态\n  // action: 对象 type 标记当前想要做什么样的修改\n  function reducer (state = &#123; count: 0 &#125;, action) &#123;\n    // 数据不可变：基于原始状态生成一个新的状态\n    if (action.type === &#39;INCREMENT&#39;) &#123;\n      return &#123; count: state.count + 1 &#125;\n    &#125;\n    if (action.type === &#39;DECREMENT&#39;) &#123;\n      return &#123; count: state.count - 1 &#125;\n    &#125;\n    return state\n  &#125;\n\n  // 2. 使用reducer函数生成store实例\n  const store = Redux.createStore(reducer)\n\n  // 3. 通过store实例的subscribe订阅数据变化\n  // 回调函数可以在每次state发生变化的时候自动执行\n  store.subscribe(() =&gt; &#123;\n    console.log(&#39;state变化了&#39;, store.getState())\n    document.getElementById(&#39;count&#39;).innerText = store.getState().count\n  &#125;)\n\n  // 4. 通过store实例的dispatch函数提交action更改状态 \n  const inBtn = document.getElementById(&#39;increment&#39;)\n  inBtn.addEventListener(&#39;click&#39;, () =&gt; &#123;\n    // 增\n    store.dispatch(&#123;\n      type: &#39;INCREMENT&#39;\n    &#125;)\n  &#125;)\n\n  const dBtn = document.getElementById(&#39;decrement&#39;)\n  dBtn.addEventListener(&#39;click&#39;, () =&gt; &#123;\n    // 减\n    store.dispatch(&#123;\n      type: &#39;DECREMENT&#39;\n    &#125;)\n  &#125;)\n  // 5. 通过store实例的getState方法获取最新状态更新到视图中\n</code></pre>\n<h2 id=\"Mobx\"><a href=\"#Mobx\" class=\"headerlink\" title=\"Mobx\"></a>Mobx</h2><p>声明式的修改数据，类似于Vue。</p>\n<h1 id=\"react中css使用\"><a href=\"#react中css使用\" class=\"headerlink\" title=\"react中css使用\"></a>react中css使用</h1><h3 id=\"出现问题\"><a href=\"#出现问题\" class=\"headerlink\" title=\"出现问题\"></a>出现问题</h3><p>react组件中使用样式时，需要引入对应的css文件，但是如果两个css文件中有相同的class命名，这时就会造成样式冲突（相互影响）。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p><strong>CSS Module</strong></p>\n<ul>\n<li>每个CSS文件都当作单独的模块，命名xxx.module.css</li>\n<li>引入时：<code>import styles from &#39;xxx.module.css&#39;</code></li>\n<li>使用时：<code>className = &#123;styles[&#39;test-style&#39;]&#125;</code></li>\n<li>这样使用后组件中对应的class就会被命名为组件名称和样式名称的拼接</li>\n</ul>\n<p>create-react-app中内置了CSS Module功能，直接使用即可。</p>\n<h3 id=\"使用sass\"><a href=\"#使用sass\" class=\"headerlink\" title=\"使用sass\"></a>使用sass</h3><p>create-react-app中内置了cass语法的支持，安装sass直接使用即可</p>\n<h2 id=\"CSS-in-JS\"><a href=\"#CSS-in-JS\" class=\"headerlink\" title=\"CSS-in-JS\"></a>CSS-in-JS</h2><h5 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h5><ul>\n<li>css-in-js是一种解决方案，包含很多工具</li>\n<li>在JS中书写CSS，带来极大的灵活性</li>\n<li>它和内联的style完全不同，也不会有内联style的问题</li>\n</ul>\n<h5 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h5><ul>\n<li>styled-components</li>\n<li>styled-js（ts支持不友好）</li>\n<li>emotion</li>\n</ul>\n<h5 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h5><ul>\n<li>优点：使用js书写，有逻辑有变量，非常灵活</li>\n<li>缺点：JSX和样式代码混在一起，代码较多，增加了编译成本</li>\n<li>使用场景：需要灵活变换样式</li>\n</ul>\n<h1 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h1><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><ul>\n<li>Web系统需要多个页面</li>\n<li>多页面就需要用路由来管理</li>\n<li>PS：业务上的页面，技术上还是react组件</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>路由设计：网址和页面之间的关系</li>\n<li>增加页面和Layout模板</li>\n<li>使用<code>react-router</code>增加路由配置</li>\n</ul>\n<p>浏览器端使用<code>react-router-dom</code>工具，其中包含：</p>\n<ul>\n<li>Outlet组件（父组件中嵌入子组件路由）</li>\n<li>Link组件（用于路由跳转）</li>\n<li>useNavigate钩子函数（用于路由跳转）</li>\n<li>useSearchParams钩子函数（用于获取路由参数）</li>\n<li>useLocation钩子函数（用于获取当前路由的信息）</li>\n</ul>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"—————\"><a href=\"#—————\" class=\"headerlink\" title=\"—————-\"></a>—————-</h1><h1 id=\"react项目\"><a href=\"#react项目\" class=\"headerlink\" title=\"react项目\"></a>react项目</h1><h1 id=\"React-核心价值\"><a href=\"#React-核心价值\" class=\"headerlink\" title=\"React 核心价值\"></a>React 核心价值</h1><p>这两个，也是所有现代前端框架的核心价值</p>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><p>什么是组件化</p>\n<ul>\n<li>拆分页面结构，易开发易维护，尤其对大型项目</li>\n<li>重复的结构，可通过组件化复用</li>\n</ul>\n<p>（画图表示）</p>\n<p>组件化并不是 React 独创的</p>\n<ul>\n<li>早年的 PHP ASP 等动态网页技术，就支持组件化</li>\n<li>HTML5 的 Web Component 也支持组件化</li>\n<li>React 正式把组件化发扬光大 （包括 ng Vue）</li>\n</ul>\n<h2 id=\"数据驱动视图\"><a href=\"#数据驱动视图\" class=\"headerlink\" title=\"数据驱动视图\"></a>数据驱动视图</h2><p>公式 <code>UI = f(state)</code> （开始可能不理解）</p>\n<p>例如，要增加一个 todo item （修改、删除，用 DOM 操作更麻烦）</p>\n<pre><code class=\"html\">&lt;ul&gt;\n    &lt;li&gt;吃饭&lt;/li&gt;\n    &lt;li&gt;睡觉&lt;/li&gt;\n&lt;/ul&gt;\n// 用 jQuery 的代码逻辑 - DOM 操作\nconst $li = $(&#39;&lt;li&gt;new todo&lt;/li&gt;&#39;)\n$ul.append($li)\n</code></pre>\n<p>用 React</p>\n<pre><code class=\"jsx\">&lt;ul&gt;\n    &#123; list.map(todo =&gt; &lt;li&gt;&#123;todo&#125;&lt;/li&gt;) &#125;\n&lt;/ul&gt;\n// 用 React 的代码逻辑 - JS 操作\nconst [list, setList]= useState([&#39;吃饭&#39;, &#39;睡觉&#39;])\nsetList(l =&gt; l.concat(&#39;new todo&#39;))\n</code></pre>\n<p>数据驱动视图的好处</p>\n<ul>\n<li>只关注业务数据，解放 DOM 操作，增加开发效率</li>\n<li>适合大型复杂的前端项目 （否则，光 DOM 操作也受不了）</li>\n</ul>\n<h1 id=\"CRA\"><a href=\"#CRA\" class=\"headerlink\" title=\"CRA\"></a>CRA</h1><p>Create React App 使用最多的脚手架，React 官方推荐</p>\n<p>官网 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcmVhdGUtcmVhY3QtYXBwLmRldi8=\">https://create-react-app.dev/</span></p>\n<h2 id=\"脚手架\"><a href=\"#脚手架\" class=\"headerlink\" title=\"脚手架\"></a>脚手架</h2><p>脚手架的好处：傻瓜式操作，简单方便<br><br>如自己搭建，中间可能会出很多问题（版本问题 + 个人操作问题），可能会劝退很多人</p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p>PS：直接使用 typescript</p>\n<pre><code class=\"shell\">## 使用 npx\nnpx create-react-app my-app --template typescript\n\n## 使用 npm\nnpm init react-app my-app --template typescript\n\n## 使用 yarn\nyarn create react-app my-app --template typescript\n</code></pre>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>项目入口 <code>src/App.js</code></p>\n<p>其他文件先不管，以后再说</p>\n<h2 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h2><pre><code>npm start\n</code></pre>\n<h1 id=\"vite\"><a href=\"#vite\" class=\"headerlink\" title=\"vite\"></a>vite</h1><p>vite 是 Vue 作者发布的打包工具，启动速度快，近两年很火爆</p>\n<p>官网 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52aXRlanMuZGV2L2d1aWRlLw==\">https://cn.vitejs.dev/guide/</span></p>\n<h2 id=\"创建项目-1\"><a href=\"#创建项目-1\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><pre><code class=\"shell\">npm create vite@latest react-demo-vite --template react-ts\n\nyarn create vite react-demo-vite --template react-ts\n</code></pre>\n<p>其他创建方式，可参考官网</p>\n<h2 id=\"项目结构-1\"><a href=\"#项目结构-1\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>入口 <code>src/App.tsx</code></p>\n<p>其他文件，以后再说</p>\n<h2 id=\"启动项目-1\"><a href=\"#启动项目-1\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h2><pre><code>npm run dev\n</code></pre>\n<h1 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h1><p>高质量代码的特点</p>\n<ul>\n<li><strong>严格编码规范</strong>（靠工具、流程，而非自觉）</li>\n<li>合理、规范的注释</li>\n<li>代码合理拆分</li>\n</ul>\n<h2 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h2><p>eslint prettier</p>\n<ul>\n<li>eslint 编码规范，如变量未定义（语法语义）</li>\n<li>prettier 编码风格，如末尾是否用 <code>;</code></li>\n<li>eslint 也有编码风格的功能，两者可能会有冲突</li>\n</ul>\n<h2 id=\"eslint\"><a href=\"#eslint\" class=\"headerlink\" title=\"eslint\"></a>eslint</h2><p>安装插件</p>\n<pre><code class=\"shell\">npm install eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin -save-dev\n</code></pre>\n<p>初始化配置文件 <code>.eslint.js</code></p>\n<pre><code class=\"shell\">npx eslint --init    ## 然后根据引导一步一步走\n</code></pre>\n<p>解释：eslint <code>plugin</code> 与 <code>extend</code> 的区别：</p>\n<ul>\n<li><code>extend</code> 提供的是 eslint 现有规则的一系列预设</li>\n<li><code>plugin</code> 则提供了除预设之外的自定义规则，当你在 eslint 的规则里找不到合适的的时候就可以借用插件来实现了</li>\n</ul>\n<p>安装 vscode 插件 <code>eslint</code> ，此时就可以看到代码 <code>App.txs</code> 中的错误提示（如定义一个未使用的变量）</p>\n<p>在 <code>package.json</code> 中增加 scripts <code>&quot;lint&quot;: &quot; eslint &#39;src/**/*.+(js|ts|jsx|tsx)&#39; &quot;</code> <br><br>控制台运行 <code>npm run lint</code> 也可以看到错误提示。如果要自动修复，可以加 <code>--fix</code> 参数</p>\n<h2 id=\"prettier\"><a href=\"#prettier\" class=\"headerlink\" title=\"prettier\"></a>prettier</h2><pre><code>npm install prettier eslint-config-prettier eslint-plugin-prettier -save-dev\n</code></pre>\n<ul>\n<li><code>eslint-config-prettier</code> 禁用所有和 Prettier 产生<strong>冲突</strong>的规则</li>\n<li><code>eslint-plugin-prettier</code> 把 Prettier 应用到 Eslint，配合 rules <code>&quot;prettier/prettier&quot;: &quot;error&quot;</code> 实现 Eslint 提醒。</li>\n</ul>\n<p>在 eslint 配置文件的 <code>extends</code> <strong>最后</strong> 增加 <code>&#39;plugin:prettier/recommended&#39;</code></p>\n<p>安装 vscode 插件 <code>prettier</code> ，此时可以看到代码 <code>App.txs</code> 中的格式提示（如末尾是否使用 <code>;</code> ，或单引号、双引号）</p>\n<p>在 <code>package.json</code> 中增加 scripts <code>&quot;format&quot;: &quot; prettier --write &#39;src/**/*.+(js|ts|jsx|tsx)&#39; &quot;</code> <br><br>控制台运行 <code>npm run format</code> 可以修复所有的格式错误</p>\n<p>设置 vscode <code>.vscode/settings.json</code> 自动保存格式，可以在文件保存时，自动保留格式</p>\n<pre><code class=\"json\">&#123;\n    &quot;editor.codeActionsOnSave&quot;: &#123;\n        &quot;source.fixAll.eslint&quot;: true\n    &#125;\n&#125;\n</code></pre>\n<p>增加配置文件 <code>.prettierrc.js</code> 规定自己的编码格式，运行 <code>npm run format</code> 可以看到效果，保存文件也可以看到效果。<br><br>【注意】如果此处没效果，可以<strong>重启 vscode</strong> 再重试。</p>\n<hr>\n<p>一直搞不定，重启 vscode 就好了。<br>在 vscode 搜“prettier” 插件时，发现一个 “reload required” 的提示，于是就重启了</p>\n<p>CRA 创建的项目，配置文件是 <code>js</code> 格式<br>vite 创建的项目，配置文件是 <code>cjs</code> 格式</p>\n<h1 id=\"提交到-git-仓库\"><a href=\"#提交到-git-仓库\" class=\"headerlink\" title=\"提交到 git 仓库\"></a>提交到 git 仓库</h1><p>PS：git 不会从 0 讲起</p>\n<h2 id=\"选择平台\"><a href=\"#选择平台\" class=\"headerlink\" title=\"选择平台\"></a>选择平台</h2><ul>\n<li>工作中，按照公司规定，可能有内网 git 仓库</li>\n<li>正式的开源项目，需要积累 star ，可以考虑 github （但有时访问不稳定，不同网络环境不一样）</li>\n<li>个人学习项目，尽量选择国内平台，速度快</li>\n</ul>\n<p>我选择 coding.net</p>\n<h2 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h2><pre><code class=\"sh\">git remote add origin xxx\ngit push -u origin master\n</code></pre>\n<h2 id=\"husky\"><a href=\"#husky\" class=\"headerlink\" title=\"husky\"></a>husky</h2><p>git-hook </p>\n<p>安装依赖</p>\n<pre><code>npm install husky -save-dev\n</code></pre>\n<p>参考文档 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3R5cGljb2RlL2h1c2t5\">https://github.com/typicode/husky</span> 增加三个 <code>pre-commit</code> 命令</p>\n<pre><code class=\"shell\">npm run lint\nnpm run format\ngit add .\n</code></pre>\n<p>可以故意制造一个错误：定义一个未使用变量（eslint 配置文件 <code>rules</code> 增加 <code>&#39;no-unused-vars&#39;: &#39;error&#39;,</code>）<br><br>然后执行 <code>git commit</code> 试试</p>\n<h2 id=\"commit-lint\"><a href=\"#commit-lint\" class=\"headerlink\" title=\"commit-lint\"></a>commit-lint</h2><p>参考文档 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvbnZlbnRpb25hbC1jaGFuZ2Vsb2cvY29tbWl0bGludCNnZXR0aW5nLXN0YXJ0ZWQ=\">https://github.com/conventional-changelog/commitlint#getting-started</span> 安装设置即可</p>\n<p>commit 规则查看 <code>node_modules/@commitlint/config-conventional</code> （在 <code>commitlint.config.js</code> 中有配置）</p>\n<p>尝试 <code>git commit -m &quot;test&quot;</code> 会失败，再尝试 <code>git commit -m &quot;chore: commit lint&quot;</code> 会成功</p>\n<h1 id=\"JSX-语法\"><a href=\"#JSX-语法\" class=\"headerlink\" title=\"JSX 语法\"></a>JSX 语法</h1><p>JSX - JS 语法扩展，可以在 JS 中写模板（类似 HTML 语法）<br><br>JSX 已经成为 ES 语法标准，也可用于其他框架，如 Vue3</p>\n<ul>\n<li>标签</li>\n<li>属性</li>\n<li>事件</li>\n<li>JS 表达式</li>\n<li>判断</li>\n<li>循环</li>\n</ul>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><ul>\n<li>首字母小写 - HTML tag</li>\n<li>首字母<strong>大写</strong> - 自定义组件</li>\n<li>如 <code>&lt;input/&gt;</code> 和 <code>&lt;Input/&gt;</code> 就不一样</li>\n</ul>\n<p>可以像 HTML 一样嵌套</p>\n<p>JSX 里的标签必须是闭合的，<code>&lt;input&gt;</code> <code>&lt;br&gt;</code> 这样写在 JSX 会报错（在 HTML 中不会报错），必须闭合 <code>&lt;input/&gt;</code></p>\n<p>每一段 JSX 只能有一个根节点，或者使用 <code>&lt;&gt;&lt;/&gt;</code> （ Fragment ）</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>和 HTML 属性基本一样，但有些和 JS 关键字冲突了</p>\n<ul>\n<li><code>class</code> 要改为 <code>className</code></li>\n<li><code>style</code> 要写成 JS 对象（不能是 string），key 采用<strong>驼峰写法</strong></li>\n<li><code>for</code> 要改为 <code>htmlFor</code></li>\n</ul>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p><code>onXxx</code> 的形式</p>\n<p>注意 TS 的写法</p>\n<pre><code class=\"jsx\">function clickHandler(event: React.MouseEvent&lt;HTMLParagraphElement&gt;) &#123;\n    event.preventDefault()\n    console.log(&#39;clicked&#39;)\n&#125;\n\nreturn &lt;p onClick=&#123;clickHandler&#125;&gt;hello world&lt;/p&gt;\n</code></pre>\n<p>如果要想<strong>传递参数</strong>，可以通过如下方式</p>\n<pre><code class=\"jsx\">  function clickHandler(event: React.MouseEvent&lt;HTMLParagraphElement&gt;, x: string) &#123;\n    event.preventDefault()\n    console.log(&#39;clicked&#39;, x)\n  &#125;\n\n  return (\n    &lt;p onClick=&#123;(e: React.MouseEvent&lt;HTMLParagraphElement&gt;) =&gt; clickHandler(e, &#39;hello&#39;)&#125;&gt;\n        hello world\n    &lt;/p&gt;\n  )\n</code></pre>\n<p>PS：Event handlers must be passed, <strong>not called!</strong> <code>onClick=&#123;handleClick&#125;</code>, not <code>onClick=&#123;handleClick()&#125;</code>.</p>\n<h2 id=\"JS-表达式\"><a href=\"#JS-表达式\" class=\"headerlink\" title=\"JS 表达式\"></a>JS 表达式</h2><p><code>&#123;xxx&#125;</code> 格式表示一个 JS 变量或表达式，可用于</p>\n<ul>\n<li>普通文本内容，或判断、循环</li>\n<li>属性值</li>\n<li>用于注释</li>\n</ul>\n<h2 id=\"判断\"><a href=\"#判断\" class=\"headerlink\" title=\"判断\"></a>判断</h2><p>JS 一般使用 <code>if...else</code> 做判断，但不能用于 JSX 的 <code>&#123;xxx&#125;</code> 中。</p>\n<p>所以，可以选择其他方式做判断</p>\n<ul>\n<li>运算符 <code>&amp;&amp;</code></li>\n<li>三元表达式 <code>a ? b : c</code></li>\n<li>用函数封装</li>\n</ul>\n<pre><code class=\"jsx\">const flag = true\nreturn &lt;div&gt;\n    &#123;flag &amp;&amp; &lt;p&gt;hello&lt;/p&gt;&#125;\n    &#123;flag ? &lt;p&gt;你好&lt;/p&gt; : &lt;p&gt;再见&lt;/p&gt;&#125;\n&lt;/div&gt;\n</code></pre>\n<p>或者用函数封装</p>\n<pre><code class=\"js\">function Hello() &#123;\n    if (flag) return &lt;p&gt;你好&lt;/p&gt;\n    else return &lt;p&gt;再见&lt;/p&gt;\n&#125;\n\nreturn &lt;Hello&gt;&lt;/Hello&gt;\n</code></pre>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>使用 <code>map</code> 做循环</p>\n<pre><code class=\"js\">  const list = [\n    &#123; username: &#39;zhangsan&#39;, name: &#39;张三&#39; &#125;,\n    &#123; username: &#39;lisi&#39;, name: &#39;李四&#39; &#125;,\n    &#123; username: &#39;shuangyue&#39;, name: &#39;双越&#39; &#125;,\n  ]\n\n  const ul = &lt;ul&gt;\n    &#123;list.map(user =&gt; &#123;\n        return &lt;li key=&#123;user.username&#125;&gt;&#123;user.name&#125;&lt;/li&gt;\n    &#125;)&#125;\n  &lt;/ul&gt;\n</code></pre>\n<p>JSX 循环必须有 <code>key</code> - 帮助 React 识别哪些元素改变了，比如被添加或删除。</p>\n<ul>\n<li>同级别 <code>key</code> 必须唯一</li>\n<li><code>key</code> 是不可改变的 —— 尽量不用 index ，要用业务 ID （也不要用随机数）</li>\n<li><code>key</code> 用于优化 VDOM diff 算法（后面再说）</li>\n</ul>\n<h2 id=\"显示-HTML-代码\"><a href=\"#显示-HTML-代码\" class=\"headerlink\" title=\"显示 HTML 代码\"></a>显示 HTML 代码</h2><p>JSX 防止注入攻击，否则用 <code>dangerouslySetInnerHTML=&#123;&#123; __html: 'xxx' &#125;&#125;</code></p>\n<h1 id=\"组件和-props\"><a href=\"#组件和-props\" class=\"headerlink\" title=\"组件和 props\"></a>组件和 props</h1><h2 id=\"React-一切皆组件\"><a href=\"#React-一切皆组件\" class=\"headerlink\" title=\"React 一切皆组件\"></a>React 一切皆组件</h2><p>React应用是由组件组成的。组件是UI(用户界面)的一部分，它有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p>\n<p>组件可嵌套</p>\n<ul>\n<li>React 通过组件来构建 UI</li>\n<li>组件拆分也有利于代码组织和维护，尤其对于大型软件</li>\n<li>JSX 中，组件 tag 首字母要大写</li>\n</ul>\n<p>代码演示：从 index.tsx 开始，到 <code>&lt;App&gt;</code> 全都是组件。</p>\n<h2 id=\"组件就是一个函数\"><a href=\"#组件就是一个函数\" class=\"headerlink\" title=\"组件就是一个函数\"></a>组件就是一个函数</h2><ul>\n<li>React 之前是 class 组件</li>\n<li>现已被函数组件 FC 全面取代</li>\n<li>输入 props ，返回一段 JSX</li>\n</ul>\n<h2 id=\"实战：List-页面抽离组件\"><a href=\"#实战：List-页面抽离组件\" class=\"headerlink\" title=\"实战：List 页面抽离组件\"></a>实战：List 页面抽离组件</h2><p>代码参考 react-ts-demo 中 <code>components/QuestionCard1.tsx</code></p>\n<ul>\n<li>props 类型</li>\n<li>TS 泛型</li>\n</ul>\n<h2 id=\"进阶：type-还是-interface\"><a href=\"#进阶：type-还是-interface\" class=\"headerlink\" title=\"进阶：type 还是 interface\"></a>进阶：type 还是 interface</h2><p>都可以实现类型定义的功能 （具体代码演示），用哪个都可以</p>\n<hr>\n<p>PS：组件之间的数据传递不仅仅只有 props ，课程后面还会继续讲解其他形式。</p>\n<p>TS 语法如果一开始不熟练，就先记住当前的。随着课程深入，用多了也就熟练了。</p>\n<p>PS：函数也可以当做属性来传递</p>\n<h1 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h1><h2 id=\"让页面“动”起来\"><a href=\"#让页面“动”起来\" class=\"headerlink\" title=\"让页面“动”起来\"></a>让页面“动”起来</h2><p>例如实现一个 click 计数功能，普通变量无法实现。即：修改普通变量无法触发组件的更新 rerender</p>\n<p>通过 useState 即可实现。</p>\n<h2 id=\"state-是什么\"><a href=\"#state-是什么\" class=\"headerlink\" title=\"state 是什么\"></a>state 是什么</h2><p>State, A component’s memory —— 这个比喻非常好！</p>\n<ul>\n<li>props 父组件传递过来的信息</li>\n<li>state 组件自己内部的状态，不对外</li>\n</ul>\n<p>每次 state 变化，都会触发组件更新，从新渲染页面。</p>\n<p>代码演示，参考 react-ts-demo 中 <code>pages/StateDemo1.tsx</code></p>\n<h2 id=\"state-的特点\"><a href=\"#state-的特点\" class=\"headerlink\" title=\"state 的特点\"></a>state 的特点</h2><h3 id=\"异步更新\"><a href=\"#异步更新\" class=\"headerlink\" title=\"异步更新\"></a>异步更新</h3><p>代码演示</p>\n<p>PS：setState 传入函数，可同步更新</p>\n<h3 id=\"可能会被合并\"><a href=\"#可能会被合并\" class=\"headerlink\" title=\"可能会被合并\"></a>可能会被合并</h3><p>代码演示</p>\n<h3 id=\"不可变数据\"><a href=\"#不可变数据\" class=\"headerlink\" title=\"不可变数据\"></a>不可变数据</h3><p>state 可以是任意 JS 类型，不仅仅是值类型。<br><br>不可直接修改 state ，而要 setState 新值。</p>\n<p>代码演示</p>\n<p>PS：函数组件，每个更新函数从新执行，<strong>state 被重置，而不是被修改</strong>。state 可以理解为 readOnly</p>\n<h2 id=\"immer\"><a href=\"#immer\" class=\"headerlink\" title=\"immer\"></a>immer</h2><p>Immer 简化了不可变数据结构的处理。特别是对于 JS 语法没那么熟悉的人。</p>\n<p>代码演示，参考 react-ts-demo 中 <code>pages/ImmerDemo1.tsx</code></p>\n<h2 id=\"实战：List-页面使用-state\"><a href=\"#实战：List-页面使用-state\" class=\"headerlink\" title=\"实战：List 页面使用 state\"></a>实战：List 页面使用 state</h2><ul>\n<li>使用 state</li>\n<li>使用 immer<ul>\n<li>push</li>\n<li>修改 isPublish</li>\n</ul>\n</li>\n</ul>\n<p>代码参考 <code>pages/List2.tsx</code></p>\n<hr>\n<p>最重要的就是：不可变数据 —— 这是 React state 的核心</p>\n<h1 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h1><h2 id=\"副作用\"><a href=\"#副作用\" class=\"headerlink\" title=\"副作用\"></a>副作用</h2><p>函数组件：执行函数，返回 JSX</p>\n<ul>\n<li>初次渲染时</li>\n<li>state 更新时</li>\n</ul>\n<p>但有些场景需要如下功能</p>\n<ul>\n<li>当渲染完成时，做某些事情</li>\n<li>当某个 state 变化时，做某些事情</li>\n<li>如 ajax 加载数据（state 变化重新加载）</li>\n</ul>\n<p>如果只有 <code>执行函数，返回 JSX</code> 这个逻辑，无法满足上面的场景。</p>\n<p>所以需要 useEffect</p>\n<h2 id=\"组件渲染完成时\"><a href=\"#组件渲染完成时\" class=\"headerlink\" title=\"组件渲染完成时\"></a>组件渲染完成时</h2><p>代码演示：List2.tsx 使用 <code>useEffect</code> 模拟 ajax 请求</p>\n<h2 id=\"某些-state-更新时\"><a href=\"#某些-state-更新时\" class=\"headerlink\" title=\"某些 state 更新时\"></a>某些 state 更新时</h2><p>代码演示：QuestionCard 监听 <code>isPublished</code> 的更新</p>\n<h2 id=\"组件销毁时\"><a href=\"#组件销毁时\" class=\"headerlink\" title=\"组件销毁时\"></a>组件销毁时</h2><p>有创建就有销毁，有生就有死</p>\n<p>代码演示：增加 <code>isDeleted</code> 属性和 <code>delete</code> 事件，看 QuestionCard 组件的销毁</p>\n<p>【重要】如果有定时任务，或者 DOM 事件，组件销毁时一定要解绑</p>\n<h2 id=\"执行两次（销毁一次）\"><a href=\"#执行两次（销毁一次）\" class=\"headerlink\" title=\"执行两次（销毁一次）\"></a>执行两次（销毁一次）</h2><p>React18 开始，<code>useEffect</code> 在开发环境下执行两次 <br><br>模拟组件挂载、销毁、重新挂载的完整流程，及早发现后续的问题。如果只挂载一次，有可能卸载组件时有问题。<br><br>而且，实际项目中某些组件真的有可能会被挂载很多次（如重置 state），要及早模拟这种情况，避免出现重复挂载的问题（如弹窗重复、bindEvent 重复）</p>\n<p><strong>生产环境下，不会再执行两次</strong></p>\n<h1 id=\"其他-Hooks\"><a href=\"#其他-Hooks\" class=\"headerlink\" title=\"其他 Hooks\"></a>其他 Hooks</h1><h2 id=\"useRef-1\"><a href=\"#useRef-1\" class=\"headerlink\" title=\"useRef\"></a>useRef</h2><p>useRef是基于useState疯转而来，区别在于没有向外暴露设置响应性数据的函数，一般用于操作 DOM 元素，也可以用来持久化缓存数据</p>\n<p>PS：useRef 也可以传入 JS 值，但更新时不会触发 rerender ，需替换为 useState</p>\n<h2 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h2><ul>\n<li>函数组件，默认，每次 state 变化都会重新执行</li>\n<li>useMemo 可以缓存某个数据，不用每次都重新生成</li>\n<li>可用于计算量比较大的数据场景</li>\n</ul>\n<p>代码参考 pages&#x2F;UseMemoAndCallback&#x2F;UseMemoDemo1.tsx</p>\n<p>注意文档中的这段话 “你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。” <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlbWVtbw==\">https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo</span><br><br>即，useMemo 的控制权在 React ，不一定保证每个都会缓存，但都是为了全局的性能最佳。</p>\n<h2 id=\"useCallback\"><a href=\"#useCallback\" class=\"headerlink\" title=\"useCallback\"></a>useCallback</h2><p>useCallback 就是 useMemo 的语法糖，和 useMemo 一样。用于缓存函数。</p>\n<h1 id=\"自定义-Hooks\"><a href=\"#自定义-Hooks\" class=\"headerlink\" title=\"自定义 Hooks\"></a>自定义 Hooks</h1><p>已学习了几个常用的内置 Hooks ，可以用于很多业务功能。</p>\n<h2 id=\"修改网页标题\"><a href=\"#修改网页标题\" class=\"headerlink\" title=\"修改网页标题\"></a>修改网页标题</h2><ul>\n<li>第一步，直接在组件内部写</li>\n<li>第二步，可以抽离一个函数</li>\n<li>第三步，可以直接抽离一个文件 src&#x2F;hooks&#x2F;useTitle.ts ，引用使用</li>\n</ul>\n<p>抽离自定义 Hook ，可用于很多组件，<strong>复用代码</strong></p>\n<h2 id=\"获取鼠标位置\"><a href=\"#获取鼠标位置\" class=\"headerlink\" title=\"获取鼠标位置\"></a>获取鼠标位置</h2><p>（刚才的没有返回值，这次有返回值）</p>\n<p>代码演示 src&#x2F;hooks&#x2F;useMousePosition.ts （直接在 App.tsx 中使用）</p>\n<h2 id=\"异步获取信息\"><a href=\"#异步获取信息\" class=\"headerlink\" title=\"异步获取信息\"></a>异步获取信息</h2><p>（再来个异步的）</p>\n<p>代码演示 src&#x2F;hooks&#x2F;useGetInfo.ts （直接在 App.tsx 中使用）</p>\n<h2 id=\"小节\"><a href=\"#小节\" class=\"headerlink\" title=\"小节\"></a>小节</h2><p>自定义 Hooks 可以抽离公共逻辑，复用到多个组件中 —— 这是 Hooks 设计的初衷</p>\n<p>在 Hooks 和函数组件之前，class 组件也有一些方法：mixin HOC render-prop 等，但都没有 Hooks 来的简单。</p>\n<h1 id=\"第三方-Hooks\"><a href=\"#第三方-Hooks\" class=\"headerlink\" title=\"第三方 Hooks\"></a>第三方 Hooks</h1><p>回顾上一节的“三步”，其实还有第四步：抽离为单独的模块，发布到 npm ，供所有开发者使用。</p>\n<p>例如，之前开发的 useTitle useMousePosition ，就现成的</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9haG9va3MuanMub3JnL3poLUNOL2hvb2tzL3VzZS10aXRsZQ==\">https://ahooks.js.org/zh-CN/hooks/use-title</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9haG9va3MuanMub3JnL3poLUNOL2hvb2tzL3VzZS1tb3VzZQ==\">https://ahooks.js.org/zh-CN/hooks/use-mouse</span></li>\n</ul>\n<h2 id=\"ahooks\"><a href=\"#ahooks\" class=\"headerlink\" title=\"ahooks\"></a>ahooks</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9haG9va3MuanMub3JnL3poLUNOLw==\">https://ahooks.js.org/zh-CN/</span></p>\n<p>ahooks 是国内流行的第三方 Hooks 库</p>\n<ul>\n<li>功能全面</li>\n<li>使用简单</li>\n<li>文档 demo 清晰易懂</li>\n</ul>\n<p>后面会再次用到 ahooks ，到时候再代码演示</p>\n<h2 id=\"react-use\"><a href=\"#react-use\" class=\"headerlink\" title=\"react-use\"></a>react-use</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0cmVhbWljaC9yZWFjdC11c2U=\">https://github.com/streamich/react-use</span></p>\n<p>react-use 是国外比较流行的，功能也很前面，但是英文文档。<br><br>先做了解吧，项目中不会使用。</p>\n<h1 id=\"Hooks-使用规则\"><a href=\"#Hooks-使用规则\" class=\"headerlink\" title=\"Hooks 使用规则\"></a>Hooks 使用规则</h1><h2 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h2><p>Hook 必须 <code>useXxx</code> 格式来命名。</p>\n<p>PS：这种命名规则也很易读，简单粗暴</p>\n<h2 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h2><p>Hook 或自定义 Hook ，只能在两个地方被调用</p>\n<ul>\n<li>组件内部</li>\n<li>其他 Hook 内部</li>\n</ul>\n<p>组件外部，或一个普通函数中，不能调用 Hook</p>\n<h2 id=\"顺序一致\"><a href=\"#顺序一致\" class=\"headerlink\" title=\"顺序一致\"></a>顺序一致</h2><p>Hook 在每次渲染时都按照相同的顺序被调用。</p>\n<ul>\n<li>Hook 必须是组件“第一层代码”</li>\n<li>Hook 不可放在 if 等条件语句中 （ 或者前面有 return ，也算是条件 ）</li>\n<li>Hook 不可放在 for 等循环语句中</li>\n</ul>\n<p>代码演示</p>\n<h2 id=\"闭包陷阱\"><a href=\"#闭包陷阱\" class=\"headerlink\" title=\"闭包陷阱\"></a>闭包陷阱</h2><p>当<strong>异步函数</strong>中获取 state 时，可能不是最新的 state 值。</p>\n<p>解决方案：替换为 <code>useRef</code> —— <strong>但 ref 变化不会触发 rerender</strong> ，所以得结合 state 一起</p>\n<h1 id=\"普通-CSS\"><a href=\"#普通-CSS\" class=\"headerlink\" title=\"普通 CSS\"></a>普通 CSS</h1><h2 id=\"内联-style\"><a href=\"#内联-style\" class=\"headerlink\" title=\"内联 style\"></a>内联 style</h2><ul>\n<li>和 HTML style 一样，元素的内联样式</li>\n<li>必须是 JS 对象形式，不可以是字符串</li>\n<li>样式名称用驼峰式写法，如 <code>fontSize</code></li>\n</ul>\n<p>代码演示</p>\n<h2 id=\"className\"><a href=\"#className\" class=\"headerlink\" title=\"className\"></a>className</h2><ul>\n<li>和 HTML class 一样，设置 CSS 样式名</li>\n<li>和 JS <code>class</code> 重复，所以改名 <code>className</code></li>\n<li>可用 <code>clsx</code> 或 <code>classnames</code> 条件判断</li>\n</ul>\n<p>代码演示</p>\n<p>链接</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xhc3NuYW1lcw==\">https://www.npmjs.com/package/classnames</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xzeA==\">https://www.npmjs.com/package/clsx</span></li>\n</ul>\n<h2 id=\"尽量不用内联-style\"><a href=\"#尽量不用内联-style\" class=\"headerlink\" title=\"尽量不用内联 style\"></a>尽量不用内联 style</h2><ul>\n<li>内联 style 代码量多，性能差</li>\n<li>外链样式（用 className）代码复用，性能好</li>\n<li>这和 React 无关，在学 HTML CSS 时就知道</li>\n</ul>\n<h1 id=\"CSS-Module\"><a href=\"#CSS-Module\" class=\"headerlink\" title=\"CSS Module\"></a>CSS Module</h1><h2 id=\"普通-CSS-的问题\"><a href=\"#普通-CSS-的问题\" class=\"headerlink\" title=\"普通 CSS 的问题\"></a>普通 CSS 的问题</h2><ul>\n<li>React 使用组件化</li>\n<li>多个组件，对应多个 CSS</li>\n<li>多个 CSS 就会造成命名重复，不好管理</li>\n</ul>\n<h2 id=\"CSS-Module-1\"><a href=\"#CSS-Module-1\" class=\"headerlink\" title=\"CSS Module\"></a>CSS Module</h2><ul>\n<li>每个 CSS 都是一个独立的模块，命名 <code>xxx.module.css</code></li>\n<li>每个模块中的 className 都不一样</li>\n<li>CRA 原生支持 CSS Module</li>\n</ul>\n<p>代码演示，参考 <code>components/Button2.tsx</code></p>\n<h2 id=\"使用-Sass\"><a href=\"#使用-Sass\" class=\"headerlink\" title=\"使用 Sass\"></a>使用 Sass</h2><ul>\n<li>CSS 写法比较原始</li>\n<li>一般使用 Sass less 等预处理语言</li>\n<li>CRA 支持 Sass Module ，把后缀改为 <code>.scss</code> 即可</li>\n</ul>\n<h1 id=\"CSS-in-js\"><a href=\"#CSS-in-js\" class=\"headerlink\" title=\"CSS-in-js\"></a>CSS-in-js</h1><ul>\n<li>在 JS 中（组件代码中）写 CSS</li>\n<li>不用担心 CSS class 重名的问题</li>\n<li>CSS-in-js 是一个解决方案，并不是一个工具的名称</li>\n</ul>\n<p>PS：CSS-in-js 并不是内联 style （重要！！！），它会经过工具的编译处理，生成 CSS class 的形式。</p>\n<h2 id=\"Styled-components\"><a href=\"#Styled-components\" class=\"headerlink\" title=\"Styled-components\"></a>Styled-components</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHlsZWQtY29tcG9uZW50cy5jb20v\">https://styled-components.com/</span></p>\n<p>代码演示，参考 <code>components/Button3.tsx</code></p>\n<h2 id=\"Styled-jsx\"><a href=\"#Styled-jsx\" class=\"headerlink\" title=\"Styled-jsx\"></a>Styled-jsx</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zdHlsZWQtanN4I2dldHRpbmctc3RhcnRlZA==\">https://github.com/vercel/styled-jsx#getting-started</span></p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p>CSS-in-js 能更灵活的支持动态样式，直接在 JS 中完成计算和样式切换。这比 css-module 更好。</p>\n<p><strong># 使用 antd</strong></p>\n<p><strong>## 安装和使用</strong></p>\n<p>参考文档 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbnQuZGVzaWduL2RvY3MvcmVhY3QvdXNlLWluLXR5cGVzY3JpcHQtY24=\">https://ant.design/docs/react/use-in-typescript-cn</span></p>\n<p>测试 Button 组件</p>\n<p><strong>## antd 组件</strong></p>\n<p>根据官网 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbnQuZGVzaWduL2NvbXBvbmVudHMvb3ZlcnZpZXctY24v\">https://ant.design/components/overview-cn/</span> 浏览一遍 antd 所有的组件，有一个了解</p>\n<h1 id=\"Tailwind-CSS\"><a href=\"#Tailwind-CSS\" class=\"headerlink\" title=\"Tailwind CSS\"></a>Tailwind CSS</h1><p>特点：把常用的 CSS 样式都细分，自己自己随意搭配。</p>\n<p>例如</p>\n<ul>\n<li>字体大小 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGFpbHdpbmRjc3MuY24vZG9jcy9mb250LXNpemU=\">https://www.tailwindcss.cn/docs/font-size</span></li>\n<li>间距 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGFpbHdpbmRjc3MuY24vZG9jcy9wYWRkaW5n\">https://www.tailwindcss.cn/docs/padding</span></li>\n<li>宽度 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGFpbHdpbmRjc3MuY24vZG9jcy93aWR0aA==\">https://www.tailwindcss.cn/docs/width</span></li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"html\">&lt;h1 className=&quot;text-3xl font-bold underline&quot;&gt;\n    Use tailwind CSS\n&lt;/h1&gt;\n</code></pre>\n<p>安装参考文档 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGFpbHdpbmRjc3MuY24vZG9jcy9ndWlkZXMvY3JlYXRlLXJlYWN0LWFwcA==\">https://www.tailwindcss.cn/docs/guides/create-react-app</span></p>\n<h1 id=\"普通表单组件\"><a href=\"#普通表单组件\" class=\"headerlink\" title=\"普通表单组件\"></a>普通表单组件</h1><h2 id=\"input-组件\"><a href=\"#input-组件\" class=\"headerlink\" title=\"input 组件\"></a>input 组件</h2><pre><code class=\"tsx\">import React, &#123; FC, useState, ChangeEvent &#125; from &#39;react&#39;\n\nconst Demo: FC = () =&gt; &#123;\n  const [text, setText] = useState(&#39;&#39;)\n  function handleChange(event: ChangeEvent&lt;HTMLInputElement&gt;) &#123;\n    setText(event.target.value)\n  &#125;\n\n  return &lt;input onChange=&#123;handleChange&#125; value=&#123;text&#125; /&gt;\n&#125;\n</code></pre>\n<h2 id=\"受控组件-vs-非受控组件\"><a href=\"#受控组件-vs-非受控组件\" class=\"headerlink\" title=\"受控组件 vs 非受控组件\"></a>受控组件 vs 非受控组件</h2><p>受控组件</p>\n<ul>\n<li>元素的值同步到 state</li>\n<li>使用 <code>value</code> 属性</li>\n</ul>\n<p>非受控组件</p>\n<ul>\n<li>元素的值，不同步到 state</li>\n<li>使用 <code>defaultValue</code> 属性</li>\n</ul>\n<p>React 推荐使用受控组件。看似麻烦，其实让设计更简单。</p>\n<h1 id=\"表单校验\"><a href=\"#表单校验\" class=\"headerlink\" title=\"表单校验\"></a>表单校验</h1><h2 id=\"antd-Form-rules\"><a href=\"#antd-Form-rules\" class=\"headerlink\" title=\"antd Form rules\"></a>antd Form rules</h2><p>参考登录、注册页</p>\n<p>PS：选择使用 antd ，顺带了解一下两个其他的 Form 验证工具</p>\n<h2 id=\"react-hook-form\"><a href=\"#react-hook-form\" class=\"headerlink\" title=\"react-hook-form\"></a>react-hook-form</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tLw==\">https://react-hook-form.com/</span></p>\n<h2 id=\"formi\"><a href=\"#formi\" class=\"headerlink\" title=\"formi\"></a>formi</h2><p>React 官网推荐的f</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3JtaWsub3JnL2RvY3Mvb3ZlcnZpZXc=\">https://formik.org/docs/overview</span></p>\n<h1 id=\"mock-服务\"><a href=\"#mock-服务\" class=\"headerlink\" title=\"mock 服务\"></a>mock 服务</h1><h2 id=\"Mock-js\"><a href=\"#Mock-js\" class=\"headerlink\" title=\"Mock.js\"></a>Mock.js</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL21vY2tqcy5jb20v\">http://mockjs.com/</span></p>\n<ul>\n<li>前端引入 Mock.js</li>\n<li>定义路由</li>\n<li>Mock.js 劫持 ajax 请求</li>\n</ul>\n<p>代码演示</p>\n<ul>\n<li>安装 Mock.js 和 axios</li>\n<li>定义路由，参考 <code>_mock/index.ts</code></li>\n<li>App.js 测试 ajax</li>\n</ul>\n<pre><code class=\"ts\">import &#39;./_mock/index&#39;\nimport axios from &#39;axios&#39;\n\nuseEffect(() =&gt; &#123;\n    // fetch(&#39;/api/test&#39;)  // 不能用 fetch\n    //   .then(res =&gt; res.json())\n    //   .then(data =&gt; console.log(data))\n\n    axios.get(&#39;/api/test&#39;).then(res =&gt; console.log(&#39;res&#39;, res.data))\n  &#125;, [])\n</code></pre>\n<p>Mock.js 的强大之处：</p>\n<ul>\n<li>前端劫持 Ajax</li>\n<li>Random 的模拟能力</li>\n</ul>\n<p>注意</p>\n<ul>\n<li>Mock.js 只能劫持 XHR ，不能劫持 fetch ，所以不要用 fetch 请求。</li>\n<li>Mock.js 要在生产环境下去掉，否则上线会有问题 —— Mock.js 体积也很大</li>\n<li>结论：不建议直接在前端使用 Mock.js</li>\n</ul>\n<h2 id=\"nodejs-搭建-Mock-服务\"><a href=\"#nodejs-搭建-Mock-服务\" class=\"headerlink\" title=\"nodejs 搭建 Mock 服务\"></a>nodejs 搭建 Mock 服务</h2><p>代码参考 question-mock</p>\n<ul>\n<li>刻意延迟 1s ，模拟真实效果</li>\n<li>使用 Mock.js 的 <code>Random</code> 功能</li>\n<li>定义写 Mock 的格式，考虑扩展性</li>\n</ul>\n<p>前端修改 <code>devServer</code> ，参考 craco.config.js</p>\n<p>扩展 webpack 配置</p>\n<ul>\n<li>使用 craco <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RpbGFueC9jcmFjbw==\">https://github.com/dilanx/craco</span></li>\n<li>可参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGluZ2ppZS50ZWNoL2FydGljbGUvMjAyMS0wMS0wNC8yNw==\">https://www.lingjie.tech/article/2021-01-04/27</span></li>\n</ul>\n<h2 id=\"在线-Mock-平台\"><a href=\"#在线-Mock-平台\" class=\"headerlink\" title=\"在线 Mock 平台\"></a>在线 Mock 平台</h2><p>不稳定，可能不维护了。有数据泄漏风险（多人使用，难免会写敏感数据）</p>\n<ul>\n<li>fast-mock</li>\n<li>y-api</li>\n<li>swagger - 尽量不推荐用国外平台（可以用做工具，但别用作服务）</li>\n</ul>\n<h1 id=\"为何使用状态管理\"><a href=\"#为何使用状态管理\" class=\"headerlink\" title=\"为何使用状态管理\"></a>为何使用状态管理</h1><h2 id=\"状态提升\"><a href=\"#状态提升\" class=\"headerlink\" title=\"状态提升\"></a>状态提升</h2><ul>\n<li>一个复杂页面，要拆分 UI 组件</li>\n<li>但数据保存在顶级组件</li>\n<li>通过 props 传递到下级组件</li>\n</ul>\n<p>代码演示，参考 react-ts-demo 中 <code>pages/homePageDemo/demo3.tsx</code> —— 需要抽离 <code>&lt;form&gt;</code> 为单独的组件</p>\n<p>（画图表示）</p>\n<h2 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h2><p>但如果情况再复杂，例如问卷编辑器，光通过状态提升无法满足。需要状态管理 —— 数据放在一个集中的第三方。</p>\n<p>（画图表示）</p>\n<p>React 状态管理的方式</p>\n<ul>\n<li>自带的 Context useReducer</li>\n<li>Redux</li>\n<li>Mobx</li>\n</ul>\n<h1 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h1><p>介绍</p>\n<p>- 向下级组件，跨组件传递信息</p>\n<p>- 不用像 props 层层传递</p>\n<p>- 例如：切换语言、切换主题等</p>\n<p>Context 只适合统一设置、下发某些全局变量（语言，主题等），应用场景比较单一</p>\n<h1 id=\"useReducer\"><a href=\"#useReducer\" class=\"headerlink\" title=\"useReducer\"></a>useReducer</h1><h2 id=\"背景-1\"><a href=\"#背景-1\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>第一，是 <code>useState</code> 的代替方案。<br/><br>当数据简单时用 <code>useState</code> ，当数据结构较为复杂时，可以考虑用 <code>useReducer</code></p>\n<p>第二，参考了 redux （马上要学）的设计，一个简化了的 redux</p>\n<h2 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>简单 demo <code>pages/CountReducer.tsx</code></p>\n<p>todo list demo <code>pages/TodoReducer/index.tsx</code></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>state 或 store - 存储数据</li>\n<li>action - 动作，格式如 <code>&#123; type: &#39;xxx&#39;, ... &#125;</code></li>\n<li>reducer - 根据 action 生成新 state —— <strong>不可变数据</strong></li>\n<li>dispatch - 触发 action</li>\n</ul>\n<p>PS：在 React 环境下，永远不能忘记 <code>不可变数据</code></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>需结合 useContext 跨组件通讯</p>\n<p>另，state 和 dispatch 没有模块化，数据混在一起，也不适合复杂项目。</p>\n<p>但简单项目还是可以用的。</p>\n<h1 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h1><p>Redux 是 React 最出名的状态管理工具</p>\n<h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>redux 和 useReducer 的概念一样</p>\n<ul>\n<li>state 或 store - 存储数据</li>\n<li>action - 动作，格式如 <code>&#123; type: &#39;xxx&#39;, ... &#125;</code></li>\n<li>reducer - 根据 action 生成新 state —— <strong>不可变数据</strong></li>\n<li>dispatch - 触发 action</li>\n</ul>\n<p>但 redux 和 useReducer 有很多区别</p>\n<ul>\n<li>store 可拆分模块</li>\n<li>可通过 Hook 获取 state 和 dispatch</li>\n<li>开发者工具</li>\n</ul>\n<h2 id=\"代码演示-1\"><a href=\"#代码演示-1\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>代码参考 undo-redo-demo （忽略 undo redo 功能）。分两步：</p>\n<ul>\n<li>不使用 immer</li>\n<li>使用 immer</li>\n</ul>\n<h2 id=\"开发者工具\"><a href=\"#开发者工具\" class=\"headerlink\" title=\"开发者工具\"></a>开发者工具</h2><p>Chrome redux DevTools</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcmVkdXgtZGV2dG9vbHMvbG1oa3BtYmVrY3Bta25rbGlvZWliZmtwbW1maWJsamQ/aGw9emgtQ04=\">https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=zh-CN</span></p>\n<p>可以看到每一步 dispatch 的 state 变化，开发调试很方便</p>\n<h2 id=\"redux-单项数据流模型\"><a href=\"#redux-单项数据流模型\" class=\"headerlink\" title=\"redux 单项数据流模型\"></a>redux 单项数据流模型</h2><p>参考这里的动<img data-src=\"https://cn.redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow/\" alt=\"Image\"></p>\n<h1 id=\"Mobx-1\"><a href=\"#Mobx-1\" class=\"headerlink\" title=\"Mobx\"></a>Mobx</h1><p>Mobx 可以通过<strong>声明式</strong>的方式来修改数据。像 Vue 。<br><br>不像 React 和 redux 那样，需要用纯函数和不可变值。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>主旨 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC5tb2J4LmpzLm9yZy90aGUtZ2lzdC1vZi1tb2J4Lmh0bWw=\">https://zh.mobx.js.org/the-gist-of-mobx.html</span></p>\n<ul>\n<li>state 数据</li>\n<li>action 动作</li>\n<li>derivation 派生<ul>\n<li>computed</li>\n<li><code>observer</code> 监听变化，包裹的 React 组件</li>\n<li><code>autorun</code> 监听变化，像 watch</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码演示-2\"><a href=\"#代码演示-2\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>简单 demo - mobx-demo&#x2F;src&#x2F;BasicDemo</p>\n<p>todo-list demo - mobx-demo&#x2F;src&#x2F;TodoDemo2</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>Mobx 使用单项数据流 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC5tb2J4LmpzLm9yZy90aGUtZ2lzdC1vZi1tb2J4Lmh0bWwjJUU1JThFJTlGJUU1JTg4JTk5\">https://zh.mobx.js.org/the-gist-of-mobx.html#%E5%8E%9F%E5%88%99</span></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>v6 已经默认去掉了<strong>装饰器</strong>语法，为了大部分的兼容性 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2J4LmpzLm9yZy9pbnN0YWxsYXRpb24uaHRtbCNtb2J4LWFuZC1kZWNvcmF0b3Jz\">https://mobx.js.org/installation.html#mobx-and-decorators</span></p>\n<p>尽量使用 <code>computed</code><br><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2J4LmpzLm9yZy90aGUtZ2lzdC1vZi1tb2J4Lmh0bWw=\">https://mobx.js.org/the-gist-of-mobx.html</span><br>When starting with MobX, people tend to overuse reactions. The golden rule is, always use computed if you want to create a value based on the current state.</p>\n<p>computed 必须是纯函数。而 action 可以修改 state （如 arr.push）<br><br>computed 采用惰性求值，会缓存其输出，并且只有当其依赖的可观察对象被改变时才会重新计算。 它们在不被任何值观察时会被暂时停用。</p>\n<h1 id=\"Redux-管理用户信息\"><a href=\"#Redux-管理用户信息\" class=\"headerlink\" title=\"Redux 管理用户信息\"></a>Redux 管理用户信息</h1><h2 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h2><p>创建 src&#x2F;store&#x2F;store.ts 和 src&#x2F;store&#x2F;userReducer.ts</p>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><p>Logo 组件，根据 username 判断链接地址<br><br>新建 hooks&#x2F;useGetUserInfo.ts</p>\n<p>hooks&#x2F;useLoadUserData.ts</p>\n<ul>\n<li>使用 <code>loginReducer</code></li>\n<li>useSelect - 根据 username 判断是否已经登录</li>\n<li>UserInfo 组件，去掉 service ，改用 useGetUserInfo</li>\n</ul>\n<p>UserInfo 组件</p>\n<ul>\n<li>使用 <code>logoutReducer</code></li>\n<li>useSelect - 显示用户信息或“登录”</li>\n</ul>\n<p>新建 <code>hooks/useNavPage</code> 执行跳转逻辑，用于 MainLayout QuestionLayout</p>\n<h1 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"————————————–\"><a href=\"#————————————–\" class=\"headerlink\" title=\"————————————–\"></a>————————————–</h1><h1 id=\"功能开发\"><a href=\"#功能开发\" class=\"headerlink\" title=\"功能开发\"></a>功能开发</h1><h1 id=\"拖拽排序\"><a href=\"#拖拽排序\" class=\"headerlink\" title=\"拖拽排序\"></a>拖拽排序</h1><h1 id=\"拖拽排序-1\"><a href=\"#拖拽排序-1\" class=\"headerlink\" title=\"拖拽排序\"></a>拖拽排序</h1><p>拖拽排序是 Web 管理系统的常见功能，React 也有相应的第三方插件供我们选择。</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>分析常见的第三方插件，并且选择一个合适的。</p>\n<ul>\n<li>看 github star ，看 npm 下载量 —— （不一定最高，但要有一定的数量规模）</li>\n<li>看 github 代码更新，和 npm 发布更新</li>\n<li>看文档和 demo ，是否易读易懂 —— （当年，Vue 能在国内打开，文档占了很大功劳）</li>\n</ul>\n<h3 id=\"react-dnd\"><a href=\"#react-dnd\" class=\"headerlink\" title=\"react-dnd\"></a>react-dnd</h3><ul>\n<li>github star 多，代码更新及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQ=\">https://github.com/react-dnd/react-dnd</span></li>\n<li>npm 下载量大 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtZG5k\">https://www.npmjs.com/package/react-dnd</span></li>\n<li>但，文档不易懂，学习成本高 。如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9hYm91dA==\">首页</span> 的 demo ，代码就非常复杂，不易读</li>\n</ul>\n<p>PS：examples 太复杂 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvdHJlZS9tYWluL3BhY2thZ2VzL2V4YW1wbGVzL3NyYy8wNC1zb3J0YWJsZS9zaW1wbGU=\">https://github.com/react-dnd/react-dnd/tree/main/packages/examples/src/04-sortable/simple</span></p>\n<h3 id=\"react-beautiful-dnd\"><a href=\"#react-beautiful-dnd\" class=\"headerlink\" title=\"react-beautiful-dnd\"></a>react-beautiful-dnd</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5k\">https://github.com/atlassian/react-beautiful-dnd</span></p>\n<ul>\n<li>github star 多， 代码更新不频繁了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5k\">https://github.com/atlassian/react-beautiful-dnd</span></li>\n<li>npm 下载量高 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtYmVhdXRpZnVsLWRuZA==\">https://www.npmjs.com/package/react-beautiful-dnd</span></li>\n<li>文档比较好理解，可以直接在 github 上找到 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2Jsb2IvbWFzdGVyL2RvY3MvYWJvdXQvZXhhbXBsZXMubWQ=\">examples</span></li>\n</ul>\n<p>但，<strong>不支持 React18 严格模式</strong>（代码好久没更新了）<br><br>去掉 <code>&lt;React.StrictMode&gt;</code> 就好了。但这样就丢失了严格模式的好处 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3Mvc3RyaWN0LW1vZGUuaHRtbA==\">https://zh-hans.reactjs.org/docs/strict-mode.html</span></p>\n<p>有解决的 lib ，但 star 太少了，不可靠 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQ=\">https://github.com/hello-pangea/dnd</span></p>\n<p>PS：暂无精力更新，看 npm 首页的描述 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtYmVhdXRpZnVsLWRuZA==\">https://www.npmjs.com/package/react-beautiful-dnd</span></p>\n<h3 id=\"Sortablejs\"><a href=\"#Sortablejs\" class=\"headerlink\" title=\"Sortablejs\"></a>Sortablejs</h3><p>老牌的 js 排序 lib ，不依赖于 React 或 Vue 。</p>\n<p>官方提供的 React 版本的下载量还可以 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NvcnRhYmxlSlMvcmVhY3Qtc29ydGFibGVqcw==\">https://github.com/SortableJS/react-sortablejs</span></p>\n<p>但它有一个提示 <code>is not considered ready for production</code> ，不推荐用于生产环境</p>\n<h3 id=\"react-sortable-hoc\"><a href=\"#react-sortable-hoc\" class=\"headerlink\" title=\"react-sortable-hoc\"></a>react-sortable-hoc</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NsYXVkZXJpYy9yZWFjdC1zb3J0YWJsZS1ob2M=\">https://github.com/clauderic/react-sortable-hoc</span></p>\n<p>star 和下载量都不错，但已不再主动维护，推荐使用 <code>dnd-kit</code></p>\n<h3 id=\"dnd-kit\"><a href=\"#dnd-kit\" class=\"headerlink\" title=\"dnd-kit\"></a>dnd-kit</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRuZGtpdC5jb20vcHJlc2V0cy9zb3J0YWJsZQ==\">https://docs.dndkit.com/presets/sortable</span></p>\n<ul>\n<li>github star 数量还可以（不算高），代码更新及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NsYXVkZXJpYy9kbmQta2l0\">https://github.com/clauderic/dnd-kit</span></li>\n<li>npm 下载量还可以（不算高）<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGRuZC1raXQvY29yZQ==\">https://www.npmjs.com/package/@dnd-kit/core</span></li>\n<li>文档和 demo 通俗移动</li>\n</ul>\n<p>代码演示，参考 dnd-kit-and-sortablejs-demo</p>\n<h2 id=\"开发-1\"><a href=\"#开发-1\" class=\"headerlink\" title=\"开发\"></a>开发</h2><ul>\n<li>抽离组件 <code>SortableContainer</code> <code>SortableItem</code> —— 图层和画布都需要拖拽排序</li>\n<li>在画布和图层使用</li>\n</ul>\n<p>之前代码的改动</p>\n<ul>\n<li>App.css 增加 <code>div[role=&quot;button&quot;] &#123; outline: 0 &#125;</code></li>\n<li>键盘快捷键，修改 <code>isActiveElementValid</code> 函数内的逻辑</li>\n</ul>\n<p>工具栏：上移&#x2F;下移</p>\n<h1 id=\"撤销重做\"><a href=\"#撤销重做\" class=\"headerlink\" title=\"撤销重做\"></a>撤销重做</h1><h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p>（先介绍 stack）</p>\n<p>两个 stack ：undo-stack redo-stack</p>\n<ul>\n<li>输入：redo-stack 清空，undo-stack 入栈</li>\n<li>undo ：undo-stack 出栈，redo-stack 入栈</li>\n<li>redo ：redo-stack 出栈，undo-stack 入栈</li>\n</ul>\n<p>画图表示<br><br>代码演示</p>\n<h2 id=\"redux-撤销重做\"><a href=\"#redux-撤销重做\" class=\"headerlink\" title=\"redux 撤销重做\"></a>redux 撤销重做</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVkdXgtdW5kbw==\">https://www.npmjs.com/package/redux-undo</span></p>\n<p>代码演示，从之前的 redux todo-list demo 上进行</p>\n<ul>\n<li>store&#x2F;store.ts</li>\n<li>pages&#x2F;TodoList.ts</li>\n</ul>\n<h2 id=\"开发-2\"><a href=\"#开发-2\" class=\"headerlink\" title=\"开发\"></a>开发</h2><ul>\n<li>src&#x2F;store&#x2F;store.ts</li>\n<li>src&#x2F;hooks&#x2F;useGetComponentInfo.ts</li>\n<li>src&#x2F;pages&#x2F;question&#x2F;Edit&#x2F;EditToolbar.tsx</li>\n</ul>\n<p>PS：看 ctrl + z 等快捷键</p>\n<h1 id=\"Chat图表\"><a href=\"#Chat图表\" class=\"headerlink\" title=\"Chat图表\"></a>Chat图表</h1><h1 id=\"chart-lib-选型\"><a href=\"#chart-lib-选型\" class=\"headerlink\" title=\"chart lib 选型\"></a>chart lib 选型</h1><p>回顾一下技术选项的三个要点，在“拖拽排序”那一节</p>\n<h2 id=\"react-chartjs-2\"><a href=\"#react-chartjs-2\" class=\"headerlink\" title=\"react-chartjs-2\"></a>react-chartjs-2</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC1jaGFydGpzLTIuanMub3JnLw==\">https://react-chartjs-2.js.org/</span></p>\n<p>基于 chartjs （知名 charts lib）</p>\n<ul>\n<li>github star 还可以，代码更新及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlYWN0Y2hhcnRqcy9yZWFjdC1jaGFydGpzLTI=\">https://github.com/reactchartjs/react-chartjs-2</span></li>\n<li>npm 下载量大 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtY2hhcnRqcy0y\">https://www.npmjs.com/package/react-chartjs-2</span></li>\n<li>文档和 demo 简洁易懂 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC1jaGFydGpzLTIuanMub3JnL2V4YW1wbGVz\">https://react-chartjs-2.js.org/examples</span></li>\n</ul>\n<p>作为备选观察</p>\n<h2 id=\"recharts\"><a href=\"#recharts\" class=\"headerlink\" title=\"recharts\"></a>recharts</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWNoYXJ0cy5vcmcvemgtQ04v\">https://recharts.org/zh-CN/</span></p>\n<p>基于 D3</p>\n<ul>\n<li>github star 更多，代码更新及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlY2hhcnRzL3JlY2hhcnRz\">https://github.com/recharts/recharts</span></li>\n<li>npm 下载量大 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVjaGFydHM=\">https://www.npmjs.com/package/recharts</span></li>\n<li>文档和 demo 简洁易懂 <strong>有中文文档</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWNoYXJ0cy5vcmcvemgtQ04vZXhhbXBsZXM=\">https://recharts.org/zh-CN/examples</span></li>\n</ul>\n<h2 id=\"echarts-for-react\"><a href=\"#echarts-for-react\" class=\"headerlink\" title=\"echarts-for-react\"></a>echarts-for-react</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQuaHVzdC5jYy9lY2hhcnRzLWZvci1yZWFjdC8=\">https://git.hust.cc/echarts-for-react/</span></p>\n<p>基于百度 echarts</p>\n<ul>\n<li>github star 不太多，代码更新不太及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2h1c3RjYy9lY2hhcnRzLWZvci1yZWFjdA==\">https://github.com/hustcc/echarts-for-react</span></li>\n<li>npm 下载量也不太大 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWNoYXJ0cy1mb3ItcmVhY3Q=\">https://www.npmjs.com/package/echarts-for-react</span></li>\n<li>文档友好，中文文档</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>最终选择了 recharts</p>\n<h1 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"————————————–-1\"><a href=\"#————————————–-1\" class=\"headerlink\" title=\"————————————–\"></a>————————————–</h1><h1 id=\"React项目性能优化\"><a href=\"#React项目性能优化\" class=\"headerlink\" title=\"React项目性能优化\"></a>React项目性能优化</h1><h1 id=\"缓存数据-减少计算\"><a href=\"#缓存数据-减少计算\" class=\"headerlink\" title=\"缓存数据 减少计算\"></a>缓存数据 减少计算</h1><p>PS：React18 开发环境下，组件会渲染两次。生产环境则不会。</p>\n<h2 id=\"useState-传入函数\"><a href=\"#useState-传入函数\" class=\"headerlink\" title=\"useState 传入函数\"></a>useState 传入函数</h2><ul>\n<li>useState 传入初始化数据</li>\n<li>如传入函数，则只在组件渲染执行一次</li>\n<li>如果数据结构较复杂，可使用函数</li>\n</ul>\n<p>代码演示，参考 react-ts-demo 中 pages&#x2F;UseStateFnDemo.tsx</p>\n<h2 id=\"useMemo-缓存数据\"><a href=\"#useMemo-缓存数据\" class=\"headerlink\" title=\"useMemo 缓存数据\"></a>useMemo 缓存数据</h2><p>（之前讲过，再回顾一遍，不用代码演示了）</p>\n<ul>\n<li>函数组件，默认，每次 state 变化都会重新执行</li>\n<li>useMemo 可以缓存某个数据，不用每次都重新生成</li>\n<li>可用于计算量比较大的数据场景</li>\n</ul>\n<p>代码参考 pages&#x2F;UseMemoAndCallback&#x2F;UseMemoDemo1.tsx</p>\n<p>注意文档中的这段话 “你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。” <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlbWVtbw==\">https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo</span><br><br>即，useMemo 的控制权在 React ，不一定保证每个都会缓存，但都是为了全局的性能最佳。</p>\n<p>项目示例：统计页，链接和二维码的 Elem</p>\n<h2 id=\"useCallback-缓存函数\"><a href=\"#useCallback-缓存函数\" class=\"headerlink\" title=\"useCallback 缓存函数\"></a>useCallback 缓存函数</h2><p>（之前讲过，再回顾一遍，不用代码演示了）</p>\n<p>useCallback 就是 useMemo 的语法糖，和 useMemo 一样。用于缓存函数。</p>\n<p>代码参考 pages&#x2F;UseMemoAndCallback&#x2F;UseCallbackDemo1.tsx</p>\n<p>项目示例：新增组件</p>\n<h2 id=\"React-memo-缓存组件\"><a href=\"#React-memo-缓存组件\" class=\"headerlink\" title=\"React.memo 缓存组件\"></a>React.memo 缓存组件</h2><p>当 state 变化时，React 会默认渲染所有<strong>子组件</strong>，无论其 props 是否变化</p>\n<p>但如果想要控制子组件根据 props 变化来渲染，可以使用 <code>React.memo</code></p>\n<p>代码演示，可以在 pages&#x2F;homePageDemo&#x2F;Demo3.tsx <br><br>为 <code>List</code> 组件增加 <code>React.memo</code></p>\n<p>PS：注意和 <code>useMemo</code> 的区别，一开始容易搞混了</p>\n<h1 id=\"代码体积和拆分\"><a href=\"#代码体积和拆分\" class=\"headerlink\" title=\"代码体积和拆分\"></a>代码体积和拆分</h1><h2 id=\"代码体积分析\"><a href=\"#代码体积分析\" class=\"headerlink\" title=\"代码体积分析\"></a>代码体积分析</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcmVhdGUtcmVhY3QtYXBwLmRldi9kb2NzL2FuYWx5emluZy10aGUtYnVuZGxlLXNpemUv\">https://create-react-app.dev/docs/analyzing-the-bundle-size/</span></p>\n<pre><code class=\"shell\"># build 以后，可以直接运行结果 （看控制台提示）\nyarn global add serve\n# npm install serve -g\nserve -s build\n</code></pre>\n<p>发现 main.js 体积有 <code>1.5M</code> —— 首页加载就需要 <code>1.5M</code> ，有点大，需要拆分。</p>\n<p>分析内部发现比较大的体积来自于 antd recharts react-dom dnd-kit 等。<br><br>首先想到的：拆分页面，路由懒加载，把编辑页、统计页拆分开</p>\n<h2 id=\"路由懒加载\"><a href=\"#路由懒加载\" class=\"headerlink\" title=\"路由懒加载\"></a>路由懒加载</h2><p>代码参考 src&#x2F;router&#x2F;index.ts</p>\n<p>再进行代码体积分析，发现 main.js 减小到 <code>1.0M</code> 还是很大。<br><br>但至少编辑页面、统计页面的代码都移除了。</p>\n<p>分析结果中，发现一个不符合预期的现象：**<code>@dnd-kit</code> 是拖拽排序的，应该在编辑页，不应该在 main.js**<br><br>查代码发现，在 src&#x2F;store&#x2F;componentsReducer&#x2F;index.ts 中用到了 <code>@dnd-kit/sortable</code> ，而后者用依赖于 <code>@dnd-kit/core</code><br><br>这个是否要优化掉？（把相关代码移动到编辑页面的引用） —— <strong>不值得！！！</strong></p>\n<ul>\n<li>这部分代码只占用 50kb ，最后GZip 压缩以后大约 16kb ，体积不算大</li>\n<li>如果移动代码，将导致代码修改较多，而且可能破坏语义、可读性</li>\n<li>综合考虑成本和收益，这里保持不变</li>\n</ul>\n<p>继续：分析结果中，占比最大的是 antd 和 react-dom ，可以抽离公共代码。</p>\n<h2 id=\"抽离公共代码\"><a href=\"#抽离公共代码\" class=\"headerlink\" title=\"抽离公共代码\"></a>抽离公共代码</h2><p>PS：生成环境需要抽离。开发环境不需要抽离，否则影响打包速度。</p>\n<p>代码参考 craco.config.js ，注意两点</p>\n<ul>\n<li>必须是生成环境。开发环境不需要抽离，否则影响打包速度。</li>\n<li>设置 <code>chunks: &#39;all&#39;</code></li>\n</ul>\n<p>重新 build 以后，发现 main.js 只有 <code>35kb</code> ，react-dom antd vendors 都被拆分出去了。</p>\n<h2 id=\"合理使用缓存\"><a href=\"#合理使用缓存\" class=\"headerlink\" title=\"合理使用缓存\"></a>合理使用缓存</h2><p>运行 build 结果，发现首页依然要加载好几个 JS 文件： main.js react-dom antd vendors<br><br>它们体积的总和依然是 1M 左右，那和优化之前一样吗？ —— <strong>不一样</strong></p>\n<ul>\n<li>优化之前是一个文件，一旦有代码改动，文件变化，缓存失效</li>\n<li>优化之后拆分多个文件，代码改动只会导致 main.js 变化，其他文件都会缓存</li>\n<li>如果不频繁升级 npm 插件，其他 js 文件不会频繁变动</li>\n</ul>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>不用做优化，css 已经被分离为 main.css antd-chunk.css edit-page.css stat-page.css</p>\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>从一开始的 1.6M 到最后的 33KB ，效果明显。</p>\n<p>PS：浏览器和服务端一般都默认支持 Gzip 压缩，体积能压缩 1&#x2F;3 左右</p>\n<h1 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"————————————–-2\"><a href=\"#————————————–-2\" class=\"headerlink\" title=\"————————————–\"></a>————————————–</h1><h1 id=\"React项目单元测试\"><a href=\"#React项目单元测试\" class=\"headerlink\" title=\"React项目单元测试\"></a>React项目单元测试</h1><h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><p>对比</p>\n<ul>\n<li>单元测试 - 某个功能模块、函数、组件的测试 —— 开发人员</li>\n<li>系统测试 - 整个功能流程的测试 —— 专业测试人员</li>\n</ul>\n<h2 id=\"jest-入门\"><a href=\"#jest-入门\" class=\"headerlink\" title=\"jest 入门\"></a>jest 入门</h2><p>jest 是最流行的前端单元测试工具<br><br>可参考官网首页的 demo <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamVzdGpzLmNuL2RvY3MvZ2V0dGluZy1zdGFydGVk\">https://www.jestjs.cn/docs/getting-started</span></p>\n<p>react-ts-demo 代码演示</p>\n<ul>\n<li>CRA 直接安装了 jest ，可直接写</li>\n<li>utils&#x2F;math.ts 和 utils&#x2F;math.test.ts</li>\n<li>运行 <code>npm run test</code> （看 package.json <code>scripts</code>）</li>\n</ul>\n<p>测试代码文件的位置</p>\n<ul>\n<li>统一放在 <code>__tests__</code> 目录下</li>\n<li>和源文件放在一起，增加 <code>.test.ts</code> 后缀</li>\n<li>选择后者（1. 结合更密切，可读性好；2. 不容易忘，敦促及时写单元测试）</li>\n</ul>\n<p>小结</p>\n<ul>\n<li>test it 构建测试用例</li>\n<li>expect 断言 —— 很多，后面一一学习</li>\n<li>测试文件的位置</li>\n</ul>\n<h2 id=\"组件单元测试\"><a href=\"#组件单元测试\" class=\"headerlink\" title=\"组件单元测试\"></a>组件单元测试</h2><p>注意，不是所有前端代码都适合单元测试，一般只对一些核心的、功能封装独立的组件进行单元测试。</p>\n<ul>\n<li>QuestionInfo</li>\n<li>QuestionTitle</li>\n<li>QuestionParagraph</li>\n<li>QuestionInput</li>\n<li>QuestionTextarea</li>\n<li>QuestionRadio</li>\n<li>QuestionCheckbox</li>\n</ul>\n<h2 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h2><p>操作</p>\n<ul>\n<li><code>npm run test</code> 加入到 husky <code>.husky/pre-commit</code></li>\n<li>为 package.json <code>scripts</code> <code>test</code> <strong>增加 <code>--watchAll=false</code></strong> —— 重要！否则无法正常执行 commit</li>\n<li>每次 commit 会执行测试</li>\n</ul>\n<p>自动测试的价值</p>\n<ul>\n<li>每次 commit 都自动执行，测试失败，无法提交代码（不污染现有的代码）</li>\n<li>避免各种“不小心” “忘了” 的问题 —— 自动化，电脑忘不了</li>\n<li>要及时完善组件单元测试，新组件也要添加单元测试</li>\n</ul>\n<h1 id=\"storybook\"><a href=\"#storybook\" class=\"headerlink\" title=\"storybook\"></a>storybook</h1><p>组件<strong>可视化</strong>测试<br><br>或者，它可以被理解为一种文档或组件使用介绍，通过 storybook 就可以看到组件的 UI 结构、属性配置等。</p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdG9yeWJvb2suanMub3JnL2RvY3MvcmVhY3QvZ2V0LXN0YXJ0ZWQvaW5zdGFsbA==\">https://storybook.js.org/docs/react/get-started/install</span></p>\n<p>进入 react 目录，运行 <code>npx storybook init</code> ，添加 storybook<br><br>PS：期间会咨询是否使用 eslint 插件，选择否。因为我们已经自己定义好 eslint 规则了</p>\n<p>先执行 <code>npm run format</code> 和 <code>npm run lint</code> 统一代码格式（storybook 新增的组件，代码风格可能不一样）</p>\n<p>执行 <code>npm run storybook</code> 启动，可以看到现成的 demo</p>\n<p>最后，新建 <code>stories/examples</code> 文件夹，把示例都拖进来。否则太多太乱。</p>\n<h2 id=\"代码演示-3\"><a href=\"#代码演示-3\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>新建 <code>stories/question</code> 目录，在这里新建组件</p>\n<ul>\n<li>QuestionInfo.stories.tsx</li>\n<li>QuestionTitle.stories.tsx</li>\n<li>QuestionParagraph.stories.tsx</li>\n<li>QuestionInput.stories.tsx</li>\n</ul>\n","categories":["react"],"tags":["react"]},{"title":"JS中类型化数组typedArray","url":"/2023/12/11/typedArray/","content":"<p>#JS中类型化数组（typed array）<br>JavaScript 的类型化数组是一种特殊的数组，可以存储和操作固定类型的数据，如整数、浮点数、字节等。相比于普通的 JavaScript 数组，类型化数组有以下几个优点：</p>\n<p>更加高效：类型化数组在内存中是连续存储的，这意味着它们可以更快地被读取和写入。此外，它们还允许我们直接访问底层的二进制数据，而不需要进行类型转换或拷贝操作。<br>更加节省空间：由于类型化数组只能存储固定类型的数据，因此它们使用的内存空间可以更加紧凑。例如，使用 Int8Array 数组可以将每个元素压缩为 1 个字节，而使用普通的 JavaScript 数组则需要至少 8 个字节来存储一个数字。<br>更加易于处理二进制数据：类型化数组可以帮助我们更加方便地处理二进制数据，如音频、视频、图像等。这些数据通常以二进制格式存储，而类型化数组可以直接读取和操作这些数据，而不需要进行复杂的解析和转换操作。<br>总之，类型化数组可以带来更高效、更紧凑、更直接的二进制数据处理体验，是 JavaScript 中处理二进制数据时非常有用的工具。虽然普通的 JavaScript 数组也可以存储二进制数据，但它们没有类型化数组那样的高效和直接性。因此，在需要处理大量二进制数据时，使用类型化数组会更加合适。</p>\n<p>Int8Array:<br>①只能存储8位有符号整数（-128到127），②使用固定大小的内存来存储数据，每个元素占用一个字节（8位）③元素连续存储</p>\n<pre><code class=\"js\">// 以长度参数构造对象\nvar int8 = new Int8Array(2);\nint8[0] = 42;\nconsole.log(int8[0]); // 42\nconsole.log(int8.length); // 2\nconsole.log(int8.BYTES_PER_ELEMENT); // 数组所占用的字节数\n// 以数组构造对象\nvar arr = new Int8Array([21, 31]);\nconsole.log(arr[1]); // 31\n// 从另一数组构造对象\nvar x = new Int8Array([21, 31]);\nvar y = new Int8Array(x);\nconsole.log(y[0]); // 21\n// 从 ArrayBuffer 构造对象\nvar buffer = new ArrayBuffer(8);\nvar z = new Int8Array(buffer, 1, 4);\n</code></pre>\n<p>还有：Uint8Array等类型<br>forEach的回调函数中不传参数</p>\n<pre><code class=\"js\">const dfs = function(root)&#123;\n    console.log(root.val,&#39;还好&#39;);\n    root.children.forEach(dfs);//forEach回调不传参数，默认传的参数就是item项\n&#125;\n</code></pre>\n","categories":["JS"],"tags":["JS","typedArray"]},{"title":"vue原理","url":"/2023/11/02/vue%E5%8E%9F%E7%90%86/","content":"<h1 id=\"vue大致流程\"><a href=\"#vue大致流程\" class=\"headerlink\" title=\"vue大致流程\"></a>vue大致流程</h1><h2 id=\"一、响应式系统：\"><a href=\"#一、响应式系统：\" class=\"headerlink\" title=\"一、响应式系统：\"></a>一、响应式系统：</h2><h4 id=\"reactive：\"><a href=\"#reactive：\" class=\"headerlink\" title=\"reactive：\"></a>reactive：</h4><p>创建代理对象（用于收集依赖）</p>\n<p><img data-src=\"/images/vue1.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><strong>需要注意的是：当使用代理对象的this时，其this指向普通对象，导致的结果就是后续使用代理对象收集不到使用this指定的函数，解决方法是通过Reflect反射。</strong></p>\n<p>此时，就创建了代理对象，并将普通对象和代理对象存在map中，此时可以通过Proxy代理的拦截器收集依赖，但是视图中的赋值并不是响应性的（需要执行依赖）。</p>\n<h4 id=\"effect：\"><a href=\"#effect：\" class=\"headerlink\" title=\"effect：\"></a>effect：</h4><p><strong>副作用函数，用于触发依赖，更新视图</strong></p>\n<p>首先通过reactiveEffect类创建副作用实例：通过实例的run方法可以执行里面的函数</p>\n<p><img data-src=\"/images/vue2.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>通过track函数收集依赖。<strong>（在Proxy对象的getter中执行）</strong></p>\n<p><img data-src=\"/images/vue3.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>通过trigger函数触发依赖  <strong>（在Proxy对象的setter中执行）</strong></p>\n<p><img data-src=\"/images/vue4.png\" alt=\"/images/image-20240123164938769\"></p>\n<h4 id=\"ref函数：\"><a href=\"#ref函数：\" class=\"headerlink\" title=\"ref函数：\"></a>ref函数：</h4><p><img data-src=\"/images/vue5.png\" alt=\"/images/image-20240123164938769\"></p>\n<h4 id=\"computed函数：\"><a href=\"#computed函数：\" class=\"headerlink\" title=\"computed函数：\"></a>computed函数：</h4><p><img data-src=\"/images/vue7.png\" alt=\"/images/image-20240123164938769\"></p>\n<h3 id=\"scheduler调度器：\"><a href=\"#scheduler调度器：\" class=\"headerlink\" title=\"scheduler调度器：\"></a>scheduler调度器：</h3><p><img data-src=\"/images/vue8.png\" alt=\"/images/image-20240123164938769\"></p>\n<h3 id=\"watch函数：Z\"><a href=\"#watch函数：Z\" class=\"headerlink\" title=\"watch函数：Z\"></a>watch函数：Z</h3><p><img data-src=\"/images/vue9.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"二、运行时runtime：\"><a href=\"#二、运行时runtime：\" class=\"headerlink\" title=\"二、运行时runtime：\"></a>二、运行时runtime：</h2><h4 id=\"createVNode函数：\"><a href=\"#createVNode函数：\" class=\"headerlink\" title=\"createVNode函数：\"></a>createVNode函数：</h4><p><img data-src=\"/images/vue10.png\" alt=\"/images/image-20240123164938769\"></p>\n<h4 id=\"h函数：\"><a href=\"#h函数：\" class=\"headerlink\" title=\"h函数：\"></a>h函数：</h4><p><img data-src=\"/images/vue11.png\" alt=\"/images/image-20240123164938769\"></p>\n<h4 id=\"nodeOps对象：\"><a href=\"#nodeOps对象：\" class=\"headerlink\" title=\"nodeOps对象：\"></a>nodeOps对象：</h4><p>封装dom元素操作</p>\n<p><img data-src=\"/images/vue13.png\" alt=\"/images/image-20240123164938769\"></p>\n<h4 id=\"patchProp函数：\"><a href=\"#patchProp函数：\" class=\"headerlink\" title=\"patchProp函数：\"></a>patchProp函数：</h4><p>根据元素类型（class属性，style属性，事件，dom Properties和其他属性），进行不同的patch打补丁操作</p>\n<p><img data-src=\"/images/vue14.png\" alt=\"/images/image-20240123164938769\"></p>\n<h4 id=\"render函数：\"><a href=\"#render函数：\" class=\"headerlink\" title=\"render函数：\"></a>render函数：</h4><p><img data-src=\"/images/vue12.png\" alt=\"/images/image-20240123164938769\"></p>\n<h4 id=\"组件渲染：\"><a href=\"#组件渲染：\" class=\"headerlink\" title=\"组件渲染：\"></a>组件渲染：</h4><p><img data-src=\"/images/vue16.png\" alt=\"/images/image-20240123164938769\"></p>\n<h3 id=\"patch函数（diff算法）：\"><a href=\"#patch函数（diff算法）：\" class=\"headerlink\" title=\"patch函数（diff算法）：\"></a>patch函数（diff算法）：</h3><p><img data-src=\"/images/vue15.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"三、编译时compile：\"><a href=\"#三、编译时compile：\" class=\"headerlink\" title=\"三、编译时compile：\"></a>三、编译时compile：</h2><p>将template模板转为render函数。这个过程中共经历了三大步骤：1、解析（解析template模板，生成AST抽象语法树）；2、转化（转化AST，生成 JavaScript  AST）；3、生成（生成render函数）</p>\n<h4 id=\"baseParse函数：\"><a href=\"#baseParse函数：\" class=\"headerlink\" title=\"baseParse函数：\"></a>baseParse函数：</h4><p>baseParse函数<strong>根据template模板</strong>，通过有限自动状态机的概念解析得到<strong>tokens</strong>，然后通过扫描tokens最终得到<strong>AST</strong>（抽象语法树）。</p>\n<h4 id=\"transform函数\"><a href=\"#transform函数\" class=\"headerlink\" title=\"transform函数:\"></a>transform函数:</h4><p>transform函数将<strong>抽象语法树AST</strong>转化为<strong>JavaScript  AST</strong>（抽象语法树）。</p>\n<h4 id=\"generate函数：\"><a href=\"#generate函数：\" class=\"headerlink\" title=\"generate函数：\"></a>generate函数：</h4><p>根据<strong>JavaScript AST</strong>（抽象语法树）<strong>生成render函数</strong>。(render函数的本质是字符串，字符串的换行和空格需要进行处理)。</p>\n<h3 id=\"compile函数：\"><a href=\"#compile函数：\" class=\"headerlink\" title=\"compile函数：\"></a>compile函数：</h3><p>根据<strong>字符串render函数</strong>通过<strong>new Function(render)()</strong>  方法创建出renderFn函数（这里不用eval函数的原因是出于安全性考虑），改名为compile函数。</p>\n<h4 id=\"parseInterpolation函数：\"><a href=\"#parseInterpolation函数：\" class=\"headerlink\" title=\"parseInterpolation函数：\"></a>parseInterpolation函数：</h4><h6 id=\"（处理插值表达式）\"><a href=\"#（处理插值表达式）\" class=\"headerlink\" title=\"（处理插值表达式）\"></a>（处理插值表达式）</h6><p>找到 }}  的索引位置，拿到双大括号内部的字符串，通过trim方法去除空格拿  到变量，通过with语法改变作用域，bind语法绑定this指向从而使用这个变量。</p>\n<h4 id=\"parseAttributes函数：\"><a href=\"#parseAttributes函数：\" class=\"headerlink\" title=\"parseAttributes函数：\"></a>parseAttributes函数：</h4><h6 id=\"（处理props属性，v-指令等）\"><a href=\"#（处理props属性，v-指令等）\" class=\"headerlink\" title=\"（处理props属性，v-指令等）\"></a>（处理props属性，v-指令等）</h6><p>通过正则表达式判断是否是Vue指令，如果是指令，就返回指令对象，如果不是指令就返回普通属性的对象。然后通过nameSet函数拿到props属性。</p>\n<h4 id=\"createStructuralDirectiveTransform函数：\"><a href=\"#createStructuralDirectiveTransform函数：\" class=\"headerlink\" title=\"createStructuralDirectiveTransform函数：\"></a>createStructuralDirectiveTransform函数：</h4><h6 id=\"（统一处理指令）\"><a href=\"#（统一处理指令）\" class=\"headerlink\" title=\"（统一处理指令）\"></a>（统一处理指令）</h6><h4 id=\"transform指令系列函数：\"><a href=\"#transform指令系列函数：\" class=\"headerlink\" title=\"transform指令系列函数：\"></a>transform指令系列函数：</h4><h6 id=\"transformIf-v-if\"><a href=\"#transformIf-v-if\" class=\"headerlink\" title=\"transformIf(v-if)\"></a>transformIf(v-if)</h6><p>AST中添加对应属性，JavascriptAST中相应变动，在生成render函数时，通过v-if绑定的变量名，在render字符串中添加上三元表达式。</p>\n<h2 id=\"四、运行时-编译时合并\"><a href=\"#四、运行时-编译时合并\" class=\"headerlink\" title=\"四、运行时+编译时合并\"></a>四、运行时+编译时合并</h2><p>此时只能导入模块中的函数进行使用，尚未处理合并的逻辑：</p>\n<h3 id=\"1、render渲染\"><a href=\"#1、render渲染\" class=\"headerlink\" title=\"1、render渲染\"></a>1、render渲染</h3><pre><code class=\"js\">&lt;script setup&gt;\nconst &#123; createApp,h &#125; = Vue;\nconst App = &#123;\n    render()&#123;\n        return h(&#39;div&#39;,&#39;hello world&#39;);\n    &#125;\n&#125;\nconst app = createApp(App);\napp.mount(&#39;#app&#39;);\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"createApp函数：\"><a href=\"#createApp函数：\" class=\"headerlink\" title=\"createApp函数：\"></a>createApp函数：</h4><p>createApp函数调用createAppAPI函数，传入render函数拿到结果</p>\n<h6 id=\"createAppAPI函数\"><a href=\"#createAppAPI函数\" class=\"headerlink\" title=\"createAppAPI函数\"></a>createAppAPI函数</h6><p>接受render函数，返回createApp函数，createApp函数拿到rootComponent和rootProps作为参数，定义出app对象，声明出component属性、container属性和mount方法，mount方法拿rootContainer作为参数，通过createVNode函数，传入rootComponent和rootProps创建出vnode虚拟节点，然后调用render函数，传入vnode虚拟节点和rootContainer进行执行。最后返回这个app对象</p>\n<h4 id=\"mount函数：\"><a href=\"#mount函数：\" class=\"headerlink\" title=\"mount函数：\"></a>mount函数：</h4><p>为了兼容不同的平台（宿主环境），需要去进行不同的处理：</p>\n<p>mount函数接受参数（选择器字符串或者dom元素），通过nromalizeContainer函数获取到dom元素。mount方法将dom元素作为rootContainer，通过createVNode函数创建出vnode虚拟节点，然后调用render函数，传入vnode虚拟节点和rootContainer进行执行。</p>\n<h6 id=\"normalizeContainer函数：\"><a href=\"#normalizeContainer函数：\" class=\"headerlink\" title=\"normalizeContainer函数：\"></a>normalizeContainer函数：</h6><p>如果参数是选择器字符串，就通过querySelector选择出dom元素，并返回。</p>\n<h2 id=\"2、template模板渲染\"><a href=\"#2、template模板渲染\" class=\"headerlink\" title=\"2、template模板渲染\"></a>2、template模板渲染</h2><pre><code class=\"js\">&lt;script setup&gt;\nconst &#123; createApp,h &#125; = Vue;\nconst App = &#123;\n    template:`&lt;div&gt;hello world&lt;/div&gt;`\n&#125;\nconst app = createApp(App);\napp.mount(&#39;#app&#39;);\n&lt;/script&gt;\n</code></pre>\n<p>此时app中是template组件模板，erbushirender函数，所以需要将模板变为render函数。</p>\n<p>在finishComponentSetup函数中进行判断：如果当前存在compile编译器，并且component中不存在render函数，就利用compile函数生成render函数，赋值到component组件实例中去，最后赋值给：instance的render。 </p>\n<h1 id=\"Vue3更新优化\"><a href=\"#Vue3更新优化\" class=\"headerlink\" title=\"Vue3更新优化\"></a>Vue3更新优化</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjU0MDkyOTU0NDMxNjY4Mjg0\">https://juejin.cn/post/7254092954431668284</span></p>\n<h6 id=\"1、静态提升\"><a href=\"#1、静态提升\" class=\"headerlink\" title=\"1、静态提升\"></a>1、静态提升</h6><p>Vue3将  ：<strong>静态的模板</strong>（不存在变化的模板）提<strong>升并进行缓存</strong>，静态的<strong>类等样式进行缓存</strong>，这样不用每次都重新更新</p>\n<h6 id=\"2、预字符串化\"><a href=\"#2、预字符串化\" class=\"headerlink\" title=\"2、预字符串化\"></a>2、预字符串化</h6><p>将<strong>不会变化的静态数据转换为字符串</strong>，以减少运行时的计算和处理。</p>\n<h6 id=\"3、缓存事件处理函数\"><a href=\"#3、缓存事件处理函数\" class=\"headerlink\" title=\"3、缓存事件处理函数\"></a>3、缓存事件处理函数</h6><p>Vue3会将<strong>事件处理函数在编译阶段缓存起来</strong>，避免了重复创建的开销。</p>\n<h6 id=\"4、Block-Tree\"><a href=\"#4、Block-Tree\" class=\"headerlink\" title=\"4、Block Tree\"></a>4、Block Tree</h6><p>Vue3中的Block Tree会将<strong>条件渲染v-if</strong>和<strong>循环渲染v-for</strong>的内容封装为一个单独的Block，从而避免大量的VNode节点创建和销毁。</p>\n<p>此外，Vue3编译之后的模板会被拆分成多个块，每个块对应一个节点或一组节点，这些快可以被独立地更新和渲染，从而避免不必要的渲染操作。</p>\n<h6 id=\"5-、patchFlag\"><a href=\"#5-、patchFlag\" class=\"headerlink\" title=\"5 、patchFlag\"></a>5 、patchFlag</h6><p>Vue3中引入了PatchFlag地概念，会<strong>标记VNode中哪些部分发生了变化</strong>，从而<strong>只对变化的部分进行比较和更新</strong>。</p>\n","categories":["vue"],"tags":["源码","vue"]},{"title":"webpack笔记","url":"/2023/10/21/webpack/","content":"<h1 id=\"babel\"><a class=\"anchor\" href=\"#babel\">#</a> <a href=\"*https://babeljs.io/setup*\">babel</a></h1>\n<h6 id=\"1执行编译的命令\"><a class=\"anchor\" href=\"#1执行编译的命令\">#</a> 1 执行编译的命令</h6>\n<p>在 package.json 文件中添加执行 babel 的命令</p>\n<p>（在 scripts 中添加：&quot;build&quot;:&quot;babel src -d dist&quot;）</p>\n<ul>\n<li><code>babel src --out-dir dist*</code></li>\n</ul>\n<h6 id=\"2babel的配置文件\"><a class=\"anchor\" href=\"#2babel的配置文件\">#</a> 2.Babel 的配置文件</h6>\n<ul>\n<li>\n<p>安装配置文件   <code>npm install @babel/preset-env@7.11.0--save-dev</code></p>\n</li>\n<li>\n<p>创建配置文件.babelrc, 并配置</p>\n</li>\n</ul>\n<p><code>&#123;</code></p>\n<p><code>&quot;presets&quot;:[&quot;@babel/preset-env&quot;]*</code></p>\n<p><code>&#125;</code></p>\n<h6 id=\"3-npm-run-build进行打包\"><a class=\"anchor\" href=\"#3-npm-run-build进行打包\">#</a> 3 .npm run build 进行打包</h6>\n<h1 id=\"webpack\"><a class=\"anchor\" href=\"#webpack\">#</a> webpack</h1>\n<h2 id=\"1-webpack是什么\"><a class=\"anchor\" href=\"#1-webpack是什么\">#</a> 【1】 webpack 是什么</h2>\n<p><code>const &#123; webpack &#125; = require(&quot;webpack&quot;)</code></p>\n<p><em>webpack 是静态模块打包器，当 webpack 处理应用程序时，会将所有这些模块打包成一个或多个文件</em></p>\n<p>处理  js  css  图片  图标字体  静态文件</p>\n<h2 id=\"2使用webpack\"><a class=\"anchor\" href=\"#2使用webpack\">#</a> 【2】使用 webpack</h2>\n<p>1  初始化项目    <code>npm init</code></p>\n<p>2  安装 webpack 需要的包</p>\n<p><code>npm install --save-dev webpack-cli@3.3.12 webpack@4.44.1</code></p>\n<p>3  配置 webpack (创建 webpack.config.js)</p>\n<p>创建配置信息 (官网查找)</p>\n<p>4  package.json 的 script 中配置 webpack 命令</p>\n<p><code>&quot;webpack&quot;: &quot;webpack --config webpack.config.js&quot;</code></p>\n<p>5  npm run webpack</p>\n<h2 id=\"3output-和-entrywebpackconfigjs中配置\"><a class=\"anchor\" href=\"#3output-和-entrywebpackconfigjs中配置\">#</a> 【3】output 和 entry (webpack.config.js 中配置)</h2>\n<p>1  entry 指定入口文件</p>\n<p>entry 中配置多个入口文件 :</p>\n<p><code>entry: &#123;</code></p>\n<p><code>main: './src/index.js'</code> ,</p>\n<p><code>search: './src/search.js</code></p>\n<p><code>&#125;</code></p>\n<p>2  output 中配置多个出口文件</p>\n<p>单个出口:</p>\n<p><code>output: &#123;</code></p>\n<p><code>path: path.resolve(__dirname, 'dist'),  //出口文件夹路径</code></p>\n<p><code>filename: 'bundle.js'   //出口文件名称</code></p>\n<p><code>&#125;</code></p>\n<p><em>// 注意如果配置了多个入口，但是只配置了一个出口，会报错</em></p>\n<p><em>// 此时采用动态输出名指定输出文件：使用 [name] 指定动态输出文件</em></p>\n<p><code>output: &#123;</code></p>\n<p><code>path: path.resolve(__dirname, 'dist'),</code></p>\n<p><code>filename: '[name].js'</code></p>\n<p><code>&#125;</code></p>\n<h2 id=\"4loader-将webpack和其他工具进行联通\"><a class=\"anchor\" href=\"#4loader-将webpack和其他工具进行联通\">#</a> 【4】loader （ 将 webpack 和其他工具进行联通 ）</h2>\n<p>1  什么是 loader (加载器，webpack 本身是用来打包 js , 要想打包 css 图片等静态资源和模块，必须要使用 loader)</p>\n<p>2  babel-loader (webpack 中使用 babel , 先用 babel 将 ES6 代码转成 ES5 的代码，然后再交给 webpack 进行打包)</p>\n<p>(1) 安装:</p>\n<p><code>npm install--save - dev babel - loader@8.1.0 @babel/core@7.11.0 @babel/preset - env@7.11.0</code></p>\n<p>(2)  创建 babel 配置文件</p>\n<p>.babelrc 文件，并且配置</p>\n<p><code>&#123;</code></p>\n<p><code>&quot;presets&quot;:[&quot;@babel/preset-env&quot;]*</code></p>\n<p><code>&#125;</code></p>\n<p>(3)  配置 loader  再 webpack.config.js 中，再原有的基础之上</p>\n<p><code>module: &#123;</code></p>\n<p><code>配置多个loader规则</code></p>\n<p><code>rules: &#123;</code></p>\n<p><code>//匹配需要处理的文件类型</code></p>\n<p><code>test: /\\.js$/,</code></p>\n<p><code>//排除不需要打包的的文件类型(node modules</code></p>\n<p><code>exclude:/node_modules/,</code></p>\n<p><code>// 联通webpack和babel ,处理文件</code></p>\n<p><code>loader: 'babel-loader'</code></p>\n<p><code>&#125;</code></p>\n<p><code>&#125;</code></p>\n<p>(4)  但是这样也只是转义了语法，ES6 代码中的一些新的 API 无法转成 ES5，此时需要引入模块，然后使用 API</p>\n<p><em>// 这也就是 babel/polyfill 的作用</em></p>\n<h2 id=\"6-使用babelpolyfill-core-js\"><a class=\"anchor\" href=\"#6-使用babelpolyfill-core-js\">#</a> 【6】 使用 babel/polyfill （ core-js ）</h2>\n<p>(1)  安装</p>\n<p>npm install --save-dev core-js@3.6.5</p>\n<p>(2)  在需要处理的 js 文件中引入 core-js 稳定版</p>\n<p><code>import 'core-js/stable'  (在要处理的js文件中引入)</code></p>\n<p>（3）npm run webpack 进行打包处理</p>\n<h2 id=\"7plugins\"><a class=\"anchor\" href=\"#7plugins\">#</a> 【7】plugins</h2>\n<p>1  plugins 介绍，插件，loader 被用于转成某些类型的模块，而插件则可以用于执行范围更广的任务</p>\n<p>需要什么功能就使用对应功能的插件</p>\n<p>2  举例应用：html-webpack-plugin 插件</p>\n<p>html 中需要在 html 中手动添加 js 文件 ， 此插件可以直接将 js 的引入嵌入 html 文件中</p>\n<p>(1) 安装</p>\n<p><code>npm install --save-dev html-webpack-plugin@4.3.0</code></p>\n<p>(2) 配置 html-webpack-plugin 插件 （在 webpack.config.js 中引入）</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> HtmlWebpackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'html-webpack-plugin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> <span class=\"token string\">'development'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 单入口</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// index: './src/index.js'</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 多入口</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/index.js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token literal-property property\">search</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/search.js'</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'dist'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'[name].js'</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\">// 单入口</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">// new HtmlWebpackPlugin(&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">//   template: './index.html'</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token comment\">// &#125;)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token comment\">// 多入口</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">HtmlWebpackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>      <span class=\"token literal-property property\">template</span><span class=\"token operator\">:</span> <span class=\"token string\">'./index.html'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>      <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'index.html'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>      <span class=\"token literal-property property\">chunks</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'index'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>      <span class=\"token literal-property property\">minify</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token literal-property property\">removeComments</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token literal-property property\">collapseWhitespace</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token literal-property property\">removeAttributeQuotes</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">HtmlWebpackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>      <span class=\"token literal-property property\">template</span><span class=\"token operator\">:</span> <span class=\"token string\">'./search.html'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>      <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'search.html'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>      <span class=\"token literal-property property\">chunks</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'search'</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>  <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"8webpack处理css文件-可以在js中引入css文件-webpack将css文件当成模块\"><a class=\"anchor\" href=\"#8webpack处理css文件-可以在js中引入css文件-webpack将css文件当成模块\">#</a> 【8】webpack 处理 css 文件 （可以在 js 中引入 css 文件 ，webpack 将 css 文件当成模块）</h2>\n<h4 id=\"一-css-loader\"><a class=\"anchor\" href=\"#一-css-loader\">#</a> 一  css-loader</h4>\n<p><em>//1  js 中  import '/src/index.css'</em></p>\n<p><em>// 2  安装 css-loader</em></p>\n<p><em>//  npm install --save-dev css-loader@4.1.1</em></p>\n<p><em>// 3  webpack.config.js 中配置 module</em></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.css$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'css-loader'</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><em>// 此时 css-loader 帮助 webpack 认识了 css 文件，然后引入，但是不会生效 (因为没有 style 标签)</em></p>\n<p><em>// 此时还需要一个 style-loader</em></p>\n<h4 id=\"二-style-loader\"><a class=\"anchor\" href=\"#二-style-loader\">#</a> 二  style-loader</h4>\n<p><em>// (1)  安装</em></p>\n<p><code>npm install --save-dev style-loader@1.2.1</code></p>\n<p><em>// (2)  配置 style-loader（webpack.config.js 中）</em></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.css$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      <span class=\"token comment\">//  loader:'css-loader'</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'style-loader'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'css-loader'</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\">// 注意会从右向左的顺序执行</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><em>// 三  如果不想直接使用 css 文件，而是想要用 link 标签引入外部 css 文件，需要用到一个插件</em></p>\n<p>mini-css-extract-plugin</p>\n<p><em>// (1) 安装</em></p>\n<p><code>npm install --save-dev mini-css-extract-plugin@0.9.0</code></p>\n<p><em>// （2）在 webpack.config.js 中导入</em></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> MiniCssExtractPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mini-css-extract-plugin'</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><em>// （3）在 webpakc.config.js 中配置（ rules 中 use 和 plugins）</em></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// webpack.config.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> HtmlWebpackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'html-webpack-plugin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">const</span> MiniCssExtractPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mini-css-extract-plugin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> <span class=\"token string\">'development'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/index.js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'js/[name].js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'dist'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.css$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token comment\">// loader: 'css-loader'</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'MiniCssExtractPlugin.loader'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'css-loader'</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\">// 注意会从右向左的顺序执行</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>  <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">HtmlWebpackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>      <span class=\"token literal-property property\">template</span><span class=\"token operator\">:</span> <span class=\"token string\">'./index.html'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>      <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'index.html'</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">MiniCssExtractPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>      <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'css/[name].css'</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>  <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"9使用loader处理图片问题\"><a class=\"anchor\" href=\"#9使用loader处理图片问题\">#</a> 【9】使用 loader 处理图片问题</h2>\n<h3 id=\"四-使用file-loader处理css文件中的图片\"><a class=\"anchor\" href=\"#四-使用file-loader处理css文件中的图片\">#</a> 四  使用 file-loader 处理 CSS 文件中的图片</h3>\n<p><em>//webpack 只能处理内部的资源，外部的远程图片不用考虑 webpack</em></p>\n<p><em>//webpack 不认识 png 等格式结尾的文件，此时就需要使用 file-loader</em></p>\n<p><em>// (1)  安装 file-loader：</em></p>\n<p><code>npm install --save-dev file-loader@6.0.0</code></p>\n<p><em>// (2)  在 webpack.config.js 的 rules 中配置 file-loader</em></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// webpack.config.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> MiniCssExtractPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mini-css-extract-plugin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> <span class=\"token string\">'development'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/index.js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'js/[name].js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'dist'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>      <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.css$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>          <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> MiniCssExtractPlugin<span class=\"token punctuation\">.</span>loader<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>              <span class=\"token literal-property property\">publicPath</span><span class=\"token operator\">:</span> <span class=\"token string\">'../'</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>          <span class=\"token string\">'css-loader'</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>      <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.(jpg|png|gif)$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>          <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'file-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>          <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'img/[name].[ext]'</span> <span class=\"token comment\">// 指定图片名称</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>  <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">MiniCssExtractPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>      <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'css/[name].css'</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>  <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><em>// （注意 file-loader 处理的图片会放到新的目录，此时需要和 minicss 插件配合使用）</em></p>\n<h3 id=\"五-使用html-withimg-loader处理html图片-处理html中使用的图片\"><a class=\"anchor\" href=\"#五-使用html-withimg-loader处理html图片-处理html中使用的图片\">#</a> 五  使用 html-withimg-loader 处理 HTML 图片  （处理 html 中使用的图片）</h3>\n<p><em>// （1）安装</em></p>\n<p><code>npm install --save-dev html-withimg-loader@0.1.16</code></p>\n<p><em>// （2）webpack.config.js 的 module 的 rules 中配置文件</em></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.(html|html)$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 待处理文件</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'html-withimg-loader'</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><em>// （3）npm run webpack 进行打包</em></p>\n<p><em>// 但是注意他与 file-loader 的配合使用，过程中会将图片当成模块，解决方法在 module 中 rules 中配置</em></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// webpack.config.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> MiniCssExtractPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mini-css-extract-plugin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> <span class=\"token string\">'development'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/index.js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'js/[name].js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'dist'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.css$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>          <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> MiniCssExtractPlugin<span class=\"token punctuation\">.</span>loader<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>          <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token literal-property property\">publicPath</span><span class=\"token operator\">:</span> <span class=\"token string\">'../'</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token string\">'css-loader'</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>      <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>      <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.(jpg|png|gif)$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>      <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'file-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>          <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'img/[name].[ext]'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>          <span class=\"token literal-property property\">esModule</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token comment\">// 不将 html 中引入的图片当成模块处理</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>  <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">MiniCssExtractPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>      <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'css/[name].css'</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>  <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"六-使用file-loader处理js图片\"><a class=\"anchor\" href=\"#六-使用file-loader处理js图片\">#</a> 六  使用 file-loader 处理 js 图片</h3>\n<p>将 js 中引入的图片的地址更换成打包后的图片的地址<br />\n在 webpack.config.js 的 module 中的 rules 中进行配置</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// webpack.config.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> MiniCssExtractPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mini-css-extract-plugin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> <span class=\"token string\">'development'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/index.js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'js/[name].js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'dist'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      <span class=\"token comment\">// 匹配图片文件</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.(jpg|png|gif)$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>      <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token comment\">// 使用 file-loader 处理</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'file-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>          <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'img/[name].[ext]'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 指定输出文件的名称和路径</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>          <span class=\"token literal-property property\">esModule</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token comment\">// 不将 html 中引入的图片当成模块处理</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>  <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token keyword\">new</span> <span class=\"token class-name\">MiniCssExtractPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>      <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'css/[name].css'</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>  <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"七-使用url-loader处理图片\"><a class=\"anchor\" href=\"#七-使用url-loader处理图片\">#</a> 七  使用 url-loader 处理图片</h3>\n<p>（ file-loader 的功能过于单一 ，url 功能更加全面，但其底层是由 file-loader 来封装的，配置时，只需要配置 url-loader 即可）</p>\n<p>（1）安装 url-loader</p>\n<p><code>npm install --save-dev url-loader@4.1.0</code></p>\n<p>（2）配置 url-loader</p>\n<p>webpack 中的 module 中的 rules 下进行配置</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.(jpg|png|gif)$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'url-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'img/[name].[ext]'</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 设置文件夹名称和文件名称</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      <span class=\"token literal-property property\">esModule</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 设置其引入不是一个路径</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>      <span class=\"token literal-property property\">limit</span><span class=\"token operator\">:</span> <span class=\"token number\">3000</span>   <span class=\"token comment\">// 将 3kb 以内的图片转成 base64 格式，存到 js 中</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>使用 url-loader 的前提时要引入 file-loader（url-loader 是由 file-loader 封装而来）</p>\n<h3 id=\"八-使用webpack-dev-server搭建开发环境\"><a class=\"anchor\" href=\"#八-使用webpack-dev-server搭建开发环境\">#</a> 八  使用 webpack-dev-server 搭建开发环境</h3>\n<p>比如：自动打包（打包热启动），当修改文件内容时，自动进行打包处理（打包之后的文件不会生成在磁盘中，而是存在内存里）</p>\n<p>（1）安装：</p>\n<p><code>npm install --save-dev webpack-dev-server@3.11.0</code></p>\n<p>(2) 配置命令（在 package.json 的 scripts 中配置）</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token string-property property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token string-property property\">\"test\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 测试命令</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token string-property property\">\"webpack\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"webpack\"</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 运行 webpack 命令</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token string-property property\">\"dev\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"webpack-dev-server\"</span>   <span class=\"token comment\">// 运行 webpack-dev-server 命令</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">// \"dev\": \"webpack-dev-server --open chrome\"  // 重新打包，并且打包之后自动开启 Chrome 浏览器</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h1 id=\"webpack配置示例\"><a class=\"anchor\" href=\"#webpack配置示例\">#</a> webpack 配置示例</h1>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> MiniCssExtractPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mini-css-extract-plugin\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> CssMinimizerWebpackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"css-minimizer-webpack-plugin\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> CopyWebpackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"copy-webpack-plugin\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> EslintWebpackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"eslint-webpack-plugin\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">const</span> HtmlWebpackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"html-webpack-plugin\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span>VueLoaderPlugin<span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"vue-loader\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"path\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span>DefinePlugin<span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"webpack\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">const</span> TerserWebpackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"terser-webpack-plugin\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getStyleLoaders</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">pre</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token comment\">// 针对 vue 项目</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        isProdcution <span class=\"token operator\">?</span> MiniCssExtractPlugin<span class=\"token punctuation\">.</span>loader <span class=\"token operator\">:</span> <span class=\"token string\">\"vue-style-loader\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token string\">'css-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token comment\">// 处理 css 兼容性</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token comment\">// 配合 package.json 之中的 browserslist 来指定兼容性做到什么程度</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'postcss-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token literal-property property\">postcssOptions</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                    <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'postcss-preset-env'</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        pre <span class=\"token operator\">&amp;&amp;</span> pre <span class=\"token operator\">===</span> <span class=\"token string\">\"sass-loader\"</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">\"sass-loader\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token literal-property property\">additionalData</span><span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">@use \"@/styles/element/index.scss\" as *;</span><span class=\"token template-punctuation string\">`</span></span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">:</span> pre <span class=\"token operator\">===</span> <span class=\"token string\">\"less-loader\"</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'less-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                <span class=\"token literal-property property\">lessOptions</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                    <span class=\"token literal-property property\">modifyVars</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                        <span class=\"token string-property property\">'primary-color'</span><span class=\"token operator\">:</span> <span class=\"token string\">'#1DA57A'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                        <span class=\"token string-property property\">'link-color'</span><span class=\"token operator\">:</span> <span class=\"token string\">'#1DA57A'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                        <span class=\"token string-property property\">'border-radius-base'</span><span class=\"token operator\">:</span> <span class=\"token string\">'2px'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                    <span class=\"token literal-property property\">javascriptEnabled</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">:</span> pre</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>Boolean<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token keyword\">const</span> isProdcution <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"production\"</span> <span class=\"token operator\">?</span> <span class=\"token boolean\">true</span> <span class=\"token operator\">:</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token keyword\">let</span> cdn <span class=\"token operator\">=</span> isProdcution <span class=\"token operator\">?</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token comment\">// css: [\"https://cdn.jsdelivr.net/npm/element-plus/dist/index.css\"],</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token literal-property property\">css</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token string\">\"https://cdn.jsdelivr.net/npm/ant-design-vue@3.2.20/dist/antd.min.css\"</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token literal-property property\">js</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token string\">\"https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.min.js\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token string\">'https://cdnjs.cloudflare.com/ajax/libs/vue-router/4.2.2/vue-router.global.prod.min.js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token string\">\"https://cdn.jsdelivr.net/npm/ant-design-vue@3.2.20/dist/antd.min.js\"</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token comment\">// \"https://cdn.jsdelivr.net/npm/element-plus\"</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>    <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/main.js'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>        <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">\"static/js/[name].js\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>        <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> isProdcution <span class=\"token operator\">?</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"../dist\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>        <span class=\"token literal-property property\">chunkFilename</span><span class=\"token operator\">:</span> <span class=\"token string\">\"static/js/[name].[hash:10].chunk.js\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        <span class=\"token literal-property property\">assetModuleFilename</span><span class=\"token operator\">:</span> <span class=\"token string\">\"static/assets/[hash:10][ext]\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>        <span class=\"token literal-property property\">clean</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>    <span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>            <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>                <span class=\"token literal-property property\">oneOf</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>                    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>                        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.css$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>                        <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token function\">getStyleLoaders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>                    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>                        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.less$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>                        <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token function\">getStyleLoaders</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"less-loader\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>                    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>                        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.s[ac]ss$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>                        <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token function\">getStyleLoaders</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sass-loader\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>                    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>                        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.styl$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>                        <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token function\">getStyleLoaders</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"stylus-loader\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>                    <span class=\"token comment\">// 处理图片</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>                    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>                        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.(jpe?g|png|gif|webp)$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>                        <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'asset'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>                        <span class=\"token literal-property property\">parser</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>                            <span class=\"token literal-property property\">dataUrlCondition</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>                                <span class=\"token literal-property property\">maxSize</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token operator\">*</span><span class=\"token number\">1024</span> <span class=\"token comment\">// 小于 10kb</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre>                            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre>                        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre>                    <span class=\"token comment\">// 处理其他字体资源</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>                    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre>                        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.(woff2?|ttf)$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre>                        <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'asset/resource'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"102\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre>                <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre>            <span class=\"token comment\">// 处理 js  eslint babel</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre>            <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre>                <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.js$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"108\"></td><td><pre>                <span class=\"token literal-property property\">include</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"../src\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>                <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">\"babel-loader\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"110\"></td><td><pre>                <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"111\"></td><td><pre>                    <span class=\"token comment\">// 开启缓存</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre>                    <span class=\"token literal-property property\">cacheDirectory</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre>                    <span class=\"token comment\">// 缓存不需要压缩</span></pre></td></tr><tr><td data-num=\"114\"></td><td><pre>                    <span class=\"token literal-property property\">cacheCompression</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"116\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"117\"></td><td><pre>            <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"118\"></td><td><pre>                <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.svg$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"119\"></td><td><pre>                <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'asset'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"120\"></td><td><pre>                <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'svgo-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"121\"></td><td><pre>                <span class=\"token literal-property property\">exclude</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'../src/icons'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"122\"></td><td><pre>                <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"123\"></td><td><pre>                    <span class=\"token literal-property property\">multipass</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"124\"></td><td><pre>                    <span class=\"token literal-property property\">js2svg</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"125\"></td><td><pre>                        <span class=\"token literal-property property\">indent</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"126\"></td><td><pre>                        <span class=\"token literal-property property\">pretty</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"127\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"128\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"129\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"130\"></td><td><pre>            <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"131\"></td><td><pre>                <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.svg$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"132\"></td><td><pre>                <span class=\"token literal-property property\">include</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'../src/icons'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"133\"></td><td><pre>                <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"134\"></td><td><pre>                    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"135\"></td><td><pre>                        <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">'svg-sprite-loader'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"136\"></td><td><pre>                        <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"137\"></td><td><pre>                            <span class=\"token literal-property property\">symbolId</span><span class=\"token operator\">:</span> <span class=\"token string\">'icon_[name]'</span></pre></td></tr><tr><td data-num=\"138\"></td><td><pre>                        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"139\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"140\"></td><td><pre>                <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"141\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"142\"></td><td><pre>            <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"143\"></td><td><pre>                <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.vue$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"144\"></td><td><pre>                <span class=\"token literal-property property\">loader</span><span class=\"token operator\">:</span> <span class=\"token string\">\"vue-loader\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"145\"></td><td><pre>                <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"146\"></td><td><pre>                    <span class=\"token literal-property property\">cacheDirectory</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"../node_modules/.cache/vue-loader\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"147\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"148\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"149\"></td><td><pre>        <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"150\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"151\"></td><td><pre>    <span class=\"token literal-property property\">resolve</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"152\"></td><td><pre>        <span class=\"token literal-property property\">extensions</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\".vue\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\".js\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\".json\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"153\"></td><td><pre>        <span class=\"token literal-property property\">alias</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"154\"></td><td><pre>            <span class=\"token string-property property\">'@'</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'../src'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"155\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"156\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"157\"></td><td><pre>    <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"158\"></td><td><pre>        <span class=\"token keyword\">new</span> <span class=\"token class-name\">EslintWebpackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"159\"></td><td><pre>            <span class=\"token literal-property property\">context</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"../src\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"160\"></td><td><pre>            <span class=\"token literal-property property\">exclude</span><span class=\"token operator\">:</span> <span class=\"token string\">\"node_modules\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"161\"></td><td><pre>            <span class=\"token literal-property property\">cache</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"162\"></td><td><pre>            <span class=\"token literal-property property\">cacheLocation</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"../node_modules/.cache/.eslintcache\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"163\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"164\"></td><td><pre>        <span class=\"token keyword\">new</span> <span class=\"token class-name\">HtmlWebpackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"165\"></td><td><pre>            <span class=\"token literal-property property\">template</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"../public/index.html\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"166\"></td><td><pre>            <span class=\"token literal-property property\">cdnTag</span><span class=\"token operator\">:</span> cdn</pre></td></tr><tr><td data-num=\"167\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"168\"></td><td><pre>        <span class=\"token keyword\">new</span> <span class=\"token class-name\">VueLoaderPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"169\"></td><td><pre>        <span class=\"token comment\">// 定义环境变量 cross-env 定义的环境变量是给打包工具使用的</span></pre></td></tr><tr><td data-num=\"170\"></td><td><pre>        <span class=\"token comment\">// DefinePlugin 是给源代码使用的，解决 vue3 的警告问题</span></pre></td></tr><tr><td data-num=\"171\"></td><td><pre>        <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefinePlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"172\"></td><td><pre>            <span class=\"token literal-property property\">__VUE_OPTIONS_API__</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"173\"></td><td><pre>            <span class=\"token literal-property property\">__VUE_PROD_DEVTOOLS__</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"174\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"175\"></td><td><pre>        isProdcution <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MiniCssExtractPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"176\"></td><td><pre>            <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">\"static/css/[name].[contenthash:10].css\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"177\"></td><td><pre>            <span class=\"token literal-property property\">chunkFilename</span><span class=\"token operator\">:</span> <span class=\"token string\">\"static/css/[name].[contenthash:10].chunk.css\"</span></pre></td></tr><tr><td data-num=\"178\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"179\"></td><td><pre>        isProdcution <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CopyWebpackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"180\"></td><td><pre>            <span class=\"token literal-property property\">patterns</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"181\"></td><td><pre>                <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"182\"></td><td><pre>                    <span class=\"token literal-property property\">from</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"../public\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"183\"></td><td><pre>                    <span class=\"token literal-property property\">to</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"../dist\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"184\"></td><td><pre>                    <span class=\"token literal-property property\">globOptions</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"185\"></td><td><pre>                        <span class=\"token comment\">// 忽律 index.html 文件</span></pre></td></tr><tr><td data-num=\"186\"></td><td><pre>                        <span class=\"token literal-property property\">ignore</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"**/index.html\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"187\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"188\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"189\"></td><td><pre>            <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"190\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"191\"></td><td><pre>    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>Boolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"192\"></td><td><pre>    <span class=\"token literal-property property\">optimization</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"193\"></td><td><pre>        <span class=\"token literal-property property\">splitChunks</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"194\"></td><td><pre>            <span class=\"token literal-property property\">chunks</span><span class=\"token operator\">:</span> <span class=\"token string\">'all'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"195\"></td><td><pre>            <span class=\"token literal-property property\">cacheGroups</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"196\"></td><td><pre>                <span class=\"token literal-property property\">vue</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"197\"></td><td><pre>                    <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[\\\\/]node_modules[\\\\/]vue(.*)?[\\\\/]</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"198\"></td><td><pre>                    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"vue-chunk\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"199\"></td><td><pre>                    <span class=\"token literal-property property\">priority</span><span class=\"token operator\">:</span> <span class=\"token number\">30</span></pre></td></tr><tr><td data-num=\"200\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"201\"></td><td><pre>                <span class=\"token string-property property\">\"ant-design-vue\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"202\"></td><td><pre>                    <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[\\\\/]node_modules[\\\\/]ant-design-vue(.*)?[\\\\/]</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"203\"></td><td><pre>                    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ant-design-vue-chunk\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"204\"></td><td><pre>                    <span class=\"token literal-property property\">priority</span><span class=\"token operator\">:</span> <span class=\"token number\">20</span></pre></td></tr><tr><td data-num=\"205\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"206\"></td><td><pre>                <span class=\"token comment\">// elementPlus: &#123;</span></pre></td></tr><tr><td data-num=\"207\"></td><td><pre>                <span class=\"token comment\">//     test: /[\\\\/]node_modules[\\\\/]element-plus(.*)?[\\\\/]/,</span></pre></td></tr><tr><td data-num=\"208\"></td><td><pre>                <span class=\"token comment\">//     name: \"elementPlus-chunk\",</span></pre></td></tr><tr><td data-num=\"209\"></td><td><pre>                <span class=\"token comment\">//     priority: 20</span></pre></td></tr><tr><td data-num=\"210\"></td><td><pre>                <span class=\"token comment\">// &#125;,</span></pre></td></tr><tr><td data-num=\"211\"></td><td><pre>                <span class=\"token literal-property property\">libs</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"212\"></td><td><pre>                    <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[\\\\/]node_modules[\\\\/]</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"213\"></td><td><pre>                    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"libs-chunk\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"214\"></td><td><pre>                    <span class=\"token literal-property property\">priority</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"215\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"216\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"217\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"218\"></td><td><pre>        <span class=\"token comment\">// 代码分割会导致缓存失效，因为每次都需要重新引入，名字就会发生变化</span></pre></td></tr><tr><td data-num=\"219\"></td><td><pre>        <span class=\"token literal-property property\">runtimeChunk</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"220\"></td><td><pre>            <span class=\"token function-variable function\">name</span><span class=\"token operator\">:</span> <span class=\"token parameter\">entrypoint</span> <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">runtime-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$&#123;</span>entrypoint<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">&#125;</span></span><span class=\"token string\">.js</span><span class=\"token template-punctuation string\">`</span></span></pre></td></tr><tr><td data-num=\"221\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"222\"></td><td><pre>        <span class=\"token literal-property property\">minimize</span><span class=\"token operator\">:</span> isProdcution<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"223\"></td><td><pre>        <span class=\"token literal-property property\">minimizer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"224\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">CssMinimizerWebpackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"225\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">TerserWebpackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"226\"></td><td><pre>        <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"227\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"228\"></td><td><pre>    <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> isProdcution <span class=\"token operator\">?</span> <span class=\"token string\">\"production\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"development\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"229\"></td><td><pre>    <span class=\"token literal-property property\">performance</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"230\"></td><td><pre>    <span class=\"token literal-property property\">devtool</span><span class=\"token operator\">:</span> isProdcution <span class=\"token operator\">?</span> <span class=\"token string\">\"source-map\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"cheap-module-source-map\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"231\"></td><td><pre>    <span class=\"token literal-property property\">devServer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"232\"></td><td><pre>        <span class=\"token literal-property property\">host</span><span class=\"token operator\">:</span> <span class=\"token string\">'localhost'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"233\"></td><td><pre>        <span class=\"token literal-property property\">port</span><span class=\"token operator\">:</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"234\"></td><td><pre>        <span class=\"token literal-property property\">open</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"235\"></td><td><pre>        <span class=\"token literal-property property\">hot</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"236\"></td><td><pre>        <span class=\"token comment\">// 解决 html5 history 刷新 404 的问题</span></pre></td></tr><tr><td data-num=\"237\"></td><td><pre>        <span class=\"token literal-property property\">historyApiFallback</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"238\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"239\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n<h1 id=\"实现miniwebpack\"><a class=\"anchor\" href=\"#实现miniwebpack\">#</a> 实现 miniwebpack</h1>\n<h3 id=\"前置知识\"><a class=\"anchor\" href=\"#前置知识\">#</a> 前置知识</h3>\n<p>我们都知道 webpack 是基于 babel 进行语法转换的，因此我们需要提前了解一些 babel 的使用方法：</p>\n<ul>\n<li>@babel/parser 模块：用于将 js 代码转为抽象语法树</li>\n<li>@babel/traverse 模块：用于遍历和操作抽象语法树（处理导入的模块）</li>\n<li>@babel/core 模块：babel 的核心模块，用于将抽象语法树转换为代码信息对象（包含重要的 code 属性，表示转换后生成的代码）</li>\n<li>@babel/preset-env 模块：babel 中的一个预设，可以在 babel.transformFromAst 中第三个参数中 presets 字段传入，可以根据当前环境将代码转成相应的兼容版本。</li>\n</ul>\n<h3 id=\"流程图\"><a class=\"anchor\" href=\"#流程图\">#</a> 流程图</h3>\n<p><img data-src=\"/images/Snipaste_2024-05-07_07-23-59.jpg\" alt=\"miniwebpack\" /></p>\n<h3 id=\"开始编码\"><a class=\"anchor\" href=\"#开始编码\">#</a> 开始编码</h3>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"path\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// @babel/parser 用于将 js 代码转化为抽象语法树</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> parser <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@babel/parser\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// @babel/traverse 用于遍历和操作抽象语法树</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">const</span> traverse <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@babel/traverse\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>default<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// Babel 的核心功能包含在 @babel/core 模块中</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">const</span> babel <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@babel/core\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 1. 分析依赖</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">parseModules</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">file</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token keyword\">const</span> entry <span class=\"token operator\">=</span> <span class=\"token function\">getModuleInfo</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token keyword\">const</span> temp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>entry<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token keyword\">const</span> depsGraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token function\">getDeps</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">,</span> entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  temp<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">moduleInfo</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 遍历全部模块信息数组</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    depsGraph<span class=\"token punctuation\">[</span>moduleInfo<span class=\"token punctuation\">.</span>file<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 映射 file 路径和 code、deps</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      <span class=\"token literal-property property\">deps</span><span class=\"token operator\">:</span> moduleInfo<span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>      <span class=\"token literal-property property\">code</span><span class=\"token operator\">:</span> moduleInfo<span class=\"token punctuation\">.</span>code<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token keyword\">return</span> depsGraph<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">getDeps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">temp<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span>deps<span class=\"token punctuation\">&#125;</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">key</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> <span class=\"token function\">getModuleInfo</span><span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    temp<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token function\">getDeps</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">getModuleInfo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">file</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>  <span class=\"token comment\">// 读取文件</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>  <span class=\"token keyword\">const</span> body <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">,</span> <span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>  <span class=\"token comment\">// 转化为 AST</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>  <span class=\"token keyword\">const</span> ast <span class=\"token operator\">=</span> parser<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>body<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token literal-property property\">sourceType</span><span class=\"token operator\">:</span> <span class=\"token string\">\"module\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>  <span class=\"token keyword\">const</span> deps <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>  <span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token comment\">// 获取 import 导入的模块</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token function\">ImportDeclaration</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">&#123;</span>node<span class=\"token punctuation\">&#125;</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>      <span class=\"token keyword\">const</span> dirname <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">dirname</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>      <span class=\"token comment\">// 获取标准化路径</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>      <span class=\"token keyword\">const</span> absPath <span class=\"token operator\">=</span> <span class=\"token string\">\"./\"</span> <span class=\"token operator\">+</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>dirname<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>      deps<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> absPath<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span>code<span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> babel<span class=\"token punctuation\">.</span><span class=\"token function\">transformFromAst</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token comment\">// 使用预设</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token literal-property property\">presets</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"@babel/preset-env\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>  <span class=\"token keyword\">const</span> moduleInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>file<span class=\"token punctuation\">,</span> deps<span class=\"token punctuation\">,</span> code<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>  <span class=\"token keyword\">return</span> moduleInfo<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre><span class=\"token comment\">// 2. 实现 bundle</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">bundle</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">file</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>  <span class=\"token comment\">// 将模块转为引用路径和映射 code、deps 的对象</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>  <span class=\"token keyword\">const</span> depsGraph <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token function\">parseModules</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">(function (graph) &#123;</pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    function require(file) &#123;</pre></td></tr><tr><td data-num=\"58\"></td><td><pre>      function absRequire(realPath) &#123;</pre></td></tr><tr><td data-num=\"59\"></td><td><pre>        return require(graph[file].deps[realPath]);  //递归调用获取返回值</pre></td></tr><tr><td data-num=\"60\"></td><td><pre>      &#125;</pre></td></tr><tr><td data-num=\"61\"></td><td><pre>      var exports = &#123;&#125;;   //exports对象，用于存储模块的返回值信息</pre></td></tr><tr><td data-num=\"62\"></td><td><pre>      (function (require, exports, code) &#123;</pre></td></tr><tr><td data-num=\"63\"></td><td><pre>        eval(code);   //eval函数用于执行字符串的js代码，传入require，exports和code</pre></td></tr><tr><td data-num=\"64\"></td><td><pre>      &#125;)(absRequire, exports, graph[file].code);</pre></td></tr><tr><td data-num=\"65\"></td><td><pre>      return exports;</pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    &#125;</pre></td></tr><tr><td data-num=\"67\"></td><td><pre>    require('</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$&#123;</span>file<span class=\"token interpolation-punctuation punctuation\">&#125;</span></span><span class=\"token string\">');</pre></td></tr><tr><td data-num=\"68\"></td><td><pre>  &#125;)(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$&#123;</span>depsGraph<span class=\"token interpolation-punctuation punctuation\">&#125;</span></span><span class=\"token string\">);</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre><span class=\"token keyword\">const</span> content <span class=\"token operator\">=</span> <span class=\"token function\">bundle</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./src/index.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre><span class=\"token comment\">// 将内容写入到输出文件 </span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./dist/bundle.js\"</span><span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre><span class=\"token comment\">//webpack 打包后的 js 文件就是一个立即执行函数，传入的参数是一个对象，对象的键是模块路径，值是模块函数代码</span></pre></td></tr></table></figure>","categories":["webpack"],"tags":["webpack","前端工程化"]},{"title":"vue3源码中的位运算","url":"/2023/09/02/vue3%E6%BA%90%E7%A0%81%E4%BD%8D%E8%BF%90%E7%AE%97/","content":"<p>vue3中通过位运算进行类型判断<br>性能提高，可读性减小：</p>\n<p>快速判断：位运算是底层的二进制操作，比起其他逻辑运算符，如逻辑与 &amp;&amp;、逻辑或 ||，位运算更加高效。在某些场景下，使用位运算可以对多个类型进行快速判断，避免了复杂的条件判断和函数调用。<br>位运算的特性：位运算的特性使得它可以用较少的存储空间表示和处理多个状态或标志位。通过将多个类型的判断压缩到一个整数中，可以节省内存空间，并且减少了不必要的变量声明和赋值操作，从而提升了性能。</p>\n","categories":["vue"],"tags":["vue","位运算"]},{"title":"webWorker","url":"/2024/01/11/webworker/","content":"<p>#引言<br>首先我们知道JS中是没有并行,并发等概念的,这是因为JS是一门单线程的语言,其中的异步执行也是利用事件循环机制进行的,并不是严格意义上的异步.由于JS单线程的特性,使得JS在执行时如果遇到大量的任务就会使得过程运行缓慢.主渲染线程的延迟明显,使得用户体验较差.</p>\n<p>#web-worker<br>web-worker的作用就是用来缓解这一问题的</p>\n<p>利用web-worker,我们可以利用浏览器新开辟一个进程,将需要大量执行的过程在这个进程中执行,然后将结果返回给我们的主进程即可.</p>\n<p>#使用示例<br>#worker.html<br><!DOCTYPE html></p>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .p{\n      line-break: unset;\n    }\n  </style>\n  <a id=\"link\"></a>\n    <p class=\"p\">\n      <%= sjdfl =%>\n    </p>\n</head>\n<body>\n  <script>\n    const \\u4e2d\\u6587 = '这是转义之后的字符';\n// 使用webworker,分担主线程的压力\n// const worker = new Worker()\n//创建一个worker\nconst worker = new Worker('./worker.js')\n    console.log(worker);\nworker.postMessage('sdfj');\nworker.postMessage({method:'echo',argus:[1,2,3,4]})\n//主线程关闭worker\nsetTimeout(()=>{\nworker.terminate()\n// worker.postMessage('close')\n},1000)\nworker.addEventListener('message',(e)=>{\n  console.log(e.data);\n})\n/**\n * 主线程监听worker错误\n */\nworker.onerror=(e)=>{\n  worker.terminate()\n  console.error('worker错误');\n}\n/**\n * 直接转移数据的控制权\n */\n// 创建4字节的缓冲区\nlet abfer = new ArrayBuffer(4);\n// 创建32位整数数组作为视图，引用缓冲区\nlet tes = new Int32Array(abfer);\nconsole.log(tes,'ArrayBuffer');\nworker.postMessage(abfer,[abfer]); //转交控制权，主线程不再存储\n/**\n * 模拟文件下载功能\n */\nconst blob = new Blob(['文件下载']);\nconst link = document.getElementById('link');\nlink.href = window.URL.createObjectURL(blob);;\nlink.download = '测试文件.txt';\nsetTimeout(()=>{\n  // link.click();\n},2000)\n/**\n * 创建worker线程加载js文件\n * ！！必须指定script标签的type为浏览器不知道的类型\n */\n// const blob1 = new Blob(document.getElementById('scriptDom').textContent);\n// const url1 = new window.URL.createObjectURL(blob1);\n// const worker2 = new Worker(url1);\n/**\n * 使用worker线程，完成轮询\n */\n//创建worker\nfunction createWorker(f){\n  const fnBlob = new Blob(['('+f.toString()+')()'])\n  const fnUrl = window.URL.createObjectURL(fnBlob);\n  return new Worker(fnUrl);\n}\nconst fnWorker = createWorker((e)=>{\n  let cache;\n  // setInterval(()=>{\n    fetch('/data').then(res=>{\n      if(cache != res){\n        console.log('变化了');\n      }\n    })\n  // },1000)\n});\n  </script>\n<script id=\"scriptDom\" type=\"app/worker\">\n  console.log('我是被woeker加载的文件');\n</script>\n</body>\n</html>\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .p{\n      line-break: unset;\n    }\n  </style>\n  <a id=\"link\"></a>\n    <p class=\"p\">\n      <%= sjdfl =%>\n    </p>\n</head>\n<body>\n  <script>\n    const \\u4e2d\\u6587 = '这是转义之后的字符';\n// 使用webworker,分担主线程的压力\n// const worker = new Worker()\n//创建一个worker\nconst worker = new Worker('./worker.js')\n    console.log(worker);\nworker.postMessage('sdfj');\nworker.postMessage({method:'echo',argus:[1,2,3,4]})\n//主线程关闭worker\nsetTimeout(()=>{\nworker.terminate()\n// worker.postMessage('close')\n},1000)\nworker.addEventListener('message',(e)=>{\n  console.log(e.data);\n})\n/**\n * 主线程监听worker错误\n */\nworker.onerror=(e)=>{\n  worker.terminate()\n  console.error('worker错误');\n}\n/**\n * 直接转移数据的控制权\n */\n// 创建4字节的缓冲区\nlet abfer = new ArrayBuffer(4);\n// 创建32位整数数组作为视图，引用缓冲区\nlet tes = new Int32Array(abfer);\nconsole.log(tes,'ArrayBuffer');\nworker.postMessage(abfer,[abfer]); //转交控制权，主线程不再存储\n/**\n * 模拟文件下载功能\n */\nconst blob = new Blob(['文件下载']);\nconst link = document.getElementById('link');\nlink.href = window.URL.createObjectURL(blob);;\nlink.download = '测试文件.txt';\nsetTimeout(()=>{\n  // link.click();\n},2000)\n/**\n * 创建worker线程加载js文件\n * ！！必须指定script标签的type为浏览器不知道的类型\n */\n// const blob1 = new Blob(document.getElementById('scriptDom').textContent);\n// const url1 = new window.URL.createObjectURL(blob1);\n// const worker2 = new Worker(url1);\n/**\n * 使用worker线程，完成轮询\n */\n//创建worker\nfunction createWorker(f){\n  const fnBlob = new Blob(['('+f.toString()+')()'])\n  const fnUrl = window.URL.createObjectURL(fnBlob);\n  return new Worker(fnUrl);\n}\nconst fnWorker = createWorker((e)=>{\n  let cache;\n  // setInterval(()=>{\n    fetch('/data').then(res=>{\n      if(cache != res){\n        console.log('变化了');\n      }\n    })\n  // },1000)\n});\n  </script>\n<script id=\"scriptDom\" type=\"app/worker\">\n  console.log('我是被woeker加载的文件');\n</script>\n</body>\n</html>\n```\n\n<p>#worker.js</p>\n<pre><code class=\"js\">//接受数据\nconsole.log(self);\nself.addEventListener(&#39;message&#39;,(e)=&gt;&#123;\n    console.log(e.data);\n    self.postMessage(&#39;我接受到了你的消息&#39;)\n    if(e.data === &#39;close&#39;)&#123;\n        self.postMessage(&#39;听你的我关闭&#39;);\n        self.close();\n    &#125;\n&#125;,false)\n// self.addEventListener(&#39;close&#39;,(e)=&gt;&#123;\n//     console.log(&#39;关闭&#39;);\n// &#125;)\n/**\n * worker内部加载脚本\n * 只能加载，不能获取其中内容\n */\nimportScripts(&#39;./main.js&#39;);\n</code></pre>\n<p>#serviceWorker.js</p>\n<pre><code class=\"js\">//serviceWorker是基于事件驱动的。\n//serviceWorker安装事件\nself.addEventListener(&#39;install&#39;,event=&gt;&#123;\n    console.log(event,&#39;安装事件&#39;);\n    event.waitUntil(()=&gt;&#123;\n        console.info(&#39;安装完成&#39;);\n    &#125;)\n&#125;)\n//serviceWorker激活事件（当安装完成之后就开始激活）\nself.addEventListener(&#39;active&#39;,(event)=&gt;&#123;\n    let cacheWhiteList = [&#39;product-v2&#39;];\n    event.waitUntil(\n        caches.keys().then(cacheNames=&gt;&#123;\n            return Promise.all(\n                cacheNames.map(cacheName=&gt;&#123;\n                    if(cacheWhiteList.indexOf(cacheName) === -1)&#123;\n                        return caches.delete(cacheName);\n                    &#125;\n                &#125;)\n            )\n        &#125;)\n    )\n&#125;)\n//serviceWorker与网页的通信\nself.addEventListener(&#39;active&#39;,(event)=&gt;&#123;\n    event.waitUntil(\n        self.clients.matchAll().then((client)=&gt;&#123;\n            client.postMessage(&#123;\n                msg:&quot;Hello serviceWorker&quot;,\n                source:&quot;serviceWorker&quot;\n            &#125;)\n        &#125;)\n    )\n&#125;)\n</code></pre>\n","categories":["JS"],"tags":["JS","webWorker"]},{"title":"正则表达式","url":"/2023/02/12/%E4%B8%AD%E5%89%8D%E5%8F%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"<h1 id=\"中前台通用项目\"><a href=\"#中前台通用项目\" class=\"headerlink\" title=\"中前台通用项目\"></a>中前台通用项目</h1><h1 id=\"一、工具和包\"><a href=\"#一、工具和包\" class=\"headerlink\" title=\"一、工具和包\"></a>一、工具和包</h1><h2 id=\"vite\"><a href=\"#vite\" class=\"headerlink\" title=\"vite\"></a>vite</h2><p><strong>一、介绍</strong></p>\n<p>webpack进行构建时，默认只会抓取并构建整个应用，然后才能提供服务，项目构建时慢、且项目中任何错误都会影响到整个项目的构建，此外webpack是基于node.js的打包工具 (vue-cli基于webpack)，其中可以使用CommonJS的语法。而Vite是一个基于ES模块的构建工具，它不再依赖于CommonJS规范。</p>\n<p><code>**vite**</code> <strong>不会在一开始就构建你的整个项目</strong>，而是会将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码（项目代码）</strong> 两部分，对于 <strong>源码</strong> 部分，它会根据 <strong>路由来拆分</strong> 代码模块，只会去构建一开始就必须要构建的内容。</p>\n<p><code>vite</code> 以  <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9Nb2R1bGVz\">原生 ESM</span> 的方式为浏览器提供源码，让浏览器接管了 <strong>打包</strong> 的部分工作。</p>\n<p><strong>问题：</strong>早期版本不支持CommonJS的语法，导致依赖都无法使用</p>\n<p><strong>解决：</strong><code>vite</code> 在后期提供了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52aXRlanMuZGV2L2d1aWRlL2RlcC1wcmUtYnVuZGxpbmcuaHRtbA==\">依赖预构建</span> 的功能，其中一个非常重要的目的就是为了解决 <strong>CommonJS 和 UMD 兼容性</strong> 问题。目前 <code>vite</code> 会先将 <code>CommonJS 或 UMD 发布的依赖项转换为 ESM</code> 之后，再重新进行编译。这也可以理解为 <strong>速度对业务的一个妥协</strong>。</p>\n<p><strong>二、使用</strong></p>\n<p>1、vite中需要在vite.config.js中配置@符号表示根路径</p>\n<pre><code class=\"js\">//       在defineConfig中进行配置：\n // 软链接\n  resolve: &#123;\n    alias: &#123;\n      &#39;@&#39;: join(__dirname, &#39;/src&#39;)\n    &#125;\n  &#125;,\n</code></pre>\n<p>2、vite中通过import.meta获取到元信息，如环境变量的获取：<code>import.meta.env.VITE_BASE_API</code> ，批量导入函数：</p>\n<p><code>import.meta.globEager(&#39;./modules/*.js&#39;)</code></p>\n<p>3、vite-plugin-svg-icons插件中使用createSvgIconsPlugin进行批量注册文件夹中的svg图标 （在vite.config.js中配置plugins）</p>\n<pre><code class=\"js\"> plugins: [\n    vue(),\n    createSvgIconsPlugin(&#123;\n      // 指定需要缓存的图标文件夹\n      iconDirs: [path.resolve(process.cwd(), &#39;src/assets/icons&#39;)],\n      // 指定symbolId格式\n      symbolId: &#39;icon-[name]&#39;\n    &#125;)\n  ],\n</code></pre>\n<p>4.代理服务器 （在vite.config.js中的defineConfig中配置：）</p>\n<pre><code class=\"js\">server: &#123;\n    proxy: &#123;\n      // 代理所有 /api 的请求，该求情将被代理到 target 中\n      &#39;/api&#39;: &#123;\n        // 代理请求之后的请求地址\n        target: &#39;https://api.imooc-front.lgdsunday.club/&#39;,\n        // target: &#39;http://127.0.0.1:3005/&#39;,\n        // 跨域\n        changeOrigin: true\n      &#125;\n    &#125;\n  &#125;\n</code></pre>\n<p>5、环境配置文件<code>.env.development</code> 开发环境文件和<code>.env.production</code> 生产环境文件 等</p>\n<p>作用：区分不同环境下的变量，比如开发环境下需要使用任意修改的假数据，但是生产环境下需要使用真实数据</p>\n<p>使用：只有以<code>VITE_</code> 为前缀的变量，才会暴露给vite进行处理，使用时使用<code>import.meta.env.变量名</code></p>\n<h2 id=\"tailwindcss\"><a href=\"#tailwindcss\" class=\"headerlink\" title=\"tailwindcss\"></a>tailwindcss</h2><p><strong>一、优势：</strong></p>\n<p>如果期望在整个项目中进行统一的划分，这样的一套变量通过css来实现，就不得不维护一个庞大的变量组，除此之外还有很多其他的问题，此时tailwindcss的优势就体现出来了</p>\n<p><strong>二、简介：</strong></p>\n<p>tailwindcss提供了很多类名，每一个类名对应一个具体的css内容，设计理念为：<strong>原子化css</strong>，css设计粒度上有4中形式，<strong>颗粒度自上而下逐渐增大，颗粒度越大则约束行越高，可定制性越弱</strong></p>\n<p>css设计粒度的四种形式：</p>\n<p>①<strong>行内样式</strong>：样式全部写入行内，自由度最高，可定制化最强，但是不方便复用。</p>\n<p>②<strong>原子化css</strong>：每一个类名代表一个css属性，自由度很强，可定义化很高，也方便复用，但是大量样式会导致大量的类名</p>\n<p>③<strong>传统形式</strong>：通过一些class来描述一段css属性，封装性强，语义化强，自由度和可定制化性一般</p>\n<p>④<strong>组件形式</strong>：封装性强，语义化强，但是自由度和可定制化性较差</p>\n<p>注意点：tailwindcss的构建顺序为移动优先，项目中构建尽量和tailwind设计保持一致。</p>\n<p><strong>三、使用：</strong></p>\n<p>①直接使用类名，注意可以指定<strong>不同屏幕尺寸</strong>和<strong>不同主题</strong>下对应的样式。</p>\n<p>②还可以自己配置特殊的样式（在tailwind.config.js中进行配置）</p>\n<p>③tailwindcss生态下有很多可以使用的插件。例如如下配置：</p>\n<pre><code class=\"js\">module.exports = &#123;\n  // 手动切换暗模式\n  darkMode: &#39;class&#39;,\n  // Tailwind 应用范围\n  content: [&#39;./index.html&#39;, &#39;./src/**/*.&#123;vue,js&#125;&#39;],\n  theme: &#123;\n    extend: &#123;\n      height: &#123;\n        header: &#39;72px&#39;,\n        main: &#39;calc(100vh - 72px)&#39;\n      &#125;,\n      fontSize: &#123;\n        xs: [&#39;0.25rem&#39;, &#39;0.35rem&#39;],\n        sm: [&#39;0.35rem&#39;, &#39;0.45rem&#39;],\n        base: [&#39;0.42rem&#39;, &#39;0.52rem&#39;],\n        lg: [&#39;0.55rem&#39;, &#39;0.65rem&#39;],\n        xl: [&#39;0.65rem&#39;, &#39;0.75rem&#39;]\n      &#125;,\n      boxShadow: &#123;\n        &#39;l-white&#39;: &#39;-10px 0 10px white&#39;,\n        &#39;l-zinc&#39;: &#39;-10px 0 10px #18181b&#39;\n      &#125;,\n      colors: &#123;\n        main: &#39;#f44c58&#39;,\n        &#39;success-100&#39;: &#39;#F2F9EC&#39;,\n        &#39;warn-100&#39;: &#39;#FCF6ED&#39;,\n      &#125;,\n      backdropBlur: &#123;\n        &#39;4xl&#39;: &#39;240px&#39;\n      &#125;,\n      variants: &#123;\n        scrollbar: [&#39;dark&#39;]\n      &#125;\n    &#125;\n  &#125;,\n  // 注册下载的tailwind-scroll-bar工具包，使用全新的scroll-bar\n  plugins: [require(&#39;tailwind-scrollbar&#39;)]\n&#125;\n</code></pre>\n<p>④ tailwind进行主题替换</p>\n<p>tailwind中有一个dark mode的概念，在使用css时，加上dark前缀的表示暗黑模式下的样式。需要在tailwind.config.js中进行配置：darkMode : ‘ class ‘,</p>\n<p>然后监听主题的切换行为，保存到vuex中并进行持久化处理，然后根据vuex中保存的当前主题修改html元素中的class属性  。  ( dark 或者 light )</p>\n<p>⑤<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGFpbHdpbmQtc2Nyb2xsYmFy\">tailwind-scrollbar</span> tailwind中scrollbar组件</p>\n<h2 id=\"Prettier\"><a href=\"#Prettier\" class=\"headerlink\" title=\"Prettier\"></a>Prettier</h2><p>Prettier是一个代码格式插件，下载插件之后，在项目根目录中配置 .prettierrc文件即可使用。例如：</p>\n<pre><code class=\"js\">&#123;\n  // 代码结尾不加分号\n  &quot;semi&quot;: false,\n  // 优先单引号\n  &quot;singleQuote&quot;: true,\n  // 不添加尾随逗号\n  &quot;trailingComma&quot;: &quot;none&quot;\n&#125;\n</code></pre>\n<h2 id=\"vueuse\"><a href=\"#vueuse\" class=\"headerlink\" title=\"vueuse\"></a>vueuse</h2><p>一、<code>useScroll（）</code>方法，获得dom元素的<code>响应式</code>位置数据</p>\n<p>二、<code>useScrollLock（）</code>方法，将dom元素的滚动<code>上锁</code>（无法滚动）</p>\n<p>三<code>、useVModel（）</code>方法，更方便的使用v-model，获得的是响应式数据</p>\n<p>四、<code>useElementBounding（）</code>方法，获得响应式的元素的宽高属性</p>\n<p>五、<code>useFullscreen（）</code>方法，将dom元素全屏显示</p>\n<p>六、<code>useIntersectionObserver（）</code>方法，监视dom元素是否在视窗显示</p>\n<p>七、 <span class=\"exturl\" data-url=\"aHR0cHM6Ly92dWV1c2Uub3JnL3NoYXJlZC93YXRjaERlYm91bmNlZC8=\">watchDebounced</span> 防抖功能的监视属性，在监视属性的基础之上，第三个参数中配置debounce属性设置防抖的时长</p>\n<p>八、<span class=\"exturl\" data-url=\"aHR0cHM6Ly92dWV1c2Uub3JnL2NvcmUvdXNlRnVsbHNjcmVlbi8jdXNlZnVsbHNjcmVlbg==\">useFullScreen</span>，全屏方法</p>\n<h2 id=\"GSAP\"><a href=\"#GSAP\" class=\"headerlink\" title=\"GSAP\"></a>GSAP</h2><p>js动效库，官网地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nc2FwLmZyYW1lci53aWtpLw==\">https://gsap.framer.wiki/</span></p>\n<h2 id=\"vuex-persisterdstate\"><a href=\"#vuex-persisterdstate\" class=\"headerlink\" title=\"vuex-persisterdstate\"></a>vuex-persisterdstate</h2><p>自动进行vuex配置模块的持久化存储处理</p>\n<h2 id=\"file-saver\"><a href=\"#file-saver\" class=\"headerlink\" title=\"file-saver\"></a><strong>file-saver</strong></h2><p>小文件下载</p>\n<h2 id=\"streamsaver\"><a href=\"#streamsaver\" class=\"headerlink\" title=\"streamsaver\"></a>streamsaver</h2><p>大文件下载</p>\n<h2 id=\"driver-js\"><a href=\"#driver-js\" class=\"headerlink\" title=\"driver.js\"></a>driver.js</h2><p>功能引导</p>\n<h2 id=\"vee-validata\"><a href=\"#vee-validata\" class=\"headerlink\" title=\"vee-validata\"></a>vee-validata</h2><p>表单校验</p>\n<h2 id=\"md5\"><a href=\"#md5\" class=\"headerlink\" title=\"md5\"></a>md5</h2><p>用于密码加密</p>\n<h2 id=\"cropperjs\"><a href=\"#cropperjs\" class=\"headerlink\" title=\"cropperjs\"></a>cropperjs</h2><p>图片裁剪</p>\n<h2 id=\"dayjs\"><a href=\"#dayjs\" class=\"headerlink\" title=\"dayjs\"></a>dayjs</h2><p>日期工具</p>\n<h1 id=\"二、组件\"><a href=\"#二、组件\" class=\"headerlink\" title=\"二、组件\"></a>二、组件</h1><p><strong>1、vite通用组件自动化注册</strong></p>\n<p>① 使用vite中的<code>import.meta.glob（）</code>方法，得到文件路径名称和导入函数的对象</p>\n<pre><code class=\"js\">import &#123; defineAsyncComponent &#125; from &#39;vue&#39;\n\nexport default &#123;\n  install(app) &#123;\n    // 获取当前路径任意文件夹下的 index.vue 文件\n    const components = import.meta.glob(&#39;./*/index.vue&#39;)\n    // 遍历获取到的组件模块\n    for (const [key, value] of Object.entries(components)) &#123;\n      // 拼接组件注册的 name\n      const componentName = &#39;m-&#39; + key.replace(&#39;./&#39;, &#39;&#39;).split(&#39;/&#39;)[0]\n      // 通过 defineAsyncComponent 异步导入指定路径下的组件\n      app.component(componentName, defineAsyncComponent(value))\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>② 然后在main.js中引入实例，使用<code>app.use（）</code>一下即可。</p>\n<p>③ 此外，指令也可以进行自动化全局注册，但是由于<code>import.meta.glob()</code>方法是异步的（适合于组件注册），指令在进行导入时需要使用<code>import.meta.globEager()</code>同步导入方法。</p>\n<pre><code class=\"js\">/**\n * 全局指令注册\n */\nexport default &#123;\n  async install(app) &#123;\n    // https://cn.vitejs.dev/guide/features.html#glob-import\n    // import.meta.globEager 为同步导入\n    const directives = import.meta.globEager(&#39;./modules/*.js&#39;)\n    for (const [key, value] of Object.entries(directives)) &#123;\n      // 拼接组件注册的 name\n      const arr = key.split(&#39;/&#39;)\n      const directiveName = arr[arr.length - 1].replace(&#39;.js&#39;, &#39;&#39;)\n      // 完成注册\n      app.directive(directiveName, value.default)\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p><strong>2、svg-icon组件</strong>：</p>\n<p>动态绑定svg中use标签的xlink:href属性，svg中使用图标的方式：</p>\n<p>①直接写路径加名称：</p>\n<pre><code class=\"html\">&lt;svg&gt;\n  &lt;use xlink:href=&quot;./access/image.svg&quot;&gt;&lt;/use&gt;\n&lt;/svg&gt;\n</code></pre>\n<p>②使用symbol标签，配合id属性</p>\n<pre><code class=\"html\">&lt;symbol id=&#39;name&#39;&gt;&lt;/symbol&gt;\n&lt;svg&gt;\n  &lt;use xlink:href=&quot;#name&quot;&gt;&lt;/use&gt;\n&lt;/svg&gt;\n</code></pre>\n<p>项目中使用了工具包<code>vite-plugin-svg-icons</code>，配置后直接生成了全部的symbol标签，id熟悉绑定了name , 直接使用即可，此外需要在main.js中导入</p>\n<pre><code class=\"js\">import &#39;virtual:svg-icons-register&#39; //导入svg-icons-register\n</code></pre>\n<p><strong>3、popup弹层组件</strong></p>\n<p><strong>4、button按钮通用组件</strong></p>\n<p>在button组件中绑定自己定义的icon组件，组件中绑定传过来的icon-name ,class 和iconColor等。组件需要使用时传入type标识按钮风格，size标识按钮大小，icon标识图标名称，iconColor标识图标颜色，iconClass表示图标的类名，isActiveAnim表示是否需要动画，loading标识加载状态。给按钮添加点击事件emits出去，如果loading为false就不触发事件</p>\n<p><strong>5、popover气泡卡片</strong></p>\n<p>设置两个插槽：具名插槽用于表示出发弹出层的视图，匿名插槽用于表示弹出层视图中展示的内容。同时希望可以控制弹层的位置</p>\n<p><strong>6、瀑布流组件</strong></p>\n<p><strong>7、长列表组件</strong></p>\n<p><strong>8、confirm确认组件</strong></p>\n<p>虚拟dom的概念就是通过js来描述dom元素，vnode虚拟节点就是告诉vue页面上需要渲染什么样式的节点。h函数就是用来创建vnode函数，h函数接收三个参数：要渲染的dom元素，attrs对象和子元素，render函数：可以根据vnode虚拟节点来渲染</p>\n<p><strong>9、trigger-menu移动端tab-bar</strong></p>\n<p><strong>10、倒计时count-down组件</strong></p>\n<h1 id=\"三、API\"><a href=\"#三、API\" class=\"headerlink\" title=\"三、API\"></a>三、API</h1><p>一、<code>window.navigator.userAgent</code>属性，拿到用户的设备信息</p>\n<p>二、<code>Element.getBoundingClientRect()</code>方法，获得dom元素的位置信息</p>\n<p>三、<code>window.matchMedia()</code>方法，接受一个媒体查询解析的字符串，返回一个MediaQueryLise对象，对象有<code>change</code>事件和<code>matches</code>属性（是否匹配成功），例如：</p>\n<pre><code class=\"js\">matchMedia = window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;)\nthemeClassName = matchMedia.matches ? &#39;dark&#39; : &#39;light&#39;\n</code></pre>\n<p>匹配系统窗口的scheme主题是否是dark模式。</p>\n<p>四、<code>window.getComputedStyle()</code> 方法返回DOM元素的css样式属性，包含位置等信息，第二个参数可以指定对应要获得的属性</p>\n<p>五、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0ludGVyc2VjdGlvbk9ic2VydmVy\">window.IntersectionObserver</span> 观察目标元素与祖先元素或顶级文档视口交叉状态</p>\n<p>六、<code>Element.requestFullscreen()</code>让指定元素全屏显示。<code>Document.exitFullscreen()</code>退出全屏。</p>\n<p>七、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0hpc3RvcnkvcHVzaFN0YXRl\">History.pushState()</span> 方法，改变url但是不会跳转页面 </p>\n<p>八、<code>URL.createObjectURL（）</code>方法，获得到对应的blob对象 ，可以将文件对象变成一个可以访问的文件对象链接</p>\n<p>九、<code>BroadcastChannel</code>广播通道，进行同源页面之间的通信（但是存在兼容性问题）</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"四、vue3技巧\"><a href=\"#四、vue3技巧\" class=\"headerlink\" title=\"四、vue3技巧\"></a>四、vue3技巧</h1><p><strong>一、transition动画标签钩子函数</strong></p>\n<p>使用js进行自定义动画样式和触发时机.（before-enter、enter、leave等事件），只使用js设置动画时，可以给transition组件的css属性绑定为false</p>\n<p><strong>二、自定义指令实现图片懒加载</strong></p>\n<p>方案：监听所有图片<strong>是否可见</strong>（交互api），如果图片不可见，就不加载图片（设置src属性），如果图片可见就加载图片。</p>\n<p>注意细节是：①对于每一个img，当监视到在视口中出现过，就可以赋值属性src，然后就可以使用<code>stop（）</code>方法停止监视dom元素是否在视口显示 ②使用<code>import.meta.globEager（）</code>方法，可以同步导入所有的指令，然后一同注册</p>\n<p><strong>三、多组件共享数据的方式</strong></p>\n<p>①父传子（绑定数据，使用props接收）②子传父（自定义事件）③依赖注入Provide &#x2F; inject（ 适用于嵌套层级较深 ）④全局状态管理vuex或者pina</p>\n<p><strong>四、搜索框匹配内容高亮显示</strong></p>\n<p>使用字符串的replace（）方法，传入正则，将匹配的内容替换为高亮显示的内容（使用v-html进行渲染）</p>\n<p>五、<strong>h函数和render函数</strong></p>\n<p>①模板 VS  渲染函数：Vue模板会被预编译成虚拟DOM渲染函数，Vue也提供了API使我们可以不使用模板进行编译：直接手写渲染函数，渲染函数相比于模板更加灵活，而模板更加直观和方便。</p>\n<p>②h函数用于创建vnodes虚拟节点，第一个参数是dom类型（可以使用’div’等，也可以使用组件），第二个参数是props(包括组件中的属性和方法  ，或者dom的属性如style)，第三个参数是子元素。</p>\n<p>③render函数，第一个参数是要渲染的虚拟节点，第二个参数是要渲染的位置（传入dom元素）</p>\n<p><strong>六、状态驱动css</strong></p>\n<p>将响应式数据绑定到css之中：<code>v-bind(变量名称)</code></p>\n<p><strong>七、从部分组件到路由的跳转动画</strong></p>\n<p>①<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0hpc3RvcnkvcHVzaFN0YXRl\">History.pushState()</span> 方法改变url地址栏（注意要绑定对应的动态路由，不然一刷新就会空白）②设置过渡动画（可以使用GSAP）</p>\n<p><strong>八、router-view作用域插槽</strong></p>\n<p>使用<strong>router-view作用域插槽</strong>，配合<strong>transition中的自定义事件</strong>，加上<strong>keep-alive的include属性</strong>缓存动态数组中的组件，利用<strong>component组件的is属性</strong>动态绑定上router-virew的作用域插槽，实现移动端下路由切换时的动态效果</p>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"五、其他业务\"><a href=\"#五、其他业务\" class=\"headerlink\" title=\"五、其他业务\"></a>五、其他业务</h1><p><strong>一、人类行为验证</strong></p>\n<p>目前人类行为验证的实现方案，主要分为两种：</p>\n<ol>\n<li><p>收费平台，年费在几万到几十万不等，有专门的技术人员帮助对接： </p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20v\">极验</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kdW4uMTYzLmNvbS90cmlhbC9zZW5zZQ==\">网易易盾</span></p>\n</li>\n<li><p>…</p>\n</li>\n<li><p>免费开源，验证的精准度，需要看服务端的能力： </p>\n</li>\n<li><p><code>gitee</code> 开源的： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vTG9uZ2Jvd0VudGVycHJpc2UvU2xpZGVyQ2FwdGNoYT9fZnJvbT1naXRlZV9zZWFyY2g=\">SliderCaptcha</span></p>\n</li>\n</ol>\n<p><strong>二、头像裁剪与上传</strong></p>\n<p><strong>三、对象存储服务</strong></p>\n<p><strong>四、移动端页面过渡</strong></p>\n<p>维护一个虚拟任务栈的数组，当push操作时，将vuex中的routerType改为push ，back操作时，将routerType改为back。</p>\n<p><strong>五、虚拟任务栈缓存</strong></p>\n<p>使用keep-alive组件中的include属性进行设置，属性值中包含的组件会进行缓存，在使用路由进行跳转的时候，改变vuex中的routerType属性（PC端下永远为none），根据routerType的属性进行路由跳转时动画的设置。</p>\n<p><strong>六、第三方登录</strong></p>\n<p>  <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb25uZWN0LnFxLmNvbS8=\">QQ互联平台</span> </p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuLndlaXhpbi5xcS5jb20v\">微信开放平台</span> </p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9XZWJzaXRlX0FwcC9XZUNoYXRfTG9naW4vV2VjaGF0X0xvZ2luLmh0bWw=\">微信登录对接官方文档</span> </p>\n<p><strong>七、用户反馈</strong></p>\n<p> <span class=\"exturl\" data-url=\"aHR0cHM6Ly90eGMucXEuY29tLw==\">腾讯兔小巢</span> （url地址中改为product）</p>\n<p><strong>八、第三方分享</strong></p>\n<p>当前微信不支持不同网站的分享</p>\n<p> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuLndlaWJvLmNvbS9pbmRleC5waHAjX2xvZ2luTGF5ZXJfMTY0NjYzNzMwNzIzMg==\">新浪微博开发平台</span> </p>\n<p> <strong>九、第三方支付</strong></p>\n<p>微信支付不支持PC网站应用（迂回）</p>\n<p> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuLmFsaXBheS5jb20v\">支付宝开放平台</span>  </p>\n<p><strong>十、项目上线与发布</strong></p>\n","categories":["正则表达式"],"tags":["正则表达式"]},{"title":"whistle抓包","url":"/2024/05/17/whistle%E4%BD%BF%E7%94%A8/","content":"<h1 id=\"whistle简单使用\"><a href=\"#whistle简单使用\" class=\"headerlink\" title=\"whistle简单使用\"></a>whistle简单使用</h1><h3 id=\"whistle安装启动\"><a href=\"#whistle安装启动\" class=\"headerlink\" title=\"whistle安装启动\"></a>whistle安装启动</h3><p>安装：npm i -g whistle</p>\n<p>使用：w2 start</p>\n<p>访问：访问对应的页面</p>\n<p>作用：</p>\n<ul>\n<li>任何的链接都会经过工具转发一下，并记录下来</li>\n<li>使用前需要配置代理到whistle服务的地址和端口上（设置代理如下）</li>\n</ul>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>设置代理：</p>\n<ul>\n<li>手机端省略</li>\n<li>电脑端：<ul>\n<li>网络偏好设置—高级—代理—网页代理、安全网页代理</li>\n<li>配置代理的ip地址和端口号（8899）</li>\n</ul>\n</li>\n</ul>\n<p>确认证书：</p>\n<p>一般会自动下载，也可以打开8899端口找到证书下载并确认信任</p>\n<p><strong>查看抓包情况和设置代理转发：</strong></p>\n<p>打开127.0.0.1:8899端口进行设置</p>\n<h1 id=\"whistle高级\"><a href=\"#whistle高级\" class=\"headerlink\" title=\"whistle高级\"></a>whistle高级</h1><h3 id=\"mock数据\"><a href=\"#mock数据\" class=\"headerlink\" title=\"mock数据\"></a>mock数据</h3><p>设置线上地址转发到本地json文件（使用file路径），模拟请求数据。</p>\n<h3 id=\"部分文件请求转发（重要）\"><a href=\"#部分文件请求转发（重要）\" class=\"headerlink\" title=\"部分文件请求转发（重要）\"></a>部分文件请求转发（重要）</h3><p>例如线上环境有某个文件报错，生产环境无法复现，可以将该文件地址转发到本地的js文件（使用file路径），方便进行调试，提高调试效率。</p>\n<h3 id=\"请求转发\"><a href=\"#请求转发\" class=\"headerlink\" title=\"请求转发\"></a>请求转发</h3><p>可以作为跨域的一种方案，将本地的请求转发到线上的路径，这样就不会发生跨域问题</p>\n<h3 id=\"注入html、css和-js\"><a href=\"#注入html、css和-js\" class=\"headerlink\" title=\"注入html、css和 js\"></a>注入html、css和 js</h3><p>whistle会自动根据响应内容的类型，判断是否注入相应的文本以及如何注入（是否用标签包裹）</p>\n<p>例如：</p>\n<pre><code class=\"yaml\">https://www.baidu.com  css:///Users/dmq/Desktop/test.css\n</code></pre>\n<p>这将会在百度的官网注入自定义的css样式。</p>\n<h6 id=\"举例：\"><a href=\"#举例：\" class=\"headerlink\" title=\"举例：\"></a>举例：</h6><p>向百度网站注入vconsole.js源码，方便调试打印日志。</p>\n<ol>\n<li><p>下载vconsole到本地或者直接复制源码到whistle中的values中</p>\n</li>\n<li><p>本地js文件创建VConsole实例，或者直接在whistle的values中创建js文件，文件中创建vconsole实例。</p>\n</li>\n<li><p>在rules中向百度网站注入两个js文件（以whistle中配置values为示例）</p>\n<pre><code class=\"yaml\">www.baidu.com  jsPrepend://&#123;vConsole.min.js&#125;  #引入源码\nwww.baidu.com  jsPrepend://&#123;vconsole.js&#125;  #引入实例化js\nwww.baidu.com  log://  #在whistle中也打印log\n</code></pre>\n</li>\n</ol>\n<h3 id=\"同步抓包日志\"><a href=\"#同步抓包日志\" class=\"headerlink\" title=\"同步抓包日志\"></a>同步抓包日志</h3><p>在rules中配置网站的输出，可以将抓包的log日志同步到whistle中的log面板，配置例如：</p>\n<pre><code class=\"yaml\">www.baidu.com   log:// #同步日志\n</code></pre>\n<h3 id=\"解决跨域问题\"><a href=\"#解决跨域问题\" class=\"headerlink\" title=\"解决跨域问题\"></a>解决跨域问题</h3><p>可以单独设置网站允许跨域访问，例如在rules中配置：</p>\n<pre><code class=\"yaml\">https://localhost:5500/list   resCors://*  #表示该网站允许跨域访问\n</code></pre>\n<p>或者使用前端转发代理来处理跨域：</p>\n<pre><code class=\"yaml\">https://localhost:8080/list   https://localhost:5500/list  \n#将请求的网址代理到同域名同端口的网址，就不会发生跨域。\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTc3NjU1L2FydGljbGUvZGV0YWlscy8xMTkyODMwMjg=\">本文学习自b站，原文档地址</span></p>\n","categories":["whistle"],"tags":["whistle","抓包工具"]},{"title":"jenkins配合git hook持续集成","url":"/2024/02/02/%E4%BD%BF%E7%94%A8Jenkins%E9%85%8D%E5%90%88github%20hook%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/","content":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>Centos 7.4</li>\n<li>JDK 1.8</li>\n</ul>\n<h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><p>以下包含相关所有的步骤，可根据现有环境进行跳过</p>\n<ol>\n<li>安装JDK</li>\n<li>安装Centos</li>\n<li>Jenkins和Github配置</li>\n<li>配置任务</li>\n</ol>\n<h3 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h3><p>Jenkins需要JDK才可以运行，我们首先安装JDK</p>\n<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcmFjbGUuY29tL3RlY2huZXR3b3JrL2phdmEvamF2YXNlL2Rvd25sb2Fkcy9qZGs4LWRvd25sb2Fkcy0yMTMzMTUxLmh0bWw=\">下载链接查看地址</span></p>\n<p>首先点击Accept License Agreement，选择Linux对应版本</p>\n<p><strong>注</strong>若想要直接获取下载链接，使用wget进行下载是不行的，我们可以先点击链接进行下载，然后在chrome中的下载任务中查看下载链接进行复制。</p>\n<pre><code>cd /usr/local/src\nwget `your download url`\n</code></pre>\n<h4 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h4><pre><code>tar -zxvf jdk-8u91-linux-x64.tar.gz\n</code></pre>\n<h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><p>将以下内容追加到 &#x2F;etc&#x2F;profile末尾,替换你对应的解压路径</p>\n<pre><code>JAVA_HOME=/usr/local/tools/jdk1.8.0_144\n\nJRE_HOME=$JAVA_HOME/jre\n\nPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\n\nCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jar\n\nexport JAVA_HOME JRE_HOME PATH CLASSPATH\n</code></pre>\n<h4 id=\"启用配置\"><a href=\"#启用配置\" class=\"headerlink\" title=\"启用配置\"></a>启用配置</h4><pre><code>source /etc/profile\n</code></pre>\n<h4 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h4><pre><code>java -version\n</code></pre>\n<h3 id=\"安装Centos\"><a href=\"#安装Centos\" class=\"headerlink\" title=\"安装Centos\"></a>安装Centos</h3><p>使用yum进行安装</p>\n<pre><code>#安装自动选择最快源的插件\n$ yum install yum-fastestmirror -y\n#添加Jenkins源:\n$ sudo wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo\n$ sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key\n #安装jenkins\n$ yum install jenkins\n</code></pre>\n<h4 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h4><pre><code>service jenkins start\n</code></pre>\n<h4 id=\"更改端口\"><a href=\"#更改端口\" class=\"headerlink\" title=\"更改端口\"></a>更改端口</h4><pre><code>vim /etc/sysconfig/jenkins\nservice jenkins restart\n</code></pre>\n<h3 id=\"Jenkins和Github配置\"><a href=\"#Jenkins和Github配置\" class=\"headerlink\" title=\"Jenkins和Github配置\"></a>Jenkins和Github配置</h3><p>这里的配置就比较多了，主要是在github上生成key,然后在Jenkins与项目进行绑定即可</p>\n<h4 id=\"初始化Jenkins\"><a href=\"#初始化Jenkins\" class=\"headerlink\" title=\"初始化Jenkins\"></a>初始化Jenkins</h4><p>这几步非常简单，按照提示进行即可</p>\n<ol>\n<li>访问你的IP:8080</li>\n<li>cat &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword 把密码输入进去</li>\n<li>Install suggested plugins进行安装</li>\n<li>设置账户密码</li>\n</ol>\n<h3 id=\"配置Github-webhooks\"><a href=\"#配置Github-webhooks\" class=\"headerlink\" title=\"配置Github webhooks\"></a>配置Github webhooks</h3><h4 id=\"在对项目有写权限的用户上获取token\"><a href=\"#在对项目有写权限的用户上获取token\" class=\"headerlink\" title=\"在对项目有写权限的用户上获取token\"></a>在对项目有写权限的用户上获取token</h4><p>进入github –&gt; setting –&gt; Personal Access Token –&gt; Generate new token</p>\n<p><a href=\"http://callmedadaxin.github.io/images/jenkins-1.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-1.png\" alt=\"img\"></a></p>\n<p>点击保存，获取token,并<strong>保存好你的token</strong></p>\n<h4 id=\"设置webhooks\"><a href=\"#设置webhooks\" class=\"headerlink\" title=\"设置webhooks\"></a>设置webhooks</h4><p>进入GitHub上指定的项目 –&gt; setting –&gt; WebHooks&amp;Services –&gt; add webhook –&gt; 输入刚刚部署jenkins的服务器的IP</p>\n<p><a href=\"http://callmedadaxin.github.io/images/jenkins-2.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-2.png\" alt=\"img\"></a></p>\n<h3 id=\"配置Jenkins的Git-Plugin\"><a href=\"#配置Jenkins的Git-Plugin\" class=\"headerlink\" title=\"配置Jenkins的Git Plugin\"></a>配置Jenkins的Git Plugin</h3><p>新版Jenkins在初始的时候已经默认安装了Git Plugin和相关依赖的Plugin，我们不用在重复进行安装，直接配置即可</p>\n<p>系统管理 –&gt; 系统设置 –&gt; GitHub –&gt; Add GitHub Sever</p>\n<p>填写API URL为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS8=\">https://api.github.com</span></p>\n<p><a href=\"http://callmedadaxin.github.io/images/jenkins-3.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-3.png\" alt=\"img\"></a></p>\n<p>点击旁边的Add按钮, 添加Secret Text<br><a href=\"http://callmedadaxin.github.io/images/jenkins-4.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-4.png\" alt=\"img\"></a></p>\n<h3 id=\"配置任务\"><a href=\"#配置任务\" class=\"headerlink\" title=\"配置任务\"></a>配置任务</h3><h3 id=\"1-新建\"><a href=\"#1-新建\" class=\"headerlink\" title=\"1.新建\"></a>1.新建</h3><p>回到主页 –&gt; 新建任务 –&gt; 新建一个自由风格的软件项目</p>\n<p><a href=\"http://callmedadaxin.github.io/images/jenkins-5.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-5.png\" alt=\"img\"></a></p>\n<h3 id=\"2-配置源码管理\"><a href=\"#2-配置源码管理\" class=\"headerlink\" title=\"2.配置源码管理\"></a>2.配置源码管理</h3><p><a href=\"http://callmedadaxin.github.io/images/jenkins-6.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-6.png\" alt=\"img\"></a></p>\n<h3 id=\"3-构建触发器，构建环境\"><a href=\"#3-构建触发器，构建环境\" class=\"headerlink\" title=\"3.构建触发器，构建环境\"></a>3.构建触发器，构建环境</h3><p><a href=\"http://callmedadaxin.github.io/images/jenkins-7.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-7.png\" alt=\"img\"></a></p>\n<h3 id=\"4-编写你的构建脚本\"><a href=\"#4-编写你的构建脚本\" class=\"headerlink\" title=\"4.编写你的构建脚本\"></a>4.编写你的构建脚本</h3><p><a href=\"http://callmedadaxin.github.io/images/jenkins-8.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-8.png\" alt=\"img\"></a></p>\n<p>保存，应用</p>\n<h2 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h2><ul>\n<li>项目会自动clone在&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;</li>\n<li>执行的全局脚本确定已经软链到 &#x2F;usr&#x2F;bin,否则访问不到</li>\n</ul>\n","categories":["jenkins配合git hook持续集成"],"tags":["jenkins","github hook"]},{"title":"前端模块化","url":"/2024/03/29/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/","content":"<h1 id=\"modules模块化\"><a href=\"#modules模块化\" class=\"headerlink\" title=\"modules模块化\"></a>modules模块化</h1><h3 id=\"模块化的优点：\"><a href=\"#模块化的优点：\" class=\"headerlink\" title=\"模块化的优点：\"></a>模块化的优点：</h3><p>可维护性、可复用性。</p>\n<h4 id=\"模块化的发展\"><a href=\"#模块化的发展\" class=\"headerlink\" title=\"模块化的发展\"></a>模块化的发展</h4><p>1、ES6之前没有模块化时，浏览器环境需要使用script进行引入js文件<br>2、后来使用全局变量+命名空间（namespace）处理，就是使用IIFE自动执行函数创建一个函数作用域，赋值给一个全局变量。<br>这样做的缺点是：依赖于全局变量，污染全局变量，不安全。<br>    依赖于约定命名空间来避免冲突，可靠性不高。<br>    需要手动管理依赖并控制执行顺序，容易出错。<br>    需要在最终上线前手动合并所有用到的模块。<br>3、node端模块系统：Common.js，缺点是浏览器端无法使用<br>4、AMD(Asynchronous module definition)异步加载模块定义，CMD(模块标准)<br>    采用异步方式加载，需要全局环境定义require和define，不需要引入其他的变量。<br>5、ES6 modules、引入和暴露方式更加多样，支持复杂的静态分析和静态、动态导入。</p>\n<h1 id=\"Bundler打包工具\"><a href=\"#Bundler打包工具\" class=\"headerlink\" title=\"Bundler打包工具\"></a>Bundler打包工具</h1><h3 id=\"诞生原因：\"><a href=\"#诞生原因：\" class=\"headerlink\" title=\"诞生原因：\"></a>诞生原因：</h3><p>使用import export这种异步加载方式在大多数浏览器中无法使用。</p>\n<h3 id=\"常见工具\"><a href=\"#常见工具\" class=\"headerlink\" title=\"常见工具\"></a>常见工具</h3><p>一、<strong>Webpack</strong>（单JS文件入口），Webpack采用代码分割、异步加载等技术，可以将多个模块打包成一个或者多个bundle,，构建的产物是一个函数。Webpack主要用于构建复杂的前端项目，如Web应用、SPA单页面应用等，支持模块化开发、代码分割、资源优化和静态文件处理等功能。。</p>\n<p>二、<strong>rollup</strong>用静态的方式分析代码，对未使用的代码更加彻底的进行树摇优化，输出的bundle更加的精简。</p>\n<p>三、<strong>snowpack</strong>（使用于新版浏览器）<br>1、出现的原因（其他Bundler的问题）：<br>当资源越来越多时，打包的速度会越来越慢，大中型项目中，启动时间可能达到好几分钟。（vite的理念来源于snowpack，充分使用了新版浏览器支持es modules的特性。）<br>2、优势：<br>snowpack利用新版浏览器支持es modules的特性，开发模式不会被打包，每个文件编译一次，永久被缓存，当一个文件修改的时候就只需要重新build那一个文件。（适用于新版浏览器）<br>四、<strong>vite</strong><br>vite基于snowpack的理念（利用新版浏览器支持es modules的特性），基于es-modules，采用rollup进行构建 ，开发模式不会打包，每个文件当使用时才会去加载，修改时只需要重新build那一个文件。<br>五、<strong>vue-cli</strong><br>vue-cli底层基于webpack，webpack通过导入导出的语句分析整个项目，将目标代码转化成兼容浏览器的js代码，只有打包后的几个文件，这个过程需要耗费一些时间。</p>\n<h1 id=\"webpack配置支持ES-Module\"><a href=\"#webpack配置支持ES-Module\" class=\"headerlink\" title=\"webpack配置支持ES Module\"></a>webpack配置支持ES Module</h1><p>webpack默认只支持CommonJS规范，配置支持ES Module规范，需要进行如下配置：<br>一：将ES Module语法的js文件通过webpack进行打包即可。<br>二：webpack默认target为web，在使用node内置库时会报错，可以修改target属性。</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;);\nmodule.exports = &#123;\n    entry: &#39;./bin/core.js&#39;,\n    output: &#123;\n        path:path.join(__dirname,&#39;/dist&#39;),\n        filename: &#39;core.js&#39;,\n    &#125;,\n    mode: &#39;production&#39;, //改变打包模式\n    target: &#39;node&#39; //进入node环境，默认是web\n&#125;\n</code></pre>\n<p>三、webpack配置babel-loader，兼容低版本node<br>方案一：安装babel-loader、@babel&#x2F;core、@babel&#x2F;preset-env（有时需要@babel&#x2F;plugin-transform-runtime插件）</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;);\nmodule.exports = &#123;\n    entry: &#39;./bin/core.js&#39;,\n    output: &#123;\n        path:path.join(__dirname,&#39;/dist&#39;),\n        filename: &#39;core.js&#39;,\n    &#125;,\n    mode: &#39;production&#39;, //改变打包模式\n    target: &#39;node&#39;, //进入node环境，默认是web\n    module: &#123;\n        rules: [\n            &#123;\n                test: /\\.js$/,\n                use: &#123;\n                    loader: &#39;babel-loader&#39;,  //使用babel-loader\n                    options: &#123;\n                        presets: [&#39;@babel/preset-env&#39;],\n                        plugins:[\n                            [\n                                &#39;@babel/plugin-transform-runtime&#39;,\n                                &#123;\n                                    corejs: 3,\n                                    regenerator: true,\n                                    useESModules: true,\n                                    helpers: true,\n                                &#125;,\n                            ],\n                        ]\n                    &#125;,\n                &#125;\n            &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<p>方案二：node.js实验功能<br>将js后缀更改为mjs后缀，即可（需要node版本为14以上）,小于14版本的时候，node执行时需要加上–experimental-modules参数，例如：<br><code>node --experimental-modules index.js</code></p>\n","categories":["前端工程化"],"tags":["ESModules"]},{"title":"三方库","url":"/2024/04/16/%E4%B8%89%E6%96%B9%E5%8C%85/","content":"<h1 id=\"脚手架开发\"><a href=\"#脚手架开发\" class=\"headerlink\" title=\"脚手架开发\"></a><strong>脚手架开发</strong></h1><p><strong>常见工具包</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29tbWFuZGVy\">Commander</span></strong></th>\n<th><strong>提供一个连贯的 <code>API</code>，用于定义 <code>CLI</code> 应用程序的各个方面，如命令、选项、别名和帮助。简化了命令行应用程序的创建。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UveWFyZ3M=\">yargs</span></strong></td>\n<td><strong>脚手架开发框架，通过解析参数和生成优雅的用户界面来帮助您构建交互式命令行工具。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbGVybmE=\">lerna</span></strong></td>\n<td><strong>多package管理</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW5xdWlyZXI=\">Inquirer</span></strong></td>\n<td><strong>一个易于嵌入且美观的 <code>Node.js</code> 命令行界面。 提供了很棒的查询会话流程。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2hhbGs=\">Chalk</span></strong></td>\n<td><strong><code>Chalk</code> 是一个非常简单的库，创建它的目的很简单——给你的终端字符串添加样式。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29sb3Jz\">colors</span></strong></td>\n<td><strong>打印<code>不同颜色的log信息</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb3Jh\">ora</span></strong></td>\n<td><strong>命令行<code>中高级的</code>、<code>功能丰富的高可定制化加载动画</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xpLXNwaW5uZXI=\">cli-spinner</span></strong></td>\n<td><strong>命令行中<code>轻量的符号加载动画</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnBtbG9n\">npmlog</span></strong></td>\n<td><strong>执行 npm 的日志记录。它支持<code>自定义级别和彩色输出</code>。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW1wb3J0LWxvY2Fs\">import-local</span></strong></td>\n<td><strong>当与全局冲突的时候，比如全局和本地都有这个脚手架时可以使用，<code>判断使用的是否是本地版本</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmluZHVw\">findup</span></strong></td>\n<td><strong><code>向上查找指定文件</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGF0aC1leGlzdHM=\">path-exists</span></strong></td>\n<td><strong><code>判断文件是否存在</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVidWc=\">Debug</span></strong></td>\n<td><strong>一个很小的 <code>JavaScript</code> 调试实用程序。 只需将一个函数的名称传递给模块，它就会返回一个经过修饰的 <code>console.error</code> 版本，以便你将调试语句传递给该模块</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZnMtZXh0cmE=\">fs-extra</span></strong></td>\n<td><strong>fs模块的扩展，支持更多文件操作功能</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2VtdmVy\">semver</span></strong></td>\n<td><strong><code>版本比对工具</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmlnbGV0\">figlet</span></strong></td>\n<td><strong>输出一些独特的大型<code>ASCII文本横幅</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdXNlci1ob21l\">user-home</span></strong></td>\n<td><strong>获取<code>用户主目录</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZG90ZW52\">dotenv</span></strong></td>\n<td><strong>获取<code>环境变量</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvcm9vdC1jaGVjaw==\">root-check</span></strong></td>\n<td><strong>检查是否是<code>管理员权限启动并自动降级</code>，防止后续因普通权限导致无法使用。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGtnLWRpcg==\">pkg-dir</span></strong></td>\n<td><strong>从某个目录开始向上查找，直到找到存在<code>package.json</code>的目录，并返回该目录。如果未找到则返回null</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWluaW1pc3Q=\">minimist</span></strong></td>\n<td><strong>用来<code>解析命令行参数和选项的库</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnBtaW5zdGFsbA==\">npminstall</span></strong></td>\n<td><strong><code>安装npm上的包</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZG93bmxvYWQtZ2l0LXJlcG8=\">download-git-repo</span></strong></td>\n<td><strong><code>安装git仓库中的包</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWpz\">ejs</span></strong></td>\n<td><strong><code>xml模板数据动态渲染</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2xvYg==\">glob</span></strong></td>\n<td><strong>根据<code>文件路径进行遍历和匹配文件</code>，拿到文件的内容。</strong></td>\n</tr>\n</tbody></table>\n<p><strong>底层原理包</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>readline（node内置库）</strong></th>\n<th><strong>命令行的输入输出</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>events（node内置库）</strong></td>\n<td><strong>事件驱动</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3RyZWFt\">stream</span></strong></td>\n<td><strong>输入输出流</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYW5zaS1lc2NhcGVz\">ansi-escapes</span></strong></td>\n<td><strong>自定义<code>命令行文字样式</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvcnhqcw==\">rxjs</span></strong></td>\n<td><strong><code>处理异步事件流</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYnVzYm95\">busboy</span></strong></td>\n<td><strong><code>多文件上传底层库</code>，尤其用于流式文件上传。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWNvbXBvbmVudHM=\">styled-components</span></strong></td>\n<td><strong>css-in-js理论工具，在<code>js中书写css样式</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWpzeA==\">styled-jsx</span></strong></td>\n<td><strong>css-in-js理论工具，在<code>js中书写css样式</code>（ts支持不友好）</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZW1vdGlvbg==\">emotion</span></strong></td>\n<td><strong>css-in-js理论工具，在<code>js中书写css样式</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3Qtcm91dGVyLWRvbQ==\">react-router-dom</span></strong></td>\n<td><strong>react在dom环境下的<code>路由工具</code></strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD****\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>****</h1><hr>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f7aca9360f75177151ab5ca62022d8f31332eea4</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a><strong>Vue</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQG53c2VlL2NvcmU=\">https://www.npmjs.com/package/@nwsee/core</span></strong></th>\n<th><strong>vue项目插件，用于页面性能监控</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a><strong>React</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGV4Y2FsaWRyYXcvZXhjYWxpZHJhdw==\">excalidraw</span></strong></th>\n<th><strong><code>画板、流程图和思维导图</code>等</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZDM=\">d3</span></strong></td>\n<td><strong><code>可视化数据图表库</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW1tZXI=\">immer</span></strong></td>\n<td><strong>改变了react<code>设置state状态的方式</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xhc3NuYW1lcw==\">classnames</span></strong></td>\n<td><strong>有条件地将 <code>classNames 连接</code>在一起</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYWhvb2tz\">ahooks</span></strong></td>\n<td><strong>国内常用的<code>react-hooks函数集</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY3JhY28=\">craco</span></strong></td>\n<td><strong>用于<code>create-react-app项目中的各种配置和重写</code></strong></td>\n</tr>\n<tr>\n<td>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</td>\n<td></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9ieA==\">mobx</span></strong></td>\n<td><strong>react声明式状态管理工具</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVkdXg=\">redux</span></strong></td>\n<td><strong>react最常用的状态管理工具</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdG9yeWJvb2suanMub3JnLw==\">StoryBook</span></strong></td>\n<td><strong><code>可视化测试工具</code></strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f7aca9360f75177151ab5ca62022d8f31332eea4</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a><strong>Node.js</strong></h1><table>\n<thead>\n<tr>\n<th align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXhwcmVzcw==\">Express</span></strong></th>\n<th align=\"left\"><strong>轻量级web框架</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGhhcGkvaGFwaQ==\">Hapi</span></strong></td>\n<td align=\"left\"><strong>以最小的开销和完全开箱急用的功能构建强大的、拓展性强的应用程序</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2FpbHM=\">Sails</span></strong></td>\n<td align=\"left\"><strong>最流行的Node.js的MVC框架</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cua29hanMubmV0Lw==\">Koa</span></strong></td>\n<td align=\"left\"><strong>下一代web开发框架</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZnMtZXh0cmE=\">Fs-extra</span></strong></td>\n<td align=\"left\"><strong>fs -extra<code>包含了</code>Node.js<code> </code>fs<code>包中没有包含的方法，比如</code>copy()<code>, </code>remove()<code>, </code>mkdirs()</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZS1jYWNoZQ==\">Node-cache</span></strong></td>\n<td align=\"left\"><strong>一个简单的缓存模块，具有设置，获取和删除方法的功能，类似于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZW1jYWNoZWQub3JnLw==\">memcached</span>。 key 值可以具有一个超时设置（ttl），在此时间之后它们将过期并从缓存中删除。</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2hhcnA=\">sharp</span></strong></td>\n<td align=\"left\"><strong><code>node图片处理</code>解决方案</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9hZHRlc3Q=\">Loadtest</span></strong></td>\n<td align=\"left\"><strong>node.js<code>压力测试工具</code></strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"Vite\"><a href=\"#Vite\" class=\"headerlink\" title=\"Vite\"></a><strong>Vite</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaHR0cC1wcm94eQ==\">http-proxy</span></strong></th>\n<th><strong>vite代理服务器的底层，用于转发http请求到响应给客户端</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a><strong>css</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGFpbHdpbmRjc3M=\">Tailwind</span></strong></th>\n<th><strong>原子化css</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWNvbXBvbmVudHM=\">Styled-components</span></strong></td>\n<td><strong>css-in-js，js中书写css</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWpzeA==\">Styled-jsx</span></strong></td>\n<td><strong>css-in-js，js中书写css</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZW1vdGlvbg==\">emotion</span></strong></td>\n<td><strong>css-in-js，js中书写css</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a><strong>日志</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9yZ2Fu\">Morgan</span></strong></th>\n<th><strong>具体来说，它是一个 <code>HTTP</code> 请求记录器，存储 <code>HTTP</code> 请求，并为你提供有关应用程序如何使用以及可能存在潜在错误的简要信息。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2luc3Rvbg==\">Winston</span></strong></td>\n<td><strong>一个几乎所有内容的日志记录器，支持多种传输方式。它存储的时间比 <code>Morgan</code> 长，它也有一个更大的维护者社区和更多的下载。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9nNGpz\">log4js</span></strong></td>\n<td><strong>用于在js中生成日志信息，可以输出到终端，也可以生成日志文件</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a><strong>数据库</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9uZ29vc2U=\">Mongoose</span></strong></th>\n<th><strong><code>Mongoose</code> 是一个 <code>MongoDB</code> 对象建模工具，设计用于在异步环境中工作。<code>Mongoose</code> 支持 <code>Promise</code> 和回调。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2VxdWVsaXpl\">Sequelize</span></strong></td>\n<td><strong><code>Sequelize</code> 是一个基于 <code>Promise</code> 的 <code>Node.js</code> <code>ORM</code> 工具，适用于 <code>Postgres</code>、MySQL、MariaDB、SQLite 和 Microsoft SQL Server。它具有可靠的事务支持、关系、即时和延迟加载、读取复制等特性。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYnJvd3Nlci1zeW5j\">browser-sync</span></strong></td>\n<td><strong><code>开启浏览器服务</code>，打开文件（html）,当执行文件改变时，自动刷新浏览器</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a><strong>浏览器</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wcHRyLmRldi8=\">Puppeteer</span></strong></th>\n<th><strong>通过DevTools协议控制浏览器，默认以无头模式运行（Chrome的无头版本）</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNkb20=\">jsdom</span></strong></td>\n<td><strong>许多Web标准的纯JavaScript实现，用于<code>node.js中模拟浏览器环境</code></strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a><strong>授权</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGFzc3BvcnQ=\">Passport</span></strong></th>\n<th><strong><code>Passport</code> 的目的是通过一组可扩展的插件(称为策略)对请求进行身份验证。向<code>Passport</code> 提供一个身份验证请求，<code>Passport</code> 提供钩子来控制身份验证成功或失败时发生的操作。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmNyeXB0\">Bcrypt</span></strong></td>\n<td><strong>它是可以帮助你生成哈希密码的库。<code>Bcrypt</code> 是由 <code>Niels Provos</code> 和 <code>David Mazieres</code> 基于 <code>Blowfish cipher</code> 设计的密码哈希函数，并于 1999 年在 USENIX 上展出。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNvbndlYnRva2Vu\">JSONWebToken</span></strong></td>\n<td><strong><code>JSON Web</code> 令牌(JWT)是一种开放的、行业标准的 <code>RFC 7519</code> 方法，用于在双方之间安全地表示声明。这个包允许你解码、验证和生成 JWT。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"静态网站生成\"><a href=\"#静态网站生成\" class=\"headerlink\" title=\"静态网站生成\"></a><strong>静态网站生成</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2F0c2J5\">Gatsby</span></strong></th>\n<th><strong>一个现代的网站生成器，可以创建快速，高质量，动态的 <code>React</code> 应用程序，从博客到电子商务网站再到用户仪表板。具有很棒的插件生态系统和模板。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbmV4dA==\">NextJS</span></strong></td>\n<td><strong><code>NextJS</code> 首先支持服务器渲染以及静态生成的内容。 你还可以将 <code>serverless</code> 功能定义为 <code>API</code> 端点。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnV4dA==\">NuxtJS</span></strong></td>\n<td><strong>在 <code>Vue</code> 的生态系统中，<code>NuxtJS</code> 基本上是 <code>NextJS</code> 的替代品。<code>NuxtJS</code> 的目标是让 <code>web</code> 开发功能强大，并且让开发者具有良好的开发意识。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a><strong>模板语法</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXVzdGFjaGU=\">Mustache</span></strong></th>\n<th><strong><code>Mustache</code> 是一种无逻辑的模板语法。它可以用于 <code>HTML</code>，配置文件，源代码等任何东西。它的工作原理是使用 hash 或对象中提供的值在模板中展开标记。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaGFuZGxlYmFycw==\">Handlebars</span></strong></td>\n<td><strong>使用模板和输入对象生成 <code>HTML</code> 或其他文本格式。<code>Handlebars</code> 模板看起来像一个嵌入了把手表达式的正则文本。<code>Handlebars</code> 很大程度上与 <code>Mustache</code> 模板兼容。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWpz\">EJS</span></strong></td>\n<td><strong><code>EJS</code> 是一种简单的模板语言，可让你使用简单的语法，快速的执行和简单的调试 <code>JavaScript</code> 来生成 <code>HTML</code> 标记。 <code>EJS</code> 拥有大量的活跃用户社区，并且该库正在积极开发中。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"mock数据\"><a href=\"#mock数据\" class=\"headerlink\" title=\"mock数据\"></a><strong>mock数据</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdXVpZA==\">Uuid</span></strong></th>\n<th><strong>方便而且体积小的包，可以快速、轻松地生成更复杂的通用惟一标识符(UUIDs)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFrZXI=\">Faker</span></strong></td>\n<td><strong>实用的 <code>npm</code> 包，用于在浏览器和 <code>Node.js</code> 中制造大量假数据。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNvbi1zZXJ2ZXI=\">jsonServer</span></strong></td>\n<td><strong>mock开发服务器数据</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbmFub2lk\">nanoid</span></strong></td>\n<td><strong><code>字符串 ID 生成器</code> ,没有其余依赖。</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"表单和邮件\"><a href=\"#表单和邮件\" class=\"headerlink\" title=\"表单和邮件\"></a><strong>表单和邮件</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdmFsaWRhdG9y\">Validator</span></strong></th>\n<th><strong>便捷的字符串验证器，使程序更加健壮的库。许多有用方法，例如 <code>isEmail()</code>， <code>isCreditCard()</code>，<code>isDate()</code> 和 <code>isURL()</code>。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZm9ybWlr\">Formik</span></strong></td>\n<td><strong><code>Formik</code> 是 <code>React</code> 和 <code>React Native</code> 的一个流行开源表单库。它具有易于使用、声明性和适应性的特点。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXVsdGVy\">Multer</span></strong></td>\n<td><strong><code>Multer</code> 是用于 <code>multipart/form-data</code> 数据格式的 <code>Node.js</code> 中间件，主要用于上传文件。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZW1haWxlcg==\">Nodemailer</span></strong></td>\n<td><strong><code>Nodemailer</code> 是 <code>Node.js</code> 应用程序的一个模块，允许轻松发送电子邮件。这个项目从 2010 年就开始了，现在它是大多数 <code>Node.js</code> 用户默认使用的解决方案。</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"pdf\"><a href=\"#pdf\" class=\"headerlink\" title=\"pdf\"></a><strong>pdf</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGRma2l0\">pdfkit</span></strong></th>\n<th><strong>适用于node和浏览器的<code>pdf生成库</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGRmLWxpYg==\">pdf-lib</span></strong></td>\n<td><strong>任何JavaScript环境中<code>创建和修改pdf</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNwZGY=\">jspdf</span></strong></td>\n<td><strong>用<code>JavaScript生成pdf</code>的库</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"富文本编辑器\"><a href=\"#富文本编辑器\" class=\"headerlink\" title=\"富文本编辑器\"></a><strong>富文本编辑器</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ucG1kb2Mub3JnL3RpbnltY2V6aG9uZ3dlbndlbmRhbmd0aW55bWNlLWpzemhvbmd3ZW5qaWFvY2hlbmdqaWV4aS5odG1s\">tinymce</span></strong></th>\n<th><strong>富文本编辑，可商用，具有美感</strong></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a><strong>测试</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvamVzdA==\">Jest</span></strong></th>\n<th><strong><code>Jest</code> 是一个令人愉快的 <code>JavaScript</code> 测试框架，专注于简洁明快。它允许你使用易于使用、熟悉且功能丰富的 <code>API</code> 编写测试，从而快速获得结果。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9jaGE=\">Mocha</span></strong></td>\n<td><strong><code>Mocha</code> 是一个 <code>JavaScript</code> 测试框架，使得异步测试简单而有趣。<code>Mocha</code> 测试是串行运行的，在将未捕获的异常映射到正确的测试用例的同时，允许进行灵活和准确的报告。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a><strong>代码规范</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXNsaW50\">ESLint</span></strong></th>\n<th><strong><code>ESLint</code> 是用于识别和报告 <code>ECMAScript / JavaScript</code> 代码中的书写方式的工具。 <code>ESLint</code> 是完全插件化的，每个规则都是一个插件，你可以在运行时添加更多内容。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcHJldHRpZXI=\">Prettier</span></strong></td>\n<td><strong><code>Prettier</code> 是一种固执己见的代码格式化程序。它通过解析代码并使用自己的规则(考虑到最大行的长度)重新打印代码，以及在必要时包装代码，来强制执行一致的样式。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"打包和压缩\"><a href=\"#打包和压缩\" class=\"headerlink\" title=\"打包和压缩\"></a><strong>打包和压缩</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2VicGFjaw==\">Webpack</span></strong></th>\n<th><strong>一个著名的功能强大的模块打包器。它的主要目的是将 <code>JavaScript</code> 文件打包以便在浏览器中使用，但它也能够转换、捆绑或打包任何资源。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaHRtbC1taW5pZmllcg==\">HTML-Minifier</span></strong></td>\n<td><strong>轻巧，高度可配置且经过良好测试的基于 <code>Javascript</code> 的 <code>HTML</code> 压缩器&#x2F;压缩器（支持 <code>Node.js</code>）。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xlYW4tY3Nz\">Clean-CSS</span></strong></td>\n<td><strong>适用于 <code>Node.js</code> 平台和任何现代浏览器的快速高效的 <code>CSS</code> 优化器。 具有高度可配置和多种兼容模式。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdWdsaWZ5LWpz\">UglifyJS2</span></strong></td>\n<td><strong><code>JavaScript</code> 解析器，压缩程序和美化工具包。 它可以使用多个输入文件，并支持许多配置选项。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a><strong>进程管理</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZW1vbg==\">Nodemon</span></strong></th>\n<th><strong>在 <code>Node.js</code> 应用程序的开发过程中使用的简单的监控脚本。对于开发非常有用，因为它非常容易重启，并且默认启用了文件监听</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcG0y\">PM2</span></strong></td>\n<td><strong>带有内置负载均衡的 <code>Node.JS</code> 应用程序的生产进程管理器。 更全面，更适合生产，给你很多参数以进行调整功能</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29uY3VycmVudGx5\">Concurrently</span></strong></td>\n<td><strong>简单而直接——这是同时运行多个命令的有用工具。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"桌面端\"><a href=\"#桌面端\" class=\"headerlink\" title=\"桌面端\"></a><strong>桌面端</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY3JlYXRlLXRhdXJpLWFwcA==\">create-tauri-app</span></strong></th>\n<th><strong>创建<code>桌面端应用程序</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"跨语言通信\"><a href=\"#跨语言通信\" class=\"headerlink\" title=\"跨语言通信\"></a><strong>跨语言通信</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ncnBjLmlvLw==\">grpc</span></strong></th>\n<th><strong>跨语言通信库</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a><strong>ORM</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvZ2V0dGluZy1zdGFydGVk\">Prisma ORM</span></strong></th>\n<th><strong>下一代Node.js 和 TypeScript ORM（对象关系映射）</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb25nb29zZS5ub2RlanMuY24v\">Mongoose</span></strong></td>\n<td><strong>mongodb数据库ODM（对象文档映射）</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"解析和语法转换\"><a href=\"#解析和语法转换\" class=\"headerlink\" title=\"解析和语法转换\"></a><strong>解析和语法转换</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanMteWFtbA==\">js-yaml</span></strong></th>\n<th><strong>用于将JavaScript语言解析为<code>yaml</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGJhYmVsL3BhcnNlcg==\">@babel&#x2F;parser</span></strong></td>\n<td><strong>将<code>JavaScript代码转换为抽象语法树</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGJhYmVsL3RyYXZlcnNl\">@babel&#x2F;traverse</span></strong></td>\n<td><strong>用于遍历和<code>操作抽象语法树</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGJhYmVsL2NvcmU=\">@babel&#x2F;core</span></strong></td>\n<td><strong>babel核心功能集，例如将抽象语法树转为JavaScript代码。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHJvbGx1cC9wbHVnaW4tbm9kZS1yZXNvbHZl\">@rollup&#x2F;plugin-node-resolve</span></strong></td>\n<td>rollup插件，用于告诉<code>rollup如何处理导入导出语句（路径补全）</code>。</td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHJvbGx1cC9wbHVnaW4tY29tbW9uanM=\">@rollup&#x2F;plugin-commonjs</span></strong></td>\n<td>rollup插件，用于<code>允许rollup将CommonJS模块</code>打包为ES语法</td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHJvbGx1cC9wbHVnaW4tdHlwZXNjcmlwdA==\">@rollup&#x2F;plugin-typescript</span></strong></td>\n<td>rollup插件，用于<code>rollup处理TypeScript文件</code></td>\n</tr>\n</tbody></table>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a><strong>其他</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYXhpb3M=\">Axios</span></strong></th>\n<th><strong>基于 <code>Promise</code> 的 <code>HTTP</code> 客户端，用于浏览器和 <code>Node.js</code>。 与 <code>JS</code> 内置 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSQ==\">Fetch API</span> 相比，它易于设置，直观且简化了很多工作。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><a href=\"https//www.npmjs.com/package/socket.io\">Socket.io</a></strong></td>\n<td><strong><code>Socket.IO</code> 支持实时，双向和基于事件的通信。 它可以在每个平台，浏览器或其他设备上运行，并同时关注可靠性和速度。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd3M=\">WS</span></strong></td>\n<td><strong>简单易用，快速且经过全面测试的 <code>WebSocket</code> 客户端和服务器实现。 一个很好的，不太抽象的，<code>Socket.io</code> 的替代方案</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGF5anM=\">DayJS</span></strong></td>\n<td><strong><code>DayJS</code> 是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9tZW50\">MomentJS</span> （自2020年9月起处于维护模式）的一种快速、轻巧的替代方案。它们的 <code>API</code> 使用类似，如果你使用过<code>MomentJS</code>，则已经知道如何使用大多数 <code>DayJS</code>。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9kYXNo\">Lodash</span></strong></td>\n<td><strong>现代化的 <code>JavaScript</code> 实用程序库，提供模块化，高性能以及其他功能。 公开关于 <code>JavaScript</code> 数组，对象和其他数据结构的许多有用方法。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdW5kZXJzY29yZQ==\">Underscore</span></strong></td>\n<td><strong><code>Underscore</code> 提供了许多常用的功能工具以及更专业的工具：函数绑定，<code>javascript</code> 模板，创建快速索引，深度相等测试等。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYXN5bmM=\">Async</span></strong></td>\n<td><strong><code>Async</code> 是一个实用模块，它为异步 <code>JavaScript</code> 提供了直接、强大的功能。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2Vk\">Marked</span></strong></td>\n<td><strong>用于解析 <code>markdown</code> 而不需要缓存或长时间阻塞的低级编译器。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmFuZG9tY29sb3I=\">Randomcolor</span></strong></td>\n<td><strong>一个用于生成有吸引力的随机颜色的小脚本。 你可以传递选项对象从而决定其产生的颜色类型。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGx1cmFsaXpl\">Pluralize</span></strong></td>\n<td><strong>该模块使用预先定义的规则列表，按顺序应用这些规则给指定单词单数或复数。 在许多情况下这很有用，例如基于用户输入的任何自动化。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVkZW50\">dedent</span></strong></td>\n<td><strong>从多行字符串中去除缩进（空格）</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXM=\">ms</span></strong></td>\n<td><strong>将易理解的时间转换为毫秒数。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaG90a2V5cy1qcw==\">hotkeys-js</span></strong></td>\n<td><strong><code>键盘事件</code>使用库。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcXM=\">qs</span></strong></td>\n<td><strong><code>查询字符串解析和字符串化库</code>，具有一些附加的安全性</strong></td>\n</tr>\n<tr>\n<td>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</td>\n<td></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFjZS1hcGk=\">face-api</span></strong></td>\n<td><strong>用于<code>人脸识别</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcXJjb2RlanM=\">qrcode</span></strong></td>\n<td><strong>用于将<code>文本转二维码</code>，并用canvas绘制出来</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbGxxcmNvZGU=\">llqrcode</span></strong></td>\n<td><strong>将扫描二维码，将二维码转为文本</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9mZm1wZWcucDJocC5jb20vZG93bmxvYWQuaHRtbA==\">FFmpeg</span></strong></td>\n<td><strong><code>跨平台多媒体处理工具</code>，可以采用命令行的方式<code>解码、编码转码复用、流式、过滤</code>和播放几乎任何机器创建的东西（如视频转码、剪辑、提取、合并）等。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbmdxdWFudC5vcmcv\">pngquant</span></strong></td>\n<td><strong>压缩 PNG 图像文件的工具,同时保持图像质量和透明度。<code>pngquant</code> 提供命令行接口和库，可轻松集成到各种应用程序和脚本中。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaHR0cC1wcm94eS1taWRkbGV3YXJl\">http-proxy-middleware</span></strong></td>\n<td><strong>代理中间件，<code>用于将特定的请求进行转发</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWltZQ==\">mime</span></strong></td>\n<td><strong>用于根据文件或路径后缀，<code>得到对应的mime类型</code>。</strong></td>\n</tr>\n<tr>\n<td>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</td>\n<td></td>\n</tr>\n<tr>\n<td>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</td>\n<td></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2ViLXZpdGFscw==\">web-vitals</span></strong></td>\n<td><strong><code>性能检测</code>工具</strong></td>\n</tr>\n<tr>\n<td>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</td>\n<td></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFjZS1hcGk=\">face-api</span></strong></td>\n<td>用于<code>人脸识别</code></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcXJjb2RlanM=\">qrcode</span></strong></td>\n<td>用于将<code>文本转二维码</code>，并用canvas绘制出来</td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbGxxcmNvZGU=\">llqrcode</span></strong></td>\n<td>将扫描二维码，将二维码转为文本</td>\n</tr>\n</tbody></table>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>37e1bb0043140141ede69a340096e04fd5a1e194<br>f7aca9360f75177151ab5ca62022d8f31332eea4</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n","categories":["三方库"],"tags":["三方库"]},{"title":"函数重载","url":"/2024/05/08/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/","content":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>函数重载是指在编程语言中允许定义多个同名函数，但是他们的参数类型、参数个数或者返回类型不同，编译器或解析器会根据调用时提供的参数类型和个数来确定使用哪个函数</p>\n<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>函数重载的主要目的就是提高代码的可读性和灵活性，同时避免了为不同功能编写不同的函数名导致的变量命名冲突和混乱。</p>\n<h1 id=\"实现函数重载\"><a href=\"#实现函数重载\" class=\"headerlink\" title=\"实现函数重载\"></a>实现函数重载</h1><h2 id=\"ts\"><a href=\"#ts\" class=\"headerlink\" title=\"ts\"></a>ts</h2><p>ts中进行函数重载其实就是根据型参数组的个数和对变量进行typeof检测，然后根据不同的情况进行分支处理</p>\n<pre><code class=\"ts\">// 函数重载的声明\nfunction average(numbers: number[]): number; // 函数签名1：接受数字数组并返回数字\nfunction average(...numbers: number[]): number; // 函数签名2：接受可变数量的数字参数并返回数字\n// 函数实现\nfunction average(...args: any[]): number &#123; // 实际函数实现\n    let sum = 0;\n    if (args.length === 1 &amp;&amp; Array.isArray(args[0])) &#123; // 如果传入的是数组\n        const numbers = args[0] as number[]; // 类型断言为数字数组\n        for (const num of numbers) &#123;\n            sum += num;\n        &#125;\n        return sum / numbers.length;\n    &#125; else if (args.length &gt; 1) &#123; // 如果传入的是多个数字\n        for (const num of args) &#123;\n            sum += num;\n        &#125;\n        return sum / args.length;\n    &#125; else &#123;\n        throw new Error(&#39;Invalid arguments&#39;); // 抛出错误，不支持的参数类型\n    &#125;\n&#125;\n\n// 调用函数重载\nconsole.log(average([1, 2, 3, 4, 5])); // 输出: 3\nconsole.log(average(1, 2, 3, 4, 5)); // 输出: 3\n</code></pre>\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><p>js中也可以通过typeof和形参数组进行函数重载，不过当然还有更好的做法，jQuery作者常用如下实现函数重载（进行重载之前要调用一次函数）：</p>\n<pre><code class=\"js\">function addMethod(object,name,fn)&#123;\n    const old = object[name];\n    object[name] = function (...args)&#123;\n        if(args.length === fn.length)&#123;\n            return fn.apply(this,args);\n        &#125;else if(typeof old === &#39;function&#39;)&#123;\n            return old.apply(this,args);\n        &#125;\n    &#125;\n&#125;;\nconst searcher = &#123;&#125;; //将对象中对应属性的重载方法全部存储起来\naddMethod(searcher,&#39;getUsers&#39;,()=&gt;&#123;\n    console.log(&#39;查询所有用户&#39;);\n&#125;);\naddMethod(searcher,&#39;getUsers&#39;,(name=&#39;a&#39;)=&gt;&#123; //注意默认参数的形参数量不与计数\n    console.log(&#39;按照姓名查询用户&#39;);\n&#125;);\n\nsearcher.getUsers();\n</code></pre>\n<p>另一种实现方法就是使用映射：</p>\n<pre><code class=\"js\">function createOverload()&#123;\n    const fnMap = new Map();\n    function overload(...args)&#123;\n        const key = args.map((it) =&gt; typeof it).join(&#39;,&#39;);\n        const fn = fnMap.get(key);\n        if(!fn)&#123;\n            throw new TypeError(&#39;没有找到对应的实现&#39;);\n        &#125;\n        return fn.apply(this,args);\n    &#125;\n    overload.addImpl = function(...args)&#123;\n        const fn = args.pop();\n        if(typeof fn !== &#39;function&#39;)&#123;\n            throw new TypeError(&#39;最后一个参数必须是函数&#39;)\n        &#125;\n        const key = args.join(&#39;,&#39;);\n        fnMap.set(key,fn);\n    &#125;;\n    return overload;\n&#125;\nconst getUsers = createOverload();\ngetUsers.addImpl(()=&gt;&#123;\n    console.log(&#39;查询所有用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;number&#39;,(page,size=10)=&gt;&#123;\n    console.log(&#39;按照页码和数量查询用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;number&#39;,&#39;number&#39;,(page,size=10)=&gt;&#123;\n    console.log(&#39;按照页码和数量查询用户&#39;);\n&#125;)\ngetUsers.addImpl(&#39;string&#39;,(name)=&gt;&#123;\n    console.log(&#39;按照姓名查询用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;string&#39;,&#39;string&#39;,()=&gt;&#123;\n    console.log(&#39;按照性别查询用户&#39;);\n&#125;);\ngetUsers(&#39;asfsdf&#39;);\n</code></pre>\n<p>总结一下实现思路，通过createOverload函数调用可以返回一个重载后的函数，createOverload函数中创建了一个map，map中将参数类型和个数与对应的函数相匹配，返回的重载函数在调用时会根据参数的类型去map中寻找对应的函数，通过apply绑定this作用域和参数执行即可。</p>\n","categories":["JS"],"tags":["JS,函数重载"]},{"title":"前端性能优化","url":"/2024/03/02/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"<h1 id=\"5-1-前端性能优化\"><a href=\"#5-1-前端性能优化\" class=\"headerlink\" title=\"5-1 前端性能优化\"></a>5-1 前端性能优化</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>任何小型企业，博主或成长型公司在网上出现时面临的最大挑战之一就是“页面加载时间”问题。除非您能确保尽可能快速无缝地加载每个页面，您才可以拥有世界上最好最引人注目的网站，否则您仍然无法赢得关注者的尊重和忠诚度。</p>\n<p>根据当今网络上的所有主要浏览器公司的说法，如果每个网站都想要排名靠前，表现良好并确保客户满意，那么每个网站都需要快。毕竟，如果您的网页加载速度很慢，那么您会立即增加客户开始在其他地方搜索信息，而不是坚持下去的风险。</p>\n<p>这也是为什么很多公司去找专门的技术人员来做SEO（<strong>Search Engine Optimization</strong>），即搜索引擎优化。 因为，页面的加载会影响到爬虫的爬取，页面加载速度是一项非常重要的指标。况且，页面优化直接影响到了用户体验。所以学习前端性能优化势在必行。</p>\n<p><strong>经常有面试官会问：从用户输入浏览器输入url到页面最后呈现 有哪些过程？有什么办法能优化页面性能？</strong></p>\n<p>答案大致如下：</p>\n<ol>\n<li>用户输入URL地址</li>\n<li>浏览器解析URL解析出主机名</li>\n<li>浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）</li>\n<li>浏览器将端口号从URL中解析出来</li>\n<li>浏览器建立一条与目标Web服务器的TCP连接（三次握手）</li>\n<li>浏览器向服务器发送一条HTTP请求报文</li>\n<li>服务器向浏览器返回一条HTTP响应报文</li>\n<li>关闭连接 浏览器解析文档</li>\n<li>如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕</li>\n</ol>\n<p><img data-src=\"/images/image-20190619100048897.png\" alt=\"/images/image-20190619100048897\"></p>\n<p>再深一点层次：会问到<strong>渲染机制</strong>，重排、重绘</p>\n<p>重排：</p>\n<ol>\n<li><p>定义：DOM结构中的各个元素都有自己的盒子(模型)，这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。</p>\n</li>\n<li><p>触发Reflow：</p>\n<ul>\n<li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li>\n<li>当你移动DOM的位置，或是搞个动画的时候</li>\n<li>当你修改CSS样式的时候</li>\n<li>当你Resize窗口的时候(移动端没有这个问题)，或者是滚动的时候</li>\n<li>当你修改网页的</li>\n</ul>\n<blockquote>\n<p>最常问：如何减少Reflow?或者避免Reflow？</p>\n</blockquote>\n</li>\n</ol>\n<p>重绘：</p>\n<ol>\n<li><p>定义：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为repaint。</p>\n<blockquote>\n<p>页面要呈现的内容，通通都绘制到页面上。</p>\n</blockquote>\n</li>\n<li><p>触发Repaint</p>\n<ul>\n<li>DOM改动</li>\n<li>CSS改动</li>\n</ul>\n<blockquote>\n<p>最常问：如何避免最小程序的Repaint？</p>\n</blockquote>\n</li>\n</ol>\n<p>既然页面的性能优化这么重要，<strong>你知道有哪些原因是影响页面性能的？</strong>比如…</p>\n<ul>\n<li>HTTP请求</li>\n<li>复杂的页面逻辑(JS设计)</li>\n<li>重度的DOM操作</li>\n<li>服务端响应</li>\n<li>大量的数据</li>\n</ul>\n<p>…</p>\n<p><strong>有哪些办法可以加速我们的页面性能？比如…</strong></p>\n<ul>\n<li>资源压缩与合并（代码打包）</li>\n<li>异步加载</li>\n<li>CDN</li>\n<li>DNS预解析</li>\n<li>缓存</li>\n</ul>\n<p>…</p>\n<p><strong>主要内容：</strong></p>\n<ul>\n<li>页面加载缓慢原因分析</li>\n<li>性能优化原则</li>\n<li>优化工具介绍</li>\n<li>浏览器的工作机制，了解一些基本常识的原理：<ol>\n<li>为什么要将js放到页脚部分</li>\n<li>引入样式的几种方式的权重</li>\n<li>css属性书写顺序建议</li>\n<li>何种类型的DOM操作是耗费性能的</li>\n</ol>\n</li>\n</ul>\n<p><strong>收获</strong></p>\n<ul>\n<li>前端页面优化，为成为SEO路添砖加瓦</li>\n<li>写出优质代码，页面性能蹭蹭蹭的往上走</li>\n<li>面试如果提到页面优化，可以娓娓道来，牛皮吹的飞起…</li>\n<li>几种常见的页面优化工具的使用PageSpeed，JSPerf</li>\n</ul>\n<p><strong>准备：</strong></p>\n<ul>\n<li>注册github账号</li>\n</ul>\n<h2 id=\"页面性能优化\"><a href=\"#页面性能优化\" class=\"headerlink\" title=\"页面性能优化\"></a>页面性能优化</h2><p>前端性能优化可以分为两大部分：浏览器部分、代码部分。</p>\n<p>浏览器部分又可以分为：</p>\n<ul>\n<li>网络层面</li>\n<li>浏览器渲染层面</li>\n<li>服务端层面</li>\n</ul>\n<p>代码部分又可以分为：</p>\n<ul>\n<li>构建层面</li>\n<li>编码层面</li>\n<li>机制(SSR，英文Server Side Render：服务器端渲染)</li>\n<li>规范</li>\n</ul>\n<p>首先来看看浏览器部分：前端的页面主要在浏览器上运行着，那么我们追根溯源，从浏览器的原理开始，研究如何进行页面性能优化。</p>\n<h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 <span class=\"exturl\" data-url=\"aHR0cDovL2dzLnN0YXRjb3VudGVyLmNvbS8=\">StatCounter 浏览器统计数据</span>，目前（2019年 6 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率 62.7%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。</p>\n<p><img data-src=\"/images/image-20190618165435861.png\" alt=\"/images/image-20190618165435861\"></p>\n<h4 id=\"浏览器的主要作用\"><a href=\"#浏览器的主要作用\" class=\"headerlink\" title=\"浏览器的主要作用\"></a>浏览器的主要作用</h4><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这些网络资源包括以下内容：</p>\n<ul>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript的</li>\n<li>媒体（图片，视频等）</li>\n</ul>\n<p>也可以分为HTML文档(HTML&#x2F;CSS&#x2F;JS)、PDF、图片、视频和其他类型。</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p>\n<p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p>\n<ul>\n<li>用来输入 URI 的地址栏</li>\n<li>前进和后退按钮</li>\n<li>书签设置选项</li>\n<li>用于刷新和停止加载当前文档的刷新和停止按钮</li>\n<li>用于返回主页的主页按钮</li>\n</ul>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。</p>\n<p><strong>有一些比较有趣的事情：</strong></p>\n<p>Safari是乔布斯在2003年的Macworld大会发布的，9年过去了，08年才发展起来的Chrome用了不到Safari一半的时间远远把Safari甩在了后面，这让Safari情何以堪。</p>\n<p>两大浏览器都是基于苹果的布局引擎Webkit，按道理Safari是占优势的，因为两者都分别是自己操作系统的默认浏览器，许多人就顺便使用了，懒得去下载别的浏览器。</p>\n<p>许多人可能会想，这还不简单，Chrome运行于Windows操作系统，而Safari大部分时候都用于苹果自己的系统，Windows .VS. OS X，哪个使用人群广？很显然是前者，所以Chrome当然比Safari发真快，<strong>可是，实际上Safari要比Chrome更早登陆Windows。</strong></p>\n<p>在2007年六月，Safari for Windows Beta版就已经发布，正式版于2008年三月发布，而Chrome直到2008年的九月才发布，Chrome只用了一年的时间就超过了Safari。</p>\n<p>大量Benchmark测试表明Chrome不管在网页打开还是JavaScript表现方面，速度都最快。</p>\n<p>但是，当Safari发布Windows版的时候，测试结果也是一样的，不管在Mac还是PC上测试，那时候都是最快的，如果仅仅是因为速度，那么Safari在2007年六月的表现就应该和chrome在2008年九月的时候一样。</p>\n<p>难道Chrome胜在插件？也许，不过Safari在2010年年中的时候也有了许多插件，当然，Chrome的插件质量更好更丰富，如果这也足够让Safari落后于Chrome，那么开发商们可能早就将游戏植入Chrome，而且，Firefox也先于Chrome和Safari植入插件，现在不也败给了Chrome吗？</p>\n<p>主要原因：</p>\n<ol>\n<li>Safari用起来不舒服，google推广给力</li>\n<li>独特的用户体验(UI、交互、云、Google全家桶)</li>\n</ol>\n<p><strong>那么Safari就一文不值了？</strong></p>\n<p>但是，Mac上的用户使用safari更加的省电、省资源，稳定性会更好。<strong>插件不需要爬梯子！！！</strong>更低的学习成本。</p>\n<p><strong>IE(Internet Explorer)的黑历史：</strong></p>\n<p>IE 浏览器的开发应该是在 1994 年中开始的，那是我还在读大学。微软为了对抗当时的主流浏览器 NetScape，准备开发自己的浏览器并在 Windows 中默认捆绑销售。但是，留给微软的时间并不充裕，他们没时间从零开始，于是和 Spyglass 合作开发，于是，计算机历史上最著名也最臭名昭著的浏览器 IE 诞生了。因为强大的功能和捆绑策略，IE 迅速击败了 NetScape，成为浏览器市场的绝对霸主。</p>\n<p>在 2002 年，IE 已经拥有了95%的市场份额，几乎打败了所有的竞争对手。大为僵，又不思进取，于是颠覆者前仆后继。Firefox 开始迅速崛起，Chrome 后来居上，反观 IE，出现了各种安全漏洞和兼容性问题。2006年，IE 被评为“史上第八糟科技产品”。在相当长的时间里，<strong>IE 浏览器是前端程序员员的噩梦</strong>。</p>\n<p>带给我们的思考：</p>\n<ul>\n<li>软件迭代更新的重要性(居安思危)</li>\n<li>用户体验、用户感知的重要性(人性化产品)</li>\n<li>互联网时代，什么都是可以替代的</li>\n<li>分享、免费、共筑共赢才是互联网的精神</li>\n</ul>\n<h4 id=\"浏览器的组成结构\"><a href=\"#浏览器的组成结构\" class=\"headerlink\" title=\"浏览器的组成结构\"></a>浏览器的组成结构</h4><p><img data-src=\"/images/layers.png\" alt=\"img\"></p>\n<ol>\n<li><p><strong>用户界面（User Interface）</strong> - 包括地址栏、前进&#x2F;后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</p>\n</li>\n<li><p><strong>浏览器引擎（Browser engine）</strong> - 在用户界面和渲染引擎之间传送指令。</p>\n</li>\n<li><p><strong>渲染引擎（Rendering engine）</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</p>\n<blockquote>\n<p>也可以叫呈现引擎（Rendering Engine）或者布局引擎（Layout Engine）</p>\n</blockquote>\n<p>默认情况下，渲染引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p>\n<p>浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种渲染引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的渲染引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p>\n<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th>渲染引擎（开发语言）</th>\n<th>脚本引擎（开发语言）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Chrome</td>\n<td>Blink (c++)</td>\n<td>V8 (c++)</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td>Blink (c++)</td>\n<td>V8 (c++)</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Webkit (c++)</td>\n<td>JavaScript Core (nitro)</td>\n</tr>\n<tr>\n<td>FireFox</td>\n<td>Gecko (c++)</td>\n<td>SpiderMonkey (c&#x2F;c++)</td>\n</tr>\n<tr>\n<td>Edge</td>\n<td>EdgeHTML (c++)</td>\n<td>Chakra JavaScript Engine (c++)</td>\n</tr>\n<tr>\n<td>IE</td>\n<td>Trident (c++)</td>\n<td>Chakra JScript Engine (c++)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Firefox在2017年启用了新的web引擎Quantum，Quantum 以 Gecko 引擎为基础，同时利用了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS9ydXN0LWxhbmcvcnVzdA==\">Rust</span> 的良好并发性和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlcnZvL3NlcnZv\">Servo</span> 的高性能组件，为 Firefox 带来了更多的并行化和 GPU 运算，让 Firefox 更快更可靠。</p>\n<p>2015 年 3 月，微软将放弃自家Edge：转而开发Chromium内核浏览器。</p>\n</blockquote>\n<p>它们的开发时间轴：</p>\n<p><img data-src=\"/images/image-20190618172835156.png\" alt=\"/images/image-20190618172835156\"></p>\n<p>WebKit 是一种开放源代码渲染引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 <span class=\"exturl\" data-url=\"aHR0cDovL3dlYmtpdC5vcmcv\">webkit.org</span></p>\n</li>\n<li><p><strong>网络（Networking）</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</p>\n</li>\n<li><p><strong>用户界面后端（UI Backend）</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</p>\n</li>\n<li><p><strong>JavaScript 解释器（JavaScript Interpreter）</strong>。用于解析和执行 JavaScript 代码，如 V8 引擎。</p>\n<p>JS引擎线程负责解析Javascript脚本，运行代码。</p>\n<p><strong>JS引擎一直等待任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中只有一个JS线程在运行</strong></p>\n</li>\n<li><p><strong>数据存储（Data Persistence）</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</p>\n</li>\n</ol>\n<h4 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h4><blockquote>\n<p>进程线程简单的理解：进程里面可以有多个线程，进程就是QQ，线程就是会话。</p>\n</blockquote>\n<ul>\n<li>浏览器是多进程的</li>\n<li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>\n<li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。</li>\n</ul>\n<p>浏览器里面的进程：</p>\n<ol>\n<li><p>Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有</p>\n<ul>\n<li>负责浏览器界面显示，与用户交互。如前进，后退等</li>\n<li>负责各个页面的管理，创建和销毁其他进程</li>\n<li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li>\n<li>网络资源的管理，下载等</li>\n</ul>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p>\n</li>\n<li><p>GPU进程：最多一个，用于3D绘制等</p>\n</li>\n<li><p>渲染进程（浏览器内核）（Renderer进程，内部是多线程的）</p>\n<ul>\n<li>默认每个Tab页面一个进程，互不影响。</li>\n<li>主要作用为页面渲染，脚本执行，事件处理等</li>\n</ul>\n</li>\n</ol>\n<p>渲染进程是多线程的：</p>\n<ol>\n<li><p>GUI渲染线程</p>\n<ul>\n<li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li>\n<li><strong>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</strong></li>\n<li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li>\n</ul>\n</li>\n<li><p>js引擎线程</p>\n<ul>\n<li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li>\n<li>JS引擎线程负责解析Javascript脚本，运行代码。</li>\n<li><strong>JS引擎一直等待任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中只有一个JS线程在运行</strong></li>\n<li><strong>同样注意，GUI渲染线程与JS引擎线程是互斥的。所以如果JS执行的时间过长，要放在body下面，否则就会导致页面渲染加载阻塞。</strong></li>\n</ul>\n</li>\n<li><p>事件触发线程</p>\n<ul>\n<li>管理着事件队列</li>\n<li>监听事件，符合条件时把回调函数放入事件队列中</li>\n</ul>\n</li>\n<li><p>定时触发器线程</p>\n<ul>\n<li>setInterval与setTimeout在此线程中计时完毕后，把回调函数放入事件队列中</li>\n<li><strong>浏览器定时计数器并不是由JavaScript引擎计数的</strong>,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确），因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li>\n<li>注意，W3C在HTML标准中规定，规定要求<strong>setTimeout中低于4ms的时间间隔算为4ms</strong>。</li>\n</ul>\n</li>\n<li><p>异步http请求线程</p>\n<ul>\n<li>检测到XHR对象状态变化时，将回调函数放入事件队列中</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li>\n</ul>\n<p>了解 一下，执行线：</p>\n<p><img data-src=\"/images/image-20190619165952240.png\" alt=\"/images/image-20190619165952240\"></p>\n</li>\n</ol>\n<p><strong>渲染线程与JS引擎线程互斥</strong></p>\n<p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>\n<p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p>\n<p>举一个简单的例子：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n      // 页面上的hello world不会变成红色\n      document.getElementById(&quot;app&quot;).style.color = &quot;red&quot;;\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      hello world!\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><strong>JS阻塞页面加载</strong></p>\n<p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p>\n<p>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p>\n<p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>\n<p>总结一下：</p>\n<ul>\n<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建），但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</li>\n<li>Javascript 阻塞 DOM 解析</li>\n</ul>\n<h4 id=\"浏览器的渲染机制\"><a href=\"#浏览器的渲染机制\" class=\"headerlink\" title=\"浏览器的渲染机制\"></a>浏览器的渲染机制</h4><p>对于渲染，我们首先需要了解一个概念：设备刷新率。</p>\n<p>设备刷新率是设备屏幕渲染的频率，通俗一点就是，把屏幕当作墙，设备刷新率就是多久重新粉刷一次墙面。基本我们平常接触的设备，如手机、电脑，它们的默认刷新频率都是60FPS，也就是屏幕在1s内渲染60次，约16.7ms渲染一次屏幕。</p>\n<p>这就意味着，我们的浏览器最佳的渲染性能就是所有的操作在一帧16.7ms内完成，能否做到一帧内完成直接决定着渲染性，影响用户交互。</p>\n<p>渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的<strong>基本流程</strong>：</p>\n<p><img data-src=\"/images/flow.png\" alt=\"img\"></p>\n<p>渲染引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI0RPTQ==\">DOM</span> 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI1JlbmRlcl90cmVlX2NvbnN0cnVjdGlvbg==\">呈现树</span>。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI2xheW91dA==\">布局</span>”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI1BhaW50aW5n\">绘制</span> - 渲染引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p>\n<blockquote>\n<p>那么我们知道了，CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要。</p>\n</blockquote>\n<p>具体的流程：</p>\n<ul>\n<li>DOM 树与 CSSOM 树合并后形成渲染树。</li>\n<li>渲染树只包含渲染网页所需的节点。</li>\n<li>布局计算每个对象的精确位置和大小。</li>\n<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。</li>\n</ul>\n<p><img data-src=\"/images/render-tree-construction.png\" alt=\"DOM CSSOM RenderTree\"></p>\n<blockquote>\n<p>请注意 <code>visibility: hidden</code> 与 <code>display: none</code> 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (<code>display: none</code>) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。</p>\n</blockquote>\n<p>我们以webkit的渲染作为示例：</p>\n<p><img data-src=\"/images/webkitflow.png\" alt=\"img\"></p>\n<p>我们可以使用调试工具来看一个真实的例子：</p>\n<p><img data-src=\"/images/image-20190618182337662.png\" alt=\"/images/image-20190618182337662\"></p>\n<p><code>script</code>标签的处理</p>\n<p>JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在解析HTML时，一旦碰到<code>script</code>，就会立即停止HTML的解析（而CSS不会），执行JS，再返还控制权。</p>\n<p>事实上，JS执行前不仅仅是停止了HTML的解析，它还必须等待CSS的解析完成。当浏览器碰到<code>script</code>元素时，发现该元素前面的CSS还未解析完，就会等待CSS解析完成，再去执行JS。</p>\n<p>JS阻塞了HTML的解析，也阻塞了其后的CSS解析，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。一个script标签，推迟了DOM的生成、CSSOM的生成以及之后的所有渲染过程，从性能角度上讲，将<code>script</code>放在页面底部，也就合情合理了。</p>\n<p>简单来说：渲染线程与JS引擎线程是互斥的，当JS引擎执行时渲染线程会被挂起（相当于被冻结了），渲染更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>\n<p>总结一下：</p>\n<p>浏览器的渲染流程分为：</p>\n<ul>\n<li>DOM树构建 </li>\n<li>CSSOM树构建 </li>\n<li>RenderObject树构建 </li>\n<li>布局</li>\n<li>绘制</li>\n</ul>\n<h4 id=\"重排reflow与重绘repaint\"><a href=\"#重排reflow与重绘repaint\" class=\"headerlink\" title=\"重排reflow与重绘repaint\"></a>重排reflow与重绘repaint</h4><p><strong>重排reflow</strong></p>\n<p>reflow指的是重新计算页面布局。</p>\n<p>某个节点reflow时会重新计算节点的尺寸和位置，而且还有可能触发其子节点、祖先节点和页面上的其他节点reflow。在这之后再触发一次repaint。</p>\n<p>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流,每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>\n<p>导致reflow的操作</p>\n<ul>\n<li>调整窗口大小</li>\n<li>改变字体</li>\n<li>增加或者移除样式表</li>\n<li>内容变化，比如用户在input框中输入文字</li>\n<li>激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)</li>\n<li>操作 class 属性</li>\n<li>脚本操作 DOM</li>\n<li>计算 offsetWidth 和 offsetHeight 属性</li>\n<li>设置 style 属性的值</li>\n</ul>\n<p>触发页面重布局的一些css属性</p>\n<ul>\n<li>盒子模型相关属性会触发重布局<ul>\n<li><code>width</code></li>\n<li><code>height</code></li>\n<li><code>padding</code></li>\n<li><code>margin</code></li>\n<li><code>display</code></li>\n<li><code>border-width</code></li>\n<li><code>border</code></li>\n<li><code>min-height</code></li>\n</ul>\n</li>\n<li>定位属性及浮动也会触发重布局<ul>\n<li><code>top</code></li>\n<li><code>bottom</code></li>\n<li><code>left</code></li>\n<li><code>right</code></li>\n<li><code>position</code></li>\n<li><code>float</code></li>\n<li><code>clear</code></li>\n</ul>\n</li>\n<li>改变节点内部文字结构也会触发重布局<ul>\n<li><code>text-align</code></li>\n<li><code>overflow-y</code></li>\n<li><code>font-weight</code></li>\n<li><code>overflow</code></li>\n<li><code>font-family</code></li>\n<li><code>line-height</code></li>\n<li><code>vertical-align</code></li>\n<li><code>white-space</code></li>\n<li><code>font-size</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>重绘repaint</strong></p>\n<p>repiant或者redraw遍历所有的节点检测各节点的可见性、颜色、轮廓等可见的样式属性，然后根据检测的结果更新页面的响应部分。</p>\n<p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘</p>\n<p>只触发重绘不触发重排的一些CSS属性：</p>\n<ul>\n<li><code>color</code></li>\n<li><code>border-style</code>、<code>border-radius</code></li>\n<li><code>visibility</code></li>\n<li><code>text-decoration</code></li>\n<li><code>background</code>、<code>background-image</code>、<code>background-position</code>、<code>background-repeat</code>、<code>background-size</code></li>\n<li><code>outline</code>、<code>outline-color</code>、<code>outline-style</code>、<code>outline-width</code></li>\n<li><code>box-shadow</code></li>\n</ul>\n<p>我们来看一个例子：</p>\n<pre><code class=\"javascript\">var bstyle = document.body.style; // cache\n\nbstyle.padding = &quot;20px&quot;; // reflow, repaint\nbstyle.border = &quot;10px solid red&quot;; //  再一次的 reflow 和 repaint\n\nbstyle.color = &quot;blue&quot;; // repaint\nbstyle.backgroundColor = &quot;#fad&quot;; // repaint\n\nbstyle.fontSize = &quot;2em&quot;; // reflow, repaint\n\n// new DOM element - reflow, repaint\ndocument.body.appendChild(document.createTextNode(&#39;dude!&#39;));\n</code></pre>\n<p>当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。</p>\n<p>但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：</p>\n<p><strong>减少重绘与重排：</strong></p>\n<p>重绘和回流在实际开发中是很难避免的，我们能做的就是尽量减少这种行为的发生。</p>\n<ul>\n<li><p>js尽量少访问dom节点和css 属性，尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。(虚拟DOM)</p>\n</li>\n<li><p>减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。</p>\n</li>\n<li><p>不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸</p>\n</li>\n<li><p>尽量通过class来设计元素样式，切忌用style 多次操作单个属性</p>\n<pre><code class=\"javascript\">// bad\nvar left = 10,\ntop = 10;\nel.style.left = left + &quot;px&quot;;\nel.style.top  = top  + &quot;px&quot;;\n\n// Good\nel.className += &quot; theclassname&quot;;\n\n// Good\nel.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;\n</code></pre>\n</li>\n<li><p>尽可能的为产生动画的 HTML 元素使用 <code>fixed</code> 或 <code>absolute</code> 的 <code>position</code> ，那么修改他们的 CSS 是不会 Reflow 的。</p>\n</li>\n<li><p>img标签要设置高宽，以减少重绘重排</p>\n</li>\n<li><p>把DOM离线后修改，如将一个dom脱离文档流，比如<code>display：none</code> ，再修改属性，这里只发生一次回流。</p>\n</li>\n<li><p>尽量用 <code>transform</code> 来做形变和位移，不会造成回流</p>\n</li>\n<li><p>权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。</p>\n</li>\n<li><p>不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，</p>\n</li>\n<li><p>避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。</p>\n</li>\n</ul>\n<blockquote>\n<p>PS:  display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。</p>\n</blockquote>\n<p>总结一下：</p>\n<p>重排：元素的尺寸变了、位置变了</p>\n<p>重绘：元素的颜色、背景、边框、轮廓变了，但是，元素的几何尺寸没有变。</p>\n<p>Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。</p>\n<h3 id=\"页面加载缓慢的原因\"><a href=\"#页面加载缓慢的原因\" class=\"headerlink\" title=\"页面加载缓慢的原因\"></a>页面加载缓慢的原因</h3><p><img data-src=\"/images/browser-rendering.gif\" alt=\"browser-rendering\"></p>\n<p><img data-src=\"/images/backend-generation.gif\" alt=\"backend-generation\"></p>\n<p><img data-src=\"/images/wpo-front-backend.png\" alt=\"wpo-front-backend\"></p>\n<h4 id=\"浏览器部分\"><a href=\"#浏览器部分\" class=\"headerlink\" title=\"浏览器部分\"></a>浏览器部分</h4><ul>\n<li><p>网络层面</p>\n<ol>\n<li><p>过多的HTTP请求</p>\n<p>打开一个网页的时候，后台程序的响应并不所需太多时间，等待的时间主要花费在下载网页元素上了，即HTML、CSS、JavaScript、Flash、图片等。据统计，每增加一个元素，网页载入的时间就会增加25-40毫秒（具体取决于用户的带宽情况）。</p>\n</li>\n<li><p>资源访问带宽小</p>\n<p>两方面，一方面是客户端的带宽，一方面是服务器端的带宽。</p>\n</li>\n<li><p>网页元素(图片、视频、样式)太大</p>\n</li>\n</ol>\n</li>\n<li><p>浏览器渲染层面</p>\n<ol>\n<li><p>渲染阻塞：</p>\n<p>浏览器想要渲染一个页面就必须先构建出<code>DOM</code>树与<code>CSSOM</code>树，如果<code>HTML</code>与<code>CSS</code>文件结构非常庞大与复杂，这显然会给页面加载速度带来严重影响。</p>\n<p>所谓渲染阻塞资源，即是对该资源发送请求后还需要先构建对应的<code>DOM</code>树或<code>CSSOM</code>树，这种行为显然会延迟渲染操作的开始时间。</p>\n<p>JS阻塞与CSS阻塞：</p>\n<p><strong>HTML、CSS、JavaScript都是会对渲染产生阻塞的资源，HTML是必需的（没有DOM还谈何渲染），但还可以从CSS与JavaScript着手优化，尽可能地减少阻塞的产生。</strong></p>\n</li>\n<li><p>重复渲染</p>\n</li>\n<li><p>DNS解析</p>\n</li>\n</ol>\n</li>\n<li><p>服务端层面</p>\n<ol>\n<li>硬件配置低：这个是双向的</li>\n<li>服务器软件，比如防火墙、内网策略等</li>\n<li>未对Nginx这类web服务器进行配置优化</li>\n<li>CPU占满、数据库未优化</li>\n<li>代码问题，代码效率，代码性能</li>\n<li>包含了过多的分析类工具</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"代码部分\"><a href=\"#代码部分\" class=\"headerlink\" title=\"代码部分\"></a>代码部分</h4><ul>\n<li><p>构建层面</p>\n<p>未对代码进行打包、压缩、兼容性优化。</p>\n<p>未合并重复的请求、代码。</p>\n</li>\n<li><p>编码层面</p>\n<p>没有良好的编码习惯，错误的编排JS与CSS</p>\n<p>for循环、迭代、同步、重定向、阻塞请求</p>\n<p>未删除重复、无用的代码</p>\n<p>未对逻辑业务复杂的代码进行重构，了解设计模式，对业务进行疏理</p>\n</li>\n<li><p>机制(SSR，英文Server Side Render：服务器端渲染)</p>\n<p>未加入Async异步机制</p>\n<p>未思考页面加载、用户体验</p>\n</li>\n<li><p>规范</p>\n<p>CSS规范</p>\n<p>HTML规范&#x2F;HTML5规范</p>\n<p>Airbnb代码规范等。</p>\n</li>\n</ul>\n<h3 id=\"优化原则\"><a href=\"#优化原则\" class=\"headerlink\" title=\"优化原则\"></a>优化原则</h3><h4 id=\"尽量减少HTTP请求\"><a href=\"#尽量减少HTTP请求\" class=\"headerlink\" title=\"尽量减少HTTP请求\"></a>尽量减少HTTP请求</h4><p>在浏览器(客户端)和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。</p>\n<p>一个正常HTTP请求的流程简述：如在浏览器中输入”<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy54eHh4eHguY29t\">www.xxxxxx.com&quot;并按下回车，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。</span></p>\n<p>而当我们请求的网页文件中有很多图片、CSS、JS甚至音乐等信息时，将会频繁的与服务器建立连接，与释放连接，这必定会造成资源的浪费，且每个HTTP请求都会对服务器和浏览器产生性能负担。</p>\n<p>网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要耗费的网络资源更多。所以，请减少HTTP请求。</p>\n<p><strong>具体的方法：</strong></p>\n<ol>\n<li><p>组合文件，优化图片，使用sprites设计风格: 将背景图片合并成一个文件，通过<code>background-image</code> 和 <code>background-position</code> 控制显示；</p>\n<p>确保您的图像不大于它们所需的图像，它们采用正确的文件格式（PNG通常更适用于少于16种颜色的图形，而JPEG通常更适合照片）并且它们是针对Web压缩的。</p>\n<p>使用CSS sprites在网站上经常使用的图像创建模板，如按钮和图标。CSS sprites将您的图像组合成一个大图像，一次加载所有（这意味着更少的HTTP请求），然后只显示您想要显示的部分。这意味着您通过不让用户等待加载多个图像来节省加载时间。</p>\n<p>有一些在线工具：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zcHJpdGVjb3cuY29tLw==\">Sprite Cow</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3ByaXRlYm94Lm5ldC8=\">Spritebox</span></li>\n</ul>\n</li>\n<li><p>肉联图片，使用<code>data:URL</code>方案将图像数据嵌入实际页面中。这可以增加HTML文档的大小。将内嵌图像组合到（缓存的）样式表中是一种减少HTTP请求并避免增加页面大小的方法。</p>\n</li>\n<li><p>简化页面的设计</p>\n</li>\n</ol>\n<h4 id=\"使用内容传送网络CDN\"><a href=\"#使用内容传送网络CDN\" class=\"headerlink\" title=\"使用内容传送网络CDN\"></a>使用内容传送网络CDN</h4><p>内容分发网络（CDN），也称为内容传送网络，是用于分发传送内容的负载的服务器网络。从本质上讲，您网站的副本存储在多个地理位置不同的数据中心，以便用户可以更快，更可靠地访问您的网站。</p>\n<p>对于初创公司和私人网站来说，CDN服务的成本可能过高，但随着您的目标受众变得越来越大并变得更加全球化，CDN对于实现快速响应时间是必要的。</p>\n<p>请记住，最终用户响应时间的80-90％用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是<em>Performance Golden Rule</em>。而不是从重新设计应用程序架构的艰巨任务开始，最好首先分散您的静态内容。这不仅可以大大缩短响应时间，而且由于内容交付网络，它更容易实现。</p>\n<p>内容传送网络（CDN）是分布在多个位置的Web服务器的集合，以更有效地向用户传送内容。选择用于向特定用户传送内容的服务器通常基于网络接近度的度量。例如，选择具有最少网络跳数的服务器或具有最快响应时间的服务器。</p>\n<blockquote>\n<p>CDN服务商有很多，这里就不再多说：专门做CDN服务器的蓝讯、网宿、帝联、快网，还有阿里云、腾讯云、华为云等。国外如<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ha2FtYWkuY29tLw==\">Akamai Technologies</span>，<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5lZGdlY2FzdC5jb20v\">EdgeCast</span>或<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZXZlbDMuY29tL2luZGV4LmNmbT9wYWdlSUQ9MzY=\">level3</span></p>\n</blockquote>\n<p>除了去购买一些CDN服务商的服务以外，对于大多数开发者，可以使用公共CDN网络上的资源，如以下的方式去使用CDN加速：</p>\n<pre><code class=\"html\">&lt;!-- google --&gt;\n&lt;script\n  type=&quot;text/javascript&quot;\n  src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js&quot;\n&gt;&lt;/script&gt;\n\n&lt;!-- cdnjs --&gt;\n&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n\n&lt;!-- qiniu cloud --&gt;\n&lt;script src=&quot;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n\n&lt;!-- other cdn --&gt;\n&lt;script\n  crossorigin=&quot;anonymous&quot;\n  integrity=&quot;sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh&quot;\n  src=&quot;https://lib.baomitu.com/jquery/3.4.1/jquery.min.js&quot;\n&gt;&lt;/script&gt;\n</code></pre>\n<h4 id=\"避免空src或者是href值\"><a href=\"#避免空src或者是href值\" class=\"headerlink\" title=\"避免空src或者是href值\"></a>避免空src或者是href值</h4><p>空的src和href都会导致多余的HTTP请求，虽然不影响加载时间，但是会对服务器产生不必要的流量和压力。浏览器仍然会向服务器发起一个 HTTP 请求：</p>\n<ul>\n<li>IE 向页面所在的目录发送请求</li>\n<li>Safari、Chrome、Firefox 向页面本身发送请求</li>\n<li>Opera 不执行任何操作</li>\n</ul>\n<p>空的src的image严重的以至于影响整个网站的用户体验，空 <code>src</code> 产生请求的后果不容小憩：</p>\n<ul>\n<li>给服务器造成意外的流量负担，尤其时日 PV 较大时；</li>\n<li>浪费服务器计算资源；</li>\n<li>可能产生报错。</li>\n</ul>\n<p>有两种形式：</p>\n<ol>\n<li><p>HTML形式</p>\n<pre><code class=\"html\">&lt;img src=&quot;&quot;&gt;\n&lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n</code></pre>\n</li>\n<li><p>JavaScript形式</p>\n<pre><code class=\"javascript\">var img = new Image();\nimg.src = &quot;&quot;;\n</code></pre>\n</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>删除空的<code>src</code>和<code>href</code>标签</li>\n<li>给<code>a</code>标签的<code>href</code>属性，连接到实际的页面：</li>\n</ol>\n<pre><code class=\"html\">&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;#nogo&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;##&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;###&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;void(0);&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;void(0)&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;;&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n</code></pre>\n<ol start=\"3\">\n<li>禁止跳转，添加<code>cursor:pointer</code>样式</li>\n</ol>\n<pre><code class=\"html\">&lt;style&gt;\n    a&#123;cursor: pointer&#125;\n&lt;/style&gt;\n&lt;a&gt;点击一&lt;/a&gt;\n&lt;a onclick=&quot;doSomething()&quot;&gt;点击二&lt;/a&gt;\n</code></pre>\n<ol start=\"4\">\n<li>给<code>a</code> 标签创建一个带有描述信息的<code>href</code> 属性，并监控<code>click</code>事件调用<code>preventDefault()</code>函数。</li>\n</ol>\n<pre><code class=\"html\">&lt;a href=&quot;#Something_De scriptive&quot; id=&quot;my_id&quot;&gt;Trigger&lt;/a&gt;\n&lt;script&gt;\n    $(&quot;#my_id&quot;).click(function(e)&#123;\n        e.preventDefault(); //取消单击事件的默认动作以阻止链接的跳转。\n        //  其他的代码\n&#125;)\n&lt;/script&gt;\n</code></pre>\n<p>优点：</p>\n<ul>\n<li>让<code>&lt;a&gt;</code>够响应键盘事件并获得焦点（从而屏幕阅读器能够读出背后的内容，增强可访问性）</li>\n<li>优雅降级，在网络连接很差，还没有加载到CSS的时候，<code>&lt;a&gt;</code>依然有手型与正常的link样式。</li>\n</ul>\n<h4 id=\"gzip的组件\"><a href=\"#gzip的组件\" class=\"headerlink\" title=\"gzip的组件\"></a>gzip的组件</h4><p>所有现代浏览器都支持 <code>gzip</code> 压缩并会为所有 HTTP 请求自动协商此类压缩。启用 <code>gzip</code> 压缩可大幅缩减所传输的响应的大小（最多可缩减 90%），从而显著缩短下载相应资源所需的时间、减少客户端的流量消耗并加快网页的首次呈现速度。 </p>\n<p>从HTTP &#x2F; 1.1开始，Web客户端表示支持使用HTTP请求中的Accept-Encoding标头进行压缩。</p>\n<pre><code>Accept-Encoding：gzip，deflate\n</code></pre>\n<p>压缩包括XML和JSON在内的任何文本响应都是值得的。不应对图像和PDF文件进行gzip压缩，因为它们已经过压缩。试图对它们进行gzip不仅会浪费CPU，还可能会增加文件大小。</p>\n<p>比如，在nginx中开启gzip压缩：</p>\n<pre><code class=\"bash\"># 开启gzip\ngzip on;\n# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩\ngzip_min_length 1k;\n# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明\ngzip_comp_level 2;\n# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;\n# 是否在http header中添加Vary: Accept-Encoding，建议开启\ngzip_vary on;\n# 禁用IE 6 gzip\ngzip_disable &quot;MSIE [1-6]\\.&quot;;\n</code></pre>\n<p>其他web容器启动gzip的方法：</p>\n<ul>\n<li>Apache：使用 <span class=\"exturl\" data-url=\"aHR0cDovL2h0dHBkLmFwYWNoZS5vcmcvZG9jcy9jdXJyZW50L21vZC9tb2RfZGVmbGF0ZS5odG1s\">mod_deflate</span></li>\n<li>Nginx：使用 <span class=\"exturl\" data-url=\"aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfZ3ppcF9tb2R1bGUuaHRtbA==\">ngx_http_gzip_module</span></li>\n<li>IIS：<span class=\"exturl\" data-url=\"aHR0cDovL3RlY2huZXQubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjNzcxMDAzKHY9V1MuMTApLmFzcHg=\">配置 HTTP 压缩功能</span></li>\n</ul>\n<h4 id=\"CSS放在顶部，JS放在底部\"><a href=\"#CSS放在顶部，JS放在底部\" class=\"headerlink\" title=\"CSS放在顶部，JS放在底部\"></a>CSS放在顶部，JS放在底部</h4><p>把Javascript脚本在底部，删除阻止渲染的JavaScript<br>在HTML文件<code>&lt;body&gt;</code>中指定外部样式表和内联样式块可能对浏览器的渲染性能产生不利影响。</p>\n<ol>\n<li>浏览器阻塞渲染网页直到所有外部的样式表都已被下载。</li>\n<li>（用<code>&lt;style&gt;</code>标记指定的）内联样式块可能会导致reflows和页面跳动。<br>因此，把外部样式表和内联样式块放在页面的<code>&lt;head&gt;</code>中是很重要的。通过确保样式表首先被下载和解析，可以让浏览器逐步渲染页面。</li>\n</ol>\n<p>具体做法：</p>\n<ul>\n<li><p>将内联样式块和<code>&lt;link&gt;</code>元素从页面<code>&lt;body&gt;</code>移动到页面<code>&lt;head&gt;</code>中。</p>\n<p>HTML 4.01规范（第12.3节）规定，始终把使用<code>&lt;link&gt;</code>标签的外部样式表放在<code>&lt;head&gt;</code>部分里，还要确保您指定的样式有正确的顺序。</p>\n</li>\n<li><p>把<code>&lt;style&gt;</code>区块放在<code>&lt;head&gt;</code>部分里。</p>\n</li>\n<li><p>使用css媒体类型</p>\n</li>\n</ul>\n<p>如果可以让<code>CSS</code>资源只在特定条件下使用，这样这些资源就可以在首次加载时先不进行构建<code>CSSOM</code>树，只有在符合特定条件时，才会让浏览器进行阻塞渲染然后构建<code>CSSOM</code>树。</p>\n<p><code>CSS</code>的媒体查询正是用来实现这个功能的，它由媒体类型以及零个或多个检查特定媒体特征状况的表达式组成。</p>\n<pre><code class=\"html\">&lt;!-- 没有使用媒体查询，这个css资源会阻塞渲染  --&gt;\n&lt;link href=&quot;style.css&quot;    rel=&quot;stylesheet&quot;&gt;\n&lt;!-- all是默认类型，它和不设置媒体查询的效果是一样的 --&gt;\n&lt;link href=&quot;style.css&quot;    rel=&quot;stylesheet&quot; media=&quot;all&quot;&gt;\n&lt;!-- 动态媒体查询， 将在网页加载时计算。\n根据网页加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。--&gt;\n&lt;link href=&quot;portrait.css&quot; rel=&quot;stylesheet&quot; media=&quot;orientation:portrait&quot;&gt;\n&lt;!-- 只在打印网页时应用，因此网页首次在浏览器中加载时，它不会阻塞渲染。 --&gt;\n&lt;link href=&quot;print.css&quot;    rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;\n</code></pre>\n<p>使用媒体查询可以让CSS资源不在首次加载中阻塞渲染，但不管是哪种CSS资源它们的下载请求都不会被忽略，浏览器仍然会先下载CSS文件。</p>\n<p><strong>把Javascript脚本在底部，删除阻止渲染的JavaScript</strong></p>\n<p>浏览器必须通过在呈现页面之前解析HTML来构建DOM树。如果您的浏览器在此过程中遇到脚本，则必须先停止并执行它，然后才能继续。</p>\n<p>具体做法：</p>\n<p>将脚本定义或引用放置到<code>&lt;body&gt;</code>底部。<br><code>&lt;script defer=&quot;defer&quot;&gt;</code> defer 属性规定是否对脚本执行进行延迟， 脚本将在页面完成解析时执行。</p>\n<p><img data-src=\"/images/bVcQV0.jpeg\" alt=\"请输入图片描述\"></p>\n<p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p>\n<p>此图告诉我们以下几个要点：</p>\n<ol>\n<li><code>defer</code>和 <code>async</code> 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>\n<li>它俩的差别在于脚本下载完之后何时执行，显然 <code>defer</code>*是最接近我们对于应用脚本加载和执行的要求的</li>\n<li>关于 <code>defer</code>，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>\n<li><code>async</code> 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>\n<li>仔细想想，<code>async</code>对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>\n</ol>\n<h4 id=\"减少DNS查找\"><a href=\"#减少DNS查找\" class=\"headerlink\" title=\"减少DNS查找\"></a>减少DNS查找</h4><p>用户访问网站的过程如下：</p>\n<ol>\n<li><p>在地址栏输入网站地址，如<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5leGFtcGxlLmNvbS8=\">www.example.com</span>;</p>\n</li>\n<li><p>本地DNS得到这个请求，查询本地DNS缓存，如果有这条记录，则直接返回对应的IP；否则，请求网络上的DNS服务器，得到相应的IP，返回给客户机，并缓存这条记录；</p>\n</li>\n<li><p>浏览器向得到的IP发起建立连接请求，得到响应后建立连接，请求数据；</p>\n</li>\n<li><p>Server端计算所需数据，并返回给client端；</p>\n</li>\n<li><p>client端，即浏览器，解析数据并显示在浏览器窗口中，至此，请求完成。</p>\n</li>\n</ol>\n<p>在 一次请求中，DNS解析可以占到请求时间的三分之一左右（这点有待验证），所以如果可以缩短DNS解析时间，就可以加快页面的打开速度。</p>\n<p>缩短DNS解析的 方法可以<strong>通过延长DNS缓存的时间</strong>，<strong>选用更快的DNS Server</strong>，<strong>减少域名总数</strong>（例如原来有5个img server，分别为img1.xxx.com至img5.xxx.com，则现在可以减少到3个）等等，但是减少域名个数又会降低资源并行下载的数量， 因为同一域名最多可以并行下载两个资源，所以这里需要一个折衷方案，作者的建议就是将资源分布在大于等于2但小于等于4个域名上（这个也有待验证，例如针 对多大的系统选用多少个域名是最合理的等）。</p>\n<p><strong>使用DNS预解析</strong></p>\n<p>这里会有一些兼容性问题，可以参见：<span class=\"exturl\" data-url=\"aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWxpbmstcmVsLWRucy1wcmVmZXRjaA==\">http://caniuse.com/#feat=link-rel-dns-prefetch</span></p>\n<p><img data-src=\"/images/sdfdsf.png\" alt=\"sdfdsf\"></p>\n<p>在网页体验中我们常会遇到这种情况，即在调用百度联盟、谷歌联盟以及当前网页所在域名外的域名文件时会遇到请求延时非常严重的情况。那么有没有方法去解决这种请求严重延时的现象呢？</p>\n<p>一般来说这种延时的原因不会是对方网站带宽或者负载的原因，那么到底是什么导致了这种情况呢。湛蓝试着进行推测，假设是DNS的问题，因为DNS解析速度很可能是造成资源延时的最大原因。在页面header中添加了以下代码（用以DNS预解析）：</p>\n<pre><code class=\"html\">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;\n\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://nsclick.baidu.com&quot; /&gt;\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://hm.baidu.com&quot; /&gt;\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://eiv.baidu.com&quot; /&gt;\n</code></pre>\n<p>dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。</p>\n<p>使用场景：</p>\n<ol>\n<li>新用户访问，后端可以通过 Cookie 判断是否为首次进入站点，对于这类用户，DNS Prefetch 可以比较明显地提升访问速度</li>\n<li>登录页，提前在页面上进行下一跳页用到资源的 DNS Prefetch</li>\n<li>页面中的静态资源在不同的domain下，如CSS、JS、图片等文件</li>\n<li>电商网站的商品页大量载入不同domain下的商品图，如淘宝</li>\n<li>手机网页</li>\n<li>大型网站</li>\n<li>js或服务端重定向</li>\n</ol>\n<blockquote>\n<p>Chrome中的一些指令：</p>\n<ul>\n<li><code>chrome://histograms/DNS.PrefetchQueue</code>：查看队列状态</li>\n<li><code>chrome://histograms/DNS</code>：查看从浏览器启动到上一页的DNS记录</li>\n<li><code>chrome://dns</code>：查看个域名DNS统计</li>\n<li><code>chrome://net-internals/#dns</code>：清除host缓存</li>\n</ul>\n</blockquote>\n<h4 id=\"压缩资源\"><a href=\"#压缩资源\" class=\"headerlink\" title=\"压缩资源\"></a>压缩资源</h4><ul>\n<li><p>压缩js，css，image</p>\n<p><strong>通过对外部资源进行压缩可以大幅度地减少浏览器需要下载的资源量，它会减少关键路径长度与关键字节，使页面的加载速度变得更快。</strong></p>\n<p><strong>对数据进行压缩其实就是使用更少的位数来对数据进行重编码</strong>。如今有非常多的压缩算法，且每一个的作用领域也各不相同，它们的复杂度也不相同，不过在这里我不会讲压缩算法的细节，感兴趣的朋友可以自己Google。</p>\n<p>在对<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>这些文件进行压缩之前，还需要先进行一次冗余压缩。<strong>所谓冗余压缩，就是去除多余的字符，例如注释、空格符和换行符</strong>。这些字符对于程序员是有用的，毕竟没有格式化的代码可读性是非常恐怖的，但它们对于浏览器是没有任何意义的，去除这些冗余可以减少文件的数据量。</p>\n<p>小图片采用base64的格式，直接嵌入代码中，可以帮我们减少http请求，但是同样，这个会造成我们代码的提及变大。请求的速度会减慢，这个需要平衡。</p>\n<p>常用工具：webpack，gulp</p>\n<blockquote>\n<p>浏览器接收到服务器返回的HTML、CSS和JavaScript字节数据并对其进行解析和转变成像素的渲染过程被称为<code>关键渲染路径</code>。通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。</p>\n</blockquote>\n</li>\n<li><p>删除重复的脚本，类似<code>tree-shaking</code></p>\n<p>在一个页面中重复引用一个脚本可能存在的问题：浏览器会重复下载并执行脚本文件。</p>\n</li>\n<li><p>使用合适大小的图片</p>\n<p>如果你只需要一个小图，就不要传一个大图。例如你实际需要显示的是一个60x60的头像，就不要传一个100x100的然后再通过设置宽高将它缩小为60x60的。原因很简单，这样会消耗不必要的带宽和系统资源。</p>\n</li>\n<li><p>减少DOM元素的数量</p>\n<p>复杂页面意味着要下载更多字节，这也意味着JavaScript中的DOM访问速度更慢。如果您想要添加事件处理程序，例如，在页面上循环500或5000个DOM元素，则会有所不同。</p>\n</li>\n<li><p>使用异步加载，async、defer</p>\n<blockquote>\n<p>服务端渲染也是一种减少浏览器资源消耗，减少页面重排重绘，也是一种现行MVVM框架单页应用最主要的SEO优化手段。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"避免3xx-x2F-4xx\"><a href=\"#避免3xx-x2F-4xx\" class=\"headerlink\" title=\"避免3xx&#x2F;4xx\"></a>避免3xx&#x2F;4xx</h4><p><strong>避免重定向</strong></p>\n<p>3xx是重定向相关的HTTP响应代码</p>\n<p>重定向的意思是，用户的原始请求（例如请求A）被重定向到其他的请求（例如请求B）。</p>\n<p>每次页面重定向到另一个页面时，您的访问者都会面临等待HTTP请求 - 响应周期完成的额外时间。例如，如果移动重定向模式如下所示：</p>\n<p><code>example.com</code> - &gt; <code>www.example.com</code> - &gt; <code>m.example.com</code> - &gt; <code>m.example.com/home</code>，这两个额外重定向中的每一个都会使您的页面成为可能加载速度慢。</p>\n<p>HTTP 重定向通过 <code>301</code>&#x2F;<code>302</code> 状态码实现。</p>\n<pre><code>HTTP/1.1 301 Moved Permanently  \nLocation: http://example.com/newuri  \nContent-Type: text/html  \n</code></pre>\n<p><code>301 Moved Permanently</code>，这个状态码标识用户所请求的资源被移动到了另外的位置，客户端接收到此响应后，需要发起另外一个请求去下载所需的资源。</p>\n<p><code>302 Found</code>，这个状态码标识用户所请求的资源被找到了，但不在原始位置，服务器会回复其他的一个位置，客户端收到此响应后，也需要发起另外一个请求去下载所需的资源。</p>\n<p>客户端收到服务器的重定向响应后，会根据响应头中 <code>Location</code> 的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。</p>\n<p>有时重定向无法避免，在糟糕也比抛出 <code>404</code> 好。虽然通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01ldGFfcmVmcmVzaA==\">HTML meta refresh</span> 和 JavaScript 也能实现，但首选 HTTP <code>3xx</code> 跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。</p>\n<p><strong>常见的优化办法：</strong></p>\n<ul>\n<li><p>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加 <code>/</code> 但未添加。比如，访问 <code>http://astrology.yahoo.com/astrology</code> 将被 301 重定向到 <code>http://astrology.yahoo.com/astrology/</code>（注意末尾的 <code>/</code>）。如果使用 Apache，可以通过 <code>Alias</code> 或 <code>mod_rewrite</code> 或 <code>DirectorySlash</code> 解决这个问题。</p>\n</li>\n<li><p>网站域名变更：CNAME 结合 <code>Alias</code> 或 <code>mod_rewrite</code> 或者其他服务器类似功能实现跳转。</p>\n</li>\n<li><p>在定义链接地址的href属性的时候，尽量使用最完整的、直接的地址。例如：<br>使用 <code>www.cnblogs.com</code> 而不是<code>cnblogs.com</code><br>使用<code>cn.bing.com</code>而不是<code>bing.com</code><br>使用<code>www.google.com.hk</code>而不是<code>google.com</code><br>使用<code>www.mysite.com/products/</code>而不是<code>www.mysite.com/products</code></p>\n</li>\n</ul>\n<p><strong>避免404浏览器找不到资源的情况发生</strong></p>\n<p>发出HTTP请求并获得无用的响应（即404 Not Found）是完全没必要的。特别糟糕的是当外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应主体，就像它是JavaScript代码一样，这样就带来的性能的浪费。</p>\n<p><strong>404的影响：</strong></p>\n<p>有时候，404错误发生了，用户可能根本没有感觉到。例如</p>\n<ul>\n<li>例如请求favicon.ico文件，或者请求了某个不存在的脚本文件、样式表、图片文件，页面还是会按照正常的方式进行呈现。</li>\n<li>丢失的脚本文件、样式表、图片文件，会导致页面的某些行为、界面效果出现异常（也可能不是很明显）</li>\n<li>最大的问题可能是性能方面的影响。尤其是如果请求一个不存在的脚本文件，因为浏览器在请求脚本文件的时候，即便是返回404，它也会尝试去按照Javascript的方式解析响应中的内容。这无疑会增加很多处理的时间，而因为该文件不存在，所以这些都是无用功。</li>\n</ul>\n<p>看得到的影响：</p>\n<ul>\n<li>如果用户请求的某个页面不存在，那么他将收到明确的回应</li>\n<li>默认情况下，他将收到一个标准的错误页面（请注意：不少用户会被这个页面吓到）</li>\n</ul>\n<p><strong>常见的优化办法：</strong></p>\n<p>404 意味着Not Found，意思是说未找到资源。既然如此，那么至少会有两种原因导致404错误：</p>\n<ul>\n<li>该资源按理说是要有，但我们没有提供。用户按照正常的方式来请求，所以资源找不到。<ul>\n<li>为网站提供favicon.ico这种经常可能会被忽略的资源</li>\n<li>使用一些检查工具：比如Link checker</li>\n</ul>\n</li>\n<li>该资源本来就不存在，用户按照不正常的方式来请求，当然还是找不到。<ul>\n<li>避免用户收藏绝对地址，给后期更新带来隐患。可以使用地址Rewrite来重写，或者在设计阶段定义一些灵活友好的地址</li>\n<li>使用Routing技术，配置路由规则。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"AJAX优化\"><a href=\"#AJAX优化\" class=\"headerlink\" title=\"AJAX优化\"></a>AJAX优化</h4><p><strong>使Ajax可缓存</strong></p>\n<p>AJAX&#x3D;Asynchronous JavaScript And XML，AJAX不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<p>由于AJAX其实也是需要发起请求，然后服务器执行，并将结果（通常是JSON格式的）发送给浏览器进行最后的呈现或者处理，所以对于网站设计优化的角度而言，我们同样需要考虑对这些请求，是否可以尽可能的利用到缓存的功能来提高性能。</p>\n<p>对于AJAX而言，有一些特殊性，并不是所有的AJAX请求都是可以缓存的。</p>\n<ol>\n<li><code>POST</code>的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码200。（这里可以优化的是，服务器端对数据进行缓存，以便提高处理速度）</li>\n<li><code>GET</code>的请求，是可以（并且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一地址的AJAX请求，不会重复再服务器执行，而是返回304。</li>\n</ol>\n<p>有的时候，我们可能希望<code>GET</code>请求不被缓存，有几种做法来达到这样的目的。</p>\n<ol>\n<li>每次调用的时候，请求不同的地址（可以在原始地址后面添加一个随机的号码）。</li>\n<li>如果你所使用的是jquery的话，则可以考虑禁用AJAX的缓存。</li>\n</ol>\n<pre><code class=\"javascript\">$.ajaxSetup(&#123; cache: false &#125;);\n</code></pre>\n<p>axios中</p>\n<pre><code class=\"javascript\">var config = &#123;\theaders: &#123;&#39;Content-Type&#39;: &#39;application/json&#39;,&#39;Cache-Control&#39; : &#39;no-cache&#39;&#125;&#125;;\n \naxios.get(&#39;/post&#39;,config)\n</code></pre>\n<p><strong>使用GET的Ajax请求</strong></p>\n<p>在使用XMLHttpRequest（目前的AJAX都是基于它实现的）的时候，浏览器中的POST实现为两步走的过程，首先发送头部信息，然后再发送数据。但如果是使用GET的话，就只有一个TCP的包发送出去（除非有大量的Cookie），这样无疑可以提高性能。</p>\n<p>但是get有容量限制，大于2K(对get的限制IE是2K，firefox、chrome是4K)的内容只能用post。</p>\n<h4 id=\"Cookie优化\"><a href=\"#Cookie优化\" class=\"headerlink\" title=\"Cookie优化\"></a>Cookie优化</h4><ul>\n<li><p>减小cookie大小</p>\n<p>减小cookie的大小，因为在发请求时浏览器会将cookie信息发送到server端，所以应该只在cookie中存必要的信息且越长度越小越好。在 写cookie的时候要记得给cookie设置一个合理的过期时间及域</p>\n</li>\n<li><p>对一些静态资源不需要使用cookie的单独设置域</p>\n<p>当浏览器发出静态图像请求并将cookie与请求一起发送时，服务器对这些cookie没有任何用处。因此，他们只会毫无理由地创建网络流量。您应该确保使用无cookie请求请求静态组件。创建一个子域并在那里托管所有静态组件。</p>\n<p>如果您的域名是<code>www.example.org</code>，您可以托管您的静态组件<code>static.example.org</code>。但是，如果您已经在顶级域上设置了cookie <code>example.org</code>而不是<code>www.example.org</code>，则所有请求都 <code>static.example.org</code>将包含这些cookie。在这种情况下，您可以购买一个全新的域，在那里托管您的静态组件，并保持此域无cookie。雅虎 用途<code>yimg.com</code>，YouTube使用<code>ytimg.com</code>，亚马逊使用<code>images-amazon.com</code>等。</p>\n<p>在无cookie域上托管静态组件的另一个好处是，某些代理可能拒绝缓存使用cookie请求的组件。在相关说明中，如果您想知道是否应该使用<code>example.org</code>或<code>www.example.org</code>作为主页，请考虑cookie的影响。</p>\n<blockquote>\n<p>省略www会让您别无选择，只能写入cookie <code>*.example.org</code>，因此出于性能原因，最好使用www子域并将cookie写入该子域。</p>\n</blockquote>\n</li>\n</ul>\n<p>归类一下：</p>\n<ul>\n<li>去除不必要的 Cookie；</li>\n<li>尽量压缩 Cookie 大小；</li>\n<li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li>\n<li>设置合适的过期时间。</li>\n</ul>\n<h4 id=\"利用缓存\"><a href=\"#利用缓存\" class=\"headerlink\" title=\"利用缓存\"></a>利用缓存</h4><p>浏览器会缓存大量信息（样式表，图像，JavaScript文件等），以便当访问者返回您的站点时，浏览器不必重新加载整个页面。然后设置“expires”标题，以表示希望缓存该信息的时间。在许多情况下，除非您的网站设计经常更改，否则一年是合理的时间段。</p>\n<p><strong>利用浏览器缓存 ，为链接或者资源，添加Expires或Cache-Control头</strong></p>\n<ul>\n<li>对于静态组件：通过设置远期未来<code>Expires</code>标头实现“永不过期”策略</li>\n<li>对于动态组件：使用适当的<code>Cache-Control</code>标头来帮助浏览器处理条件请求</li>\n</ul>\n<p>格式：</p>\n<pre><code class=\"bash\">Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date\n# e.g.\nExpires: Thu, 01 Dec 1994 16:00:00 GMT \n#（必须是GMT格式）\n</code></pre>\n<p>通过HTTP的META设置expires和cache-control</p>\n<pre><code class=\"html\">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=7200&quot; /&gt;\n&lt;meta http-equiv=&quot;Expires&quot; content=&quot;Mon, 01 Aug 2019 00:00:00 GMT&quot; /&gt;\n</code></pre>\n<p>上述设置仅为举例，实际使用其一即可。这样写的话仅对该网页有效，对网页中的图片或其他请求无效，并不会做任何<code>cache</code>。<br>这样客户端的请求就多了，尽管只是检查<code>Last-modified</code>状态的东西，但是请求一多对浏览速度必定有影响。</p>\n<p><code>Cache-Control</code> 的参数包括:</p>\n<ul>\n<li><strong>max-age&#x3D;</strong>[单位：秒 seconds] — 设置缓存最大的有效时间. 类似于 <code>Expires</code>, 但是这个参数定义的是时间大小（比如：60）而不是确定的时间点.单位是[秒 seconds].</li>\n<li><strong>s-maxage&#x3D;</strong>[单位：秒 seconds] — 类似于 <code>max-age</code>, 但是它只用于公享缓存 (e.g., proxy) .</li>\n<li><strong>public</strong> — 响应会被缓存，并且在多用户间共享。正常情况, 如果要求 <span class=\"exturl\" data-url=\"aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzIwNzY0MDguaHRt\">HTTP 认证</span>,响应会自动设置为 private.</li>\n<li><strong>private</strong> — 响应只能够作为私有的缓存(e.g., 在一个浏览器中)，不能再用户间共享。</li>\n<li><strong>no-cache</strong> — 响应不会被缓存,而是实时向服务器端请求资源。这一点很有用，这对保证<span class=\"exturl\" data-url=\"aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzIwNzY0MDguaHRt\">HTTP 认证</span>能够严格地禁止缓存以保证安全性很有用（这是指页面与public结合使用的情况下）.既没有牺牲缓存的效率，又能保证安全。</li>\n<li><strong>no-store</strong> — 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</li>\n<li><strong>must-revalidate</strong> — 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。</li>\n<li><strong>proxy-revalidate</strong> — 类似于 <code>must-revalidate</code>,但不适用于代理缓存.</li>\n</ul>\n<p><strong>把css与js使用外联的方式进行使用</strong></p>\n<p>建议将css和js以外联方式引用以充分利用<code>cache</code>，只有一个例外就是针对首页，首页可以采用内联来减少http请求数，加快页面显示速度，文中说首 页内联的原因是首页被人们访问的次数不会太多，而且样式一般比较特殊，不像其它页面一样有相同的页面模板（因为就有相同的样式部分），所以首页的样式可以 内联。并且应该在首页加载完成之后，再在后台动态加载后续页面的css和js，以提高后续页面的访问速度。</p>\n<p>如果站点上的用户每个会话有多个页面查看，并且您的许多页面重复使用相同的脚本和样式表，则缓存的外部文件可能会带来更大的潜在好处。</p>\n<blockquote>\n<p>对于现在的单页面的应用，更适合于动态加载的方案</p>\n</blockquote>\n<p><strong>缓存favicon.ico，并设置最好小于1k</strong></p>\n<p>favicon.ico是一个保留在服务器根目录中的图片，为了减轻拥有favicon.ico的带来的性能问题，请确保：</p>\n<ul>\n<li>优化它的大小，最好不到1K。</li>\n<li>设置Expires标头，使其缓存。</li>\n</ul>\n<p><strong>配置的ETag</strong></p>\n<p>ETag，全程为：<code>Entity Tag</code>，意思是实体标签，它属于HTTP协议的一部分，也就是所有的Web服务器都应该支持这个特性。它的作用是用一个特殊的字符串来标识某个资源的“版本”，客户端（浏览器）请求的时候，比较ETag如果一致，则表示该资源并没有被修改过，客户端（浏览器）可以使用自己缓存的版本，避免重复下载。<br>它比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">响应标</th>\n<th align=\"left\">优势 和特点</th>\n<th align=\"left\">劣势 和可能的问题</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Expires</td>\n<td align=\"left\">- HTTP 1.0就有，简单易用。 - 服务器通过这个Header告诉浏览器，某资源直到某个时间才会过期，所以在没有过期之前，浏览器就直接使用本地的缓存了。</td>\n<td align=\"left\">- 因为这是时间是由服务器发送的（UTC），但如果服务器时间和客户端事件存在不一致，可能会有些问题。 - 可能存在版本的问题，因为如果在到期之前修改过了，客户端是不会知道的。 - Cache-Control中的max-age可以实现类似的效果，但更加好，因为max-age是一个以秒为单位的时间数，而不是具体的时间，所以不存在上面提到的第一个问题。</td>\n</tr>\n<tr>\n<td align=\"left\">Cache-Contro</td>\n<td align=\"left\">- 服务器通过一个Header（Last-Modified）告诉浏览器，某资源最后修改的时间。 - 浏览器在请求的时候，包含一个Header（If-Modified-Since）,然后服务器可以进行比较，如果在该时间后没有修改过，则返回304。 - 它比Expires多很多选项设置</td>\n<td align=\"left\">- Last-Modified 也是一个时间，但该时间只能精确到秒，如果在同一个秒中有多次修改（这个在现在的环境下应该确实是可能的），则可能会发生问题。</td>\n</tr>\n<tr>\n<td align=\"left\">ETag</td>\n<td align=\"left\">- 可以更加精确地判断资源是否被修改，因为它不是一个时间值，而是对时间经过处理的一个长整型数值（当然具体算法我们目前还不得而知）。 - 浏览器发起新请求时需要包含 If-None-Match。</td>\n<td align=\"left\">- 如果部署在服务器场环境中，配置不当的话，可能每个服务器会对相同的资源生成不一样的ETag，这样就增加了重复下载的可能性。</td>\n</tr>\n</tbody></table>\n<p>我们来看一个真实的例子：</p>\n<p><img data-src=\"/images/image-20190619145105413.png\" alt=\"/images/image-20190619145105413\"></p>\n<p>其他的一些缓存使用：</p>\n<ul>\n<li>使用本地缓存，缓存部分常用用户数据、公开数据</li>\n<li>缓存机制设计：缓存+过期时间</li>\n</ul>\n<p>总结一下：</p>\n<ul>\n<li>添加Expires或Cache-Control</li>\n<li>Etag</li>\n<li>缓存favicon.ico</li>\n<li>外联js&#x2F;css</li>\n</ul>\n<h4 id=\"缩短服务器响应时间\"><a href=\"#缩短服务器响应时间\" class=\"headerlink\" title=\"缩短服务器响应时间\"></a>缩短服务器响应时间</h4><p>服务器响应时间受到访问流量，每个页面使用的资源，服务器使用的软件以及硬件本身的影响。要改善服务器响应时间，请查找性能瓶颈，如慢速数据库查询，慢速路由或缺少足够的内存并修复它们。最佳服务器响应时间低于200毫秒。</p>\n<p>很多潜在因素都可能会延缓服务器响应，例如缓慢的应用逻辑、缓慢的数据库查询、缓慢的路由、框架、库、资源 CPU 不足或内存不足。您需要充分考虑所有这些因素，才能改善服务器的响应用时。 若想找出服务器响应用时过长的原因，首先要进行衡量。然后，准备好相关数据，并参阅有关如何解决该问题的相应指导。当解决问题后，您必须继续衡量服务器响应用时，并设法应对任何会在将来出现的性能瓶颈问题。</p>\n<ol>\n<li><strong>收集并检查</strong>现有性能和数据。若无可用内容，请使用自动化的网络应用监测解决方案（市面上有托管的开源版本，适用于大多数平台）进行评估，或添加自定义的方法。</li>\n<li><strong>找出并修复</strong>首要的性能瓶颈问题。如果z您使用的是热门网页框架或内容管理平台，请参阅与性能优化最佳做法相关的文档。</li>\n<li><strong>监测并提醒</strong>任何会在将来出现的性能衰退问题！</li>\n</ol>\n<blockquote>\n<p>通常来说，服务器的响应时间由数据库的问题居多，还有错误的程序设计(比如：烂用for循环去查数据库)。</p>\n</blockquote>\n<h3 id=\"优化工具\"><a href=\"#优化工具\" class=\"headerlink\" title=\"优化工具\"></a>优化工具</h3><h4 id=\"Google-Page-Speed\"><a href=\"#Google-Page-Speed\" class=\"headerlink\" title=\"Google Page Speed\"></a>Google Page Speed</h4><p>Google Page Speed以帮助开发人员和网站所有者确保他们的网页尽可能顺畅，快速地运行。</p>\n<p><strong>Google Page Speed特点：</strong></p>\n<ul>\n<li>在CSS方面更加注重细节，对于CSS选择器，Google Page Speed提供了大量有用的建议</li>\n<li>页面速度活动功能类似于加载计时器评估，但它实时提供图表，因此可以在任何给定时间准确查看网站上发生的情况。</li>\n<li>自动优化：使用PageSpeed模块，可以将Google与您的Nginx或Apache网站服务器集成，以自动优化您的网站。</li>\n<li>优化库集成：可以找到PageSpeed模块背后优化建议，允许设计和构建自己的工具。</li>\n</ul>\n<p>对于某些人来说，Google Page Speed将是显而易见的选择，因为它可以与其他对维护网站性能至关重要的Google工具一起使用，例如Google Analytics。</p>\n<h4 id=\"JsPerf-amp-Benchmark-js\"><a href=\"#JsPerf-amp-Benchmark-js\" class=\"headerlink\" title=\"JsPerf &amp; Benchmark.js\"></a>JsPerf &amp; Benchmark.js</h4><p>经常看到项目中有一个benchmark的文件夹，那么这个benchmark是干嘛用的？</p>\n<p>JsPerf在线：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qc3BlcmYuY29tLw==\">https://jsperf.com/</span></p>\n<p>JsPerf Github地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2pzcGVyZi9qc3BlcmYuY29t\">https://github.com/jsperf/jsperf.com</span></p>\n<p>Benchmark.js网址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2JlbmNobWFyay5qcw==\">https://github.com/bestiejs/benchmark.js</span></p>\n<p>BenchMark.js可以本地安装，而JsPerf.js是线上使用的。</p>\n<p>HTML中引入：</p>\n<pre><code class=\"html\">&lt;script src=&quot;lodash.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;platform.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;benchmark.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>或者使用<code>npm</code>:</p>\n<pre><code class=\"bash\">$ &#123;sudo -H&#125; npm i -g npm\n$ npm i --save benchmark\n</code></pre>\n<p>下面是一个具体的用例：</p>\n<p>Reg vs IndexOf</p>\n<pre><code class=\"javascript\">var suite = new Benchmark.Suite;\n\n// add tests\nsuite.add(&#39;RegExp#test&#39;, function() &#123;\n  /o/.test(&#39;Hello World!&#39;);\n&#125;)\n.add(&#39;String#indexOf&#39;, function() &#123;\n  &#39;Hello World!&#39;.indexOf(&#39;o&#39;) &gt; -1;\n&#125;)\n// add listeners\n.on(&#39;cycle&#39;, function(event) &#123;\n  console.log(String(event.target));\n&#125;)\n.on(&#39;complete&#39;, function() &#123;\n  console.log(&#39;Fastest is &#39; + this.filter(&#39;fastest&#39;).map(&#39;name&#39;));\n&#125;)\n// run async\n.run(&#123; &#39;async&#39;: true &#125;);\n\n// logs:\n// =&gt; RegExp#test x 4,161,532 +-0.99% (59 cycles)\n// =&gt; String#indexOf x 6,139,623 +-1.00% (131 cycles)\n// =&gt; Fastest is String#indexOf\n</code></pre>\n<p>再来看一个 call与apply的对比：</p>\n<pre><code class=\"javascript\">var Benchmark = require(&#39;benchmark&#39;);\nvar suite = new Benchmark.Suite;\nvar arr1 = function (str) &#123;\n    return [].slice.apply(str);\n&#125;;\nvar str2 = function (str) &#123;\n    return [].slice.call(str);\n&#125;;\n// 添加测试\nsuite.add(&#39;arr1&#39;, function() &#123;\n    arr1(&#39;test&#39;);\n&#125;)\n    .add(&#39;str2&#39;, function() &#123;\n        str2(&#39;test&#39;);\n    &#125;)\n// add listeners\n    .on(&#39;cycle&#39;, function(event) &#123;\n        console.log(String(event.target));\n    &#125;)\n    .on(&#39;complete&#39;, function() &#123;\n        console.log(&#39;Fastest is &#39; + this.filter(&#39;fastest&#39;).pluck(&#39;name&#39;));\n    &#125;)\n// run async\n    .run(&#123; &#39;async&#39;: true &#125;);\n</code></pre>\n<p>benckmark是对js运行能效的一个对比测试，让你能够知道自己的JS代码中与其他方案对比的时候，是否有优化的空间。当然，这些新的方案，需要自己去编写去测试。同样，也可以在JsPerf的官网上去看其他的测试结果。</p>\n<p>执行办法 ：</p>\n<pre><code class=\"javascript\">npm init -y\n\nnpm install -S benchmark\n\ntouch test.js //Linux\n\nnode test.js\n</code></pre>\n<h2 id=\"代码优化——写出优质的代码\"><a href=\"#代码优化——写出优质的代码\" class=\"headerlink\" title=\"代码优化——写出优质的代码\"></a>代码优化——写出优质的代码</h2><p>命题很大，但是我们要简化来谈一下。</p>\n<p>代码优化，先要写出优质的代码，有几点原则：</p>\n<ul>\n<li>使用辅助应用对代码进行检查，Eslint等</li>\n<li>使用预编译工具，如less，sass，stylus。</li>\n<li>使用官方的开发规范：命名规范、注释、使用规范、文档规范</li>\n<li>写出逻辑上易于阅读的代码：设计模式、代码结构、文档编排(目录结构)</li>\n<li>代码审查</li>\n<li>单元测试</li>\n<li>异常与错误机制</li>\n</ul>\n<p>之后就是练习与阅读，阅读别人的代码，学习别人的精华，了解别人代码中的缺点。使用JsPerf或者benchemark去对比优化性能。</p>\n<p>前端代码规范：Airbnb，github，Google，腾讯，阿里等。</p>\n<h2 id=\"JsPerf\"><a href=\"#JsPerf\" class=\"headerlink\" title=\"JsPerf\"></a>JsPerf</h2><h3 id=\"JsPerf使用简介\"><a href=\"#JsPerf使用简介\" class=\"headerlink\" title=\"JsPerf使用简介\"></a>JsPerf使用简介</h3><h4 id=\"线上使用方案\"><a href=\"#线上使用方案\" class=\"headerlink\" title=\"线上使用方案\"></a>线上使用方案</h4><p>需要使用Github进行登录：</p>\n<p><img data-src=\"/images/image-20190618210408261.png\" alt=\"/images/image-20190618210408261\"></p>\n<p>点击<code>Login with Github to Create Test Cases</code>:</p>\n<p><img data-src=\"/images/image-20190619103010414.png\" alt=\"/images/image-20190619103010414\"></p>\n<p>登录之后，进入授权页面：</p>\n<p><img data-src=\"/images/image-20190619103140822.png\" alt=\"/images/image-20190619103140822\"></p>\n<p>登录过后，就可以创建自己的测试用例啦：</p>\n<p>\u0001<img data-src=\"/images/image-20190619143549467.png\" alt=\"/images/image-20190619143549467\"></p>\n<h4 id=\"线下使用方案：\"><a href=\"#线下使用方案：\" class=\"headerlink\" title=\"线下使用方案：\"></a>线下使用方案：</h4><p>环境准备：</p>\n<ul>\n<li>Mysql</li>\n<li>Nodejs</li>\n</ul>\n<p>创建过程：</p>\n<ol>\n<li><p>安装Mysql</p>\n<pre><code class=\"bash\">mysql -uroot -e &quot;CREATE DATABASE jsperf; GRANT ALL ON jsperf.* TO &#39;jsuser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;jspass&#39;; FLUSH PRIVILEGES;&quot;\n</code></pre>\n</li>\n<li><p>在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYnJvd3NlcnNjb3BlLm9yZy8=\">Browserscope.org</span> 注册一个API key ，在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYnJvd3NlcnNjb3BlLm9yZy91c2VyL3NldHRpbmdz\">the settings page</span>页面中.</p>\n</li>\n<li><p>注册一个 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2FwcGxpY2F0aW9ucy9uZXc=\">new OAuth GitHub application</span>. 使用callback URL 留空. 复制 “Client ID” 和 “Client Secret”到github的页面上。</p>\n</li>\n<li><p>使用<code>npm install</code>安装</p>\n</li>\n<li><p>配置<code>.env</code>的文件</p>\n</li>\n</ol>\n<pre><code class=\"bash\">NODE_ENV=development\n# from Prerequisites step 1\nMYSQL_USER=jsuser\nMYSQL_PASSWORD=jspass\nMYSQL_DATABASE=jsperf\n# from Prerequisites step 2\nBROWSERSCOPE=\n# from Prerequisites step 3\nGITHUB_CLIENT_ID=\nGITHUB_CLIENT_SECRET=\nGITHUB_CALLBACK=http://localhost:3000\n\nBELL_COOKIE_PASS=password-should-be-32-characters\nCOOKIE_PASS=password-should-be-32-characters\n\n# customizable but not recommended for local development\n# SCHEME=http\n# DOMAIN=localhost\n# PORT=3000\n# MYSQL_HOST=localhost\n# MYSQL_PORT=3306\n# LOGGLY_TOKEN=\n# LOGGLY_SUBDOMAIN=\n# REDIS_HOST=\n# REDIS_PORT=\n# REDIS_PASSWORD=\n</code></pre>\n<ol start=\"6\">\n<li>运行<code>npm start</code></li>\n</ol>\n<h3 id=\"代码示例for-vs-foreach\"><a href=\"#代码示例for-vs-foreach\" class=\"headerlink\" title=\"代码示例for vs foreach\"></a>代码示例for vs foreach</h3><p>我们对比一下for 与 foreach</p>\n<p><img data-src=\"/images/screencapture-jsperf-2019-06-18-21_15_29.png\" alt=\"screencapture-jsperf-2019-06-18-21_15_29\"></p>\n<p>测试过程：</p>\n<p><img data-src=\"/images/image-20190618211820471.png\" alt=\"/images/image-20190618211820471\"></p>\n<p>测试结果：</p>\n<p><img data-src=\"/images/image-20190618211915799.png\" alt=\"/images/image-20190618211915799\"></p>\n<p>这里有一个更全面的对比结果：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qc3BlcmYuY29tL2Zvci12cy1mb3JlYWNoLzc1\">https://jsperf.com/for-vs-foreach/75</span></p>\n<p><img data-src=\"/images/image-20190618213130251.png\" alt=\"/images/image-20190618213130251\"></p>\n<p><img data-src=\"/images/image-20190618213201840.png\" alt=\"/images/image-20190618213201840\"></p>\n<p>还有一些比较有意思的测试：</p>\n<p>可以通过浏览：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qc3BlcmYuY29tL3BvcHVsYXI=\">https://jsperf.com/popular</span>进行查看</p>\n<p><img data-src=\"/images/image-20190619143653346.png\" alt=\"/images/image-20190619143653346\"></p>\n<h3 id=\"前端项目优化实践\"><a href=\"#前端项目优化实践\" class=\"headerlink\" title=\"前端项目优化实践\"></a>前端项目优化实践</h3><p>我们来对比下Date()与Moment()中的format</p>\n<pre><code class=\"javascript\">const Benchmark = require(&#39;benchmark&#39;);\nconst moment = require(&#39;moment&#39;)\n\nDate.prototype.Format = function (fmt) &#123;\n  var o = &#123;\n    &quot;M+&quot;: this.getMonth() + 1, //月份\n    &quot;d+&quot;: this.getDate(), //日\n    &quot;h+&quot;: this.getHours(), //小时\n    &quot;m+&quot;: this.getMinutes(), //分\n    &quot;s+&quot;: this.getSeconds(), //秒\n    &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度\n    &quot;S&quot;: this.getMilliseconds() //毫秒\n  &#125;;\n  if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));\n  for (var k in o) &#123;\n    if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));\n  &#125;\n  return fmt;\n&#125;\n\nvar suite = new Benchmark.Suite;\n\n// add tests\nsuite.add(&#39;Date format&#39;, function () &#123;\n  console.log(new Date().Format(&#39;yyyy-MM-dd hh:mm:ss&#39;))\n&#125;)\n  .add(&#39;Moment format&#39;, function () &#123;\n    console.log(moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;))\n  &#125;)\n  // add listeners\n  .on(&#39;cycle&#39;, function (event) &#123;\n    console.log(String(event.target));\n  &#125;)\n  .on(&#39;complete&#39;, function () &#123;\n    console.log(&#39;Fastest is &#39; + this.filter(&#39;fastest&#39;).map(&#39;name&#39;));\n  &#125;)\n  // run async\n  .run(&#123; &#39;async&#39;: true &#125;);\n</code></pre>\n<p>输出结果 ：</p>\n<pre><code class=\"bash\">Moment format x 73,570 ops/sec ±4.93% (82 runs sampled)\nFastest is Moment format\n</code></pre>\n<h2 id=\"PageSpeed\"><a href=\"#PageSpeed\" class=\"headerlink\" title=\"PageSpeed\"></a>PageSpeed</h2><h3 id=\"PageSpeed简介\"><a href=\"#PageSpeed简介\" class=\"headerlink\" title=\"PageSpeed简介\"></a>PageSpeed简介</h3><p>PageSpeed Insights 的Chrome扩展是由谷歌官方开发的一款可以分析页面载入的各个方面，包括资源、网络、DOM以及时间线等等信息的插件，也提供在线访问方式。</p>\n<h4 id=\"使用Google-PageSpeed-Insights\"><a href=\"#使用Google-PageSpeed-Insights\" class=\"headerlink\" title=\"使用Google PageSpeed Insights\"></a>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw==\">Google PageSpeed Insights</span></h4><p>打开<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw==\">https://developers.google.com/speed/pagespeed/insights/</span></p>\n<p>输入需要分析的网址即可，这里面需要注意必须在公网可以访问到网址。</p>\n<p><img data-src=\"/images/image-20190619212956061.png\" alt=\"/images/image-20190619212956061\"></p>\n<h4 id=\"使用Chrome插件-x2F-Mozila插件\"><a href=\"#使用Chrome插件-x2F-Mozila插件\" class=\"headerlink\" title=\"使用Chrome插件&#x2F;Mozila插件\"></a>使用Chrome插件&#x2F;Mozila插件</h4><p><img data-src=\"/images/image-20190619203556941.png\" alt=\"/images/image-20190619203556941\"></p>\n<p>下载安装办法：</p>\n<ol>\n<li><p>使用插件ID:<code>djfpadpbeemogokhllpiakdeadpoclan</code> 到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaHJvbWUtZXh0ZW5zaW9uLWRvd25sb2FkZXIuY29tLyVFNiU5RCVBNSVFNCVCOCU4QiVFOCVCRCVCRA==\">https://chrome-extension-downloader.com/来下载</span></p>\n<p>打开：<span class=\"exturl\" data-url=\"Y2hyb21lOi8vZXh0ZW5zaW9ucy8=\">chrome:&#x2F;&#x2F;extensions&#x2F;</span></p>\n<p>把<code>ctx</code>文件拖进去</p>\n</li>\n<li><p>如果有梯子，那么直接在商店里面搜索</p>\n</li>\n</ol>\n<p>插件使用：</p>\n<p><img data-src=\"/images/image-20190619212836235.png\" alt=\"/images/image-20190619212836235\"></p>\n<h3 id=\"前端项目优化实践-1\"><a href=\"#前端项目优化实践-1\" class=\"headerlink\" title=\"前端项目优化实践\"></a>前端项目优化实践</h3><h2 id=\"补充学习\"><a href=\"#补充学习\" class=\"headerlink\" title=\"补充学习\"></a>补充学习</h2><h3 id=\"编码、解码形成DOM树的过程\"><a href=\"#编码、解码形成DOM树的过程\" class=\"headerlink\" title=\"编码、解码形成DOM树的过程\"></a>编码、解码形成DOM树的过程</h3><p>浏览器从网络或硬盘中获得<code>HTML</code>字节数据后会经过一个流程将字节解析为<code>DOM</code>树：</p>\n<ul>\n<li>编码： <strong>先将HTML的原始字节数据转换为文件指定编码的字符。</strong></li>\n<li>令牌化： 然后<strong>浏览器会根据HTML规范来将字符串转换成各种令牌</strong>（如<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>这样的标签以及标签中的字符串和属性等都会被转化为令牌，每个令牌具有特殊含义和一组规则）。令牌记录了标签的开始与结束，通过这个特性可以轻松判断一个标签是否为子标签（假设有<code>&lt;html&gt;</code>与<code>&lt;body&gt;</code>两个标签，当<code>&lt;html&gt;</code>标签的令牌还未遇到它的结束令牌<code>&lt;/html&gt;</code>就遇见了<code>&lt;body&gt;</code>标签令牌，那么<code>&lt;body&gt;</code>就是<code>&lt;html&gt;</code>的子标签）。</li>\n<li>生成对象： <strong>接下来每个令牌都会被转换成定义其属性和规则的对象（这个对象就是节点对象）。</strong></li>\n<li>构建完毕： <strong>DOM树构建完成，整个对象集合就像是一棵树形结构</strong>。可能有人会疑惑为什么<code>DOM</code>是一个树形结构，这是因为标签之间含有复杂的父子关系，树形结构正好可以诠释这个关系（<code>CSSOS</code>同理，层叠样式也含有父子关系。例如： <code>div p &#123;font-size: 18px&#125;</code>，会先寻找所有<code>p</code>标签并判断它的父标签是否为<code>div</code>之后才会决定要不要采用这个样式进行渲染）。</li>\n</ul>\n<p>整个<code>DOM</code>树的构建过程其实就是： <strong>字节 -&gt; 字符 -&gt; 令牌 -&gt; 节点对象 -&gt; 对象模型</strong>，下面将通过一个示例<code>HTML</code>代码与配图更形象地解释这个过程。</p>\n<p>如下面的这段HTML</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;title&gt;Critical Path&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img data-src=\"/images/63503acbly1fk2te7tuh0j20nv0dbjtl.jpg\" alt=\"DOM Rendering\"></p>\n<h3 id=\"优化工作清单\"><a href=\"#优化工作清单\" class=\"headerlink\" title=\"优化工作清单\"></a>优化工作清单</h3><p>当小伙伴们出现了页面性能问题时，或者在设计我们的应用之前，就可以参考如下的条目进行快速检查。</p>\n<ul>\n<li>页面内容<ul>\n<li>减少 HTTP 请求数</li>\n<li>减少 DNS 查询</li>\n<li>避免重定向</li>\n<li>缓存 Ajax 请求</li>\n<li>延迟加载</li>\n<li>预先加载</li>\n<li>减少 DOM 元素数量</li>\n<li>划分内容到不同域名</li>\n<li>尽量减少 iframe 使用</li>\n<li>避免 404 错误</li>\n</ul>\n</li>\n<li>服务器<ul>\n<li>使用 CDN</li>\n<li>添加 Expires 或 Cache-Control 响应头</li>\n<li>启用 Gzip</li>\n<li>配置 Etag</li>\n<li>尽早输出缓冲</li>\n<li>Ajax 请求使用 GET 方法</li>\n<li>避免图片 src 为空</li>\n</ul>\n</li>\n<li>Cookie<ul>\n<li>减少 Cookie 大小</li>\n<li>静态资源使用无 Cookie 域名</li>\n</ul>\n</li>\n<li>CSS<ul>\n<li>把样式表放在 <code>&lt;head&gt;</code> 中</li>\n<li>不要使用 CSS 表达式</li>\n<li>使用 <code>link</code> 替代 <code>@import</code></li>\n<li>不要使用 filter</li>\n</ul>\n</li>\n<li>JavaScript<ul>\n<li>把脚本放在页面底部</li>\n<li>使用外部 JavaScript 和 CSS</li>\n<li>压缩 JavaScript 和 CSS</li>\n<li>移除重复脚本</li>\n<li>减少 DOM 操作</li>\n<li>使用高效的事件处理</li>\n</ul>\n</li>\n<li>图片<ul>\n<li>优化图片</li>\n<li>优化 CSS Sprite</li>\n<li>不要在 HTML 中缩放图片</li>\n<li>使用体积小、可缓存的 favicon.ico</li>\n</ul>\n</li>\n<li>移动端<ul>\n<li>保持单个文件小于 25 KB</li>\n<li>打包内容为分段（multipart）文档</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优化关键渲染路径\"><a href=\"#优化关键渲染路径\" class=\"headerlink\" title=\"优化关键渲染路径\"></a>优化关键渲染路径</h3><p>假设有一个<code>HTML</code>页面，它只引入了一个<code>CSS</code>外部文件：</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>它的关键渲染路径如下：</p>\n<p><img data-src=\"/images/63503acbly1fk56dzdbn9j20nr068dga.jpg\" alt=\"img\"></p>\n<p>首先浏览器要先对服务器发送请求获得<code>HTML</code>文件，得到<code>HTML</code>文件后开始构建<code>DOM</code>树，在遇见<code>&lt;link&gt;</code>标签时浏览器需要向服务器再次发出请求来获得<code>CSS</code>文件，然后则是继续构建<code>DOM</code>树和<code>CSSOM</code>树，浏览器合并出渲染树，根据渲染树进行布局计算，执行绘制操作，页面渲染完成。</p>\n<p>有以下几个用于描述关键渲染路径性能的词汇：</p>\n<ul>\n<li>关键资源：可能阻塞网页首次渲染的资源（上图中为2个，<code>HTML</code>文件与外部<code>CSS</code>文件<code>style.css</code>）。</li>\n<li>关键路径长度： 获取关键资源所需的往返次数或总时间（上图为2次或以上，一次获取<code>HTML</code>文件，一次获取<code>CSS</code>文件，这个次数基于<code>TCP</code>协议的最大拥塞窗口，一个文件不一定能在一次连接内传输完毕）。</li>\n<li>关键字节：所有关键资源文件大小的总和（上图为<code>9KB</code>）。</li>\n</ul>\n<p>接下来，案例代码的需求发生了变化，它新增了一个<code>JavaScript</code>文件。</p>\n<pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><a href=\"http://wx1.sinaimg.cn/large/63503acbly1fk56e0i20xj20or06ygmi.jpg\"><img data-src=\"http://wx1.sinaimg.cn/large/63503acbly1fk56e0i20xj20or06ygmi.jpg\" alt=\"img\"></a></p>\n<p><code>JavaScript</code>文件阻塞了<code>DOM</code>树的构建，并且在执行<code>JavaScript</code>脚本时还需要先等待构建<code>CSSOM</code>树，上图的关键渲染路径特性如下：</p>\n<ul>\n<li>关键资源： 3（<code>HTML</code>、<code>style.css</code>、<code>app.js</code>）</li>\n<li>关键路径长度： 2或以上（浏览器会在一次连接中一起下载<code>style.css</code>和<code>app.js</code>）</li>\n<li>关键字节：11KB</li>\n</ul>\n<p>现在，我们要优化关键渲染路径，首先将<code>&lt;script&gt;</code>标签添加异步属性<code>async</code>，这样浏览器的<code>HTML</code>解析器就不会阻塞这个<code>JavaScript</code>文件了。</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img data-src=\"/images/63503acbly1fk56e0sokqj20oj074ab1.jpg\" alt=\"img\"></p>\n<ul>\n<li>关键资源：2（<code>app.js</code>为异步加载，不会成为阻塞渲染的资源）</li>\n<li>关键路径长度： 2或以上</li>\n<li>关键字节： 9KB（<code>app.js</code>不再是关键资源，所以没有算上它的大小）</li>\n</ul>\n<p>接下来对<code>CSS</code>进行优化，比如添加上媒体查询。</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img data-src=\"/images/63503acbly1fk56e15x4jj20ny082mxu.jpg\" alt=\"img\"></p>\n<ul>\n<li>关键资源：1（<code>app.js</code>为异步加载，<code>style.css</code>只有在打印时才会使用，所以只剩下<code>HTML</code>一个关键资源，也就是说当<code>DOM</code>树构建完毕，浏览器就会开始进行渲染）</li>\n<li>关键路径长度：1或以上</li>\n<li>关键字节：5KB</li>\n</ul>\n<p><strong>优化关键渲染路径就是在对关键资源、关键路径长度和关键字节进行优化</strong>。关键资源越少，浏览器在渲染前的准备工作就越少；同样，关键路径长度和关键字节关系到浏览器下载资源的效率，它们越少，浏览器下载资源的速度就越快。</p>\n<h3 id=\"其他JS在线测试网站\"><a href=\"#其他JS在线测试网站\" class=\"headerlink\" title=\"其他JS在线测试网站\u0010\"></a>其他JS在线测试网站\u0010</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qc2JlbmNoLm1lLw==\">jsbench.me</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2pzYmVuLmNoLw==\">jsben.ch</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWFzdXJldGhhdC5uZXQv\">measurethat.net</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWdldGVzdC5vcmcv\">webpagetest.org</span></li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsv\">浏览器的工作原理：新式网络浏览器幕后揭秘</span> <strong>强烈推荐</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9wZXJmb3JtYW5jZS9jcml0aWNhbC1yZW5kZXJpbmctcGF0aC9yZW5kZXItdHJlZS1jb25zdHJ1Y3Rpb24=\">渲染树构建、布局及绘制</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb3ouY29tL2Jsb2cvaW1wcm92aW5nLXNlYXJjaC1yYW5rLWJ5LW9wdGltaXppbmcteW91ci10aW1lLXRvLWZpcnN0LWJ5dGU=\">优化第一个字节的时间</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6Y3N1L2FydGljbGUvZGV0YWlscy83Mjg2MTg5MQ==\">TCP的三次握手与四次挥手（详解+动图）</span>推荐</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTYvMTIvMDIvcGVyZm9ybWFuY2UtdHVubmluZy5odG1s\">常见性能优化策略的总结</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb3ouY29tL2xlYXJuL3Nlby9wYWdlLXNwZWVk\">Page Speed</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzAxMWUwYzUxODgyNTJlYTY2YWZkZmEjaGVhZGluZy02OA==\">web性能优化篇</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTk2NmJkMTZmYjlhMDYzNTE3MmE1MGE=\">2018 前端性能优化清单</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ2Y2JhZWU1MWQ0NTNmNDU2MTJhMmM=\">（译）2019年前端性能优化清单 — 上篇</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ3MWVhZmYyNjVkYTYxNmQ1NDdjOGM=\">（译）2019年前端性能优化清单 — 中篇</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ3M2NkYWU1MWQ0NTUxOGQ0NzAxZmY=\">（译）2019年前端性能优化清单 — 下篇</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvZG9jcy9pbnNpZ2h0cy9ydWxlcw==\">PageSpeed Insights 规则</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zeWx2YW5hc3N1bi5naXRodWIuaW8vMjAxNy8xMC8wMy8yMDE3LTEwLTAzLUJyb3dzZXJDcml0aWNhbFJlbmRlcmluZ1BhdGgv\">浏览器渲染过程与性能优化</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yNjhjN2YzZGQ3YTY=\">如何提升 CSS 选择器性能</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbC5jbi9hcmNoaXZlcy85NTE3\">前端性能优化：2018年JavaScript开销及优化工具和方法</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTY1NDdkMGYyNjVkYTNlMjgzYTFkZjc=\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</span>推荐</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWFkODZjMTZmMjY1ZGE1MDVhNzdkY2E0\">彻底理解浏览器的缓存机制</span> 推荐2</li>\n</ol>\n","categories":["前端性能优化"],"tags":["性能优化"]},{"title":"前端监控","url":"/2024/04/29/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/","content":"<h1 id=\"前端监控\"><a href=\"#前端监控\" class=\"headerlink\" title=\"前端监控\"></a>前端监控</h1><h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><strong>为什么要进行前端监控：</strong></p>\n<ul>\n<li>页面的访问行为，PV、UV、IP、PV点击率、UV点击率、停留时长</li>\n<li>用户的操作行为，模块曝光、</li>\n<li>模块点击</li>\n<li>页面的性能，首屏渲染时间、API请求时间</li>\n<li>异常的监控，JS Error、API异常、业务异常</li>\n<li>业务的监控，成交金额、每日消息数</li>\n</ul>\n<p><strong>常见的应用场景：</strong></p>\n<ul>\n<li>流量分析</li>\n</ul>\n<p><strong>常见的前端监控平台：</strong></p>\n<ul>\n<li>百度统计</li>\n<li>阿里云ARMS</li>\n<li>友盟</li>\n</ul>\n<p><strong>前端监控的数据有什么作用</strong></p>\n<ul>\n<li>流量数据监控，如：PV、UV、点击率、页面停留时长等</li>\n<li>自定义事件监控，如：曝光事件、滑动事件、请求事件等</li>\n<li>交易指标监控，如：成交额、转化率等</li>\n<li>其他综合分析，如：用户画像分析、流量漏斗、销量预测等</li>\n</ul>\n<p><strong>前端监控的三个阶段</strong></p>\n<ul>\n<li>初阶：使用第三方平台，百度、友盟、阿里云ARMS等</li>\n<li>中阶：自研前端监控库，缺乏完整的监控体系</li>\n<li>高阶：自研前端监控平台，具备完整的监控体系</li>\n</ul>\n<h1 id=\"百度统计接入\"><a href=\"#百度统计接入\" class=\"headerlink\" title=\"百度统计接入\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b25namkuYmFpZHUuY29tLw==\">百度统计接入</span></h1><p><strong>流量分析免费，行为分析需要付费。</strong></p>\n<ol>\n<li>官网创建网站，设置域名和首页</li>\n<li>保证域名公共可读</li>\n<li>复制统计代码，添加到要跟踪的网页中（加入到head标签之前）</li>\n</ol>\n<p><strong>阿里云ARM和友盟分析方案较全，接入方案大致相同，但是当数据量较大时，有一定的成本，所以考虑自建前端统计系统。</strong></p>\n<p><strong>什么时候需要考虑自建前端监控系统？</strong></p>\n<ol>\n<li>不仅仅需要流量分析，还需要做行为分析</li>\n<li>自建成本小于或等于平台付费</li>\n<li>希望网站监控数据能存到自己数据库中，并且数据隐私化。</li>\n</ol>\n<h1 id=\"监控平台架构\"><a href=\"#监控平台架构\" class=\"headerlink\" title=\"监控平台架构\"></a>监控平台架构</h1><p><strong>前端监控平台的分层：</strong></p>\n<ul>\n<li><p>前端监控JSSDK</p>\n<ul>\n<li>采集</li>\n<li>上报<ul>\n<li>默认上报：页面PV、性能等</li>\n<li>手动上报：页面操作行为</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端监控API和大数据仓库</p>\n<ul>\n<li>接收上报的数据</li>\n<li>数据仓库：MaxCompute<ul>\n<li>数据查询</li>\n<li>数据存储</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端监控数据可视化</p>\n<ul>\n<li>日志大数据清洗</li>\n<li>大数据回流RDS（非结构化数据 &#x3D;&gt; 结构化数据）</li>\n</ul>\n</li>\n</ul>\n<p><strong>监控平台架构说明：</strong></p>\n<p><img data-src=\"/images/Snipaste_2024-04-29_08-11-46.jpg\" alt=\"监控平台架构\"></p>\n<h2 id=\"JS库的开发\"><a href=\"#JS库的开发\" class=\"headerlink\" title=\"JS库的开发\"></a>JS库的开发</h2><h4 id=\"JS-SDK\"><a href=\"#JS-SDK\" class=\"headerlink\" title=\"JS  SDK\"></a>JS  SDK</h4><p>monitor.js：</p>\n<pre><code class=\"js\">function collect()&#123;\n    console.log(&#39;collect&#39;);\n&#125;\nfunction upload()&#123;\n    console.log(&#39;upload&#39;);\n&#125;\nwindow.testMonitor = &#123;\n    collect,\n    upload,\n&#125;\n</code></pre>\n<p>上传到服务器，在需要监控的页面引入脚本。</p>\n<p><strong>一、直接引入脚本：</strong></p>\n<p>直接使用script标签引入在线地址。</p>\n<p><strong>二、异步加载（确保脚本加载完成后再使用api）：</strong></p>\n<pre><code class=\"html\">&lt;script&gt;\n(function()\n    const script = document.createElement(&#39;script&#39;);\n    script.src = &#39;https://imooc.youbaobao.xyz/imooc-cli-monitor.js&#39;\n    const body = document.body;\n    body.insertBefore(script,body.firstChild);\n    script.onload = function()&#123;\n    var event = new CustomEvent(&#39;onMonitorScriptLoad&#39;);\n    window.dispatchEvent(event);\n)()\n&lt;/script&gt;\n&lt;script&gt;\n    window.addEventListener(&#39;onMonitorScriptLoad&#39;,function()&#123;\n    window.testMonitor.collect();\n    window.testMonitor.upload();\n&#125;):\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"PV埋点\"><a href=\"#PV埋点\" class=\"headerlink\" title=\"PV埋点\"></a>PV埋点</h4><p><strong>一、分包便于代码书写和维护</strong></p>\n<p>假设将项目分为：index.js、collect.js和upload.js三个js文件，分别用于整合、收集和上报。</p>\n<p><strong>二、设置页面基本信息</strong></p>\n<p>在meta标签中设置变量，假设为：test-app-id，在body标签中设置test-page-id，此变量用于区分不同的站点。</p>\n<p><strong>三、collect.js</strong></p>\n<pre><code class=\"js\">import &#123; upload &#125; from &#39;./upload&#39;;\n//自定义一些钩子函数\nlet beforeCreateParams;\nlet beforeUpload;\nlet afterUpload;\nlet onError=(err)=&gt;&#123;\n    console.error(err);\n&#125;;\n\nexport function collect()&#123;\n    console.log(&#39;收集开始...&#39;);\n&#125;\n// 采集信息\nfunction collection(customData,eventType)&#123;\n    let appId , pageId , timeStamp , ua;\n    beforeCreateParams &amp;&amp; beforeCreateParams();\n    const metaList = document.getElementsByTagName(&#39;meta&#39;)\n    for (let i=0;i&lt; metaList.length;i++)&#123;\n        const meta = metaList[i];\n        console.log(meta.getAttribute(&#39;test-app-id&#39;));\n        if (meta.getAttribute(&#39;test-app-id&#39;))&#123;\n            appId = meta.getAttribute(&#39;test-app-id&#39;);\n         &#125;\n       &#125;\n    const body = document.body;\n    pageId = body.getAttribute(&#39;test-page-id&#39;);\n    if (!appId || !pageId) return;\n    timeStamp = new Date().getTime();\n    ua = window.navigator.userAgent;\n    console.log(appId,pageId,timeStamp,ua);\n    let data = `appId=$&#123;appId&#125;&amp;pageId=$&#123;pageId&#125;&amp;timeStamp=$&#123;timeStamp&#125;&amp;ua=$&#123;ua&#125;`;\n    if(beforeUpload)&#123;\n        data = beforeUpload(data); //允许定制数据\n    &#125;\n    //日志上报\n    // upload(&#123; appId,pageId,timeStamp,ua &#125;)  不常用\n    let url , uploadData;\n    try&#123;\n        data = &#123;...customData,...data&#125;\n        const ret = upload(data,&#123;eventType&#125;)\n        url = ret.url;\n        uploadData = ret.data;\n    &#125;catch(e)&#123;\n        onError(e);\n    &#125;finally&#123;\n        afterUpload &amp;&amp; afterUpload(url,uploadData);\n    &#125;\n    \n&#125;\n//发送PV日志\nexport function sendPV()&#123;\n    collection(&#123;&#125;,&#39;PV&#39;)\n&#125;\n// 上报曝光埋点\nexport function sendExp(data=&#123;&#125;)&#123;\n    collection(data,&#39;EXP&#39;)\n&#125;\n//注册钩子函数\nexport function registerBeforeCreateParams(fn)&#123;\n    beforeCreateParams = fn;\n&#125;\nexport function registerBeforeUpload(fn)&#123;\n    beforeUpload = fn;\n&#125;\nexport function registerAfterUpload(fn)&#123;\n    afterUpload = fn;\n&#125;\nexport function registerOnError(fn)&#123;\n    onError = fn;\n&#125;\nexport default &#123; &#125;;\n</code></pre>\n<p><strong>四、upload.js</strong></p>\n<pre><code class=\"js\">export function upload(data) &#123;\n    const img = new Image(); //利用image标签跨域特性\n    const &#123; eventType = &quot;PV&quot; &#125; = options;\n    const params = encodeURIComponent(data) + &#39;&amp;eventType=&#39; + eventType;\n    const src = &#39;http://dmqtest.com?data=&#39; + params ;\n    console.log(params,src,eventType);\n    img.src = src;\n    img = null; //注意内存释放\n    return &#123;\n        url: src,\n        data: &#123;\n            params,\n        &#125;\n    &#125;\n&#125;\nexport default upload;\n</code></pre>\n<p><strong>五、index.js</strong></p>\n<pre><code>import &#123; sendPV , registerBeforeCreateParams,registerBeforeUpload,registerAfterUpload &#125; from &#39;./collect&#39;;\nimport &#123; upload &#125; from &#39;./upload&#39;;\nwindow.testMonitor = &#123;\n    upload,\n    sendPV,\n    registerBeforeCreateParams,\n    registerBeforeUpload,\n    registerAfterUpload,\n    registerOnError\n&#125;\n</code></pre>\n<p><strong>六、index.html</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; test-app-id=&quot;app123456&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n    &lt;script src=&#39;https://dmqtest.com/index.js&#39;&gt;&lt;/script&gt;\n&lt;body test-page-id=&quot;page123456&quot;&gt;\n    &lt;script&gt;\n        window.onload = function()&#123;\n            window.testMonitor.registerBeforeCreateParams(()=&gt;&#123;\n                console.log(&#39;创建之前&#39;)\n            &#125;);\n            window.testMonitor.registerBrforeUpload((params)=&gt;&#123;\n                return params + &#39;&amp;custom=1&#39;; //添加自定义数据\n            &#125;)\n            window.testMonitor.registerAfterUpload((url,data)=&gt;&#123;\n                \n            &#125;)\n            window.testMonitor.sendPV();\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"曝光埋点\"><a href=\"#曝光埋点\" class=\"headerlink\" title=\"曝光埋点\"></a>曝光埋点</h4><p>曝光埋点记录元素由不可变到可变的过程，需要浏览器IntersectionObserver这个API的支持。</p>\n<p><strong>浏览器5种Observer：</strong></p>\n<ul>\n<li>MutationObserver（用于监听DOM树的变化，一般为属性、子节点的增删改）</li>\n<li>IntersectionObserver（用于监听一个元素和可视区域相交部分的比列，然后在可视比列到达某一阈值的时候触发回调）</li>\n<li>PerformanceObserver（用于检测性能度量事件，在浏览器的性能事件轴记录下一个新的performance entries的时候将会被通知）</li>\n<li>ResizeObserver（用于监听DOM的变化，一般为节点的出现和隐藏，节点大小的变化）</li>\n<li>ReportingObserver（用于监听过时的api、浏览器的一些干预行为的预告）</li>\n</ul>\n<p><strong>IntersectionObserver：</strong></p>\n<p><strong>方法：</strong></p>\n<ul>\n<li><p>observe：开始监听一个目标元素</p>\n<p>语法：IntersectionObserver.disconnect();</p>\n</li>\n<li><p>disconnect：停止监听</p>\n<p>语法：IntersectionObserver.observe(targetElement);</p>\n</li>\n<li><p>takeRecords:返回所有观察目标的IntersectionObserverEntry对象数组。</p>\n<p>语法：intersectionObserverEntries &#x3D; intersectionObserver.takeRecords();</p>\n</li>\n<li><p>unobserve:使IntersectionObserver停止监听特定目标元素</p>\n<p>语法：IntersectionObserver.unobserve(targetElement);</p>\n</li>\n</ul>\n<p><strong>配置项：</strong></p>\n<ul>\n<li>targetElement：目标DOM</li>\n<li>root：指定根目录，也就就是当目标元素显示在这个元素中时会触发监控回调</li>\n<li>rootMargin：类似于css的margin，设定root元素的边框区域。</li>\n<li>threhold：阈值，决定了什么时候触发回调函数。</li>\n</ul>\n<p><strong>返回参数：</strong></p>\n<ul>\n<li>tIme:可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li>\n<li>rootBounds:是在根元素矩形区域的信息</li>\n<li>intersectionRatio:目标元素的可见比例</li>\n<li>intersectionRect:目标元素与根元素交叉区域的信息</li>\n<li>isIntersecting:判断元素是否符合options中的可见条件</li>\n<li>boundingClientRect:目标元素的矩形区域的信息</li>\n<li>target:被观察的目标元素</li>\n</ul>\n<p><strong>upload.js文件中添加：</strong></p>\n<pre><code class=\"js\">// ....省略\n// 上报曝光埋点\nexport function sendExp(data=&#123;&#125;)&#123;\n    collection(data,&#39;EXP&#39;)\n&#125;\n// 最后在index.js中暴露出去。\n</code></pre>\n<p><strong>collect.js文件中添加：</strong></p>\n<pre><code class=\"js\">//....省略\nexport function collectAppear()&#123;\n    const appearEvent = new CustomEvent(&#39;onAppear&#39;);\n    const disappearEvent = new CustomEvent(&#39;onDisappear&#39;);\n    let ob;\n    if(window.testMonitorObserver)&#123;\n        ob = window.testMonitorObserver;\n    &#125;else&#123;\n        ob = new IntersectionObserver(function(e)&#123;\n        e.forEach(item=&gt;&#123;\n            if(item.intersectionRatio &gt; 0)&#123;\n                console.log(item.target.className + &#39;appear&#39;);\n                item.target.dispatchEvent(appearEvent);\n            &#125;else&#123;\n                console.log(item.target.className + &#39;disappear&#39;);\n                item.target.dispatchEvent(disappearEvent);\n            &#125;\n        &#125;)\n    &#125;);\n    &#125;\n    let obList = [];\n    const appear = document.querySelectorAll(&#39;[appear]&#39;);\n    for(let i=0;i&lt;appear.length;i++)&#123;\n        if(obList.includes(appear[i]))&#123;\n            ob.observe(appear[i]);\n            obList.push(appear[i]);\n        &#125;\n    &#125;\n    window.testMonitorObserver = ob; //存起来防止重复\n    window.monitorObserverList = obList;\n&#125;\n</code></pre>\n<p><strong>index.js中使用：</strong></p>\n<pre><code class=\"js\">//...省略\n// import引入collectAppear函数。\nwindow.onload = function()&#123;\n    collectAppear();\n&#125;\n</code></pre>\n<h4 id=\"点击埋点\"><a href=\"#点击埋点\" class=\"headerlink\" title=\"点击埋点\"></a><strong>点击埋点</strong></h4><p><strong>collect.js中添加：</strong></p>\n<pre><code class=\"js\">//...省略\n//上报点击埋点\nexport function sendClick(data=&#123;&#125;)&#123;\n    collection(data,&#39;CLICK&#39;)\n&#125;\n//暴露出去，index.js导入该方法并暴露出去。\n</code></pre>\n<h4 id=\"自定义埋点\"><a href=\"#自定义埋点\" class=\"headerlink\" title=\"自定义埋点\"></a>自定义埋点</h4><p><strong>collect.js中添加：</strong></p>\n<p>自定义埋点行为就直接在内部添加CUSTOM对应的处理逻辑，可以使用其他的Observer实现更多功能。</p>\n<pre><code class=\"js\">//...省略\n//上报自定义埋点\nexport function sendCustom(data=&#123;&#125;)&#123;\n    collection(data,&#39;CUSTOM&#39;)\n&#125;\n//暴露出去，index.js导入该方法并暴露出去。\n</code></pre>\n<h2 id=\"大数据平台开发\"><a href=\"#大数据平台开发\" class=\"headerlink\" title=\"大数据平台开发\"></a>大数据平台开发</h2><p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vemgvbWF4Y29tcHV0ZS8jOn46dGV4dD0lRTQlQkElOTElRTUlOEUlOUYlRTclOTQlOUYlRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUUlRTglQUUlQTElRTclQUUlOTclRTYlOUMlOEQlRTUlOEElQTEsJTI4TWF4Q29tcHV0ZSUyOSVFNiU5OCVBRiVFNCVCOCU4MCVFNyVBNyU4RCVFNSVCRiVBQiVFOSU4MCU5RiVFMyU4MCU4MSVFNSVBRSU4QyVFNSU4NSVBOCVFNiU4OSU5OCVFNyVBRSVBMSVFNyU5QSU4NFRCJTJGUEIlRTclQkElQTclRTYlOTUlQjAlRTYlOEQlQUUlRTQlQkIlOTMlRTUlQkElOTMlRTglQTclQTMlRTUlODYlQjMlRTYlOTYlQjklRTYlQTElODglRTMlODAlODIlMjBNYXhDb21wdXRlJUU1JTkwJTkxJUU3JTk0JUE4JUU2JTg4JUI3JUU2JThGJTkwJUU0JUJFJTlCJUU0JUJBJTg2JUU1JUFFJThDJUU1JTk2JTg0JUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU1JUFGJUJDJUU1JTg1JUE1JUU2JTk2JUI5JUU2JUExJTg4JUU0JUJCJUE1JUU1JThGJThBJUU1JUE0JTlBJUU3JUE3JThEJUU3JUJCJThGJUU1JTg1JUI4JUU3JTlBJTg0JUU1JTg4JTg2JUU1JUI4JTgzJUU1JUJDJThGJUU4JUFFJUExJUU3JUFFJTk3JUU2JUE4JUExJUU1JTlFJThCJUVGJUJDJThDJUU4JTgzJUJEJUU1JUE0JTlGJUU2JTlCJUI0JUU1JUJGJUFCJUU5JTgwJTlGJUU3JTlBJTg0JUU4JUE3JUEzJUU1JTg2JUIzJUU3JTk0JUE4JUU2JTg4JUI3JUU2JUI1JUI3JUU5JTg3JThGJUU2JTk1JUIwJUU2JThEJUFFJUU4JUFFJUExJUU3JUFFJTk3JUU5JTk3JUFFJUU5JUEyJTk4JUVGJUJDJThDJUU2JTlDJTg5JUU2JTk1JTg4JUU5JTk5JThEJUU0JUJEJThFJUU0JUJDJTgxJUU0JUI4JTlBJUU2JTg4JTkwJUU2JTlDJUFDJUVGJUJDJThDJUU1JUI5JUI2JUU0JUJGJTlEJUU5JTlBJTlDJUU2JTk1JUIwJUU2JThEJUFFJUU1JUFFJTg5JUU1JTg1JUE4JUUzJTgwJTgy\">MaxCompute阿里云原生大数据计算服务</span>：</strong></p>\n<p>MaxCompute是基于数据分析场景的企业级SaaS模式云数据仓库，以Serverless架构提供快速、全托管的在线数据仓库服务，消除了传统数据平台在资源扩展性和弹性方面的限制，最小化用户运维投入。</p>\n<p><strong>使用：</strong></p>\n<ol>\n<li><p>使用MaxCompute创建数据库，在数据开发页面创建表进行记录前端监控数据</p>\n</li>\n<li><p>使用py脚本对接（暂时没有js包），需要安装python和pip（包管理工具）</p>\n</li>\n<li><p>安装pyodps：<code>pip install pyodps</code></p>\n</li>\n<li><p>connect.py文件中写入示例：</p>\n<pre><code class=\"python\">from odps import ODPS;\n\nodps = ODPS(&#39;LTAI5tBDj3HajwRVhc6me5KR&#39;,&#39;DJqWAI1IWUBZnZGE#FKDSFJDEJLet&#39;,&#39;test_monitor&#39;,endpoint=&#39;https://service-cn-hangzhou.odps.aliyun-inc.com&#39;)\n\nresult = odps.executexecute_sql(&#39;select * from test_monitor where datetime=&quot;20240325&quot;&#39;)\n\nwith result.open_reader() as reader:\n    for record in reader:\n        print(record[0],record[1])\n# 打印表名\nfor table in odps.list_tables():\n    print(table)\ndata = [\n    [&#39;appid123&#39;,&#39;pageid123&#39;,&#39;123456&#39;,&#39;ua123&#39;,&#39;http://www.baidu.com&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;202403&#39;]\n]\n# 写入数据\nodps.write_table(&#39;test_table&#39;, data)\n# ....等等后续操作\n</code></pre>\n</li>\n</ol>\n<p><strong>前端监控平台可视化架构图：</strong></p>\n<p><img data-src=\"/images/Snipaste_2024-04-30_15-14-09.jpg\" alt=\"前端监控流程架构\"></p>\n","categories":["前端监控"],"tags":["前端监控"]},{"title":"容器化运维操作","url":"/2024/02/02/%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/","content":"<h1 id=\"5-6-容器化运维操作\"><a href=\"#5-6-容器化运维操作\" class=\"headerlink\" title=\"5-6 容器化运维操作\"></a>5-6 容器化运维操作</h1><p>日趋复杂的运维开发环境，对虚拟服务器及应用服务的要求更加的多元化。我们需要更加容易扩展、性能优越、方便监控的管理服务，容器化应用、容器化运维应运而生。</p>\n<p><strong>【知己知彼】你将在学习本课程中学习到：</strong></p>\n<ol>\n<li>理解&#x2F;安装docker容器技术</li>\n<li>秒级快速部署mysql、nginx、tomcat等服务</li>\n<li>使用容器技术发布nodejs应用</li>\n<li>…</li>\n</ol>\n<p><strong>【工欲善其事，必先利其器】你需要准备的环境（三选一）：</strong></p>\n<ul>\n<li>Linux环境(Centos 7以上&#x2F;Debian 8以上&#x2F;Ubuntu 16.04LTS以上版本)</li>\n<li>Windows 64位专业版&#x2F;企业版&#x2F;教育版(Build 15063以上)</li>\n<li>macOS Sierra 10.12以上的版本</li>\n</ul>\n<blockquote>\n<p>如果，你有了上面的环境，就可以很快速的跟着我们的内容快速学习。</p>\n</blockquote>\n<h2 id=\"容器和Docker\"><a href=\"#容器和Docker\" class=\"headerlink\" title=\"容器和Docker\"></a>容器和Docker</h2><h3 id=\"什么是容器化？\"><a href=\"#什么是容器化？\" class=\"headerlink\" title=\"什么是容器化？\"></a>什么是容器化？</h3><p>容器化是将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像的一种软件开发方法。</p>\n<p><img data-src=\"/./assets/docker-containerized-appliction-blue-border_2.png\" alt=\"docker-containerized-appliction-blue-border_2\"></p>\n<p>软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。</p>\n<p>容器化应用程序在容器主机上运行，而容器主机在 OS（Linux 或 Windows）上运行。因此，容器的占用比虚拟机 (VM) 映像小得多。</p>\n<p>容器化的特点：</p>\n<ul>\n<li>一致的运行环境</li>\n<li>可伸缩性</li>\n<li>更方便的移植</li>\n<li>隔离性</li>\n</ul>\n<h3 id=\"什么是Docker\"><a href=\"#什么是Docker\" class=\"headerlink\" title=\"什么是Docker?\"></a>什么是Docker?</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21vYnkvbW9ieQ==\">Docker</span>是用GO语言开发的应用容器引擎，基于容器化，沙箱机制的应用部署技术。可适用于自动化测试、打包，持续集成和发布应用程序等场景，包括阿里云，亚马逊在内的云计算服务商都采用了docker来打造serverless服务平台。它不仅仅可以部署项目，还可以用于数据库搭建，nginx服务搭建，nodejs、php等编程语言环境搭建。</p>\n<blockquote>\n<p>PS: docker现已改名为moby</p>\n</blockquote>\n<p>Docker中的三个<strong>重要概念</strong>：</p>\n<ul>\n<li><p>镜像(image)：分片的（只读）文件系统，由Dockerfile创建</p>\n<p>独立、易扩展、更效率</p>\n</li>\n<li><p>容器(container)：由Docker进程创建和管理的：文件系统 +  系统资源 + 网络配置 + 日志管理</p>\n<p>docker是docker镜像的运行环境，所以容器的概念就比较好理解了</p>\n</li>\n<li><p>仓库(registry)：用来远端存储docker镜像</p>\n<p>版本控制、变更管理、为持续集成与快速部署提供便利</p>\n</li>\n</ul>\n<h3 id=\"Docker-vs-虚拟机\"><a href=\"#Docker-vs-虚拟机\" class=\"headerlink\" title=\"Docker vs 虚拟机\"></a>Docker vs 虚拟机</h3><p><img data-src=\"/./assets/docker-containerized-and-vm-transparent-bg.png\" alt=\"docker-containerized-and-vm-transparent-bg\"></p>\n<ol>\n<li>容器是应用层的抽象，它将代码和依赖关系打包在一起。 多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。 容器占用的空间比VM少（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要更少的VM和操作系统。</li>\n<li>虚拟机（VM）是物理硬件的抽象，将一台服务器转变为多台服务器。 管理程序允许多台VM在单台机器上运行。 每个VM都包含操作系统的完整副本，应用程序，必要的二进制文件和库 - 占用数十GB。 虚拟机也可能很慢启动。</li>\n</ol>\n<p><strong>总结一下：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">容器</th>\n<th align=\"left\">虚拟机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">启动</td>\n<td align=\"left\">秒级</td>\n<td align=\"left\">分钟级</td>\n</tr>\n<tr>\n<td align=\"left\">硬盘使用</td>\n<td align=\"left\">一般为 <code>MB</code></td>\n<td align=\"left\">一般为 <code>GB</code></td>\n</tr>\n<tr>\n<td align=\"left\">性能</td>\n<td align=\"left\">接近原生</td>\n<td align=\"left\">弱于</td>\n</tr>\n<tr>\n<td align=\"left\">系统支持量</td>\n<td align=\"left\">单机支持上千个容器</td>\n<td align=\"left\">一般几十个</td>\n</tr>\n<tr>\n<td align=\"left\">开发&#x2F;环境定制</td>\n<td align=\"left\">方便(命令行、面向对象式)</td>\n<td align=\"left\">进入虚拟机</td>\n</tr>\n</tbody></table>\n<p><strong>相同点：</strong></p>\n<ol>\n<li>文件隔离&#x2F;文件共享（沙箱）</li>\n<li>资源隔离</li>\n<li>网络隔离</li>\n<li>支持多种宿主环境（扩展）</li>\n<li>快照&#x2F;镜像（版本控制&#x2F;变更管理）</li>\n</ol>\n<p><strong>不同点：</strong></p>\n<ol>\n<li>不同的资源管理&#x2F;依赖&#x2F;&#x2F;释放（虚拟机占用更多的系统资源）</li>\n<li>不同的应用运行环境</li>\n<li>Docker是写时复制</li>\n<li>不同的日志方式(Docker收集日志，而虚拟机需要在虚拟系统里面看日志)</li>\n<li>不同的交互方式(Docker偏shell，虚拟机偏GUI)</li>\n</ol>\n<h3 id=\"Docker的工作原理-重点\"><a href=\"#Docker的工作原理-重点\" class=\"headerlink\" title=\"Docker的工作原理(重点)\"></a>Docker的工作原理(重点)</h3><p><img data-src=\"/./assets/work.png\" alt=\"work\"></p>\n<p>Docker是容器化部署技术，它主要作用在于通过运行容器来实现应用部署，而容器基于镜像运行。</p>\n<p>简单地说，就是将你的项目和依赖包(基础镜像)打成一个带有启动指令的项目镜像，然后在服务器创建一个容器，让镜像在容器内运行，从而实现项目的部署。</p>\n<p>服务器就是容器的宿主机，docker容器与宿主机之间是相互隔离的。</p>\n<p>Docker 的基础是Linux容器（LXC：Linux Containers）等技术。</p>\n<p><strong>一般情况下：</strong></p>\n<p>Linux(服务器) -&gt; tomcat安装 -&gt; Java依赖 -&gt; maven依赖 -&gt;放置在&#x2F;usr&#x2F;lib目录 -&gt; 配置tomcat端口&#x2F;目录 -&gt; 运行tomcat中的startup.sh脚本 -&gt; 配置网络、防火墙等(后续) -&gt; 服务启动</p>\n<p><strong>Docker：</strong></p>\n<p>使用基于java的tomcat镜像 -&gt; docker run -&gt; 指定端口&#x2F;挂载webapp目录 -&gt; 服务启动</p>\n<p>这其中，发生了什么？</p>\n<ol>\n<li><p>Docker会自己拉取镜像，若本地已经存在该镜像，则不用到网上去拉取</p>\n</li>\n<li><p>创建新的容器</p>\n</li>\n<li><p>分配文件系统并且挂着一个可读写的层，任何修改容器的操作都会被记录在这个读写层上，你可以保存这些修改成新的镜像，也可以选择不保存，那么下次运行改镜像的时候所有修改操作都会被消除</p>\n</li>\n<li><p>分配网络\\桥接接口，创建一个允许容器与本地主机通信的网络接口</p>\n</li>\n<li><p>设置ip地址，从池中寻找一个可用的ip地址附加到容器上，换句话说，localhost并不能访问到容器</p>\n</li>\n<li><p>运行你指定的程序</p>\n</li>\n<li><p>捕获并且提供应用输出，包括输入、输出、报错信息</p>\n</li>\n</ol>\n<p>Docker的价值：</p>\n<p>从应用架构角度：统一复杂的构建环境；</p>\n<p>从应用部署角度：解决依赖不同、构建麻烦的问题，结合自动化工具（如jenkins）提高效率。</p>\n<p>从集群管理角度：规范的服务<strong>调度</strong>，<strong>服务发现</strong>，<strong>负载均衡</strong></p>\n<h2 id=\"常见的应用场景介绍\"><a href=\"#常见的应用场景介绍\" class=\"headerlink\" title=\"常见的应用场景介绍\"></a>常见的应用场景介绍</h2><p>Docker提供了轻量级的虚拟化，相比于虚拟机，可以在同一台机器上创建更多数量的容器。它常见的应用场景：1. 快速部署；2. 隔离应用； 3. 提高开发效率； 4. 版本控制； 5. 简化配置，整合资源； </p>\n<h3 id=\"快速部署\"><a href=\"#快速部署\" class=\"headerlink\" title=\"快速部署\"></a>快速部署</h3><p>我们尝试着来部署一个mysql：</p>\n<pre><code class=\"bash\">docker run -d --name mysql-test -e MYSQL_ROOT_PASSWORD=123456 mysql\n</code></pre>\n<p><img data-src=\"/./assets/3.gif\" alt=\"3\"></p>\n<p>同样的道理，我们来部署一个nginx:</p>\n<p><img data-src=\"/./assets/4.gif\" alt=\"4\"></p>\n<p>注意：这里没有映射服务端口，所以在<code>80</code>端口是看不到<code>index.html</code>中的内容的。需要加入<code>-p</code>参数来映射端口！！</p>\n<pre><code class=\"bash\">docker run -d --name web -p 8000:80 -v $&#123;your_dir&#125;:/usr/share/nginx/html nginx\n</code></pre>\n<h3 id=\"隔离应用\"><a href=\"#隔离应用\" class=\"headerlink\" title=\"隔离应用\"></a>隔离应用</h3><p>我们可以同时跑两个mysql，两个nginx，指定不同的端口进行映射：</p>\n<p>把<code>mysql-test1</code>映射到<code>8001</code>端口，把<code>mysql-test2</code>映射到<code>8002</code>端口。</p>\n<pre><code class=\"bash\">docker run -d --name mysql-test1 -p 8001:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql\ndocker run -d --name mysql-test2 -p 8002:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql\n</code></pre>\n<p>把web1映射到8100端口，把web2映射到8200端口。</p>\n<pre><code class=\"bash\">docker run -d --name web1 -p 8100:80 -v $&#123;your_dir&#125;:/usr/share/nginx/html nginx\ndocker run -d --name web2 -p 8200:80 -v $&#123;your_dir&#125;:/usr/share/nginx/html nginx\n</code></pre>\n<h3 id=\"提高开发效率\"><a href=\"#提高开发效率\" class=\"headerlink\" title=\"提高开发效率\"></a>提高开发效率</h3><ol>\n<li><p>一致的运行环境</p>\n<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n</li>\n<li><p>更快速的启动时间</p>\n</li>\n</ol>\n<p>   传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>\n<ol start=\"3\">\n<li><p>更高效的复用系统资源</p>\n<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n</li>\n<li><p>仓库&#x2F;镜像机制</p>\n<p>使用仓库可以方便的在任何有docker进程的虚拟机&#x2F;服务器&#x2F;主机上运行docker应用，环境的统一，让它们的部署变的非常的简单。</p>\n</li>\n</ol>\n<h3 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h3><p>Docker容器还可以像git仓库一样，可以让你提交变更到Docker镜像中并通过不同的版本来管理它们，来看看下面的例子：</p>\n<p>我们之前创建了一个<code>mysql</code>，现在，我们使用<code>commit</code>命令就可以给它做一个快照，打上一个<code>tag</code>。</p>\n<p><img data-src=\"/./assets/5.gif\" alt=\"5\"></p>\n<p>在后面的课程中，我们会详细的介绍<a href=\"#Docker%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(%E9%87%8D%E7%82%B9)\">Docker的常见命令</a></p>\n<h3 id=\"DevOps流程\"><a href=\"#DevOps流程\" class=\"headerlink\" title=\"DevOps流程\"></a>DevOps流程</h3><p>对开发和运维（<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvRGV2T3Bz\">DevOps</span>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>\n<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly95ZWFzeS5naXRib29rcy5pby9kb2NrZXJfcHJhY3RpY2UvaW1hZ2UvZG9ja2VyZmlsZQ==\">Dockerfile</span> 来进行镜像构建，并结合 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udGludW91c19pbnRlZ3JhdGlvbg==\">持续集成(Continuous Integration)</span> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udGludW91c19kZWxpdmVyeQ==\">持续部署(Continuous Delivery&#x2F;Deployment)</span> 系统进行自动部署。</p>\n<p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\n<h2 id=\"使用Docker\"><a href=\"#使用Docker\" class=\"headerlink\" title=\"使用Docker\"></a>使用Docker</h2><h3 id=\"Docker如何进行安装\"><a href=\"#Docker如何进行安装\" class=\"headerlink\" title=\"Docker如何进行安装\"></a>Docker如何进行安装</h3><h4 id=\"关于系统需求-重点\"><a href=\"#关于系统需求-重点\" class=\"headerlink\" title=\"关于系统需求(重点)\"></a>关于系统需求(重点)</h4><ol>\n<li>平台类</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作系统</th>\n<th align=\"center\">x86_64</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci1tYWMvaW5zdGFsbC8=\">Docker Desktop for Mac (macOS)</span></td>\n<td align=\"center\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci13aW5kb3dzL2luc3RhbGwv\">Docker Desktop for Windows (Microsoft Windows 10)</span></td>\n<td align=\"center\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li>服务器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">平台</th>\n<th align=\"left\">x86_64 &#x2F; amd64</th>\n<th align=\"left\">ARM</th>\n<th align=\"left\">ARM64 &#x2F; AARCH64</th>\n<th align=\"left\">IBM Power (ppc64le)</th>\n<th align=\"left\">IBM Z (s390x)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvY2VudG9zLw==\">CentOS</span></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvZGViaWFuLw==\">Debian</span></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/debian/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/debian/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/debian/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvZmVkb3JhLw==\">Fedora</span></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/fedora/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/fedora/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvdWJ1bnR1Lw==\">Ubuntu</span></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n</tr>\n</tbody></table>\n<h4 id=\"Linux-重点\"><a href=\"#Linux-重点\" class=\"headerlink\" title=\"Linux(重点)\"></a>Linux(重点)</h4><p>对于中国用户：</p>\n<pre><code class=\"shell\">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n</code></pre>\n<p>对于国外vps：</p>\n<pre><code>curl -fsSL https://get.docker.com -o get-docker.sh\nsh get-docker.sh\n</code></pre>\n<blockquote>\n<p>脚本介绍：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9kb2NrZXItaW5zdGFsbA==\">https://github.com/docker/docker-install</span></p>\n</blockquote>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>安装Docker的系统需求：</p>\n<ul>\n<li>系统版本：Windows 10 64bit: Pro, Enterprise or Education (Build 15063 or later).</li>\n<li>在BIOS中开启了虚拟化（virtualization），正常情况下会默认开启，去系统管理中看看有没有Hyper-v被安装了。</li>\n<li>CPU特性：SLAT-capable.</li>\n<li>4GB以上的内存</li>\n</ul>\n<blockquote>\n<p>如果不满足上面的需求，则需要使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vdG9vbGJveC9vdmVydmlldy8=\">Docker Toolbox</span>，相当于是运行了一个virtualbox的虚拟镜像。</p>\n</blockquote>\n<h4 id=\"MacOS\"><a href=\"#MacOS\" class=\"headerlink\" title=\"MacOS\"></a>MacOS</h4><p><strong>方法一官方<code>dmg</code>：</strong></p>\n<p>官方下载地址：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9lZGl0aW9ucy9jb21tdW5pdHkvZG9ja2VyLWNlLWRlc2t0b3AtbWFj\">Docker Descktop for Mac</span></p>\n<p>对系统的要求：</p>\n<blockquote>\n<p>Requires Apple Mac OS Sierra 10.12 or above. Download <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vdG9vbGJveC9vdmVydmlldy8=\">Docker Toolbox</span> for previous OS versions.</p>\n</blockquote>\n<p>只要系统是 Mac OS Sierra 10.12以上即可。</p>\n<p>下载完<code>Docker.dmg</code>安装包之后，双击即可以安装，可能需要系统管理员权限，输入密码即可。</p>\n<p>运行过后，小图标：</p>\n<p><img data-src=\"/./assets/2.gif\" alt=\"2\"></p>\n<p>安装完之后，在终端工具中，使用<code>docker version</code>来查看Docker版本。</p>\n<p><img data-src=\"/./assets/docker-version.jpg\" alt=\"docker-version\"></p>\n<p><strong>方法二brew cask：</strong></p>\n<pre><code class=\"shell\">brew update \n\nbrew cask install docker\n\n# 删除的方法, 还需要手动删除Docker.app\nbrew cask uninstall docker\n</code></pre>\n<p>上面的命令将会把Docker安装在<code>Applications</code>目录下。</p>\n<h3 id=\"Docker国内加速\"><a href=\"#Docker国内加速\" class=\"headerlink\" title=\"Docker国内加速\"></a>Docker国内加速</h3><ol>\n<li>Docker的Toolbox镜像站(推荐)，主要是针对低版本的windows与mac用户：</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS9kb2NrZXItdG9vbGJveC8=\">http://mirrors.aliyun.com/docker-toolbox/</span></p>\n<ol start=\"2\">\n<li>Docker镜像加速，主要是对<code>docker pull</code>拉取镜像操作进行网络加速优化：</li>\n</ol>\n<p>需要注册阿里云的账号，登录<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20v\">容器Hub服务</span>，在左侧的加速器帮助页面就会显示为你独立分配的加速地址。</p>\n<p><img data-src=\"/./assets/image-20190524172015448.png\" alt=\"/images/image-20190524172015448\"></p>\n<h3 id=\"第一个Docker应用hello-world\"><a href=\"#第一个Docker应用hello-world\" class=\"headerlink\" title=\"第一个Docker应用hello world\"></a>第一个Docker应用hello world</h3><ol>\n<li><p>查看docker版本</p>\n</li>\n<li><p>运行第一个Docker应用</p>\n<p>使用<code>docker run</code>命令</p>\n</li>\n<li><p>查看容器运行状态</p>\n<p>使用<code>docker ps</code>命令来查看正在运行的容器的状态，<code>-a</code>参数来查看所有的已经运行的容器(无论是否停止)</p>\n</li>\n</ol>\n<p><img data-src=\"/./assets/1.gif\" alt=\"1\"></p>\n<h3 id=\"Docker常见命令-重点\"><a href=\"#Docker常见命令-重点\" class=\"headerlink\" title=\"Docker常见命令(重点)\"></a>Docker常见命令(重点)</h3><ul>\n<li><p>**创建<code>run</code>**，<code>-p</code> 映射宿主机的端口给镜像服务使用，<code>-v</code> 挂载宿主机的文件目录到镜像里面去，-it是提供交互式的终端工具，<code>-d</code> 是让镜像容器在后台去持续运行,<code>--name</code> 指定容器的名称，exec可以进入到容器里面去：</p>\n<pre><code>docker exec -it &lt;container_name&gt; /bin/bash\n\ndocker exec -it &lt;container_name&gt; /bin/sh\n</code></pre>\n</li>\n<li><p><strong>启动<code>start</code>&#x2F;停止<code>stop</code>&#x2F;重启<code>restart</code>&#x2F;删除已停止容器<code>rm</code></strong></p>\n</li>\n<li><p><strong>登录仓库<code>login</code>&#x2F;拉取镜像<code>pull</code>&#x2F;推送<code>push</code>&#x2F;提交镜像<code>commit</code>&#x2F;给指定容器标签<code>tag</code></strong></p>\n<p>docker hub上去注册我们的账号，才能使用login</p>\n<p>使用docker commit来给运行中的容器打tag:</p>\n<pre><code>docker commit &lt;container_id&gt; &lt;namespace&gt;/&lt;image_name&gt;:tag\n</code></pre>\n<pre><code>docker commit e12b80defe8c itcast/mysql\n</code></pre>\n<p>使用<code>pull</code>&#x2F;<code>push</code>命令来推送本地的镜像到远程仓库</p>\n<pre><code>docker pull/push &lt;namespace&gt;/&lt;image_name&gt;:tag\n</code></pre>\n</li>\n<li><p>查看所有本地镜像<code>images</code>&#x2F;删除本地镜像<code>rmi</code></p>\n<p>删除镜像之前，要停止<code>stop</code>并且删除<code>rm</code>运行中的容器。</p>\n</li>\n<li><p>查看容器服务打印的日志<code>logs</code>&#x2F;检阅容器<code>inspect</code>(更详细的容器信息，硬件&#x2F;网络&#x2F;版本等)&#x2F;进入容器<code>exec</code></p>\n</li>\n<li><p>查看版本<code>version</code>&#x2F;docker进程信息<code>info</code></p>\n</li>\n<li><p>查看命令帮助：</p>\n</li>\n</ul>\n<pre><code>docker &lt;run/pull&gt; --help\n</code></pre>\n<h2 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h2><h3 id=\"制作Docker镜像-重点\"><a href=\"#制作Docker镜像-重点\" class=\"headerlink\" title=\"制作Docker镜像(重点)\"></a>制作Docker镜像(重点)</h3><p>Dockerfile 是一个由一堆命令+参数构成的脚本，使用 <code>docker build</code> 即可执行脚本构建镜像，自动的去做一些事，主要用于进行持续集成。</p>\n<p>一般，Dockerfile 共包括四部分：</p>\n<ul>\n<li>基础镜像信息</li>\n<li>维护者信息</li>\n<li>镜像操作指令</li>\n<li>容器启动时执行指令</li>\n</ul>\n<p>当Node.js遇见Docker，下面介绍Docker在前端中的应用：</p>\n<p>一个简单的Koa应用：</p>\n<pre><code class=\"javascript\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\n// response\napp.use(ctx =&gt; &#123;\n  ctx.body = &#39;Hello Koa!!&#39;;\n&#125;);\n\napp.listen(3000);\n</code></pre>\n<p>Dockerfile示例：</p>\n<pre><code class=\"dockerfile\">FROM node:10\n\nLABEL maintainer=itheima@itcast.cn\n\n# 创建 app 目录\nWORKDIR /app\n\n# 把 package.json，package-lock.json(npm@5+) 或 yarn.lock 复制到工作目录(相对路径)\nCOPY [&quot;package.json&quot;,&quot;*.lock&quot;,&quot;./&quot;]\n\n# 打包 app 源码\n# 特别注意：要指定工作目录中的文件名\nCOPY src ./src\n\n# 使用.dockerignore文件，上面两个COPY合并成一个\n# COPY . .\n\n# 使用Yarn安装 app 依赖\n# 如果你需要构建生产环境下的代码，请使用：\n# --prod参数\nRUN yarn --prod --registry=https://registry.npm.taobao.org\n\n# 对外暴露端口 -p 4000:3000\nEXPOSE 3000\n\nCMD [ &quot;node&quot;, &quot;src/index.js&quot; ]\n</code></pre>\n<p>使用<code>docker build</code>打包：</p>\n<pre><code class=\"shell\">docker build -t $&#123;your_name&#125;/$&#123;image_name&#125;:$&#123;tag&#125; .\n</code></pre>\n<p>这里的<code>your_name</code>代表的是远程仓库中的用户名，或者仓库地址; <code>image_name</code>为镜像名称，<code>tag</code>是给镜像打的标签，用于版本控制。例如：</p>\n<pre><code class=\"shell\">docker build -t itheima/node-demo:1.0 .\n</code></pre>\n<p>打包过程：</p>\n<pre><code class=\"bash\">$ docker build -t itheima/node-demo:1.0 .\nSending build context to Docker daemon  17.92kB\nStep 1/8 : FROM node:10\n ---&gt; 5a401340b79f\nStep 2/8 : LABEL maintainer=itheima@itcast.cn\n ---&gt; Using cache\n ---&gt; dd01419f30d5\nStep 3/8 : WORKDIR /app\n ---&gt; Using cache\n ---&gt; bb9a44851ec9\nStep 4/8 : COPY . .\n ---&gt; Using cache\n ---&gt; b08ff37c5456\nStep 5/8 : RUN ls -la /app\n ---&gt; Using cache\n ---&gt; 4e0e57e807a1\nStep 6/8 : RUN yarn --prod --registry=https://registry.npm.taobao.org\n ---&gt; Using cache\n ---&gt; 96ab842b4766\nStep 7/8 : EXPOSE 3000\n ---&gt; Using cache\n ---&gt; 505dda4e680f\nStep 8/8 : CMD [ &quot;node&quot;, &quot;src/index.js&quot; ]\n ---&gt; Using cache\n ---&gt; f60e25a577de\nSuccessfully built f60e25a577de\nSuccessfully tagged itheima/node-demo:1.0\n</code></pre>\n<p><strong>回顾前面的知识：</strong></p>\n<p>如何使用？</p>\n<p>还记得<code>docker run</code>命令吗？</p>\n<pre><code class=\"bash\">docker run -d --name nodedemo -p 3000:3000 itheima/node-demo:1.0\n</code></pre>\n<p>然后使用<code>docker ps</code>来看运行状态</p>\n<pre><code class=\"bash\">$ docker run -d --name nodedemo -p 3000:3000 itheima/node-demo:1.0\nc863da9afea1558593843233aec08989184d8dafbb0f8443830d1e523104ab00\n$ docker ps\nCONTAINER ID        IMAGE                   COMMAND               CREATED             STATUS              PORTS                    NAMES\nc863da9afea1        itheima/node-demo:1.0   &quot;node src/index.js&quot;   2 seconds ago       Up 1 second         0.0.0.0:3000-&gt;3000/tcp   nodedemo\n</code></pre>\n<h3 id=\"Docker-compose介绍\"><a href=\"#Docker-compose介绍\" class=\"headerlink\" title=\"Docker-compose介绍\"></a>Docker-compose介绍</h3><p>通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p>\n<p><img data-src=\"/./assets/docker-compose.png\" alt=\"docker-compose\"></p>\n<p>Compose 中有两个重要的概念：</p>\n<ul>\n<li>服务 (service) ：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (project) ：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li>\n</ul>\n<p>Docker Compose 是 Docker 的独立产品，因此需要安装 Docker 之后在单独安装 Docker Compose .</p>\n<p><strong>安装方法：</strong></p>\n<pre><code class=\"bash\">#下载\nsudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\n#安装\nchmod +x /usr/local/bin/docker-compose\n#查看版本\ndocker-compose --version\n</code></pre>\n<p><strong>常见使用：</strong></p>\n<p>前面的例子，使用<code>docker-compose</code>改写：</p>\n<pre><code class=\"yaml\">version: &#39;3&#39;\nservices:\n  mysql:\n    image: mysql\n    container_name: test-mysql\n    ports:\n    - &quot;8000:3306&quot;\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n</code></pre>\n<p>在此文件的当前目录下，使用<code>docker-compose up -d</code>来执行。</p>\n<p>生命周期管理：</p>\n<p>创建：<code>run</code>&#x2F;<code>up</code></p>\n<p>启动&#x2F;停止&#x2F;删除&#x2F;重启：<code>start/stop/rm/restart</code></p>\n<p>检视&#x2F;日志：<code>logs</code>&#x2F;<code>ps</code></p>\n<p>看两个个复杂的应用：</p>\n<p>搭建本地mongo + mongo-express服务</p>\n<pre><code class=\"yaml\">version: &#39;3.1&#39;\nservices:\n  mongo:\n    image: mongo\n    restart: always\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: root\n      MONGO_INITDB_ROOT_PASSWORD: 123456\n\n  mongo-express:\n    image: mongo-express\n    restart: always\n    ports:\n      - 8081:8081\n    environment:\n      ME_CONFIG_MONGODB_ADMINUSERNAME: root\n      ME_CONFIG_MONGODB_ADMINPASSWORD: 123456\n</code></pre>\n<p>给公司搭建一个git服务器吧？！</p>\n<p>项目地址: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NhbWVlcnNibi9kb2NrZXItZ2l0bGFi\">https://github.com/sameersbn/docker-gitlab</span></p>\n<p>推荐服务器配置：适用于10人的小团队~~~~</p>\n<p>2core</p>\n<p>2GB+2GB(swap) </p>\n<pre><code class=\"yaml\">version: &#39;2&#39;\n\nservices:\n  redis:\n    restart: always\n    image: sameersbn/redis:4.0.9-1\n    command:\n    - --loglevel warning\n    volumes:\n    - /srv/docker/gitlab/redis:/var/lib/redis:Z\n\n  postgresql:\n    restart: always\n    image: sameersbn/postgresql:10\n    volumes:\n    - /srv/docker/gitlab/postgresql:/var/lib/postgresql:Z\n    environment:\n    - DB_USER=gitlab\n    - DB_PASS=password\n    - DB_NAME=gitlabhq_production\n    - DB_EXTENSION=pg_trgm\n\n  gitlab:\n    restart: always\n    image: sameersbn/gitlab:11.11.0\n    depends_on:\n    - redis\n    - postgresql\n    ports:\n    - &quot;10080:80&quot;\n    - &quot;10022:22&quot;\n    volumes:\n    - /srv/docker/gitlab/gitlab:/home/git/data:Z\n    environment:\n    - DEBUG=false\n\n    - DB_ADAPTER=postgresql\n    - DB_HOST=postgresql\n    - DB_PORT=5432\n    - DB_USER=gitlab\n    - DB_PASS=password\n    - DB_NAME=gitlabhq_production\n\n    - REDIS_HOST=redis\n    - REDIS_PORT=6379\n\n    - TZ=Asia/Kolkata\n    - GITLAB_TIMEZONE=Kolkata\n\n    - GITLAB_HTTPS=false\n    - SSL_SELF_SIGNED=false\n\n    - GITLAB_HOST=localhost\n    - GITLAB_PORT=10080\n    - GITLAB_SSH_PORT=10022\n    - GITLAB_RELATIVE_URL_ROOT=\n    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string\n    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string\n    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string\n\n    - GITLAB_ROOT_PASSWORD=123456\n    - GITLAB_ROOT_EMAIL=itheima@itcast.cn\n...\n</code></pre>\n<p>docker-compose在前端里面的使用：</p>\n<p>Nodejs + mongodb + koa + vue的应用组合：</p>\n<p>特别注意：</p>\n<p>视频中，我们使用vue是在局部安装的，所以使用npx命令在进行创建。</p>\n<p>vue官网推荐大家进行全局安装:</p>\n<pre><code class=\"bash\">npm i -g @vue/cli\n\n# 然后使用\nvue create myproject\n</code></pre>\n<p> docker-compose.yml</p>\n<pre><code class=\"yaml\">version: &#39;3&#39;\nservices:\n  web:\n    image: web:1.0\n    ports:\n    - &quot;8080:80&quot;\n\n  server:\n    image: server:1.0\n    ports:\n    - &quot;3000:3000&quot;\n    depends_on:\n    - mongodb\n    links:\n    - mongodb:db\n\n  mongodb:\n    image: mongo\n    restart: always\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: root\n      MONGO_INITDB_ROOT_PASSWORD: 123456\n</code></pre>\n<p><code>depends_on</code> 决定了容器加载的先后顺序，这里<code>mongdb</code>、<code>web</code>先加载，<code>mongdb</code>创建完成之后，再来创建<code>server</code>。</p>\n<h3 id=\"自学补充知识\"><a href=\"#自学补充知识\" class=\"headerlink\" title=\"自学补充知识\"></a>自学补充知识</h3><ol>\n<li>什么是Kubernetes?</li>\n</ol>\n<p>Kubernetes, 中文意思是舵手或导航员，它是一个容器集群管理系统，主要职责是容器编排（Container Orchestration）——启动容器，自动化部署、扩展和管理容器应用，还有回收容器。</p>\n<p>文档: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLw==\">https://kubernetes.io/zh/</span></p>\n<p>集群相关：<span class=\"exturl\" data-url=\"aHR0cDovL21lc29zLmFwYWNoZS5vcmcv\">Mesos</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9zd2FybQ==\">Docker Swarm</span></p>\n<ol start=\"2\">\n<li>简单的DevOps流程介绍：</li>\n</ol>\n<p><img data-src=\"/./assets/devOps-8692746.jpeg\" alt=\"devOps\"></p>\n<p>参考链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDcwNDY1\">从一张图看Devops全流程</span></p>\n<ol start=\"3\">\n<li>Docker中的文件系统，深入理解原理：</li>\n</ol>\n<p><img data-src=\"/./assets/%E4%B8%80%E5%9B%BE%E7%9C%8B%E5%B0%BDDocker%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png\" alt=\"一图看尽Docker容器文件系统\"></p>\n<ol start=\"4\">\n<li><p>Docker的一般开发流程介绍：</p>\n<ul>\n<li>寻找基础镜像</li>\n<li>基于基础镜像编写Dockerfile脚本</li>\n<li>根据Dockerfile脚本创建项目镜像</li>\n<li>将创建的镜像推送到docker仓库 (根据自身需要，可做可不做)</li>\n<li>基于项目镜像创建并运行docker容器 (实现最终部署)</li>\n</ul>\n<p>这里面如果一扩展，就变成了自动化开发流程，比如：加入版本控制git -&gt; 使用webhook -&gt; jenkins自动打包  -&gt; docker自动构建 -&gt; 推送镜像 -&gt; 生产环境部署</p>\n</li>\n</ol>\n<h2 id=\"课程资源\"><a href=\"#课程资源\" class=\"headerlink\" title=\"课程资源\"></a>课程资源</h2><p>Docker for Mac【系统：10.12以上】: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL21hYy9zdGFibGUvRG9ja2VyLmRtZw==\">https://download.docker.com/mac/stable/Docker.dmg</span></p>\n<p>Docker for Windows【系统：专业版及企业版】: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL3dpbi9zdGFibGUvRG9ja2VyJTIwZm9yJTIwV2luZG93cyUyMEluc3RhbGxlci5leGU=\">https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe</span></p>\n<p>Docker ToolBox for Mac【系统：10.10.3以上】: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL21hYy9zdGFibGUvRG9ja2VyVG9vbGJveC5wa2c=\">https://download.docker.com/mac/stable/DockerToolbox.pkg</span> </p>\n<p>Docker ToolBox for Windows【系统：windows7以上】：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL3dpbi9zdGFibGUvRG9ja2VyVG9vbGJveC5leGU=\">https://download.docker.com/win/stable/DockerToolbox.exe</span></p>\n","categories":["容器化运维操作"],"tags":["容器化运维操作"]},{"title":"常见开源协议","url":"/2023/02/02/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/","content":"<h1 id=\"常见的开源协议\"><a href=\"#常见的开源协议\" class=\"headerlink\" title=\"常见的开源协议\"></a>常见的开源协议</h1><h3 id=\"1：Apache-License-2-0\"><a href=\"#1：Apache-License-2-0\" class=\"headerlink\" title=\"1：Apache License 2.0\"></a>1：Apache License 2.0</h3><p>这是一个著名的非盈利开源组织Apache采用的协议，它励代码共享和尊重原作者的著作权，同时也允许代码修改，再发布（作为开源或商业软件）。</p>\n<ul>\n<li>要求</li>\n</ul>\n<ol>\n<li>在代码中保留作者提供的协议和版权信息</li>\n<li>如果修改了代码，则必须在被修改的文件中进行说明。</li>\n</ol>\n<ul>\n<li>允许的权利<br> 商用、分发、修改、专利授权、私用<br> 、附加协议</li>\n<li>禁止项</li>\n</ul>\n<ol>\n<li>禁止因使用等造成影响责任承担、也就是说免责申明</li>\n<li>不能使用相应的商标。</li>\n</ol>\n<p><strong>提示：商业软件可以使用，也可以修改使用Apache协议的代码。</strong></p>\n<h3 id=\"2：GPLv3\"><a href=\"#2：GPLv3\" class=\"headerlink\" title=\"2：GPLv3\"></a>2：GPLv3</h3><p>此协议是应用最为广泛的开源协议，拥有较强的版权自由要求,也赋予和保证了开源项目开发者广泛的权利。基本上，它允许用户合法复制，分发和修改软件，但衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同。</p>\n<ul>\n<li>要求</li>\n</ul>\n<ol>\n<li>修改后的源码也需要公开</li>\n<li>版权及协议也要于此协议一致</li>\n<li>修改后，需要在相应的文件做说明，</li>\n</ol>\n<ul>\n<li>允许<br> 商用，分发，修改，专利授权，私用</li>\n<li>禁止</li>\n</ul>\n<ol>\n<li>禁止因使用等造成影响责任承担、也就是说免责申明</li>\n<li>静止在软件分发传播过程中附加上原来没有的协议条款等</li>\n</ol>\n<p><strong>提示：商业软件不能使用GPL协议的代码。</strong></p>\n<h3 id=\"3：LGPL\"><a href=\"#3：LGPL\" class=\"headerlink\" title=\"3：LGPL\"></a>3：LGPL</h3><p>其主要用于一些代码库，LGPL比起GPL它授予的权限较少，LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。因此使用LGPL协议的开源代码可以被商业软件作为<strong>类库引用</strong>并发布和销售。注意是以类库的形式使用，也就是说如果修改了源代码的话则也必须使用LGPL协议贡献源码出来。</p>\n<ul>\n<li>要求</li>\n</ul>\n<ol>\n<li>公开使用了LGPL部分的代码，其余部分不需要公开。</li>\n<li>可以库引用的方式用于商业软件。</li>\n<li>在代码中保留作者提供的协议和版权信息</li>\n</ol>\n<ul>\n<li>允许<br> 商用、分发、修改、专利授权、私用、附加协议</li>\n<li>禁止<br> 禁止承担责任，(免责申明)、</li>\n</ul>\n<p><strong>提示：商业软件可以使用，但不能修改LGPL协议的代码。</strong></p>\n<p><strong>GPL&#x2F;LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</strong></p>\n<h3 id=\"4：MIT\"><a href=\"#4：MIT\" class=\"headerlink\" title=\"4：MIT\"></a>4：MIT</h3><p>宽松简单且精要的一个协议。在适当标明来源及免责的情况下，它允许你对代码进行任何形式的使用,也就是原作者只想保留版权,而无任何其他了限制,而你必须在发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。</p>\n<ul>\n<li>要求<br> 在代码中保留作者提供的协议和版权信息</li>\n<li>允许<br> 商用、分发、修改、私用、附加协议</li>\n<li>禁止<br> 禁止承担责任，(免责申明)</li>\n</ul>\n<p><strong>提示：商业软件可以使用，也可以修改MIT协议的代码，甚至可以出售MIT协议的代码。</strong></p>\n<h3 id=\"5：BSD\"><a href=\"#5：BSD\" class=\"headerlink\" title=\"5：BSD\"></a>5：BSD</h3><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。与MIT协议只存在细微差异。差别为MIT可以使用原名称进行宣传，而BSD不可以。</p>\n<ul>\n<li>要求<br> 在代码中保留作者提供的协议和版权信息</li>\n<li>允许<br> 商用、分发、修改、私用、附加协议</li>\n<li>禁止<br> 禁止承担责任，(免责申明)</li>\n</ul>\n<p><strong>提示：商业软件可以使用，也可以修改使用BSD协议的代码。</strong></p>\n<h3 id=\"6：Mozilla-2-0\"><a href=\"#6：Mozilla-2-0\" class=\"headerlink\" title=\"6：Mozilla 2.0\"></a>6：Mozilla 2.0</h3><p>是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点，允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者。这种授权维护了商业软件的利益，它要求基于这种软件得修改无偿贡献版权给该软件。</p>\n<ul>\n<li>要求</li>\n</ul>\n<ol>\n<li>公开源代码</li>\n<li>在代码中保留作者提供的协议和版权信息</li>\n</ol>\n<ul>\n<li>允许<br> 商用、分发、修改、专利授权、私用、附加协议</li>\n<li>禁止</li>\n</ul>\n<ol>\n<li>禁止承担责任，(免责申明)</li>\n<li>禁止使用商标</li>\n</ol>\n<p><strong>提示：商业软件可以使用，也可以修改MPL协议的代码，但修改后的代码版权归软件的发起者。</strong></p>\n","categories":["开源协议"],"tags":["开源协议"]},{"title":"复杂业务部署与优化","url":"/2024/04/12/%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/","content":"<h1 id=\"软件生命周期：\"><a href=\"#软件生命周期：\" class=\"headerlink\" title=\"软件生命周期：\"></a>软件生命周期：</h1><p><img data-src=\"/images/Snipaste_2024-04-16_12-54-33.jpg\" alt=\"/images/Snipaste_2024-04-16_12-54-33.jpg\"></p>\n<h1 id=\"架构流程图\"><a href=\"#架构流程图\" class=\"headerlink\" title=\"架构流程图\"></a>架构流程图</h1><p><img data-src=\"/images/Snipaste_2024-04-17_12-16-04.jpg\" alt=\"/images/Snipaste_2024-04-17_12-16-04.jpg\"></p>\n<h1 id=\"复杂项目通用方案\"><a href=\"#复杂项目通用方案\" class=\"headerlink\" title=\"复杂项目通用方案\"></a>复杂项目通用方案</h1><h4 id=\"业务的复杂度\"><a href=\"#业务的复杂度\" class=\"headerlink\" title=\"业务的复杂度\"></a>业务的复杂度</h4><ul>\n<li>交互的复杂性</li>\n<li>数据结构和状态的复杂性</li>\n<li>多项目互相依赖的复杂性</li>\n<li>打包</li>\n<li>性能优化</li>\n<li>第三方库的使用和调研以及二次开发</li>\n</ul>\n<h4 id=\"流程的复杂度\"><a href=\"#流程的复杂度\" class=\"headerlink\" title=\"流程的复杂度\"></a>流程的复杂度</h4><ul>\n<li>git flow</li>\n<li>lint工具</li>\n<li>单元测试</li>\n<li>commit信息</li>\n<li>PR revirew</li>\n<li>CI &#x2F; CD</li>\n</ul>\n<h1 id=\"CI-x2F-CD的概念\"><a href=\"#CI-x2F-CD的概念\" class=\"headerlink\" title=\"CI &#x2F; CD的概念\"></a>CI &#x2F; CD的概念</h1><p>业务组件库的开发和发布是随着一些列任务进化的：</p>\n<ul>\n<li>本地commit钩子函数完成commit验证</li>\n<li>代码push到远端之后</li>\n<li>跑特定的test（不仅仅是本机的unit test，也可能有时间很长的E2E test）</li>\n<li>test通过之后检查是否有新的tag，如果有就自动publish一个新的版本</li>\n<li>甚至还有更多，自动部署文档站点等等。</li>\n</ul>\n<p>这些任务如果手动操作，就费时费力，所以需要自动化进行。</p>\n<h4 id=\"CI（Continuous-integration）持续集成\"><a href=\"#CI（Continuous-integration）持续集成\" class=\"headerlink\" title=\"CI（Continuous integration）持续集成\"></a>CI（Continuous integration）持续集成</h4><p>持续集成是指频繁地将代码集成到主干，一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。</p>\n<p>作用有：</p>\n<ul>\n<li>快速发现错误</li>\n<li>防止分支大幅偏离主干</li>\n</ul>\n<p>持续集成的目的就是让产品可以快速迭代，同时保持高质量。</p>\n<h4 id=\"CD（Continuous-Delivery）持续交付\"><a href=\"#CD（Continuous-Delivery）持续交付\" class=\"headerlink\" title=\"CD（Continuous Delivery）持续交付\"></a>CD（Continuous Delivery）持续交付</h4><p>持续交付是指频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</p>\n<h4 id=\"CD（Continuous-Deployment）持续部署\"><a href=\"#CD（Continuous-Deployment）持续部署\" class=\"headerlink\" title=\"CD（Continuous Deployment）持续部署\"></a>CD（Continuous Deployment）持续部署</h4><p>持续部署是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p>\n<h4 id=\"CI-x2F-CD两大服务：\"><a href=\"#CI-x2F-CD两大服务：\" class=\"headerlink\" title=\"CI &#x2F; CD两大服务：\"></a>CI &#x2F; CD两大服务：</h4><ul>\n<li>github actions</li>\n<li>travis-ci</li>\n</ul>\n<h1 id=\"列表排序解决方案\"><a href=\"#列表排序解决方案\" class=\"headerlink\" title=\"列表排序解决方案\"></a>列表排序解决方案</h1><p>列表排序原理：</p>\n<pre><code class=\"js\">&lt;template&gt;\n    &lt;div&gt;\n      &lt;ul class=&quot;ul&quot; @drop=&quot;onDrop&quot;&gt;\n        &lt;li \n            v-for=&quot;(item,index) in list&quot; \n            :data-index=&quot;index&quot; \n            :key=&quot;item.id&quot; \n            @dragover=&quot;onDragover($event,index)&quot; \n            @dragstartart=&quot;dragstart($event,index)&quot; \n            @dragenter=&quot;dragenter($event,index)&quot; \n            draggable=&quot;true&quot; \n            :class=&quot;[item.id==currentLi?&#39;glost&#39;:&#39;&#39;]&quot;\n        &gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n/*eslint-disable*/\nimport &#123; ref &#125; from &quot;vue&quot;;\nimport &#123;arrayMoveImmutable&#125; from &#39;array-move&#39;;\nlet currentLi = ref(1);\nlet index = ref(1);\nconst list = ref(\n  [\n  &#123;id:1,name:&#39;列表1&#39;&#125;,\n  &#123;id:2,name:&#39;列表2&#39;&#125;,\n  &#123;id:3,name:&#39;列表3&#39;&#125;,\n  &#123;id:4,name:&#39;列表4&#39;&#125;,\n  &#123;id:5,name:&#39;列表5&#39;&#125;,\n]\n)\nconst dragstart = (e,inde)=&gt;&#123;\n  currentLi.value = inde;\n&#125;\nconst dragenter = (e,ind)=&gt;&#123;\n  if(ind != currentLi.value)&#123;\n      list.value = arrayMoveImmutable(list.value,ind,currentLi.value)\n      currentLi.value = ind;\n  &#125;\n&#125;\nconst onDrop = (e)=&gt;&#123;\n  console.log(e.target.dataset.index,&#39;drop&#39;);\n  list.value = arrayMoveImmutable(list.value,index.value,currentLi.value)\n  console.log(list.value);\n&#125;\nconst onDragover = (e,inde)=&gt;&#123;\n  e.preventDefault();\n  index.value = inde;\n&#125;\n&lt;/script&gt;\n\n&lt;style  scoped&gt;\n.ul&gt;li&#123;\n  width: 100%;\n  height: 50px;\n  border: 1px solid red;\n&#125;\n.glost&#123;\n  box-shadow: 10px 10px 3px 3px gray;\n&#125;\n&lt;/style&gt;\n</code></pre>\n<p>列表排序常用工具包：</p>\n<ul>\n<li>vue-draggable</li>\n<li>sortable.js</li>\n<li>array-move.js</li>\n</ul>\n<h1 id=\"拖动改变位置原理\"><a href=\"#拖动改变位置原理\" class=\"headerlink\" title=\"拖动改变位置原理\"></a>拖动改变位置原理</h1><p>通过监听mousedown和mousemove事件，用element.getBoundingClientRect方法获得x和y，left和top等属性，改变对应元素的top和left属性。</p>\n<h1 id=\"拖动改变大小原理\"><a href=\"#拖动改变大小原理\" class=\"headerlink\" title=\"拖动改变大小原理\"></a>拖动改变大小原理</h1><p> 设置边框元素，边框元素的四个角添加圆点元素，监听mousedown事件和mousemove事件，并将最新的坐标赋值给元素的尺寸大小。</p>\n<h1 id=\"快捷键实现原理\"><a href=\"#快捷键实现原理\" class=\"headerlink\" title=\"快捷键实现原理\"></a>快捷键实现原理</h1><p>好用的快捷键第三方库：Hotkeys.js</p>\n<p>事件原理：keydown事件的监听，通过event.key判断是那个快捷键，从而执行对应的操作。</p>\n<h1 id=\"撤销重做原理\"><a href=\"#撤销重做原理\" class=\"headerlink\" title=\"撤销重做原理\"></a>撤销重做原理</h1><p>维护一个固定长度的histories数组和historyIndex指针，每次修改的时候添加一条记录（标识操作类型和数据）。回滚时改变historyIndex指针。</p>\n<h1 id=\"右键菜单原理\"><a href=\"#右键菜单原理\" class=\"headerlink\" title=\"右键菜单原理\"></a>右键菜单原理</h1><p>在需要显示的区域拦截默认的右键点击事件，判断是否点击在组件元素上（通过event.target），显示一个自定义菜单，其中包括操作项，显示在鼠标的位置（event.clientX和event.clientY），点击完成操作，通过display:none隐藏。</p>\n<h1 id=\"自动保存实现方案\"><a href=\"#自动保存实现方案\" class=\"headerlink\" title=\"自动保存实现方案\"></a>自动保存实现方案</h1><ul>\n<li>定时保存（语雀）</li>\n<li>实时保存（石墨）</li>\n</ul>\n<p>实现原理：添加isDrity字段标记数据是否有修改，当修改时将isDirty设置为true，根据isDIrty的值设置定时器，定时触发保存逻辑。</p>\n<h1 id=\"DOM元素截图实现方案\"><a href=\"#DOM元素截图实现方案\" class=\"headerlink\" title=\"DOM元素截图实现方案\"></a>DOM元素截图实现方案</h1><p>工具包：html2canvas</p>\n<p>实现原理：</p>\n<p>根据DOM元素的styles样式，通过svg的foreignObject元素引入XML命名空间的元素，然后创建一个image标签，将svg通过url.createObjectURL方法创建一个路径赋值给一个image标签的src属性，通过canvas画笔 的drawImage方法将image图片绘制到canvas画布上。</p>\n<p>实现流程：</p>\n<ul>\n<li>style设置DOM样式</li>\n<li>svg引入DOM</li>\n<li>createObjectURL创建url路径</li>\n<li>将url复制到image标签的src</li>\n<li>canvas的drawImage将image图片绘制到canvas画布上</li>\n</ul>\n<pre><code class=\"js\">const data =\n&quot;&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39;width=&#39;400px&#39;height=&#39;40\n&quot;&lt;foreignabject width=&#39;100%&#39;height=&#39;100%&#39;&gt;&quot;+\n&quot;&lt;div xmlns=&#39;http://ww.w3.org/1999/xhtml&#39;&gt;&quot;\nelement.innerHTML+\n&quot;&lt;/div&gt;&quot;+\n&quot;&lt;/foreignobject&gt;&quot; +\n&quot;&lt;/svg&gt;&quot;\n\nconst svg = new Blob([data],&#123;type:&quot;image/svg+xml;charset=utf-8&quot;&#125;);\nconst url = URL.createobjectURL(svg)\nconst image = new Image()\nimage.src = url\nimage.addEventListener(&#39;load&#39;,()=&gt;&#123;\n    const ctx =anvas.getContext(&#39;2d&#39;);\n    if (ctx)&#123;\n    ctx.drawImage(image,0,0)\n    &#125;\n&#125;)\n</code></pre>\n<h1 id=\"二维码生成方案\"><a href=\"#二维码生成方案\" class=\"headerlink\" title=\"二维码生成方案\"></a>二维码生成方案</h1><ul>\n<li>工具包：node-qrcode</li>\n<li>ts项目中需要安装额外的定义文件。</li>\n</ul>\n<p>简单原理：将数据变为二进制，然后通过canvas将二进制变为图像。</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;canvas id=&quot;qrcode&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;&lt;/canvas&gt;\n  &lt;script&gt;\n    //将字符串转为二进制形式\n    function toBianary(str)&#123;\n        let res = &#39;&#39;;\n        for(let i=0;i&lt;str.length;i++)&#123;\n            let charCode = str.charCodeAt(i);\n            let binaryCharCode = charCode.toString(2);\n            res += binaryCharCode.padStart(8,&#39;0&#39;);\n        &#125;\n        return res;\n    &#125;\n    //绘制\n    function drawQRCode(text, canvas) &#123;\n      var context = canvas.getContext(&quot;2d&quot;);\n      // 绘制黑白像素点\n      for (var i = 0; i &lt; text.length; i++) &#123;\n        var row = Math.floor(i / canvas.width);\n        var col = i % canvas.width;\n        var color = text.charAt(i) === &quot;1&quot; ? &quot;#000000&quot; : &quot;#FFFFFF&quot;;\n        context.fillStyle = color; \n        context.fillRect(col, row, 1, 1);\n      &#125;\n    &#125;\n    var qrcodeCanvas = document.getElementById(&quot;qrcode&quot;);\n    drawQRCode(toBianary(&#39;https://dmqweb.cn&#39;), qrcodeCanvas); // 示例：绘制一个简单的二维码\n  &lt;/script&gt;\n</code></pre>\n<h1 id=\"复制功能实现原理\"><a href=\"#复制功能实现原理\" class=\"headerlink\" title=\"复制功能实现原理\"></a>复制功能实现原理</h1><ul>\n<li>工具包：clipboard.js</li>\n<li>自带type定义文件</li>\n</ul>\n<p>实现原理：</p>\n<p>方案一：document.execCommand()方法。内置一系列功能，包括复制文本（但<strong>前提是需要选中文本</strong>），可以使用不可见元素迂回。</p>\n<p>方案二：Clipboard API（ navigator.clipboard ），但是对于<strong>浏览器兼容性有待加强。</strong></p>\n<h1 id=\"下载文件原理\"><a href=\"#下载文件原理\" class=\"headerlink\" title=\"下载文件原理\"></a>下载文件原理</h1><ul>\n<li>工具包：FileSaver.js（小文件）</li>\n<li>StreamSaver.js（大文件）</li>\n</ul>\n<p>方案一：超链接a标签添加download属性，属性值为文件名，rel属性设置打开页面的具体实现细节。（但前提是<strong>href属性为当前同源情况下</strong>。）</p>\n<p>方案二：通过axios请求到图片地址，通过URL.createObjectURL创建为一个与document相绑定的地址，赋值给a标签即可。（不要忘记使用URL.revokeObjectURL将创建的地址移除。）</p>\n<p>方案三：通过FileReader.readAsDataURL，创建一个FileReader实例，使用readAsDataURL读取对象返回一段base64格式的字符串，监听reader实例的onload事件，创建a标签将reader.result赋值给a标签的href属性。</p>\n<pre><code class=\"js\">downloadFile:function(data,fileName)&#123;\n   const reader = new FileReader()\n   // 传入被读取的blob对象\n   reader.readAsDataURL(data)\n   // 读取完成的回调事件\n   reader.onload = (e) =&gt; &#123;\n       let a = document.createElement(&#39;a&#39;)\n       a.download = fileName\n       a.style.display = &#39;none&#39;\n       // 生成的base64编码\n       let url = reader.result\n       a.href = url\n       document.body.appendChild(a)\n       a.click()\n       document.body.removeChild(a)\n   &#125;\n&#125;\n</code></pre>\n<p>终极解决方案：由于通过URL.createObjectURL和FileReader都会先将数据保存到内存中，业务中经常需要后端验证token之后才能拿到文件，不能直接使用a标签。因此实际中可以先发送ajax请求验证token，验证之后颁发一个过期时间短的cookie，之后使用a标签进行下载即可。但是同样会受到a标签download属性跨域请求的限制。</p>\n<h1 id=\"应用部署的流程\"><a href=\"#应用部署的流程\" class=\"headerlink\" title=\"应用部署的流程\"></a>应用部署的流程</h1><p><strong>构建</strong><br>Javascript语言本身是不需要编译的。<br>但是现代的前端项目使用的语言和或者的模块系统都无法在浏览器中使用，都需要使用特定的<br>bundler将源代码最终转换为浏览器支持的」avascript代码。<br><strong>不同的环境:</strong><br>开发环境(development) ：本地的测试环境<br>测试环境(test或者staging）：线上的测试环境</p>\n<p>生产环境（production)：线上的生产环境</p>\n<p><strong>生产和开发环境的区别</strong><br>*开发环境<br>*会添加丰富的错误提示<br>可以使用mock server或者本地后端环境<br>添加各种便利的功能-比如hot reload,自动刷新<br>*不太关心静态资源的大小，最好提供最丰富的调试信息(sourcemap)等。</p>\n<p><strong>生产环境</strong><br>稳定是最重要的原则<br>速度是第一要务<br><strong>生产环境和测试环境的区别</strong><br>高度相似<br>使用的后端服务不一样</p>\n<p><strong>环境变量设置（按优先级）</strong></p>\n<ul>\n<li>跨平台设置环境变量工具包：cross-env</li>\n<li>命令中添加环境变量（平台限制）</li>\n<li>环境变量文件中配置</li>\n</ul>\n<p><strong>在项目根目录中放置下列文件来指定环境变量</strong><br>.env                                        #在所有的环境中被载入<br>.env.local                             #在所有的环境中被载入，但会被git忽略<br>env.[mode]                         #只在指定的模式中被载入<br>env.[mode].local             #只在指定的模式中被载入，但会被git忽略</p>\n<h1 id=\"webpack构建优化\"><a href=\"#webpack构建优化\" class=\"headerlink\" title=\"webpack构建优化\"></a>webpack构建优化</h1><h3 id=\"Bundler：\"><a href=\"#Bundler：\" class=\"headerlink\" title=\"Bundler：\"></a>Bundler：</h3><p>将浏览器不支持的模块进行编译，转换，<br>合并最后生成的代码可以在浏览器端良好的运行的工具。</p>\n<h3 id=\"Loaders：\"><a href=\"#Loaders：\" class=\"headerlink\" title=\"Loaders：\"></a><strong>Loaders：</strong></h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uY2VwdHMvbG9hZGVycy8=\">https://webpack.docschina.org/concepts/loaders/</span><br>loader用于对模块的源代码进行转换。loader可以使你在import或”Ioad(加载)”模块时预处理文件。<br><strong>多个Loader</strong><br>module.rules允许你在webpack配置中指定多个loader。这种方式是展示loader的一种简明方式，并且有助于使代码变得简洁和易于维护。</p>\n<p><strong>webpack中loader配置：</strong></p>\n<pre><code class=\"json\">const path = require(&#39;path&#39;)\nmodule.exports = &#123;\n    entry:&#39;./main.js&#39;,\n    output:&#123;\n        path:path.resolve(dirname,&#39;dist&#39;),\n        filename:bundle.js&#39;,\n    &#125;\n&#125;,\nmodule:&#123;\n    rules:[\n    &#123;\n        test:/八.css$/,\n        use: [\n            loader:&#39;style-loader&#39;&#125;,   //先写的loader后执行。\n            loader:&#39;css-loader&#39;&#125;\n        ]\n    &#125;]\n  &#125;\n&#125;\n</code></pre>\n<h6 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h6><p><strong>webpack中loader原理：</strong></p>\n<p> 在webpack.config.js的module字段的rules数组中进行配置：添加一个对象标识一个独立的匹配项，test字段使用正则表示匹配的文件名，use数组表示对应文件需要执行的loader，webpack在打包时会<strong>将文件内容传入并执行对应的loader</strong>（是一个函数），<strong>执行loader函数后会将函数返回值包装成一个新的函数</strong>，因此webpack中的loader通常需要进行两次module.exports。</p>\n<pre><code class=\"js\">//手写一个md文件的loader\nconst marked = require(&#39;marked&#39;);  //第三方库，用于将md转为html\nconst utils = require(&#39;loader-utils&#39;)  //官方库，用于获取用户配置loader时传入的参数\nconst markdownLoader = (source) =&gt; &#123;\n    const options = utils.getOptions(this);\n    const html = marked(source , options);\n    return  `module.exports = $&#123;JSON.stringify(html)&#125;`;\n&#125;\nmodule.exports = markdownLoader;\n</code></pre>\n<p>配置：</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;)\nmodule.exports = &#123;\n    entry:&#39;./main.js&#39;,\n    output:&#123;\n        path:path.resolve(dirname,&#39;dist&#39;),\n        filename:bundle.js&#39;,\n    &#125;\n&#125;,\nmodule:&#123;\n    rules:[\n    &#123;\n        test:/\\.css$/,\n        use: [\n            &#123; loader:&#39;style-loader&#39; &#125;,   //先写的loader后执行。\n            &#123; loader:&#39;css-loader&#39; &#125;\n        ]\n    &#125;,\n    &#123;\n        test:/\\.md$/,\n        use: [\n            &#123; loader: &#39;./markdonwn-loader&#39;,options:&#123; headerIds:false &#125; &#125; //其中options是给loader函数传入的第二个参数，loader中可以使用loader-utils官方三方库进行接受\n        ]\n    &#125;]\n  &#125;\n&#125;\n</code></pre>\n<p><strong>多个Loader串联</strong><br>最后的loader最早调用，将会传入原始资源内容。<br>第一个loader最后调用，期望值是传出JavaScript和source map(可选)。<br>中间的loader执行时，会传入前一个loader传出的结果。<br><strong>将markdown转换为html:turndown</strong><br>地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIub20vZG9tY2hyaXN0aWUvdHVybmRvd24=\">https://github.om/domchristie/turndown</span></p>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins:\"></a><strong>plugins:</strong></h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uY2VwdHMvcGx1Z2lucy8=\">https://webpack.docschina.org/concepts/plugins/</span><br>插件是webpack的支柱功能。webpack自身也是构建开你在webpack配置中用到的相同的插件系统之上！插件目的在于解决loader无法实现的其他事。(我自己的理解，loader解决的是各种不同资源的问题，plugins更多解决的是项目整体的事情)</p>\n<pre><code class=\"json\">const path = require(&#39;path&#39;);\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nmodule.exports = &#123;\n    entry:&#39;./main.js&#39;,\n    output:&#123;\n        path:path.resolve(dirname,&#39;dist&#39;),\n        filename:bundle.js&#39;,\n    &#125;\n&#125;,\nmodule:&#123;\n    rules:[\n    &#123;\n        test:/八.css$/,\n        use: [\n            loader:&#39;style-loader&#39;&#125;,   //先写的loader后执行。\n            loader:&#39;css-loader&#39;&#125;\n        ]\n    &#125;]\n  &#125;,\nplugins:[\n    new BundlesizeWebpackPlugin( &#123; sizeLimit:3 &#125; )  //自己手写的插件（如下）\n    new webpack.ProgressPlugin(), //显示打包过程（webpack内置插件）\n    new HtmlwebpackPlugin(),\n]\n&#125;\n</code></pre>\n<h6 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h6><p><strong>webpack中plugins原理：</strong></p>\n<p>webpack执行时会将plugins字段中的插件实例取出并将webpack实例传入并执行其<strong>apply方法</strong>，通过webpack实例的hooks中的方法我们可以操控对应的钩子函数。</p>\n<p>官方的教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb250cmlidXRlL3dyaXRpbmctYS1wbHVnaW4v\">https://webpack.js.org/contribute/writing-a-plugin/</span><br><strong>插件的格式</strong><br>一个JavaScript函数或JavaScript类<br>在它原型上定义的apply方法，会在安装插件时被调用，并被webpack compiler调用一次<br>指定一个触及到webpack本身的事件钩子，即hooks,用于特定时机处理额外的逻辑<br>Compiler Hooks列表<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmlzLm9yZy9hcGkvY29tcGlsZXItaG9va3Mv\">https://webpack.is.org/api/compiler-hooks/</span></p>\n<pre><code class=\"js\">//手写一个webpack插件，打包文件超出限制时，报错。\nconst &#123; resolve &#125; = require(&#39;path&#39;);\nconst &#123; statSync &#125; = require(&#39;fs&#39;); //fs模块中同步读取文件信息\nclass BundlesizeWebpackPlugin &#123;\n    constructor(options) &#123;\n        this.options = options;\n    &#125;\n    apply(compiler) &#123;\n        //获取到传入的参数\n        const &#123; sizeLimit &#125; = this.options;\n        compiler.hooks.compile.tap(&#39;BundleSizePlugin&#39;,(compilationParams)=&gt;&#123; //编译时钩子,参数是参数\n            console.log(&#39;compile阶段&#39;,compilationParams);\n        &#125;)\n        compiler.hooks.done.tap(&#39;BundleSizePlugin&#39;,(stats)=&gt;&#123; //结束时钩子，参数是打包后的信息。\n            console.log(&#39;done&#39;,stats); \n            //拿到打包后文件的路径和文件名\n            const &#123; path , filename &#125; = stats.compilation.outputOptions;\n            //拼接成文件路径\n            const bundlePath = resolve(path,filename);\n            //获取到文件size\n            const &#123; size &#125; = statSync(bundlePath);\n            const bundleSize = size / 1024;\n            if(bundleSize &lt; sizeLimit) &#123;\n                console.log(&#39;Safe:Bundle-Size&#39;,bundleSize,&#39;\\n Size Limit:&#39;,sizeLimit);\n            &#125;else&#123;\n                console.error(&#39;Unsafe:Bundle-Size&#39;,bundleSize,&#39;\\n Size Limit:&#39;,sizeLimit);\n            &#125;\n        &#125;) \n    &#125;\n&#125;\nmodule.exports = BundlesizeWebpackPlugin;\n</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Loaders关注代码中的单个资源，Plugins关注整体流程，可以接触到webpack构建流程中的<br>各个阶段并劫持做一些代码处理。</strong></p>\n<h1 id=\"node后端框架\"><a href=\"#node后端框架\" class=\"headerlink\" title=\"node后端框架\"></a>node后端框架</h1><h2 id=\"Node-js后端框架调研\"><a href=\"#Node-js后端框架调研\" class=\"headerlink\" title=\"Node.js后端框架调研\"></a>Node.js后端框架调研</h2><p><strong>后端框架应该注意的三大问题</strong><br>路由Routes<br>请求Request<br>响应Response</p>\n<h4 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h4><p>官方网址：[https:l&#x2F;expressis.com(https:expressis.com)<br>**安装**<br>官方网址：[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9leHByZXNzaXMuY29tL3poLWNuL3N0YXJ0ZXIvaW5zdGFsbGluZy5odG1sXQ==\">https://expressis.com/zh-cn/starter/installing.html]</span>(https:l&#x2F;expressjs.com&#x2F;zh-<br>cn&#x2F;starter&#x2F;installing.html)<br>使用生成器安装，可以自动生成一系列的脚手架代码：[https:&#x2F;expressjs.com&#x2F;zh<br>cn&#x2F;starter&#x2F;generator.htmll(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9leHByZXNzaXMuY29tL3poLWNuL3N0YXJ0ZXIvZ2VuZXJhdG9yLmh0bWw=\">https://expressis.com/zh-cn/starter/generator.html</span>)</p>\n<p><strong>优点</strong></p>\n<p>快速简单、易上手</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>路由响应中，很可能有：从外部请求数据的服务，有验证路由的请求参数，返回特定的格式。</li>\n<li>所有逻辑不分青红皂白的写在一起！很容易产生冗长的难以维护的代码。</li>\n<li>一些大型必备的模块，如第三方服务初始化，安全，日志都没有明确的标准。</li>\n</ul>\n<p><strong>Express中间件：</strong></p>\n<p>Express是一个基于中间件的框架，其余任务都会在中间件中执行，中间件是一个队列结构，先写入的任务先执行,中间件的写法是：app.use()，当调用中间件时，会向传入的函数中传入req,res和next函数。</p>\n<p><strong>中间件可以完成的任务</strong></p>\n<ul>\n<li>执行任何代码。</li>\n<li>对请求和响应对象进行更改。</li>\n<li>结束请求&#x2F;响应循环。</li>\n<li>调用堆栈中的下一个中间件。</li>\n</ul>\n<h4 id=\"Koa2\"><a href=\"#Koa2\" class=\"headerlink\" title=\"Koa2\"></a>Koa2</h4><p><strong>官网地址</strong>：[https:I&#x2F;koajs.com(https:&#x2F;koajs.com)</p>\n<p><strong>Koa2和Express的区别</strong></p>\n<ul>\n<li>使用Promise(async,await)代替callback (node&gt;v7.6.0)</li>\n<li>使用ctx(上下文对象)封装req(Request)和res(Response),以及一些常用的功能。</li>\n<li><strong>完全不同的中间件机制</strong></li>\n<li><strong>更轻量级，没有捆绑任何中间件</strong></li>\n<li>官方文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2tvYWpzL2tvYS9ibG9iL21hc3Rlci9kb2NzL2tvYS12cy1leHByZXNzLm1k\">https://github.com/koajs/koa/blob/naster/docs/koa-vs-express.md</span></li>\n</ul>\n<p><strong>Koa2中间件：</strong></p>\n<ol>\n<li>Koa2中间件，由Express的队列模型（同步）转变为洋葱模型，当程序运行到<code>await next()</code>的时候就会暂停当前程序，进入下一个中间件，处理完之后才会仔回过头来继续处理。</li>\n<li>Koa2洋葱模型解决的问题就是一个中间件可以调用其他中间件执行后，再继续自己的操作，Express框架中next()执行后就直接到下一个中间件操作，无法退回。</li>\n</ol>\n<p><img data-src=\"/images/Snipaste_2024-04-22_14-30-49.jpg\" alt=\"Koa2中间件\"></p>\n<p><strong>代码示例：</strong></p>\n<pre><code class=\"js\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\nconst PORT = 3000;\napp.use(async (ctx, next)=&gt;&#123;\n    console.log(1)\n    await next();\n    console.log(1)\n&#125;);\napp.use(async (ctx, next) =&gt; &#123;\n    console.log(2)\n    await next();\n    console.log(2)\n&#125;)\napp.use(async (ctx, next) =&gt; &#123;\n    console.log(3)\n&#125;)\napp.listen(PORT);\nconsole.log(`http://localhost:$&#123;PORT&#125;`);\n</code></pre>\n<p><strong>Koa2特点：</strong></p>\n<ul>\n<li>响应机制的不同</li>\n<li>Express:我们直接操作的是res对象，直接res.send之后就立即响应了。</li>\n<li>Koa2:数据的响应是通过ctx.body进行设置，注意这里仅是设置并没有立即响应，而是在所有的中间件结束之后做了响应。</li>\n</ul>\n<p><strong>缺点：</strong>Koa2在使用上有一定的缺点，因为太过于轻量使得在使用时需要手动处理很多操作，可以使用基于Koa2的上层框架（如：egg.js）</p>\n<h4 id=\"egg-js\"><a href=\"#egg-js\" class=\"headerlink\" title=\"egg.js\"></a>egg.js</h4><p><strong>Express和Koa2的不足</strong></p>\n<ul>\n<li>简单而且扩展性强，适合个人的比较小的项目</li>\n<li>没有约定，对于统一维护和开发非常不利</li>\n</ul>\n<p><strong>对于后端框架的需求</strong></p>\n<ul>\n<li>需要有一套优秀的统一的约定或者架构进行开发</li>\n<li>有丰富的扩展机制和可定制性</li>\n<li>Typescript支持</li>\n</ul>\n<p><strong>egg.js</strong></p>\n<ul>\n<li>地址：[https:l&#x2F;eggis.org&#x2F;zh-cnI(https:l&#x2F;eggjs.org&#x2F;zh-cn) （基于Koa2）</li>\n<li>阿里大厂出品，维护有保障。国内开发者开发，中文文档质量有保证。</li>\n<li><strong>约定优于配置，按照一套统一的约定进行应用开发。</strong></li>\n<li>一个插件只做一件事，高度可扩展的插件机制</li>\n<li>支持Typescript</li>\n</ul>\n<pre><code class=\"bash\">//nodejs版本10以上\nnpm init egg --type=ts\nnpm install\nnpm run dev\n</code></pre>\n<p><strong>egg.js概念：</strong></p>\n<ul>\n<li><p>Application-全局应用对象，只有一个实例。</p>\n</li>\n<li><p>Context-上下文对象，每次请求生成一个实例。</p>\n</li>\n<li><p>Request-请求对象，来自Koa。</p>\n</li>\n<li><p>Response-响应对象，来自Koa的一个新的对象。</p>\n</li>\n<li><p>Helper-用来提供一些实用的utility函数。框架内置了几个简单的Helper函数。</p>\n</li>\n</ul>\n<h4 id=\"Nest-js\"><a href=\"#Nest-js\" class=\"headerlink\" title=\"Nest.js\"></a>Nest.js</h4><ul>\n<li>地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm5lc3Rqcy5jbi8=\">https:&#x2F;docs.nestjs.com</span></li>\n<li>内置并且完全支持Typescript</li>\n<li>开箱即用的应用程序架构</li>\n<li>可扩展，松散耦合</li>\n<li>大量采用了装饰器的写法 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm5lc3Rqcy5jbi8xMC9vcGVuYXBpP2lkPSVFOCVBMyU4NSVFOSVBNSVCMCVFNSU5OSVBOA==\">Nest.js装饰器</span></li>\n</ul>\n<h1 id=\"vue-config-js\"><a href=\"#vue-config-js\" class=\"headerlink\" title=\"vue.config.js\"></a>vue.config.js</h1><p><strong>个性化构建结果-vue.config,js</strong><br>在基础的配置上，自定义构建的结果-可以使用vue.config.js<br>文档地址：https:l&#x2F;cli.vuejs.org&#x2F;zh&#x2F;config#vue-config-js<br>简介两个字段<br>*<strong>PublicPath</strong>-部署应用包时的基本URL,这个配置对应的是webpack的PublicPath属性<br>★<br>默认值为’&#x2F;‘，Vue CLI会假设你的应用是被部署在一个域名的根路径上<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYmMuY29tLw==\">https://abc.com/</span><br>★<br>可以设置为子路径-如果你的应用被部署在https:abc,com&#x2F;sub&#x2F;那么就设置为’&#x2F;sub’<br>*可以设置为CDN路径-在我们的应用中，最后静态资源是要全部上传到CDN的，（脚手<br>架自动完成)，所以这里可以设置为一个cDN域名-‘https:l&#x2F;oss.imooc-Iego.com&#x2F;editor’<br>*还可以设置为绝对路径(‘’或者’.&#x2F;‘)，这样所有的资源都会被链接为相对路径</p>\n<p><strong>css.loaderOptions</strong>属性<br>*向CSS相关的loader传递选项<br>*Ant-design-vue的样式变量：https:lww,antd,com docs&#x2F;vue&#x2F;customize-theme-cn<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Z1ZUNvbXBvbmVudC9hbnQtZGVzaWduLQ==\">https://github.com/vueComponent/ant-design-</span><br>yue&#x2F;blob&#x2F;master&#x2F;components&#x2F;style&#x2F;themes&#x2F;default.less<br>*添加更多的CSS预处理器：<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbGkudnVlanMub3JnL3poL2d1aWRlL2Nzcy5odG1sIyVFOSVBMiU4NCVFNSVBNCU4NCVFNyU5MCU4NiVFNSU5OSVBOA==\">https://cli.vuejs.org/zh/guide/css.html#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8</span><br>*特别注意less和Iess-loader的版本问题。不要装最新的，建议选用：</p>\n<pre><code class=\"js\">//vue.config.js配置：\nconst isstaging = !process.env.VUE_APP_STAGINE\nconst isProduction = process.env.NODE_ENV &#39;production&#39;\nmodule.exports = &#123;\n    /生产环境要使用0SS地址\n    /其他环境都使用绝对路径\n    publicPath:(isProduction 6 !isStaging)&#39;https://oss.imooc-lego.com/\n    css:&#123;\n        loaderOptions:&#123;\n        less:&#123;\n            lessoptions:&#123;\n                modifyVars:&#123;\n                   &#39;primary-color&#39;:&#39;#3E7FFF&#39;,\n                &#125;，\n                javascriptEnabled:true\n            &#125;\n        &#125;,\n    configureWebpack: config =&gt; &#123;\n        config.plugins.push(\n            new webpack.IgnorePlugin(&#123;        //打包时忽略对应的文件\n                resourceRegExp: /^\\.\\/locale$/,\n                contextRegExp: /moment$/,\n            &#125;)\n        )\n        if(isAnalyzeMode)&#123;\n            config.plugins.push(\n                new BundleAnalyzerPlugin(&#123;    //添加打包后的文件分析工具（BundleAnalyzerPlugin）\n                    analyzerMode : &#39;static&#39;,\n                &#125;)\n            )\n        &#125;\n    &#125;\n    &#125;\n</code></pre>\n<h1 id=\"项目构建优化\"><a href=\"#项目构建优化\" class=\"headerlink\" title=\"项目构建优化\"></a>项目构建优化</h1><p><strong>好用的webpack插件:webpack-bundle-analyzer</strong></p>\n<p>可视化webpack打包后的工具包大小，便于分析依赖和进行项目优化。如上vue.config.js中配置。</p>\n<p><strong>根据图表的优化步骤</strong></p>\n<p>一、看看有没有什么重复的模块，或者没有用的模块被打包到了最终的代码中<br>二、看看package.json,对比一下是否有应该在devDeps的模块，被错误的放置到了deps当中<br>三、检查是否有重复加载的模块，或者是功能大体相同的模块。<br>比如：使用<strong>es</strong>版本的第三方库，享受tree-shaking的红利。<br>四、检查是否有没有用的模块是否打包到了最终的文件中，通过如下插件忽略对应的文件，从而tree-shaking掉忽略的文件（如国际化需要的各种语言包）,详细配置如上vue.config.js中。</p>\n<p>*webpack ignore plugin <span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZ2xwbHVnaW5zL2lnbm9yZS1wbHVnaW4vI3Jvb3Q=\">https://webpack.js.orglplugins/ignore-plugin/#root</span></p>\n<p><strong>将三方库中全部导入更换为按需导入</strong></p>\n<pre><code class=\"js\">import &#123;Input,Dropdown,Slider,Select&#125; from &#39;Antd-vue&#39;;\nconst components = [Input,Dropdown,Slider,Select];\nconst install = (app) =&gt; &#123;\n    components.forEach(item=&gt;&#123;\n        app.component(item.name,item);\n    &#125;)\n&#125;\nexport default&#123; install &#125;;\n// 在main.js中导入，然后app.use\n</code></pre>\n<p><strong>浏览器缓存优化</strong></p>\n<p>一、项目即使是上线之后也会在后续追加或修改代码，如果分包较少重新上线后就不能使用浏览器缓存的文件，当分包数量较多时，就可以充分利用浏览器缓存。</p>\n<p>二、分包较多时可以使用浏览器支持平行加载多个文件的特性。（HTTP1对同一域名并行请求的个数进行了限制，HTTP2完全突破了这个限制）</p>\n<p><strong>手动分割第三方库为多个文件</strong></p>\n<p>webpack的config.optimization中自带一些优化的配置项：</p>\n<ul>\n<li>minimize：压缩</li>\n<li>splitChunks：分包（可以配置minSize等）</li>\n<li>等等</li>\n</ul>\n<pre><code class=\"js\">//vue.config.js配置：\nmodule.exports = &#123;\n    // ....省略\n    configureWebpack: config =&gt; &#123;\n        config.optimization.splitChunks = &#123;\n            maxInitialRequests: Infinity,\n            minSize: 300 * 1024,\n            chunks: &#39;all&#39;,\n            cacheGroups: &#123;\n                antVendor: &#123;\n                    name: &#39;ant-design-vue&#39;,\n                    test: /[\\\\/]node_modules[\\\\/](ant-design-vue)[\\\\/]/,\n                &#125;,\n                canvasVendor: &#123;\n                    name: &#39;html2canvas,\n                    test: /[\\\\/]node_modules[\\\\/](html2canvas)[\\\\/]/,\n                &#125;,\n                vendor: &#123;\n                    name: &#39;vendor&#39;,\n                    test: /[\\\\/]node_modules[\\\\/](!html2canvas)(!ant-design-vue)[\\\\/]/\n                &#125;,\n                all &#123;\n                    test: /[\\\\/]node_modules[\\\\/]/, //匹配全部的node_modules中的文件\n                    name (module) &#123; const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/)\n                    return `npm.$&#123;packageName.replace(&#39;@&#39;,&#39;&#39;)&#125;`\n                &#125;,\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"项目运行优化\"><a href=\"#项目运行优化\" class=\"headerlink\" title=\"项目运行优化\"></a>项目运行优化</h1><p><strong>路由懒加载</strong></p>\n<p>使用import函数动态加载，配合魔法注释可以和webpack中的bundler相配合使用，例如：</p>\n<pre><code class=\"js\">import(/* webpackChunkName: &quot;my-lodash&quot; */ &#39;lodash&#39;).then(lodash=&gt;&#123;\n     // ....\n&#125;)\n</code></pre>\n<p><strong>改变HTML标题，增强SEO</strong></p>\n<p>项目中动态添加标题的原理：使用HtmlWebpackPlugin插件，插入动态js语句进行占位，然后通过项目中package.json中的name进行替换。</p>\n<pre><code class=\"js\">//vue.config.js配置：\nmodule.exports = &#123;\n    // ....省略\n   chainWebpack: config =&gt; &#123;\n       config.plugin(&#39;html&#39;).tap(args=&gt;&#123;\n           args[0].title = &#39;网站标题&#39;,\n           args[0].desc = &#39;网站详情描述&#39;\n           return args;\n       &#125;)\n   &#125;\n&#125;\n//记得添加 &lt;meta name=&quot;viewport&quot; content=&quot;&lt;%= htmlWebpackPlugin.options.desc %&gt;&quot;&gt;\n</code></pre>\n<p><strong>同构渲染方式</strong><br>服务端渲染和客户端渲染的区别就在于在哪里完成html完整文件的拼接：</p>\n<h3 id=\"客户端渲染\"><a href=\"#客户端渲染\" class=\"headerlink\" title=\"客户端渲染\"></a>客户端渲染</h3><p>客户端渲染由客户端完成html文件的拼接，服务端只负责提供数据。<br>优势：首屏加载快<br>劣势：不利于SEO</p>\n<h3 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h3><p>服务端渲染由服务端完成html文件的凭借，客户端直接渲染即可<br>优势：利于SEO，<br>劣势：白屏问题（获取html文件较慢）,服务端压力大，占用CPU资源。</p>\n<h3 id=\"同构渲染\"><a href=\"#同构渲染\" class=\"headerlink\" title=\"同构渲染\"></a>同构渲染</h3><p>服务端先通过服务端渲染，生成html以及初始化数据，客户端拿到代码和初始化数据，在客户端进行激活渲染。<br>优势：兼容了前端渲染的大部分优点（节省服务端资源、多终端适配渲染、局部刷新等），同时也具有服务端渲染首屏加载快，SEO支持好的特点。<br>劣势：服务端必须是要js支持的语言，增加了整个系统的复杂度和维护成本。</p>\n<h3 id=\"SSG预渲染\"><a href=\"#SSG预渲染\" class=\"headerlink\" title=\"SSG预渲染\"></a>SSG预渲染</h3><p><strong>静态站点生成</strong> (Static-Site Generation，缩写为 SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那就可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管。</p>\n<p>SSG 保留了和 SSR 应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR 应用的花销更小，也更容易部署，因为它输出的是静态 HTML 和资源文件。这里的关键词是<strong>静态</strong>：SSG 仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署。</p>\n<p>如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如 &#x2F;、&#x2F;about 和 &#x2F;contact 等)，那么你可能需要 SSG 而不是 SSR。SSG 也非常适合构建基于内容的网站，比如文档站点或者博客。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vdml0ZXByZXNzLmRldi8=\">VitePress</span> 就是一个由 Vite 和 Vue 驱动的静态站点生成器。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL2Jsb2IvbWFpbi9wbGF5Z3JvdW5kL3Nzci12dWUvcHJlcmVuZGVyLmpz\">Vite脚手架渲染SSG代码示例</span>。</p>\n<h1 id=\"部署与HTTP优化\"><a href=\"#部署与HTTP优化\" class=\"headerlink\" title=\"部署与HTTP优化\"></a>部署与HTTP优化</h1><h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a><strong>部署</strong></h3><p><strong>前端部署：https:llci,uejs,org&#x2F;zh&#x2F;guide&#x2F;deployment.html</strong></p>\n<p>原理就是：将构建生成的产物直接烤贝到任何的静态文件服务器当中。</p>\n<p><strong>后端部署：https:&#x2F;eggis.org&#x2F;zh-cn&#x2F;core&#x2F;deployment.html</strong></p>\n<p>几乎没有构建过程：除非你用了typescript等需要编译的语言。</p>\n<p>方案一：直接将本地的源代码打个压缩包拷贝到目标服务器，然后启动服务器。</p>\n<p>方案二：在服务器中直接pu川源代码，install,.然后启动服务器。</p>\n<h3 id=\"Nginx-反向代理\"><a href=\"#Nginx-反向代理\" class=\"headerlink\" title=\"Nginx:反向代理\"></a><strong>Nginx:反向代理</strong></h3><p><strong>Nginx</strong>作为服务器软件，它的优点：</p>\n<ul>\n<li>特别适合前后端分离的项目</li>\n<li>保证安全</li>\n<li>非常快</li>\n<li>支持负载均衡</li>\n</ul>\n<p>使用：</p>\n<ul>\n<li>安装nginx</li>\n<li>nginx    命令启动服务器</li>\n<li>nginx -s stop    命令关闭服务器</li>\n<li>nginx -v      命令查看配置信息</li>\n<li>nginx -s reload      命令重启服务</li>\n<li>配置nginx.conf文件</li>\n</ul>\n<h3 id=\"HTTP缓存\"><a href=\"#HTTP缓存\" class=\"headerlink\" title=\"HTTP缓存\"></a><strong>HTTP缓存</strong></h3><p>（若服务器使用nginx，则在nginx.conf中配置）</p>\n<p>Expires <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0V4cGlyZXM=\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires</span><br><strong>Expires响应头包含日期&#x2F;时间，即在此时候之后，响应过期</strong><br>使用nginx添加对应的响应头：expires指令<br>文档地址：http:l&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx http headers module.html</p>\n<p>但是由于客户端时间和用户端时间并不总是相同的，于是有了Cache-Control：</p>\n<p><strong>Cache-Control</strong>:通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。<br>文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIv\">https://developer</span> mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Headers&#x2F;Cache-Control</p>\n<p>*<strong>Etag</strong>:ETagHTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽<br>因为如果内容没有改变，Wb服务器不需要发送完整的响应，直接返回304表示可以使用缓存文件。<br>*文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0VUYWc=\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag</span><br><strong>Last-Modified</strong>:是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。<br>文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0xhc3QtTW9kaWZpZWQ=\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified</span><br>nginx Etag:<span class=\"exturl\" data-url=\"aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfY29yZV9tb2R1bGUuaHRtbCNldGFn\">http://nginx.org/en/docs/http/ngx_http_core_module.html#etag</span><br>304 Not Modified <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSElUUC9TdGF0dXMvMzA0\">https://developer.mozilla.org/zh-CN/docs/Web/HITP/Status/304</span></p>\n<p>浏览器使用缓存：</p>\n<p><img data-src=\"/images/image.png\" alt=\"/images/image.png\"></p>\n<h3 id=\"压缩算法\"><a href=\"#压缩算法\" class=\"headerlink\" title=\"压缩算法\"></a>压缩算法</h3><p>压缩比对照表<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWl4ZGIuZ2l0aHViLmlvL3NxdWFzaC1iZW5jaG1hcmsvI3JhdGlvLXZzLWNvbXByZXNzaW9u\">https://quixdb.github.io/squash-benchmark/#ratio-vs-compression</span></p>\n<h4 id=\"gzip\"><a href=\"#gzip\" class=\"headerlink\" title=\"gzip\"></a>gzip</h4><p><strong>一、动态压缩（服务器在返回静态文件之前，由服务器对每个请求压缩后再进行输出）</strong></p>\n<p>nginx中启用gzip：在nginx.conf中配置：</p>\n<ul>\n<li>gzip  on;        开启gzip</li>\n<li>gzip_types     text&#x2F;plain  application&#x2F;javascript              设置那些文件需要压缩</li>\n<li>gzip_min_length   1k;         小于设置值不会压缩</li>\n<li>gzip_comp_level     1;          压缩级别</li>\n<li>等等</li>\n</ul>\n<p><strong>二、静态压缩（服务器直接使用压缩文件进行输出）</strong></p>\n<p>两个步骤</p>\n<ul>\n<li>生成压缩文件（gzip命令或使用webpack插件 compression-webpack-plugin）</li>\n<li>在ngin×开启支持静态压缩的模块（例如gzip_static  :  on）</li>\n</ul>\n<h4 id=\"Brotli\"><a href=\"#Brotli\" class=\"headerlink\" title=\"Brotli\"></a>Brotli</h4><p><strong>一、动态压缩（服务器在返回静态文件之前，由服务器对每个请求压缩后再进行输出）</strong></p>\n<p><strong>使用前提</strong><br>浏览器支持：https:caniuse.com&#x2F;brotli<br><strong>HTTPS协议</strong><br>NGINX对应的模块：https:&#x2F;github.com&#x2F;google&#x2F;nginx&#x2F;brotli</p>\n<p>nginx中启用Brotli：在nginx.conf中配置：</p>\n<ul>\n<li>brotli  on;        开启Brotli</li>\n<li>brotli_types     text&#x2F;plain  application&#x2F;javascript              设置那些文件需要压缩</li>\n<li>等等</li>\n</ul>\n<p><strong>二、静态压缩（服务器直接使用压缩文件进行输出 ,如上。）</strong></p>\n<h3 id=\"HTTP优化\"><a href=\"#HTTP优化\" class=\"headerlink\" title=\"HTTP优化\"></a>HTTP优化</h3><p>HTTP是建立在TCP协议之上，所以<strong>HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性</strong>，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的延迟时间。所以减少这些重新握手和至关重要。</p>\n<h4 id=\"keepAlive属性\"><a href=\"#keepAlive属性\" class=\"headerlink\" title=\"keepAlive属性\"></a>keepAlive属性</h4><p>keepAlive属性可以保持服务器端和客户端建立的会话连接，开启之后除首次建立连接外的其他请求不会进行<strong>DNS Lookup</strong>（NDS域名解析）和<strong>Initial connection</strong>（三报文握手建立连接），可以在服务端文件中进行配置。</p>\n<p><strong>KeepAlive的优点</strong></p>\n<ul>\n<li>TCP连接更少，I这样就会节约TCP连接在建立、释放过程中，主机和路由器上的CPU和内存开销。</li>\n<li>网络拥塞也减少了，拿到响应的延时也减少了</li>\n</ul>\n<h4 id=\"HTTP2\"><a href=\"#HTTP2\" class=\"headerlink\" title=\"HTTP2\"></a>HTTP2</h4><p><strong>使用HTTP&#x2F;2提升性能</strong></p>\n<ul>\n<li>2010年SPDY <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TUERZJUU2JUJDJTk0JUU1JThDJTk2JUU1JTg4JUIw\">https://baike.baidu.com/item/SPDY演化到</span></li>\n<li>2015 HTTP&#x2F;2 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9IVFRQXzI=\">https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_2</span></li>\n</ul>\n<p><strong>兼容性</strong></p>\n<p>需要浏览器支持-https:&#x2F;caniuse.com&#x2F;http2</p>\n<p>需要HTTPS协议支持</p>\n<p><strong>主要特性</strong></p>\n<p>一、二进制协议：</p>\n<p>HTTP2由原来的文本请求（报文）转变为二进制请求帧，加快传输</p>\n<p>二、多路复用：</p>\n<p><strong>HTTP2多路复用解决了浏览器同一域名并行请求数量的限制。</strong></p>\n<p>在HTTP&#x2F;2中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟开一个TCP连接都需要慢慢提升传输速度。</p>\n<p><strong>同个域名只需要占用一个TCP连接</strong>，使用一个连接并行发送多个请求和响应，<strong>消除了因多个TCP连接而带来的延时和内存消耗</strong>。</p>\n<p>三、Header压缩复用</p>\n<p>TTP&#x2F;2在客户端和服务器端使用“<strong>首部表</strong>”来跟踪和存储之前发送的键一值对，对于相同的数据，不再通过每次请求和响应发送。</p>\n<p><strong>配置HTTP2：</strong></p>\n<p>依nginx为例：在server字段的listen字段添加：listen   443   ssl   http2; </p>\n<h1 id=\"Mongodb数据库\"><a href=\"#Mongodb数据库\" class=\"headerlink\" title=\"Mongodb数据库\"></a>Mongodb数据库</h1><h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a><strong>基本操作</strong></h3><pre><code class=\"js\">// 导入Mongodb客户端构造函数\nimport &#123; MongoClient,ObjectId, &#125; from &quot;mongodb&quot;;\n// 创建mongo实例(传入url)\nconst client = new MongoClient(&#39;mongodb://localhost:27017/&#39;);\n// 执行函数，连接mongodb数据库\nasync function run() &#123;\n  try &#123;\n    await client.connect(); //等待实例连接\n    const db = client.db(&#39;hello&#39;); //创建数据库\n    const res = await db.command(&#123; ping: 1 &#125;); //ping命令\n    console.log(&#39;connected&#39;, res);\n    const userCollection = db.collection(&#39;user&#39;);//创建集合表\n// 数据的插入\n    // const result = await userCollection.insertOne(&#123;name:&quot;张三&quot;,age:18&#125;)\n    // const results = await userCollection.insertMany([&#123;name:&quot;李四&quot;,age:12&#125;,&#123;name:&quot;王五&quot;,age:13&#125;]);\n    // console.log(result,results); //返回影响的信息，id等\n//数据的查找\n    const result = await userCollection.findOne(&#123;name:&#39;张三&#39;&#125;);\n    console.log(result);\n    const resultCursor =  userCollection.find(); //find返回的是指针对象，不是结果\n    //将游标变为数组结果\n    const results = await userCollection.find().toArray();\n    // console.log(results);\n//比较操作符 $lt小于 $gt大于\n    const results2 = await userCollection.find(&#123;age:&#123;$lt:16&#125;&#125;).toArray();\n    // console.log(results2);\n//逻辑操作符 $or\n    const results3 = await userCollection.find(&#123;$or:[&#123;age:&#123;$gt:12&#125;&#125;,&#123;name:&quot;王五&quot;&#125;]&#125;).toArray();\n    // console.log(results3);\n//元素操作符  $exists存在与否  $type指定类型\n    const results4 = await userCollection.find(&#123;age:&#123;$type:&#39;number&#39;&#125;&#125;).toArray();\n    // console.log(results4);\n//limit  第二个参数传入options配置（projection表示包含字段哪些字段）\n    const result5 = await userCollection.find(&#123;age:&#123;$type:&#39;number&#39;&#125;&#125;,&#123;limit:2,skip:3,sort:&#123;age:-1&#125;,projection:&#123;name:0&#125;&#125;).toArray();\n    // console.log(result5);\n//更新替换数据   update更新数据  replaceOne替换数据 ,修改操作要传具体更新操作符：\n//普通更新操作符： $set设置值 $inc增加 $rename重命名 $unset删除 \n//数组更新操作符： $push数组字段添加 $pop删除 $all包含 $regex正则  .属性符 .$属性占位符\n    const result6 = await userCollection.replaceOne(&#123;name:&quot;张三&quot;&#125;,&#123;name:&quot;Lebrown&quot;&#125;);\n    const result7 = await userCollection.updateOne(&#123;_id:new ObjectId(&#39;6628b9876bac632e95ead1bb&#39;)&#125;,&#123;$set:&#123;name:&quot;updateOne&quot;&#125;,$inc:&#123;age:10&#125;&#125;);\n    const result8 = await userCollection.updateOne(&#123;_id: new ObjectId(&#39;6628b9876bac632e95ead1bb&#39;)&#125;,&#123;$set:&#123;&quot;hobbies.0&quot;:&quot;golf&quot;&#125;&#125;)\n    const result9 = await userCollection.updateOne(&#123;_id: new ObjectId(&#39;6628b9876bac632e95ead1bb&#39;),hobbies:&#39;glof&#39;&#125;,&#123;$set:&#123;&quot;hobbies.$&quot;:&quot;golf-new&quot;&#125;&#125;)\n    // console.log(result8);//返回影响信息\n//删除数据：deleteOne(filter) 和deleteMany\n  &#125; catch (e) &#123;\n    console.error(e);\n  &#125; finally &#123;\n    await client.close();\n  &#125;\n&#125;\nrun();\n</code></pre>\n<h3 id=\"mongodb高级\"><a href=\"#mongodb高级\" class=\"headerlink\" title=\"mongodb高级\"></a><strong>mongodb高级</strong></h3><h5 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h5><p><strong>MongoDB索引</strong></p>\n<ul>\n<li>索引(Index)<strong>为了提高查询效率</strong></li>\n<li>MongoDB的文件类型：<strong>BSON</strong>,Binary JSON,主要被用作MongoDB数据库中的数据存储和网络传输格式。</li>\n<li>假如没有索引，必须扫描这个巨大BSON对象集合中的每个文档并选取那些符合查询条件的记录，这样是低效的。</li>\n<li>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中。</li>\n<li>为某个字段创建索引之后查找速度非常快，ObjectId是自带的索引（ _ id _ ）。</li>\n</ul>\n<p><strong>创建索引</strong></p>\n<p>创建索引可以直接用Navicate等工具，也可以代码中使用：</p>\n<pre><code class=\"js\">//......省略\n//给name字段创建索引之前耗时很大，创建之后耗时很小\nconst indexResult = await userCollection.find(&#123;name:&quot;James&quot;&#125;).explain();\nconsole.log(indexResult);\n//创建索引，属性表示字段，值表示升序降序\nconst result = await userCollection.createIndex(&#123;name:1&#125;) //1表示升序\n//取消索引\nconst result1 = await userCollection.dropIndex(&quot;name_1&quot;)\n</code></pre>\n<h5 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h5><p>聚合操作将来自多个文档的值组合在一起，并且可以对分组数据执行各种操作以返回相应的结果。<br><strong>linux常用的管道写法：</strong></p>\n<pre><code class=\"bash\">ps aux | grep mongo\n</code></pre>\n<p><strong>聚合常用的操作符：</strong></p>\n<ul>\n<li>$group将collection中的document:分组，可用于统计结果</li>\n<li>$natch过滤数据，只输出符合结果的文档</li>\n<li>$project修改输入文档的结构（例如重命名，增加、删除字段，创建结算结果等）</li>\n<li>$sot将结果进行排序后输出</li>\n<li>$imit限制管道输出的结果个数</li>\n<li>$skp跳过制定数量的结果，并且返回剩下的结果</li>\n</ul>\n<p><strong>表达式操作符：</strong></p>\n<ul>\n<li>$sum计算总和，{$sum:1}表示返回总和×1的值（即总和的数量），使用{$sum:’$制定字段’}也能直接获取制定字段的值的总和</li>\n<li>$avg求平均值</li>\n<li>$min求min值</li>\n<li>$max求max值</li>\n<li>$push将结果文档中插入值到一个数组中</li>\n<li>$frst根据文档的排序获取第一个文档数据</li>\n<li>$last同理，获取最后一个数据</li>\n</ul>\n<pre><code class=\"js\">//.....\nconst pipeLine = [\n    &#123; $match : &#123; age : &#123; $gt : 30 &#125;&#125;&#125;,\n    &#123; $group : &#123; _id : &quot;$steam&quot; , total : &#123; $sum : &quot;$age&quot; &#125; , count : &#123; $sum : 1 &#125;&#125;&#125;,\n    &#123; $sort : &#123; total : 1 &#125;&#125;\n]\ncosnt result = await userCollection.aggregate(pipeLine).toArray();\n//....\n</code></pre>\n<h5 id=\"多表联查\"><a href=\"#多表联查\" class=\"headerlink\" title=\"多表联查\"></a>多表联查</h5><p><strong>普通方式使用多表联查需要两次查询</strong></p>\n<pre><code class=\"js\">// 导入Mongodb客户端构造函数\nimport &#123; MongoClient,ObjectId, &#125; from &quot;mongodb&quot;;\n// 创建mongo实例(传入url)\nconst client = new MongoClient(&#39;mongodb://localhost:27017/&#39;);\n// 执行函数，连接mongodb数据库\nasync function run() &#123;\n  try &#123;\n    await client.connect(); //等待实例连接\n    const db = client.db(&#39;hello&#39;); //创建数据库\n    const res = await db.command(&#123; ping: 1 &#125;); //ping命令\n    console.log(&#39;connected&#39;, res);\n//获取表\n     const teamCollection = db.collection(&#39;team&#39;);\n     const playerCollection = db.collection(&#39;player&#39;);\n     const netsTeam = await teamCollection.findOne(&#123;team:&quot;NETS&quot;&#125;);\n     const netsPlayers = await playerCollection.find(&#123;team:netsTeam._id&#125;).toArray();\n  &#125; catch (e) &#123;\n    console.error(e);\n  &#125; finally &#123;\n    await client.close();\n  &#125;\n&#125;\nrun();\n</code></pre>\n<p><strong>使用聚合中$lookup进行多表联查只需要一次查询：</strong></p>\n<pre><code class=\"js\">//...\nconst pipeLine2 = [\n    &#123;\n        $match : &#123; team : &#123; $exists : true &#125; &#125;\n    &#125;,\n    &#123;\n        $lookup : &#123;\n            from : &quot;team&quot;,\n            localField : &quot;team&quot;,\n            foreignField : &quot;_id&quot;,\n            as : &quot;team&quot;\n        &#125;\n    &#125;\n] \nconst playerWithTeam = await playerCollection.aggregate(pipeLine2).toArray();\nconsole.log(playerWithTeam);\n//...\n</code></pre>\n<h3 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h3><p><em>MongoDB最佳设计实践：</em>[https:l<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5tb25nb2RiLmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS9tb25nb2RiLXNjaGVtYS1kZXNpZ24tYmVzdC1wcmFjdGljZXMvXQ==\">www.mongodb.Com/developer/article/mongodb-schema-design-best-practices/]</span>(<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZGV2ZWxvcGVyL2FydGljbGUvbW9uZ29kYi0=\">https://www.mongodb.com/developer/article/mongodb-</span><br>schema-design-best-practices&#x2F;)</p>\n<p>  关键问题：数据产生关系的时候，选择内嵌还是引用？</p>\n<p><strong>内嵌模式：</strong></p>\n<p>优势：</p>\n<ul>\n<li>只需要一次查询就可以查询所有的信息。</li>\n<li>避免多集合查询。</li>\n<li>只需要一个操作就可以更新多个信息。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>单个文档太大，查询可能更耗时，获得的无关信息概率增大。</li>\n<li>针对每个文档，MongoDB有一个16M的最大限制，内嵌太多，可能超过这个限制。</li>\n</ul>\n<p><strong>引用模式：</strong></p>\n<p>优势：</p>\n<ul>\n<li>将数据分散到不同文档，数据量会变小。</li>\n<li>不太会超过16M最大限制。</li>\n<li>每次查询取得不必要数据的慨率降低。</li>\n</ul>\n<p>劣势：需要多次查询才能获得最终数据</p>\n<p><strong>最佳设计实践：</strong></p>\n<ul>\n<li><p>一对几个：推荐使用内嵌形式</p>\n</li>\n<li><p>一对很多：推荐使用引用形式</p>\n<ul>\n<li>子集合中使用一个字段保存父集合的_id   ； 或者：</li>\n<li>父集合中使用一个数组保存子集合的_id</li>\n</ul>\n</li>\n<li><p>一对亿万：只能子集合中使用一个字段保存父集合的_id</p>\n</li>\n</ul>\n<h3 id=\"访问权限管理\"><a href=\"#访问权限管理\" class=\"headerlink\" title=\"访问权限管理\"></a><strong>访问权限管理</strong></h3><p><strong>授权文档</strong>：https:&#x2F;docs.mongodb.com&#x2F;manual&#x2F;core&#x2F;authentication&#x2F;<br><strong>内置的Roles</strong>：https:&#x2F;docs.mongodb.com&#x2F;manual&#x2F;reference&#x2F;built-in-roles&#x2F;</p>\n<p><strong>在mongo命令行中输入：</strong></p>\n<pre><code class=\"cmd\">show dbs\nuse admin\n# mongodb基于RBAC进行权限管理，设置roles可以设置相应的全选，见上。\ndb.createUser(&#123; user : &#39;root&#39; , pwd : &#39;123456&#39; , roles : [&#39;root&#39;] &#125;) \ndb.auth(&#39;root&#39;,&#39;123456&#39;)\n# --auth 开启数据库的权限验证，也可以直接在mongo.conf中配置（先终止运行mongod）\nmongod --config /usr/local/etc/mongo.conf --auth\n# 操作配置了权限管理的数据库\nmongo -u &quot;root&quot; -p &quot;123456&quot; --authenticationDatabase &quot;admin&quot;\n</code></pre>\n<p><strong>初始化一个新数据库以后期望的步骤</strong></p>\n<ul>\n<li>创建admin级谜别的root用户&#x2F;roles:root</li>\n<li>创建对应的数据库lego</li>\n<li>创建该数据库的管理员dmq&#x2F;roles:readWrite</li>\n<li>代码中，使用管理员dmq的用户名密码链接数据库并且完成操作。</li>\n</ul>\n<p>步骤如下：</p>\n<pre><code>show dbs\nuse lego\ndb.createUser(&#123; user : &quot;dmq&quot; , pwd : &#39;123456&#39; , roles : [&#123; role : &quot;readWrite&quot; , db : &quot;lego&quot; &#125;]&#125;)\n# 重启服务：mongod --config /usr/local/etc/mongo.conf --auth\n# 这样在mongodb的配置文件中设置用户信息，就保证只能读取数据库信息，保证了数据库的安全。（如果用户信息来自admin数据库就需要配置authSource:&#39;admin&#39;。）\n</code></pre>\n<h1 id=\"Mongoose\"><a href=\"#Mongoose\" class=\"headerlink\" title=\"Mongoose\"></a>Mongoose</h1><p><strong>出现的原因：</strong></p>\n<p>使用原生的mongoDB nodejs driver数据结构及其操作过于灵活，类似于ORM：</p>\n<p><strong>mongoose：</strong>（mongoose之于mongodb类似于ts之于js，都是在原有的基础之上加一层抽象层，进行类型定义等操作）</p>\n<p>mongoose：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb25nb29zZWlzLmNvbS8=\">https://mongooseis.com/</span></p>\n<ul>\n<li>建立在native mongoDB nodejs driver之上</li>\n<li>提出Modl,数据模型的概念，用来约束集合中的数据结构</li>\n<li>非常多扩展的内容</li>\n<li>它是一个ODM(Object Document Mapping)工具。</li>\n</ul>\n<h3 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h3><p>ORM指的是<strong>Object Relational Mapping对象关系映射</strong>，针对于关系型数据库。</p>\n<p><strong>简单说，ORM就是通过实例对象的语法，完成关系型数据库的操作的技术。</strong></p>\n<p><strong>ORM优点</strong></p>\n<ul>\n<li>不需要再去写晦涩的SQL语句。</li>\n<li>使用面向对象的方式操作数据，代码量少，语义性好，容易理解。</li>\n<li>Classes类-Tables</li>\n<li>Objects实例-Records(表中的一行数据)</li>\n<li>Attributes属性-Records</li>\n<li>内置很多功能，数据验证，清洗，预处理等等操作。</li>\n</ul>\n<h3 id=\"ODM\"><a href=\"#ODM\" class=\"headerlink\" title=\"ODM\"></a>ODM</h3><p>ODM指的是<strong>Object Document Mapping对象文档映射</strong>。ODM针对于noSql数据库，关注文档模型，mongoose是ODM的一种实现，可以用于约束数据类型。</p>\n<pre><code class=\"javascript\">const User = mongoose.model(&quot;User&quot;,&#123;\n    username:&#123; type : string &#125;,\n    password:&#123; type : String &#125;\n&#125;)\n//user object\nconst newUser new User(&#123;\n    username:&quot;john-doe&quot;,\n    password:&quot;helloworld&quot;,\n&#125;)\nawait newUser.save()\n</code></pre>\n<h1 id=\"egg-mongoose\"><a href=\"#egg-mongoose\" class=\"headerlink\" title=\"egg-mongoose\"></a>egg-mongoose</h1><p>详见源码，此处省略。</p>\n<h1 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h1><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Stream的官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbA==\">https://nodejs.org/api/stream.html</span><br><strong>流是Node.js中最好，也是最容易误解的慨念</strong><br>流就是数据的合集，数据可以是字符串也可以是数组，流的数据不是一次性全部获得的。</p>\n<p>大文件输出方式：</p>\n<ul>\n<li><p>直接读取</p>\n<p>输入的文件————读取到内存—————-输出文件内容</p>\n</li>\n<li><p>流式读取</p>\n<p>输入的文件————通过可读流读取到管道—————–通过可写流输出文件内容</p>\n</li>\n</ul>\n<p><strong>Node.js支持流的内置模块：</strong></p>\n<p><strong>Readable Streams:</strong></p>\n<ul>\n<li>HTTP responses,on the client</li>\n<li>HTTP requests,on the server</li>\n<li>fs read streams</li>\n<li>zlib streams</li>\n<li>crypto streams</li>\n<li>TCP sockets</li>\n<li>child process stdout and stderr</li>\n<li>process.stdin</li>\n</ul>\n<p><strong>Writable  Streams:</strong></p>\n<ul>\n<li>HTTP requests,on the client</li>\n<li>HTTP responses,on the server</li>\n<li>fs write streams</li>\n<li>zlib streams</li>\n<li>crypto streams</li>\n<li>TCP sockets</li>\n<li>child process stdin</li>\n<li>process.stdout,process.stderr</li>\n</ul>\n<p><strong>流的类型：</strong></p>\n<ul>\n<li>Readable-可读操作。</li>\n<li>Vritable-可写操作。</li>\n<li>Duplex-可读可写操作. </li>\n<li>Transform-操作被写入数据，然后读出结果。</li>\n</ul>\n<h3 id=\"pipe\"><a href=\"#pipe\" class=\"headerlink\" title=\"pipe\"></a>pipe</h3><p><strong>流的流动：</strong></p>\n<p>可读流Readable（数据源input）———————-pipe管道—————————————-可写流Writable（输出output）</p>\n<pre><code class=\"js\">import &#123; createReadStream, createWriteStream &#125; from &#39;fs&#39;;\nconst readStream = createReadStream(&#39;./a.txt&#39;);\nreadStream.pipe(process.stdout);\n</code></pre>\n<p>可读流Readable（数据源input）————-pipe管道—————转换流Transform—————-pipe管道———–可写流Writable（输出output）</p>\n<pre><code class=\"js\">import &#123; createReadStream, createWriteStream, write &#125; from &#39;fs&#39;;\nconst readStream = createReadStream(&#39;./a.txt&#39;);\nconst writeStream = createWriteStream(&#39;./b.txt&#39;);\nreadStream.pipe(writeStream);\n</code></pre>\n<h3 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><strong>流是基于EventEmitter（事件），pipe方法是基于事件封装的的语法糖，常见的事件有：</strong></p>\n<p><strong>Readable  Streams：可读流事件和函数</strong></p>\n<ul>\n<li>Events<ul>\n<li>data–当没有数据时触发</li>\n<li>end–没有更多的数据可读时触发</li>\n<li>error–在接受和写入过程中发生错误时触发</li>\n<li>finish–所有数据已被写入到底层系统时触发</li>\n<li>close</li>\n<li>readable</li>\n</ul>\n</li>\n<li>Functions<ul>\n<li>pipe() , unpipe()</li>\n<li>read() , unshift() , resume()</li>\n<li>pause() , isPaused()</li>\n<li>setEncoding()</li>\n</ul>\n</li>\n</ul>\n<p><strong>Writable  Streams：写入流事件和函数</strong></p>\n<ul>\n<li>Events<ul>\n<li>drain</li>\n<li>finish</li>\n<li>error</li>\n<li>close</li>\n<li>pipe&#x2F;unpipe</li>\n</ul>\n</li>\n<li>Functions<ul>\n<li>write()</li>\n<li>end()</li>\n<li>cork() , uncork()</li>\n<li>setDefaultEncoding()</li>\n</ul>\n</li>\n</ul>\n<p><strong>pipe方法原理：</strong></p>\n<pre><code class=\"js\">import &#123; createReadStream , createWriteStream &#125; from &#39;fs&#39;;\nconst readStream = createReadStream(&#39;./a.txt&#39;);\nconst writeStream = createWriteStream(&#39;./b.txt&#39;);\nreadStream.on(&#39;data&#39; , chunk=&gt;&#123;\n    writeStream.write(chunk);\n&#125;)\nreadStream.on(&#39;end&#39;,()=&gt;&#123;\n    writeStream.end();\n&#125;)\n</code></pre>\n<p>压缩：</p>\n<pre><code class=\"js\">import &#123; createReadStream , createWriteStream &#125; from &#39;fs&#39;;\nimport &#123; createGzip &#125; from &#39;zlib&#39;;\nconst readStream = createReadStream(&#39;./a.txt&#39;);\nconst writeStream = createWriteStream(&#39;./b.txt&#39;);\nreadStream.pipe(createGzip()).pipe(writeStream);\n</code></pre>\n<p>封装：</p>\n<pre><code class=\"js\">cosnt savePromise = (readStream , writeStream = stdout)&#123;\n    return new Promise(resolve,reject)&#123;\n        readStream\n            .pipe(writeStream)\n            .on(&#39;finish&#39;,resolve)\n            .on(&#39;error&#39;,reject)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"pipeline\"><a href=\"#pipeline\" class=\"headerlink\" title=\"pipeline\"></a>pipeline</h3><p><strong>使用pipe方法有时会存在一个问题：</strong></p>\n<pre><code class=\"js\">//....\ncreateReadStream(&#39;./a.txt&#39;)\n    .pipe(stdout)\n    .on(&#39;finish&#39;,finishFn)\n    .on(&#39;error&#39;,errFn);  //这里监听的是pipe后的错误，对于createReadStream的错误则会卡死\n</code></pre>\n<p><strong>于是推出了pipeline方法：</strong></p>\n<pre><code class=\"js\">//...\npipeLine(fs.createReadStream(&#39;./a.txt&#39;),zlib.createGzip(),fs.createWriteStream(&#39;./b.txt&#39;),(err)=&gt;&#123;\n    if (err) &#123; console.error(&#39;pipeline failed&#39;,error) &#125;;\n    else &#123; console.log(&#39;successed&#39;) &#125;\n&#125;)\n</code></pre>\n<h1 id=\"对象存储服务\"><a href=\"#对象存储服务\" class=\"headerlink\" title=\"对象存储服务\"></a>对象存储服务</h1><p><strong>自己完成静态文件存储的问题</strong></p>\n<ul>\n<li>Nod.js不擅长处理静态文件的存储和展示，没有未静态文件做特殊的优化</li>\n<li>如果将图片生成多种处理格式要耗费大量的资源和空间</li>\n</ul>\n<p><strong>各三方比对</strong></p>\n<h3 id=\"阿里云OSS\"><a href=\"#阿里云OSS\" class=\"headerlink\" title=\"阿里云OSS\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0Li9vc3M=\">阿里云OSS</span></h3><p><strong>特点</strong></p>\n<ul>\n<li>支持丰富的图片处理<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnQuX2RldGFpbC80NDY4Ni5odG1s\">https://help.aliyun.com/document._detail/44686.html</span></li>\n<li>egg.js有对应的插件：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1vc3M=\">https://github.com/eggjs/egg-oss</span></li>\n</ul>\n<p><strong>价格</strong></p>\n<ul>\n<li>下行流量100GB一年352元<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21tb24tYnV5LmFsaXl1bi5jb20vP3NwbT01MTc2Ljc5MzM2OTEuSl81MjUzNzg1MTYwLjEuMmUzOTRjNTlxM0ZJc0EmY29tbW9kaXR5Q29kZT1vc3NiYWcjL2J1eQ==\">https://common-buy.aliyun.com/?spm=5176.7933691.J_5253785160.1.2e394c59q3FIsA&amp;commodityCode=ossbag#/buy</span></li>\n<li>基本图片处理：每月0-10TB:免费&gt;10TB:0.025元&#x2F;GB</li>\n</ul>\n<h3 id=\"七牛云KODO\"><a href=\"#七牛云KODO\" class=\"headerlink\" title=\"七牛云KODO\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucWluaXUuY29tL3ByaWNlcy9rb2Rv\">七牛云KODO</span></h3><p><strong>特点：</strong></p>\n<ul>\n<li>多媒体处理功能非常丰富<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2luaXUuY29tL3Byb2R1Y3RzL2RvcmE=\">https://www.giniu.com/products/dora</span></li>\n<li>图片视频处理</li>\n<li>审核</li>\n<li>人工智能分析</li>\n</ul>\n<p><strong>价格：</strong></p>\n<ul>\n<li>外网流出100GB-年278.4元<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xbWFsbC5xaW5pdS5jb20vdGVtcGxhdGUuL01URXk/c3BlY19jb21ibz1NekUwTlE=\">https://qmall.qiniu.com/template./MTEy?spec_combo=MzE0NQ</span></li>\n<li>基本图片处理：每月0-20TB:免费20TB以上：0.025元&#x2F;GB https:&#x2F;<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5xaW5pdS5jb20vcHJpY2VzL2RvcmE=\">www.qiniu.com/prices/dora</span></li>\n</ul>\n<h3 id=\"腾讯云COS\"><a href=\"#腾讯云COS\" class=\"headerlink\" title=\"腾讯云COS\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzQzNg==\">腾讯云COS</span></h3><p><strong>特点：</strong></p>\n<p>图像处理有一些新的亮点，比如自研的TPG压缩等</p>\n<p><strong>价格：</strong></p>\n<ul>\n<li>外网流出100GB一年396元<span class=\"exturl\" data-url=\"aHR0cHM6Ly9idXkuY2xvdWQudGVuY2VudC4uY29tL3ByaWNlL2NvcyN0YWIwLWxpc3Qx\">https://buy.cloud.tencent..com/price/cos#tab0-list1</span></li>\n<li>基本图片处理：每月0-20TB:免费20TB以上：0.025元&#x2F;GB</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzEyNDYvNDUyNzQ=\">https://cloud.tencent.com/document/product/1246/45274</span></li>\n<li>图片压缩：1元&#x2F;千次</li>\n</ul>\n<h1 id=\"SSR服务端渲染\"><a href=\"#SSR服务端渲染\" class=\"headerlink\" title=\"SSR服务端渲染\"></a>SSR服务端渲染</h1><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>SSR-Server Side Rendering</strong></p>\n<p>Vue关于SSR的介绍：https:&#x2F;sSr.uejs.org&#x2F;zh</p>\n<p><strong>SSR的优点</strong></p>\n<ul>\n<li>更好的SEO</li>\n<li>更快的渲染时间(Time to content)，</li>\n</ul>\n<p><strong>SSR的缺点</strong></p>\n<ul>\n<li><p>开发的限制，浏览器相关的操作只能在特定的钩子函数中使用</p>\n</li>\n<li><p>SPA应用完全静态化，而SSR app需要Node.js Server才能运行</p>\n</li>\n<li><p>服务端负荷更高</p>\n</li>\n</ul>\n<p><strong>SSR的实现：</strong></p>\n<ul>\n<li><p>基本原理：@vue&#x2F;server-renderer https:lv3.uejs.org&#x2F;guide&#x2F;ssr&#x2F;getting-started.html#installation</p>\n</li>\n<li><p>使用createSSRApp,renderToString以及renderToStream方法</p>\n</li>\n</ul>\n<p><strong>成熟的，大而全的SSR通用开发框架：</strong></p>\n<ul>\n<li>Nuxt.js <span class=\"exturl\" data-url=\"aHR0cHM6Ly9udXh0anMub3JnLw==\">https://nuxtjs.org/</span>  （Vue）</li>\n<li>React类似的Next.js https:&#x2F;nextjs.orgl （React）</li>\n</ul>\n<h3 id=\"SSR\"><a href=\"#SSR\" class=\"headerlink\" title=\"SSR\"></a>SSR</h3><p>express等框架的res.render方法可以渲染html模板，使用的是nunjucks库进行数据填充。</p>\n<p>index.html</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html class=&quot;no-js&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;description&quot; content=&quot;&#123;&#123; desc &#125;&#125;&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body style=&quot;&#123;&#123; bodyStyle &#125;&#125;&quot;&gt;  //根据传入的props动态添加style样式\n    &#123;&#123; html | safe &#125;&#125;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>index.js  (依据express框架为例：)</p>\n<pre><code>//...res是响应参数\nres.render(&#39;index&#39;,function(err,html)&#123;\n    res.send(html);\n&#125;)\n</code></pre>\n<h3 id=\"vue中SSR\"><a href=\"#vue中SSR\" class=\"headerlink\" title=\"vue中SSR\"></a>vue中SSR</h3><p>1、vue3有包：@vue&#x2F;server-renderer，在3.2.13版本以上内置了，低于此版本需要自行安装。</p>\n<p>2、使用：</p>\n<pre><code class=\"js\">//.......... res是服务端返回\nimport &#123; pipeline &#125; from &#39;stream/promises&#39;;\nimport &#123; createSSRApp &#125; from &#39;vue&#39;;\nimport &#123; renderToString , renderToNodeStream &#125; from &#39;@vue/server-renderer&#39;\nconst vueApp = createSSRApp(&#123;\n    data:()=&gt;&#123; msg:&#39;hello world&#39; &#125;,\n    template: &#39;&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&#39;\n&#125;)\nconst appContent = await renderToString(vueApp);\nres.type = &#39;text/html&#39;;\nres.body = appContent;\n// 或者使用流式输出：\nconst stream = renderToNodeStream(vueApp);\nres.statys = 200;\nawait pipeline(stream,res);\n</code></pre>\n<h1 id=\"RBAC权限验证\"><a href=\"#RBAC权限验证\" class=\"headerlink\" title=\"RBAC权限验证\"></a>RBAC权限验证</h1><h3 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>权限验证的场景以及需求：</strong></p>\n<ul>\n<li>特定的角色的用户才能操作特定的资源</li>\n<li>不同的用户能操作同类资源的特定实体</li>\n<li>不同的用户操作特定资源的不同属性</li>\n</ul>\n<p><strong>谁(User)拥有什么权限(Authority）去操作(Operation)哪些资源(Resource)</strong><br>根据角色完成权限的控制-RBAC(role based access control)，其实就是在原本用户——-权限的对应关系之上加一层中间层角色：用户——角色—–权限。好处是使得用户和权限的对应关系更加清晰和易于掌控。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>Node.js实现RBAC的库：</p>\n<ul>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29udXJ5L2FjY2Vzc2NvbnRyb2w=\">AccessControl.js（不推荐，不维护了）</span></p>\n<ul>\n<li>1.6k Star</li>\n<li>3年没有更新，很多issue没人处理</li>\n<li>不支持ts</li>\n</ul>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nhc2Jpbi9ub2RlLWNhc2Jpbg==\">Casbin</span></p>\n<ul>\n<li>1.7k Star</li>\n<li>ts编写，支持多种编程语言</li>\n<li>概念比较复杂，使用略繁琐</li>\n</ul>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0YWxuaXkvY2FzbA==\">Casl</span></p>\n<ul>\n<li><p>3.4k Star</p>\n</li>\n<li><p>ts编写</p>\n</li>\n<li><p>简单易用，可读性良好</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Casl使用\"><a href=\"#Casl使用\" class=\"headerlink\" title=\"Casl使用\"></a><strong>Casl使用</strong></h3><pre><code class=\"js\">import &#123; AbilityBuilder , Ability &#125; from &#39;@casl/ability&#39;;\nclass Work &#123;\n    constructor(attrs)&#123;\n        Object.assign(this,attrs);\n    &#125;\n&#125;\nconst templateWork = new Work(&#123; id : 1 , isTemplate : true &#125;);\nconst notWork = new Work(&#123; id : 2 , isTemplate : false &#125;);\nfunction defineRules()&#123;\n    const &#123; can , cannot ,build &#125; = new AbilityBuilder(Ability);\n    can(&#39;read&#39;,&#39;Work&#39;);\n    cannot(&#39;delete&#39;,&#39;Work&#39;);\n    can(&#39;update&#39;,&#39;Work&#39;,&#123;isTemplate:false&#125;);\n    return build();\n&#125;\nconsole.log(templateWork.constructor.name)\nconst rules defineRules()\nconsole.log(rules.can(&#39;read&#39;,&#39;Work&#39;))\nconsole.log(rules.can(&#39;delete&#39;,&#39;Work&#39;))\nconsole.log(rules.can(&#39;update&#39;,templateWork))\nconsole.log(rules.can(&#39;update&#39;,notWork))\n</code></pre>\n<h1 id=\"部署-1\"><a href=\"#部署-1\" class=\"headerlink\" title=\"部署\"></a>部署</h1><h3 id=\"传统模式\"><a href=\"#传统模式\" class=\"headerlink\" title=\"传统模式\"></a>传统模式</h3><p><strong>本地开发</strong><br>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1iaW4=\">egg-bin</span>，提供了便捷的方式在本地进行开发、调试、单元测试，它可以自动的监控文件的修改，然后重新运行对应的命令。<br>采用的配置文件是：config.default.ts<br>启动开发环境命令为<code>egg-bin dev</code><br><strong>生产环境运行程序</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbTIua2V5bWV0cmljcy5pby8=\">pm2-process manager</span></p>\n<p><code>node script.js pm2 start script.js</code></p>\n<p><strong>PM2的优势：</strong></p>\n<ul>\n<li>cluster模式运行</li>\n<li>自动重启auto reload</li>\n<li>热替换hot reload</li>\n<li>性能监控Monitoring</li>\n</ul>\n<p><strong>egg.js中有对应于PM2的内置方法：</strong></p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1zY3JpcHRz\">egg-scripts</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1jbHVzdGVy\">egg-cluster</span></li>\n</ul>\n<p><strong>egg.js生产环境启动和关闭</strong><br><code>egg-scripts start egg-scripts stop</code></p>\n<p><strong>配置文件</strong><br>config.prod.ts config.default.ts<br><strong>编译过程</strong><br>需要手动将ts转换为js,借助<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3doeGF4ZXMvZWdnLXRzLWhlbHBlcg==\">ets</span><br><code>特别注意将项目中的typscript版本升级到4.4.3 </code></p>\n<p><code>npm run tsc</code></p>\n<h2 id=\"Cluster模型\"><a href=\"#Cluster模型\" class=\"headerlink\" title=\"Cluster模型\"></a>Cluster模型</h2><p><strong>Egg.js Cluster模型的原理</strong><br>Egg.js关于这部分内容的文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZ2dqcy5vcmcvemgtY24vY29yZS9jbHVzdGVyLWFuZC1pcGMuaHRtbA==\">https://eggjs.org/zh-cn/core/cluster-and-ipc.html</span><br><strong>为什么要采用Cluster模式</strong><br>JavaScript代码是运行在单线程上的，那么如果用Node.js来做Web Server,就无法享受到多核运算的好处。<br><strong>什么是Cluster模式</strong><br>文档：http:l&#x2F;nodejs.cn&#x2F;api&#x2F;cluster.html</p>\n<p>Node.jS的单个实例在单个线程中运行。为了利用多核系统，用户有时会想<br>要启动Node.js进程的集群来处理负载。</p>\n<ul>\n<li>在服务器上同时启动多个进程</li>\n<li>每个进程里都跑的是同一份源代码（将一个进程的工作分给多个进程去做）</li>\n<li>这些进程可以同时监听一个端口</li>\n</ul>\n<p><strong>Cluster的运行模式：</strong></p>\n<p>Request————-master_process主进程———————workers进程（多个）</p>\n<p><strong>进程间通信（IPC）：</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUExJThDJUU3JUE4JThCJUU5JTk2JTkzJUU5JTgwJTlBJUU4JUE4JThB\">IPC Inter-Process Communication</span></p>\n<p>IPC指的是至少两个进程或线程间传送数据或信号的一些技术或者方法，Node.js将其封装为基于事件的形式便于使用。</p>\n<p><strong>Cluster使用：</strong></p>\n<pre><code class=\"js\">import http from &#39;http&#39;;\nimport cluster from &#39;cluster&#39;;\nimport &#123; cpus &#125; from &#39;os&#39;;\nimport process from &#39;process&#39;;\nif(cluster.isPrimary)&#123;\n    console.log(`master $&#123;process.pid&#125; running`);\n    const cpuLength = cpus().length;\n    for(let i = 0 ; i &lt; cpuLength ; i++)&#123;\n        cluster.fork();\n    &#125;\n    cluster.on(&#39;exit&#39;,(worker)=&gt;&#123;\n        console.log(`worker $&#123;worker.process.pid&#125; exited`);\n    &#125;)\n&#125;else&#123;\n    http.createServer((req,res)=&gt;&#123;\n        res.writeHead(200);\n        res.end(&quot;hello world&quot;);\n    &#125;).listen(8000);\n    console.log(`worker $&#123;process.pid&#125; started`);\n    console.log(cluster.workers); //获得子进程，可以通过process.send和on(&#39;message&#39;)事件进行进程间通信。\n&#125;\n</code></pre>\n<p><strong>egg.js中对于Cluster的二次封装：</strong></p>\n<ul>\n<li>使用egg-scripts启动master process</li>\n<li>使用egg-cluster启动和CPU核数相等的app_worker process</li>\n<li>使用egg-cluster启动的一个独特的agent_.worker process</li>\n</ul>\n<p><strong>进程守护</strong><br>考虑到生产环境的健壮性，必须保证进程异常的情况下怎样处理。<br><strong>当代码抛出异常并没有被捕获的时候，worker使用process.on(‘uncaughtException’,handler)来捕获对应的错误，这时进程处于不确定的状态，需要优雅退出。</strong></p>\n<p><strong>系统异常</strong><br>而当一个进程出现异常导致crash或者被系统杀死时，不像未捕获异常发生时我们还有机会让进程继续执行，Master立刻fork一个新的Worker。<br><strong>Agent机制</strong><br>有一些特殊性质的工作，不能多个worker一起合作，容易造成混乱。对于这种工作egg.js提供了一个新的agent进程来完成。</p>\n<p><strong>Egg.js三种进程的总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>进程数量</th>\n<th>作用</th>\n<th>稳定性</th>\n<th>是否运行业务代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Master进程</td>\n<td>1</td>\n<td>进程管理，进程间消息转发</td>\n<td>非常高</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Agent进程</td>\n<td>1</td>\n<td>后台运行工作</td>\n<td>高</td>\n<td>少量</td>\n</tr>\n<tr>\n<td>Workers进程</td>\n<td>CPU核数</td>\n<td>执行业务代码</td>\n<td>一般</td>\n<td>是</td>\n</tr>\n</tbody></table>\n<p><strong>Cluster模型和Node多进程的区别：</strong></p>\n<ul>\n<li>Cluster模块可以将一个node进程分裂成多个子进程，每个子进程独立运行在cpu内核上，以提升应用程序的并发能力和性能，通过主进程和子进程之间的通信来实现负载均衡，处理并发请求。</li>\n<li>node多进程使用child_process模块，其不具备负载均衡和通信机制，需要自行实现进程间通信和负载均衡逻辑。可用于处理长时操作，返回结果给主进程。</li>\n</ul>\n<p><strong>Node.js压力测试工具：</strong></p>\n<p>模拟高并发场景：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9hZHRlc3Q=\">Loadtest</span></p>\n<pre><code class=\"bash\"># n                   总过发送多少个请求\n# c concurrency       同时有几个客户端在发送请求\n# rps request per seconds   每秒发送多少个请求\nloadtest -n 400 -c 10 --rps 200 http://mysite.com/ \n</code></pre>\n<h1 id=\"云服务器\"><a href=\"#云服务器\" class=\"headerlink\" title=\"云服务器\"></a>云服务器</h1><h4 id=\"购买\"><a href=\"#购买\" class=\"headerlink\" title=\"购买\"></a>购买</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L2Vjcw==\">阿里云ECS</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9wcm9kdWN0L2N2bQ==\">腾讯云CVM</span></p>\n<p>价格（学生优惠）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9hY3QvY2FtcHVzP2Zyb209MTQ1OTk=\">https://cloud.tencent.com/act/campus?from=14599</span> 12G 38</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHVhd2VpY2xvdWQuY29tL3Byb2R1Y3QvZWNzLmh0bWw=\">华为云ECS</span></p>\n<h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4><p><strong>为什么使用root登录时一个不好的实践</strong></p>\n<ul>\n<li>有非常多的bot会尝试使用root+pwd的ssh方式暴力登录机器，当尝试成功以后，黑客就会控制整个系统。</li>\n<li><em>假如使用特定用户名+pwd,bot需要先猜测用户名(N次)，然后是密码(M次)，这样复杂度提升到N</em>M</li>\n<li>root可以造成更大的危害，影响整个系统，而某个特定用户只能影响它的文件系统</li>\n</ul>\n<p><strong>创建一个用户账号进行登录</strong></p>\n<pre><code class=\"bash\"># 远程登录\nssh root@xxx.xx.xx.xx\n# 添加用户以及设置密码\nadduser dmq\n</code></pre>\n<p><strong>设置该用户拥有sudo权限，给予它在登录以后切换到root的能力</strong></p>\n<pre><code class=\"bash\"># 修改权限，u表示所有者，w表示写权限+表示添加\nchmod u+w /etc/sudoers\n# 编辑文件\nvim /etc/sudoers\n# 找到  `root ALL=(ALL)  ALL`\n# 再加一行  `dmq ALL=(ALL)  ALL`\n</code></pre>\n<p><strong>使用新用户登录并且测试权限</strong></p>\n<pre><code class=\"bash\">ssh dmq@xxx.xx.xx.xx\n# 可以使用 su 直接切换为root用户\n# 也可以使用sudo快捷的使用root权限进行操作\n</code></pre>\n<p><strong>禁止使用root远程登录ssh</strong></p>\n<pre><code class=\"bash\"># 修改ssh配置\nvim /etc/ssh/sshd_config I\n# 修改yes为no\nPermitRootLogin no\n# 重启sshd服务\nservice sshd restart\n</code></pre>\n<p><strong>可选：不使用密码登录</strong><br>为什么使用密码登录有时候是一个不好的实践？<br><strong>非常简单：用户经常使用非常错误（简单的）用户密码，全球最常用的密码是123456以及bc123,而且用户会在多个账户大量重复使用，所以黑客从别的地方盗取的密码很可能在其他账户也可以使用</strong></p>\n<p><strong>使用SSH kev讲行登录</strong><br>SSH key采角了经典的非对称加密技术，可以使用工具创建一个公钥和私钥，你可以将公钥放置在任何的服务器当中，在本地保留私钥。在ssh登录的时候，SSH验证公钥和私钥的合法性，当合法的时候，就可以免密码登录了。证书由1024Bits到4096Bits（128到512字符)的随机字符组成，<br>要比你自己的密码安全的多。</p>\n<pre><code class=\"bash\">#创建ssh key pair\nssh-keygen -t rsa -b 4096 -C &quot;your email@example.com&quot;\nwindows可以使用putty或者git scma软件生成，备注网址：\nhttps://www.jianshu.com/p/95262f5eba7a\n# 本地ssh证书的位置\n-/.ssh/id rsa\n-/.ssh/id rsa.pub\n# 登录远程机器\nssh viking@xxx.xx.xx.xx\n# 创建受信任的登录密钥\n# 这个文件当中的公钥会被当前的主机设置为信任方\ntouch -/.ssh/authorized keys\n# 将id rsa.pub的文本内容黏贴进来\n</code></pre>\n<p><strong>可选，关闭密码登录服务器的功能</strong></p>\n<pre><code class=\"bash#修改ssh配置\">vim /etc/ssh/sshd config\n#修改为no\nPasswordAuthentication no\n#重启服务\nservice sshd i restart\n</code></pre>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p><strong>准备云服务器必备软件</strong></p>\n<ul>\n<li>nodejs (16)</li>\n<li>MongoDB</li>\n<li>Redis</li>\n<li>Git</li>\n</ul>\n<p><strong>Linux发行版的两大家族</strong></p>\n<ul>\n<li>Debian(完全免费的Linux发行版)-Ubuntu(基于Debian,更加容易上手)-apt包管理系统-软件格式为deb包大</li>\n<li>Red Hat(商用Linux发行版)-CentOS(Red Hat减去收费软件)-yum包管理系统-软件格式为rpm</li>\n</ul>\n<p><strong>软件安装</strong><br><strong>安装Node.js</strong><br>1安装nvm管理node版本<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=\">https://github.com/nvm-sh/nvm</span><br>2使用包管理器安装node最新版本<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZGVzb3VyY2UvZGlzdHJpYnV0aW9ucy9ibG9iL21hc3Rlci9SRUFETUUubWQjZGVi\">https://github.com/nodesource/distributions/blob/master/README.md#deb</span></p>\n<p><strong>安装MongoDB</strong><br>1从源代码下载安装，回顾之前的内容<br>2使用包管理器安装<br>Ubuntu:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC90dXRvcmlhbC9pbnN0YWxsLW1vbmdvZGItb24tdWJ1bnR1Lw==\">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/</span><br>Centos:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC90dXRvcmlhbC9pbnN0YWxsLW1vbmdvZGItb24tcmVkLWhhdC8=\">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</span></p>\n<p><strong>安装Redis</strong><br>*1从源代码下载安装，回顾之前的基础知识<br>*2使用包管理器安装<br>CentOS:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1pbnN0YWxsLXNlY3VyZS1yZWRpcy1jZW50b3MtNw==\">https://www.digitalocean.com/community/tutorials/how-to-install-secure-redis-centos-7</span><br>Ubuntu:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1pbnN0YWxsLWFuZC1zZWN1cmUtcmVkaXMtb24tdWJ1bnR1LTE4LTA0\">https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04</span></p>\n<h4 id=\"管理\"><a href=\"#管理\" class=\"headerlink\" title=\"管理\"></a>管理</h4><p><strong>使用service或者systemctl管理服务</strong></p>\n<pre><code class=\"bash\"># systemd 模块 - https://en.wikipedia.org/wiki/Systemd\nservice  服务名称(mongod)  操作指令(status/start/stop/restart)\nsystemctl  操作指令(start/stop/status/restart/reload)  服务名称service\n</code></pre>\n<h1 id=\"普通部署\"><a href=\"#普通部署\" class=\"headerlink\" title=\"普通部署\"></a>普通部署</h1><p><strong>在服务器上部署并运行</strong></p>\n<ul>\n<li><p>1登录远程机器，使用普通用户。</p>\n</li>\n<li><p>2在自己的目录下面，clone代码</p>\n</li>\n<li><p>3安装对应的依赖</p>\n<ul>\n<li><p>可以使用sharp淘宝mirror来安装比较大的二进制文件。</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaGFycC5waXhlbHBsdW1iaW5nLmNvbS9pbnN0YWxsI2NoaW5lc2UtbWlycm9y\">https://sharp.pixelplumbing.com/install#chinese-mirror</span></p>\n</li>\n</ul>\n</li>\n<li><p>4创建并且设置.env文件</p>\n</li>\n<li><p>5开启云服务对应的端口(7001)访问。</p>\n<ul>\n<li><p>阿里云：左侧导航“本实例安全组”，“配置规则”，“手动添加”端口</p>\n</li>\n<li><p>其他云平台请自行查看。</p>\n</li>\n</ul>\n</li>\n<li><p>6启动服务器</p>\n<ul>\n<li><p>确认mongo,redis在运行状态</p>\n</li>\n<li><p>npm run tsc</p>\n</li>\n<li><p>npm run start</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>于此可以完成基本的项目部署，但是这种部署方式启动和更新时过于复杂，存在如下问题：</p>\n<p>三个问题</p>\n<ul>\n<li>前置软件的安装，它们在不同操作系统中安装的方式，启动的脚本，预设初始的方式有可能都不相同，这就给我们造成一个很大的困扰，假如你在多台机器上部署的话，可能会遇到各种各样的问题。</li>\n<li>项目需要运行一系列对应的命令才能启动</li>\n<li>项目更新的问题，需要一系列手动的步骤，这是一个非常繁琐，而且容易出错的步骤。有没有更方便的方式可以完成这个过程呢？<ul>\n<li>完成对应的pull代码，更新依赖，启动应用的过程</li>\n<li>是在特定的提交自动触发这个过程</li>\n</ul>\n</li>\n</ul>\n<p>想要更加方便的进行部署可以使用如下工具：</p>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS9wcm9kdWN0cy9kb2NrZXItZGVza3RvcA==\">Docker</span></h2><h3 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>问题</strong><br>我们希望有一个工具可以帮我们一键智能部署，假如你要部署在多台不同的机器上，可以不用在担心不同系统，不同版本的差异，以及运行之前需要安装不同软件的痛苦。<br><strong>解决</strong><br>当红的虚拟化软件：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG9ja2VyLmNvbWwv\">Docker</span><br>Docker的进化</p>\n<p><img data-src=\"/images/Snipaste_2024-04-26_20-27-53.jpg\" alt=\"Docker的进化\"></p>\n<ul>\n<li>传统虚拟机，虚拟硬件以后，需要在上面安装一个完整的操作系统。</li>\n<li>Docker:推出了容器的概念，每个容器不需要安装完成的操作系统，里面的进程直接运行在Docker创造的宿主内核中，不需要虚拟硬件。</li>\n</ul>\n<p><strong>Docker的优点</strong></p>\n<ul>\n<li>更快速的启动速度</li>\n<li>更少的资源占用</li>\n<li>一致的运行环境，使用户不关注操作系统而只关心应用程序。</li>\n<li>微服务架构，docker天生适配微服务架构（Docker 有助于将一个复杂系统分解成一系列可组合的部分，这让用户可以用更离散的方式来思考其服务。用户可以在不影响全局的前提下重组软件，使其各部分更易于管理和可插拔。）</li>\n<li>用户可以更准确地控制构建环境的状态，Docker 构建比传统软件构建方法更具有可重现性和可复制性。使持续交付的实现变得更容易。</li>\n</ul>\n<h3 id=\"Docker-images\"><a href=\"#Docker-images\" class=\"headerlink\" title=\"Docker  images\"></a><strong>Docker  images</strong></h3><p>可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9zZWFyY2g/Zz0mdHlwZT1pbWFnZSVFNCVCOCVBRCVFOCU4RSVCNyVFNSU4RiU5NiVFNSU5MCU4NCVFNyVBNyU4RCVFNSVBRSU5OCVFNiU5NiVCOSVFNyU5QSU4NCVFOSU5NSU5QyVFNSU4MyU4RiVFRiVCQyU4QyVFNSVCOSVCNiVFNCVCOCU5NCVFNSU4RiVBRiVFNCVCQiVBNSVFNCVCOCU4QSVFNCVCQyVBMCVFNCVCRCVBMCVFOCU4NyVBQSVFNSVCNyVCMSVFNyU5QSU4NCVFOCU4NyVBQSVFNSVBRSU5QSVFNCVCOSU4OSVFOSU5NSU5QyVFNSU4MyU4Rg==\">https://hub.docker.com/search?g=&amp;type=image中获取各种官方的镜像，并且可以上传你自己的自定义镜像</span><br>Docker镜像仓库获取镜像的命令是docker pull</p>\n<pre><code class=\"bash\"># 下载镜像\ndocker pull &lt;image-name&gt;:&lt;tag&gt;\n# 查看以及下载的镜像\ndocker images\n# 删除镜像\ndocker rmi &lt;image-id&gt;\n# 上传\ndocker push &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;\n</code></pre>\n<p><strong>使用镜像代理：</strong></p>\n<pre><code class=\"json\">&quot;registry-mirrors&quot;: [\n    &quot;https://docker.mirrors.ustc.edu.cn/&quot;,\n    &quot;https://reg-mirror.qiniu.com&quot;\n]\n</code></pre>\n<h3 id=\"Docker-Container\"><a href=\"#Docker-Container\" class=\"headerlink\" title=\"Docker Container\"></a><strong>Docker Container</strong></h3><p><strong>启动Docker容器</strong></p>\n<pre><code class=\"bash\">docker run -d -p 主机端口:镜像端口 --name 容器名称 镜像名称\n# 例如：（--name 容器名称省略）\ndocker run -d -p 81:80 nginx\n# -d  后台运行\n# -p  端口映射，81为主机的端口，80为镜像端口\n# --name 自定义容器名称\n# 镜像名称，假如本地没有，会自动pull一次镜像进行下载。\n</code></pre>\n<p><strong>其他命令</strong></p>\n<pre><code class=\"bash\"># 查看所有容器\ndocker  ps\n# 停止容器\ndocker stop container-id\n# 删除容器\ndocker rm container-id\n# 启动已终止容器\ndocker container start container-id\n</code></pre>\n<p><strong>进入容器内部</strong></p>\n<pre><code class=\"bash\">docker exec -it &lt;container-id&gt; command\n-i : 即使没有附加也保持STDIN 打开\n-t : 分配一个伪终端\n</code></pre>\n<h3 id=\"持久化容器数据\"><a href=\"#持久化容器数据\" class=\"headerlink\" title=\"持久化容器数据\"></a><strong>持久化容器数据</strong></h3><p>使用-v参数，可以设定一个数据的映射关系，将本地的文件映射到容器中对应的文件中去。</p>\n<pre><code class=\"bash\">docker run -d -p 81:80 -v host:container image-name\n#例如：将本地数据卷映射到容器中\ndocker run -d -v /data/db:/data/db mongo\n</code></pre>\n<p><strong>创建对应的数据卷volumn</strong></p>\n<pre><code class=\"bash\"># 创建数据卷\ndocker volume create &lt;volumn-name&gt;\n#例如：docker volume create mongo\n# 使用volumn数据卷\ndocker run -d -v &lt;volumn-name&gt;:/data/db mongo\n# 例如：docker run -d -v mongo:/data/db mongo\n# 检查数据卷\ndocker volume inspect &lt;volumn-name&gt;\n# 删除数据卷\ndocker volume remove mongo\n</code></pre>\n<h3 id=\"Dockerfile自定义镜像\"><a href=\"#Dockerfile自定义镜像\" class=\"headerlink\" title=\"Dockerfile自定义镜像\"></a>Dockerfile自定义镜像</h3><p>Docker image中的镜像虽然非常多，但是不能完全符合自己项目的全部需求，可以自定义构建一个自己的镜像。</p>\n<p>Dockerfile是一个特殊的文本文件，其中包括一系列指令，用于构建对应的镜像。</p>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9idWlsZGVyLyNmcm9t\">指令</span></strong></p>\n<p> <strong>Dockerfile示例：</strong></p>\n<pre><code class=\"dockerfile\"># 指定基础镜像，从node14开始构建\nFROM node:14\n\n# 创建对应的文件夹，作为项目运行的位置\nRUN mkdir -p /usr/src/app\n\n# 指定工作区，后面的运行任何命令都是在这个工作区中完成的\nWORKDIR /usr/sec/app\n\n# 从本地拷贝对应的文件 到 工作区\nCOPY server.js /usr/src/app\n\n# 执行安装命令\nRUN npm install --registry=https://registry.npm.taobao.org\nRUN npm run tsc\n\n#告知当前Docker image暴露的是3000端☐\nEXPOSE 3000\n\n#执行启动命令，一个Dockerfile只能有一个\nCMD node server.js\n</code></pre>\n<p><strong>构建：</strong></p>\n<pre><code class=\"bash\"># 这里特别注意上下文的概念，不要在根目录使用Dockerfi1e\ndocker build [选项] &lt;上下文路径/URL/-&gt;\n# 例如：(在项目文件夹中运行)\ndocker build -t test-node .\n</code></pre>\n<p><strong>.dockerignore文件用于忽略docker中需要打包进镜像的文件</strong></p>\n<p><strong>.dockerignore示例：</strong></p>\n<pre><code class=\"dockerfile\"># Microbundle cache\n.rpt2_cache/\n.rts2_cache_cjs/\n.rts2_cache_es/\n.rts2_cache_umd/\n# Optional REPL history\n.node_repl_history\n# Output of &#39;npm pack&#39;\n*.tgz\n# Yarn Integrity file\n.yarn-integrity\n</code></pre>\n<p> <strong>多个容器相互通信：</strong></p>\n<p>要点：Docker中每一个container应该只完成一个工作，并且将它做好。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>解耦，这样不同的服务和后端代砀都可以完全分离开来，方便管理以及未来的扩展。</li>\n<li>服务的更新以及升级都是完全独立的。</li>\n<li>在一个container中，启动多个不同的进程，需要一个进程管理器</li>\n</ul>\n<p><strong>通信过程：</strong></p>\n<p>docker容器之间不能直接进行访问，而是应该通过docker网络进行访问。</p>\n<pre><code class=\"bash\"># 创建docker网络\ndocker network create test\n# 在创建的docker网络中启动服务\ndocker run -d --network test --name mongo -p 27017:27017 mongo\n# 将原来项目中的的ip地址替换为docker的name名称\n# 例如原来为：mongodb://localhost:27017/api  的地址要替换为： mongodb://mongo:27017/api\n# 只有在同一个docker网络中启动的项目间才能进行访问。\ndocker run -d --network test --name use -p 80:3000 use\n</code></pre>\n<p>如果每个容器都要这样操作一遍就会显得非常麻烦，这时就需要使用Docer compose工具（配置docker-compose.yml文件）</p>\n<p>Docker compose工具</p>\n<p>Docker compose是Docker官方推出的工具，用来管理和共享多个容器的应用，Mac系统和Windows系统安装客户端时自带。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9pbnN0YWxsLw==\">Linux需要单独安装</span>。</p>\n<pre><code class=\"bash\">docker-compose version\n</code></pre>\n<p><strong>配置：</strong></p>\n<ul>\n<li>docker compose通过一个特殊的yml文件，进行配置，这个文件必须命名为<strong>docker-compose.yml</strong></li>\n<li>docker-compose所有的字段参考文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9jb21wb3NlLWZpbGUvY29tcG9zZS1maWxlLXYzLw==\">https://docs.docker.com/compose/compose-file/compose-file-v3/</span></li>\n</ul>\n<p><strong>docker-compose.yml文件配置示例：</strong></p>\n<pre><code class=\"yaml\">version: &#39;3&#39; # docker指令版本\nservices: # 要启动的服务\n  test-mongo: # 服务名称，这里的服务名称对应着容器通信时的前缀！\n    image: mongo # 使用的镜像名称\n    container_name: test-mongo # 容器名称\n    volumes:  # 使用的数据卷映射\n      - &#39;.docker-volumes/mongo/data:/data/db&#39;\n    ports:  # 端口映射\n      - 27017:27017\n    environment: # 设置环境变量\n      - MONGO_INITDB_ROOT_USERNAME=admin  # 内置的环境变量，可以初始化添加一个User\n      - MONGO_INITDB_ROOT_PASSWORD=pass\n    env_file: # 设置环境变量文件，将敏感信息放置到环境变量文件中\n      - .env\n  test-use: # 第二个项目，注意对齐关系\n    depends_on: # 配置所依赖的服务\n      - test-mongo\n    build: # 设置构建配置\n      context: . # 操作上下文为当前目录\n      dockerfile: Dockerfile # 基于Dockerfile进行构建\n    image: test-use-image\n    container_name: test-use\n    ports:\n      - 7001:7001\n</code></pre>\n<p><strong>启动以及关闭：</strong></p>\n<pre><code class=\"bash\"># 启动\ndocker-compose up -d\n# 关闭\ndocker-compose down\n</code></pre>\n<h3 id=\"数据库配置\"><a href=\"#数据库配置\" class=\"headerlink\" title=\"数据库配置\"></a>数据库配置</h3><p><strong>数据库准备工作</strong></p>\n<ul>\n<li>数据库配置，初始化工作，比如插入一些特定的数据</li>\n<li>避免使用root用户去启动服务，从而提高安全性（配置数据库访问权限）</li>\n</ul>\n<p><strong>特殊的初始化数据库的位置：&#x2F;docker-entrypoint-initdb.d（这个文件夹中的脚本会在容器启动前自动执行）</strong></p>\n<ul>\n<li><p>可以创建js文件或者sh文件（shell）进行执行。</p>\n</li>\n<li><p>mongoDB：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fbW9uZ28=\">https://hub.docker.com/_mongo</span></p>\n</li>\n<li><p>Postgres:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fbHBvc3RncmVz\">https://hub.docker.com/_lpostgres</span></p>\n</li>\n<li><p>特别注意，只有在数据库没有被创建的情况下，也就是<strong>数据库的文件夹是空的情况下</strong>，脚本才会被执行。</p>\n</li>\n</ul>\n<p><strong>docker-compose.yml文件中配置env_file为当前文件夹下的.env文件。</strong></p>\n<p>可以使用js文件或者sh文件，但是由于此文件在其余文件之前运行，此时js文件中通过process.env获取不到所需要的环境变量，可以选用sh文件。</p>\n<p><strong>Shell中EOF&lt;&lt;的用法</strong><br>在Shell中我们通常将EOF与&lt;结合使用，表示，二债的输入作为子命令或子Shell的输入，直到遇到EOF为止，再返回到主调Shell。.</p>\n<pre><code class=\"shell\">#!/bin/bash\nmongo &lt;&lt;EOF\nuse admin\ndb.auth(&#39;root&#39;,&#39;123456&#39;)\nuse lego\ndb.createUser(&#123;\n    user: &#39;$MONGO_DB_USERNAME&#39;,\n    pwd: &#39;$MONGO_DB_PASSWORD&#39;,\n    roles: [&#123;\n        role: &#39;readWrite&#39;,\n        db: &#39;lego&#39;\n    &#125;]\n&#125;)\ndb.createCollection(&#39;works&#39;)\ndb.works.insertMany([\n    &#123;\n          id:19,\n          title:&#39;测试标题&#39;,\n          name:&#39;张三&#39;\n    &#125;\n])\nEOF\n</code></pre>\n<h3 id=\"优化镜像大小\"><a href=\"#优化镜像大小\" class=\"headerlink\" title=\"优化镜像大小\"></a>优化镜像大小</h3><p> <strong>Docker镜像构建优化：使用alpine版本的镜像</strong></p>\n<p>优化镜像大小  ：   什么是Alpine Linux:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbHBpbmVsaW51eC5vcmcv\">https://alpinelinux.org</span></p>\n<p><strong>Alpine的优点</strong></p>\n<ul>\n<li><p>Small小</p>\n<ul>\n<li><p>默认软件包，alpine选择busybox</p>\n</li>\n<li><p>C运行库，一般会用glibc,alpine选择musl</p>\n</li>\n</ul>\n</li>\n<li><p>最简依赖，Simple</p>\n<ul>\n<li><p>很多内置软件的插件都去掉。</p>\n</li>\n<li><p>国际化内容都被删除</p>\n</li>\n</ul>\n</li>\n<li><p>Secure安全</p>\n</li>\n</ul>\n<p><strong>使用alpine版本的镜像可以大大减小镜像的体积。</strong></p>\n<p><strong>DockerBuild构建提速</strong></p>\n<p>docker中运行命令是基于一层一层的，当修改文件之后，COPY后的缓存全部失效，这时就会重新执行后续命令，使用不了缓存，导致构建速度很慢。此时可以将原来COPY文件夹，改为COPY具体的文件（进行拆分），以更好地使用缓存。</p>\n<h3 id=\"部署-2\"><a href=\"#部署-2\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p><strong>安装Docker（有的云服务可以自定义安装）</strong></p>\n<p>Ubuntu：（需要使用root账户进行安装）</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9kb2NrZXIvdWJ1bnR1LWRvY2tlci1pbnN0YWxsLmh0bWw=\">https://www.runoob.com/docker/ubuntu-docker-install.html</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvdWJ1bnR1Lw==\">https://docs.docker.com/engine/install/ubuntu/</span></li>\n</ul>\n<p><strong>配置用户组</strong><br>因为是root安装，普通用户执行对应的命令的时候有可能会报错：<br><code>Can&#39;t connect to docker daemonGot permission denied while trying to connect to the Docker daemonsocket at unix:///var/run/docker.sock</code></p>\n<p><strong>需要将对应的用户添加到docker的用户组中。</strong></p>\n<pre><code class=\"bash\">#usermod命令修改用户账户\n#a--append添加-G--groups\n组的名称\nsudo usermod-aG docker 你的用户名\n#如果组不存在，添加对应的docker组\nsudo groupadd docker\n#查看一个用户所属的组\ngroups\n</code></pre>\n<p><strong>添加下载镜像：</strong></p>\n<pre><code class=\"bash\"># root\nvim /etc/docker/daemon.json\n&#123;\n&quot;registry-mirrors&quot;:\n&quot;https://docker.mirrors.ustc.edu.cn/&quot;,\n&quot;https://reg-mirror.qiniu.com&quot;\n]\n</code></pre>\n<p><strong>运行：</strong></p>\n<pre><code class=\"bash\"># 拉最新的代码\ngit pull\n# 先查看目前端口是否被占用\n# 如果被占用，释放端口\n# 或者改变docker-compose,yml的映射端口\ndocker-compose up -d\n</code></pre>\n<h1 id=\"YAML语言\"><a href=\"#YAML语言\" class=\"headerlink\" title=\"YAML语言\"></a>YAML语言</h1><p>YAML<br>(YAML Ain’t a Markup Language)是一种标记语言，它使用空格作为缩进，看起来非常的简洁，可读性非常的好，非常适合一些内容大纲和配置文件。他最终是通过工具转化为JSON文件的，但是YAML的可读性比JSON强很多，因此复杂的配置文件一般使用YAML。</p>\n<p><strong>例如：</strong></p>\n<pre><code class=\"yaml\"># 字符串不用加引号\nkey: value\nnumber: 100\nboolean: true\n# 字符串不用加引号，但是加上也不会报错\nquote_string: &#39;quote String&#39;\n# 多行字符串使用 literal block语法：也就是竖线\nmutiple_string: |\n  line one\n  line two\n  line three\n# collection types 集合类型\n# 使用缩进表示层级关系，最好使用两个空格，不是两个空格也没关系，对齐就行\nperson:\n  name: dmq\n  age: 18\n  address:\n    city: 上海\n\n# sequences 数组或者列表\nhobbies:\n  - Item 1\n  - Item 2\n  - name: weson\n    value: xyz\n    address:\n      city: 北京\n</code></pre>\n<h1 id=\"Github-Action\"><a href=\"#Github-Action\" class=\"headerlink\" title=\"Github Action\"></a>Github Action</h1><p>Github官方的CI&#x2F;CD工具，作为github的亲儿子，和github几乎是完美的无缝衔接的，功能非常强大。</p>\n<p>CI   CD常用工具：</p>\n<ul>\n<li>Github actions <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vYWN0aW9ucw==\">https://docs.github.com/en/actions</span></li>\n<li>Travis <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudHJhdmlzLWNpLmNvbS8=\">https://www.travis-ci.com/</span></li>\n<li>CircleCl <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaXJjbGVjaS5jb20v\">https://circleci.com/</span></li>\n<li>Jenkins <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamVua2lucy5pby8=\">https://www.jenkins.io/</span></li>\n<li>优势讨论：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMwNjE5NTAzMy9hbnN3ZXIvMTg3MDMyMjExOA==\">https://www.zhihu.com/question/306195033/answer/1870322118</span></li>\n</ul>\n<p><img data-src=\"/images/Snipaste_2024-04-27_18-37-04.jpg\" alt=\"/images/Snipaste_2024-04-16_12-54-33.jpg\"></p>\n<p><strong>Workflow</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy91bmRlcnN0YW5kaW5nLWdpdGh1Yi1hY3Rpb25zI3dvcmtmbG93cw==\">https://docs.github.com/cn/actions/learn-github-actions/understanding-github-actions#workflows</span><br>Workflow是一个可配置的自动化流程，可以包含多个jobs,通过一个在repo当中的yml文件来定义对应的流程，一个repo可以包含多个workflow。<br><strong>Events</strong><br>Event是触发workflow的特殊事件，比如pull request,push或者issue,也可以完全自定义，完整列表请看：https:&#x2F;docs.github.com&#x2F;cn&#x2F;actions&#x2F;learn-github-actions&#x2F;events-that-trigger-workflows</p>\n<p><strong>Jobs</strong></p>\n<p>Job是Workflow当中一系列的可执行步骤，每个Job是在同一个runner中进行的（(Runner是指处于github的一台特殊的虚拟机，支持各种操作系统)，每个步骤或者是一个shell脚本，抑或是一个可执行的action,每个步骤是按顺序执行，并且互相依赖的。</p>\n<p><img data-src=\"/images/Snipaste_2024-04-27_19-54-06.jpg\" alt=\"/images/Snipaste_2024-04-16_12-54-33.jpg\"></p>\n<p><strong>Actions</strong></p>\n<p>Action是github actions中的一个自定义应用，它可以运行一系列复杂的并且常用的任务，使用action可以帮我们减少在workflow中写重复代码，Github提供了非常多常用的action,可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlP3R5cGU9YWN0aW9ucw==\">这里查阅</span>，同时我们也可以写自己的action。</p>\n<p><strong>github secrets</strong></p>\n<p>项目中有的私密信息不希望公开暴露，通常的做法是将私密信息写道env文件中，使用gitingore将其忽略掉，这里还有一个做法就是github secrets，在github官网设置github secret，然后在文件中直接书写变量。</p>\n<p><strong>例如：.github文件夹下workflow文件夹下创建一个yml文件，写入：</strong></p>\n<pre><code class=\"yaml\">name: Github Actions Demo\non: [push]\njobs:\n  Check-Github-actions:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo &quot;triggered by a $&#123;&#123; github.event_name &#125;&#125; event&quot;\n      - run: echo &quot;running on a $&#123;&#123; runner.os &#125;&#125; server hosted by github&quot;\n      - name: check out repo code\n        uses: actions/checkout@v2 # 在工作流程中检出代码仓库的内容、确保工作流程始终使用一致的代码版本\n      - run: echo &quot;the $&#123;&#123; github.reopsitory &#125;&#125; has been cloned&quot;\n      - name: List files in the repo\n        run: |\n          ls $&#123;&#123; github.workspace &#125;&#125;\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        width:\n          repository: &#39;vikingmute/lego-bricks&#39;\n      - name: List files in the repo\n        run: |\n          ls $&#123;&#123; github.workspace &#125;&#125;\n      - uses: actions/setup-node@v2\n        with:\n          node-version: &#39;16&#39;\n      - run: node -v\n      - run: npm install -g typescript\n      - run: tsc -v\n  jobs:\n    SECRET-SSH-ACTIONS:\n      runs-on: ubuntu-latest\n      steps:\n      #使用ssh-action完成远程登陆：文档地址：https://github.com/appleboy/ssh-action\n        - uses: appleboy/ssh-action@master \n          with:\n            host: $&#123;&#123; secrets.HOST &#125;&#125;\n            username: $&#123;&#123; secrets.SSH_USER &#125;&#125;\n            password: $&#123;&#123; secrets.SSH_PWD &#125;&#125;\n            script_stop: true\n            script: |\n              pwd\n              ls -l\n              touch secret.txt\n              echo $&#123;&#123; secrets.MY_SECRET &#125;&#125; &gt;&gt; secret.txt\n</code></pre>\n<h1 id=\"自动化部署\"><a href=\"#自动化部署\" class=\"headerlink\" title=\"自动化部署\"></a>自动化部署</h1><h2 id=\"推送远程镜像仓库\"><a href=\"#推送远程镜像仓库\" class=\"headerlink\" title=\"推送远程镜像仓库\"></a>推送远程镜像仓库</h2><p><strong>普通线上更新流程：</strong></p>\n<pre><code class=\"bash\"># 每次代码更新以后，登录到ssh服务器\n# 关闭服务\ndocker-compose down\n# 更新代码\ngit pull\n# 假如有.env，的更新需要重新设置，env文件\n# 重新build应用镜像\ndocker-compose build lego-backend\n# 重启服务\ndocker-compose up -d\n</code></pre>\n<p><strong>弊端：</strong></p>\n<ul>\n<li><p>初次上线和更新属于两步</p>\n</li>\n<li><p>初次上线需要特别的操作，就是之前手动部署上线的运行的过程</p>\n<ul>\n<li><p>clone代码</p>\n</li>\n<li><p>设置环境变量.env</p>\n</li>\n<li><p>docker-compose up -d</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>追求的成果：</strong></p>\n<p><strong>每次提交，可以自动一次性的部署到任何服务器，实现初次启动或者更新的效果，这才是一个完美的devops的流程</strong></p>\n<p><strong>解决方案：</strong></p>\n<p>将上面本地的镜像存在于docker hub服务器中，这样每次就不用重新build，而是直接拉取。</p>\n<pre><code class=\"yaml\">services:\n  lego-redis:\n    image:redis:6\n  lego-mongo:\n    image:mongo:latest\n  lego-backend:\n    image:lego-backend\n#我们需要每次手动的build镜像，也就说镜像只存在于本地\n  build:\n    ......context:.\n    dockerfile:Dockerfile\n</code></pre>\n<p><strong>改为：</strong></p>\n<pre><code class=\"yaml\"># 更好的方案\n# 不需要任何代码库中的文件，只需要一个docker-compose.yml文件\n# 就可以轻松的在任何服务器运行\nservices:\n  lego-redis:\n    image:redis:6\n  lego-mongo\n    image:mongo:latest\n  lego-backend:\n# 不需要build,而是存在于docker hub服务器中，可以每次直接拉取\n    image:lego-backend:1.0.1\n</code></pre>\n<p><strong>docker hub免费版有限制，推荐使用阿里云容器镜像服务：</strong></p>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sd3d3LmFsaXl1bi5jb20vcHJvZHVjdC9hY3I=\">阿里云容器镜像服务ACR</span></strong><br>个人版完全免费</p>\n<p>创建镜像仓库之后，需要将本地镜像推送到ACR仓库中：</p>\n<pre><code class=\"bash\"># 来到镜像仓库的基本信息页面\n# 登录\ndocker login --username=用户名 registry.cn-hangzhou.aliyuncs.com\n# tag两种方式：\n# 1:使用tag bui1d\ndocker build--tag &quot;registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]&quot;\n# 2:给 build 好的打 tag\ndocker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]\n# 查看镜像是否 build 完成\ndocker images\n# 推送镜像\ndocker push registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]\n# 在阿里云ACR界面检查看是否已经存在\n</code></pre>\n<h2 id=\"Github-Actions自动部署\"><a href=\"#Github-Actions自动部署\" class=\"headerlink\" title=\"Github Actions自动部署\"></a>Github Actions自动部署</h2><p><strong>使用github actions加成自动化部署：当推送代码到github仓库时，让我们的代码自动提交镜像到镜像仓库。</strong></p>\n<p><strong>大体分为两步</strong></p>\n<ul>\n<li><h6 id=\"在github服务器上build-image并且push\"><a href=\"#在github服务器上build-image并且push\" class=\"headerlink\" title=\"在github服务器上build image并且push\"></a>在github服务器上build image并且push</h6></li>\n<li><p><strong>使用docker-compose-online文件在服务器上运行应用</strong></p>\n</li>\n</ul>\n<p><strong>第一步详细流程分析，在github runner上运行</strong></p>\n<ul>\n<li><p>checkout代码（在github服务器上）</p>\n</li>\n<li><p>创建.env文件，并且添加两个环境变量( upload to OSS需要两个对应的信息 )</p>\n</li>\n<li><p>使用阿里云ACR完成docker login</p>\n</li>\n<li><p>使用正确的阿里云tag进行docker build</p>\n<ul>\n<li>怎样每次push生成特殊的tag？是一个后续的问题</li>\n</ul>\n</li>\n<li><p>docker push</p>\n</li>\n</ul>\n<p>例如：【1】在项目文件夹.github&#x2F;workflow下创建yml文件，写入：</p>\n<pre><code>name: build image,push to ACR\non: [push]\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      # checkout 代码\n      - uses: actions/checkout@v2\n      # 创建env文件\n      - run: touch .env\n      # 使用“ &gt;&gt; ”添加信息\n      - run: echo ALC_ACCESS_KEY=$&#123;&#123; secrets.ALC_ACCESS_KEY &#125;&#125; &gt;&gt; .env\n      - run: echo ALC_SECRET_KEY=$&#123;&#123; secrets.ALC_SECRET_KEY &#125;&#125; &gt;&gt; .env\n      # 使用阿里云ACR 完成 docker login\n      - name: Login to Aliyun ACR\n        uses: aliyun/acr-login@v1 # 使用专属的镜像\n        with:\n          login-server: https://registry.cn-hangzhou.aliyuncs.com\n          region-id: cn-hangzhou # 查看官网自己仓库的信息\n          username: &quot;$&#123;&#123; secrets.ACR_USERNAME &#125;&#125;&quot;\n          password: &quot;$&#123;&#123; secrets.ACR_PASSWORD &#125;&#125;&quot;\n        # 使用正确的阿里云 tag 进行 docker build\n        - name: Build image for Docker\n          run: docker build --tag &quot;registry.cn-hangzhou.aliyuncs.com/dmq00/test:0.0.2&quot;\n        - name: Push Image to ACR\n          run: docker push registry.cn-hangzhou.aliyuncs.com/dmq00/test:0.0.2\n</code></pre>\n<p>这样就能保证代码push到github上之后自动将镜像推送到docker镜像仓库，结合dockerfile文件就能保证使用docker镜像时自动执行命令，安装对应依赖并执行项目。</p>\n<p><strong>第二步详细流程分析，在服务器上部署对应的代码并且运行</strong></p>\n<ul>\n<li><p>checkout代码</p>\n</li>\n<li><p>创建.env文件，添加多个环境变量。(应用所有需要的环境变量)，github  secrets中添加。</p>\n</li>\n<li><p>创建文件夹，拷贝如下文件到文件夹内</p>\n<ul>\n<li>.env</li>\n<li>docker-compose-online.yml</li>\n<li>mongo-entrypoint文件夹</li>\n</ul>\n</li>\n<li><p>将新建的文件夹拷贝到服务器(SCP)当中</p>\n<ul>\n<li>使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlYm95L3NjcC1hY3Rpb24=\">https://github.com/appleboy/scp-action</span></li>\n</ul>\n</li>\n<li><p>SSH到服务器中</p>\n<ul>\n<li>进入拷贝的文件夹内</li>\n<li>登录阿里云ACR</li>\n<li>停止服务docker-compose down （第一次的话，没有启动也不会报错）</li>\n<li>启动服务docker-compose up</li>\n<li>清理工作可选，保证安全（删除.env文件，登出docker账户）</li>\n</ul>\n</li>\n</ul>\n<p><strong>后续过程需要完成：</strong></p>\n<ul>\n<li><p>在push tags的时候才触发对应的job</p>\n<p>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy9ldmVudHMtdGhhdC10cmlnZ2VyLXdvcmtmbG93cw==\">https://docs.github.com/cn/actions/learn-github-actions/events-that-trigger-workflows</span></p>\n</li>\n<li><p>怎样获取对应的每次提交相关的特殊信息</p>\n<p>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy9jb250ZXh0cw==\">https://docs.github.com/en/actions/learn-github-actions/contexts</span></p>\n</li>\n<li><p>使用这个特殊信息，在对应的docker-compose-online.yml中进行替换，将要启动的版本替换为将要构建的版本。</p>\n</li>\n</ul>\n","categories":["复杂业务部署与优化"],"tags":["复杂业务部署与优化"]},{"title":"微前端","url":"/2024/05/24/%E5%BE%AE%E5%89%8D%E7%AB%AF/","content":"<h1 id=\"微前端介绍\"><a href=\"#微前端介绍\" class=\"headerlink\" title=\"微前端介绍\"></a>微前端介绍</h1><p>微前端按业务功能将一整块前端应用分解成一系列更小的、更内聚的微前端应用，同时通过明确的交互协议来管理这些应用间的依赖关系，实现不同业务的解耦合。并将每个前端应用交给独立团队负责，各自独立开发、独立部署、充分利用并行性。</p>\n<ul>\n<li>微前端是一种架构风格，monorepo是一种开发策略，模块联邦是一种打包和部署方式<ul>\n<li>微前端将大型的前端应用分解成一组小的、独立的前端服务，每一个小的前端服务可以由不同的团队独立开发、部署和维护。微前端的目标是提高大型前端项目的可维护性、可扩展性和灵活性</li>\n<li>monorepo是一种开发策略（技巧），它将多个项目或服务的代码放在一个单一的版本控制系统仓库中，有助于简化依赖管理、代码共享和团队协作。对于工具库能更好的暴露单独模块。</li>\n<li>模块联邦是Webpack5引入的一个特性，允许将多个Webpack项目远程接入、联合起来，形成一个单一的应用，每个模块可以独立开发和部署，同时共享彼此的代码，模块联邦是一种新的打包和部署前端应用的方式。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"微前端应用\"><a href=\"#微前端应用\" class=\"headerlink\" title=\"微前端应用\"></a>微前端应用</h1><h2 id=\"EMP\"><a href=\"#EMP\" class=\"headerlink\" title=\"EMP\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbXAyLm5ldGxpZnkuYXBwLw==\">EMP</span></h2><p>模块联邦技术，微前端构建方案，是基于 webpack 5 module federation 的微前端方案。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>webpack 联邦编译可以保证所有子应用依赖解耦；</li>\n<li>应用间去中心化的调用、共享模块；</li>\n<li>模块远程 ts 支持；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>对 webpack 强依赖，老旧项目不友好；</li>\n<li>没有有效的 css 沙箱和 js 沙箱，需要靠用户自觉；</li>\n<li>子应用保活、多应用激活无法实现；</li>\n<li>主、子应用的路由可能发生冲突；</li>\n</ol>\n<p>底层原理 这个东西有点类似于拆包，也可以叫模块共享，例如React有个模块可以共享给Vue项目用Vue2的组件可以共享给Vue3用。</p>\n<h2 id=\"single-spa\"><a href=\"#single-spa\" class=\"headerlink\" title=\"single-spa\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnNpbmdsZS1zcGEuanMub3JnL2RvY3MvZ2V0dGluZy1zdGFydGVkLW92ZXJ2aWV3\">single-spa</span></h2><p>single-spa是微前端的基础框架，乾坤框架就是基于single-spa来实现的，在single-spa的基础上做了一层封装，也解决了single-spa的一些缺陷。</p>\n<h2 id=\"乾坤\"><a href=\"#乾坤\" class=\"headerlink\" title=\"乾坤\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vcWlhbmt1bi51bWlqcy5vcmcvemgv\">乾坤</span></h2><p><strong>特点</strong></p>\n<ol>\n<li>html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；</li>\n<li>完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了 strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案；</li>\n<li>做了静态资源预加载能力；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；</li>\n<li>css 沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；</li>\n<li>无法同时激活多个子应用，也不支持子应用保活；</li>\n<li>无法支持 vite 等 esmodule 脚本运行；</li>\n</ol>\n<h2 id=\"无界\"><a href=\"#无界\" class=\"headerlink\" title=\"无界\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vd3VqaWUtbWljcm8uZ2l0aHViLmlvL2RvYy9hcGkvYnVzLmh0bWw=\">无界</span></h2><p><strong>特点</strong></p>\n<ol>\n<li>接入简单只需要四五行代码</li>\n<li>不需要针对vite额外处理</li>\n<li>预加载</li>\n<li>应用保活机制</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>隔离js使用一个空的iframe进行隔离</li>\n<li>子应用axios需要自行适配</li>\n<li>iframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从’about:blank’初始化为主应用的host，这个采用的计时器去等待的不是很悠亚。</li>\n</ol>\n<p>底层原理 使用shadowDom 隔离css，js使用空的iframe隔离，通讯使用的是proxy</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>无界的原理就是使用开启影子dom来进行样式的隔离，通过使用attachShadow方法开启影子dom（继承HTMLElement），获得的shadow影子dom添加template（无界的初始模板）为子元素，这样就进行了样式隔离，最后通过window.customElement.define注册dom元素wu-jie，使用标签即可。</p>\n<p>index.js：</p>\n<pre><code class=\"js\">window.onload = () =&gt; &#123;\n    class WuJie extends HTMLElement &#123;\n        constructor() &#123;\n            super()\n            this.init()\n            this.getAttr(&#39;url&#39;)\n        &#125;\n        init() &#123;\n          const shadow =  this.attachShadow(&#123; mode: &quot;open&quot; &#125;) //开启影子dom 也就是样式隔离\n          const template = document.querySelector(&#39;#wu-jie&#39;) as HTMLTemplateElement\n          console.log(template);\n          shadow.appendChild(template.content.cloneNode(true))\n        &#125;\n        getAttr (str:string) &#123;\n           console.log(&#39;获取参数&#39;,this.getAttribute(str));\n        &#125;\n        //生命周期自动触发有东西插入\n        connectedCallback () &#123;\n           console.log(&#39;类似于vue 的mounted&#39;);\n        &#125;\n        //生命周期卸载\n        disconnectedCallback () &#123;\n              console.log(&#39;类似于vue 的destory&#39;);\n        &#125;\n        //跟watch类似\n        attributeChangedCallback (name:any, oldVal:any, newVal:any) &#123;\n            console.log(&#39;跟vue 的watch 类似 有属性发生变化自动触发&#39;);\n        &#125;\n    &#125;\n    window.customElements.define(&#39;wu-jie&#39;, WuJie)\n&#125;\n</code></pre>\n<p>index.html：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!--外层写一个div测试隔离--&gt;\n    &lt;div&gt;我是div&lt;/div&gt;\n    &lt;wu-jie url=&quot;xxxxxx&quot;&gt;&lt;/wu-jie&gt;\n    &lt;template id=&quot;wu-jie&quot;&gt;\n       &lt;!--div的样式是作用于全局的--&gt;\n        &lt;style&gt;\n            div &#123;\n                background: red;\n            &#125;\n        &lt;/style&gt;\n         &lt;div&gt;\n            样式隔离的\n         &lt;/div&gt;\n    &lt;/template&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><p>使用：</p>\n<p>需要从wujie的实例导出<code>preloadApp</code>,参数跟<code>startApp</code> 一致，预加载必须开启exec选项</p>\n<pre><code class=\"js\">preloadApp(&#123; name: &quot;vue3&quot;, url: &quot;http://127.0.0.1:5174/&quot;, exec: true &#125;)\npreloadApp(&#123; name: &quot;react&quot;, url: &quot;http://127.0.0.1:5175/&quot;, exec: true &#125;)\n</code></pre>\n<ul>\n<li>exec代表是否进行预加载，默认值是true</li>\n<li>js的执行模式，由于子应用的执行会阻塞主应用的渲染线程，当设置为true时js采取类似于react fiber的模式方式间断执行，每个js文件的执行都包裹在<code>requestidlecallback</code>中，每执行一个js文件后就可以返回去响应外部的输入，不会造成浏览器渲染和加载之间的冲突从而造成卡顿，但是这个颗粒度是js文件，所以应该保证js文件不应过大。</li>\n</ul>\n<p>浏览器一帧之内要做的事情：</p>\n<ul>\n<li>处理用于输入（事件）</li>\n<li>执行定时任务</li>\n<li>执行requestAnimationFrame</li>\n<li>执行dom的回流和重绘</li>\n<li>计算更新涂层的更新指令</li>\n<li>绘制指令合并主线程，如果有空余时间执行requestidlecallbask</li>\n</ul>\n<p>react也有该机制 但是react并没有用 <code>requestidlecallback</code>，说是这个东西经过测试可能会超过16ms，超过16ms绘制就会看起来很卡 所以react16是用的 <code>requestAnimationFrame + postMessage</code> 实现的那为什么不用<code>setTimeOut</code> setTimeOut 及时为0 也会有一个最小毫秒延迟4ms，所以是用了postMessage，react18又换成了<code>MessageChannel</code> 实现了队列方式去执行任务。</p>\n<h2 id=\"micro-app\"><a href=\"#micro-app\" class=\"headerlink\" title=\"micro-app\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vemVyb2luZy5qZC5jb20vbWljcm8tYXBwL2RvY3MuaHRtbCUyMy8=\">micro-app</span></h2><p>micro-app 是基于 webcomponent + qiankun sandbox 的微前端方案。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>使用 webcomponet 加载子应用相比 single-spa 这种注册监听方案更加优雅；</li>\n<li>复用经过大量项目验证过 qiankun 的沙箱机制也使得框架更加可靠；</li>\n<li>组件式的 api 更加符合使用习惯，支持子应用保活；</li>\n<li>降低子应用改造的成本，提供静态资源预加载能力；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>css 沙箱依然无法绝对的隔离，js 沙箱做全局变量查找缓存，性能有所优化；</li>\n<li>支持 vite 运行，但必须使用 plugin 改造子应用，且 js 代码没办法做沙箱隔离；</li>\n<li>对于不支持 webcompnent 的浏览器没有做降级处理；</li>\n</ol>\n<p>底层原理 js隔离跟qiankun类似也是使用proxy + with，css隔离自定义前缀类似于scoped</p>\n<h1 id=\"模块联邦\"><a href=\"#模块联邦\" class=\"headerlink\" title=\"模块联邦\"></a>模块联邦</h1><p>模块联邦是跟<code>webpack5</code>强耦合的，是基于webpack5内置插件的 无须安装</p>\n<p>它相当于是一个去中心化技术，它可以让多个独立构建的应用之间，动态的调用彼此的模块。这种运行机制，可以让我们轻松的拆分应用，真正做到跨应用的模块共享。</p>\n<p>配置过程就是在webpack.config.js中配置ModuleFederationPlugin插件，打完包之后观察会发现其实就是import函数动态加载，使用模块联邦的好处就在于之前当多个项目共有的模块改变时，每一个项目都需要重新install一下，而使用模块联邦之后，就相当于动态导入，免去了重新install的过程（由项目的克隆转为类似软链接的过程）。</p>\n","categories":["微前端"],"tags":["微前端"]},{"title":"性能指标","url":"/2024/05/11/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","content":"<h1 id=\"常见浏览器性能指标\"><a href=\"#常见浏览器性能指标\" class=\"headerlink\" title=\"常见浏览器性能指标\"></a>常见浏览器性能指标</h1><h1 id=\"TTFB-Time-To-First-Byte\"><a href=\"#TTFB-Time-To-First-Byte\" class=\"headerlink\" title=\"TTFB(Time To First Byte)\"></a>TTFB(Time To First Byte)</h1><p>发出页面请求到接收到应答数据第一个字节的时间总和，包含了：</p>\n<ol>\n<li>DNS解析时间</li>\n<li>TCP链接时间</li>\n<li>发送HTTP请求时间</li>\n<li>获得响应消息第一个字节的时间。</li>\n</ol>\n<h1 id=\"FP（First-Paint）\"><a href=\"#FP（First-Paint）\" class=\"headerlink\" title=\"FP（First Paint）\"></a><strong>FP</strong>（First Paint）</h1><p>首次绘制时间，这个指标用于记录页面第一次绘制像素的时间。</p>\n<h1 id=\"FCP（First-Contentful-Paint）\"><a href=\"#FCP（First-Contentful-Paint）\" class=\"headerlink\" title=\"FCP（First Contentful Paint）\"></a><strong>FCP</strong>（First Contentful Paint）</h1><p>首次内容绘制时间，这个指标用于记录页面首次绘制文本、图片、非空白 Canvas 或 SVG 的时间。</p>\n<h1 id=\"LCP（Largest-Contentful-Paint）\"><a href=\"#LCP（Largest-Contentful-Paint）\" class=\"headerlink\" title=\"LCP（Largest Contentful Paint）\"></a><strong>LCP</strong>（Largest Contentful Paint）</h1><p>最大内容绘制时间，用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录。</p>\n<h1 id=\"CLS（Cumulative-Layout-Shift）\"><a href=\"#CLS（Cumulative-Layout-Shift）\" class=\"headerlink\" title=\"CLS（Cumulative Layout Shift）\"></a><strong>CLS</strong>（Cumulative Layout Shift）</h1><p>累计位移偏移，记录了页面上非预期的位移波动。计算方式为：位移影响的面积 * 位移距离。</p>\n<h1 id=\"TTI（Time-to-Interactive）\"><a href=\"#TTI（Time-to-Interactive）\" class=\"headerlink\" title=\"TTI（Time to Interactive）\"></a><strong>TTI</strong>（Time to Interactive）</h1><p>首次可交互时间。这个指标计算过程略微复杂，它需要满足以下几个条件：</p>\n<ol>\n<li>从 FCP 指标后开始计算；</li>\n<li>持续 5 秒内无长任务（执行时间超过 50 ms）且无两个以上正在进行中的 GET 请求；</li>\n<li>往前回溯至 5 秒前的最后一个长任务结束的时间。</li>\n</ol>\n<h1 id=\"FID（First-Input-Delay）\"><a href=\"#FID（First-Input-Delay）\" class=\"headerlink\" title=\"FID（First Input Delay）\"></a><strong>FID</strong>（First Input Delay）</h1><p>首次输入延迟时间，记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟。</p>\n<h1 id=\"TBT（Total-Blocking-Time）\"><a href=\"#TBT（Total-Blocking-Time）\" class=\"headerlink\" title=\"TBT（Total Blocking Time）\"></a><strong>TBT</strong>（Total Blocking Time）</h1><p>阻塞总时间，记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。</p>\n","categories":["性能优化"],"tags":["性能指标"]},{"title":"数据库","url":"/2023/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"一、什么是数据库\"><a href=\"#一、什么是数据库\" class=\"headerlink\" title=\"一、什么是数据库\"></a>一、什么是数据库</h2><h6 id=\"数据库是用来组织存储和管理数据的仓库\"><a href=\"#数据库是用来组织存储和管理数据的仓库\" class=\"headerlink\" title=\"数据库是用来组织存储和管理数据的仓库\"></a>数据库是用来组织存储和管理数据的仓库</h6><h2 id=\"二、常见的数据库\"><a href=\"#二、常见的数据库\" class=\"headerlink\" title=\"二、常见的数据库\"></a>二、常见的数据库</h2><h4 id=\"1、（传统型、关系型、SQL数据库）\"><a href=\"#1、（传统型、关系型、SQL数据库）\" class=\"headerlink\" title=\"1、（传统型、关系型、SQL数据库）\"></a>1、（传统型、关系型、SQL数据库）</h4><p>①MySQL数据库（目前使用最广泛，流行度最高的开源免费数据库）</p>\n<p>②Oracle数据库（收费）</p>\n<p>③SQL  Server数据库（收费）</p>\n<h4 id=\"2、（新型、非关系型、NoSQL数据库）\"><a href=\"#2、（新型、非关系型、NoSQL数据库）\" class=\"headerlink\" title=\"2、（新型、非关系型、NoSQL数据库）\"></a>2、（新型、非关系型、NoSQL数据库）</h4><p>④Mongodb 数据库 （一定程度上弥补了传统型数据库的缺陷）</p>\n<h2 id=\"三、MySQL数据库和MongoDB数据库的区别\"><a href=\"#三、MySQL数据库和MongoDB数据库的区别\" class=\"headerlink\" title=\"三、MySQL数据库和MongoDB数据库的区别\"></a>三、MySQL数据库和MongoDB数据库的区别</h2><p>1、MySQL是关系型数据库，而mongodb是非关系型数据库；<br>2、MySQL中支持多种引擎，不同引擎有不同的存储方式，而mongodb以类JSON的文档的格式存储；<br>3、MySQL使用传统SQL语句进行查询，而mongodb有自己的<code>查询方式</code>（<code>类似JavaScript的函数</code>）；<br>4、<code>MySQL占用空间小</code>，支持join，而mongodb占用空间大，不支持join。</p>\n<p><strong>对比：</strong></p>\n<table>\n<thead>\n<tr>\n<th>数据库</th>\n<th>MongoDB</th>\n<th>MySQL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库模型</td>\n<td>非关系型</td>\n<td>关系型</td>\n</tr>\n<tr>\n<td>存储方式</td>\n<td>以类JSON的文档的格式存储</td>\n<td>不同引擎有不同的存储方式</td>\n</tr>\n<tr>\n<td>查询语句</td>\n<td>MongoDB查询方式（类似JavaScript的函数）</td>\n<td>SQL语句</td>\n</tr>\n<tr>\n<td>数据处理方式</td>\n<td>基于内存，将热数据存放在物理内存中，从而达到高速读写</td>\n<td>不同引擎有自己的特点</td>\n</tr>\n<tr>\n<td>成熟度</td>\n<td>新兴数据库，成熟度较低</td>\n<td>成熟度高</td>\n</tr>\n<tr>\n<td>广泛度</td>\n<td>NoSQL数据库中，比较完善且开源，使用人数在不断增长</td>\n<td>开源数据库，市场份额不断增长</td>\n</tr>\n<tr>\n<td>事务性</td>\n<td>仅支持单文档事务操作，弱一致性</td>\n<td>支持事务操作</td>\n</tr>\n<tr>\n<td>占用空间</td>\n<td>占用空间大</td>\n<td>占用空间小</td>\n</tr>\n<tr>\n<td>join操作</td>\n<td>MongoDB没有join</td>\n<td>MySQL支持join</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、MySQL数据库\"><a href=\"#四、MySQL数据库\" class=\"headerlink\" title=\"四、MySQL数据库\"></a>四、MySQL数据库</h2><h3 id=\"1、介绍\"><a href=\"#1、介绍\" class=\"headerlink\" title=\"1、介绍\"></a>1、介绍</h3><h4 id=\"（1）传统型数据库的数据组织结构\"><a href=\"#（1）传统型数据库的数据组织结构\" class=\"headerlink\" title=\"（1）传统型数据库的数据组织结构\"></a>（1）传统型数据库的数据组织结构</h4><p>数据库（database）、数据表(table)、数据行(row）、字段(field)</p>\n<h4 id=\"（2）实际开发中-库、表、行、字段的关系\"><a href=\"#（2）实际开发中-库、表、行、字段的关系\" class=\"headerlink\" title=\"（2）实际开发中 库、表、行、字段的关系\"></a>（2）实际开发中 库、表、行、字段的关系</h4><p>①一般每个项目都对应独立的数据库  ②不同数据要存储到不同的表中  ③存储信息由字段决定</p>\n<h4 id=\"（3）安装MySQL-Server-和MySQLWorkbench软件\"><a href=\"#（3）安装MySQL-Server-和MySQLWorkbench软件\" class=\"headerlink\" title=\"（3）安装MySQL Server 和MySQLWorkbench软件\"></a>（3）安装MySQL Server 和MySQLWorkbench软件</h4><p>①MySQL Server:提供数据存储和服务的软件     ②MySQLWorkbench可视化管理MySQL</p>\n<h3 id=\"2、用MySQLWorkbench管理数据库\"><a href=\"#2、用MySQLWorkbench管理数据库\" class=\"headerlink\" title=\"2、用MySQLWorkbench管理数据库\"></a>2、用MySQLWorkbench管理数据库</h3><h3 id=\"（1）创建数据库、创建数据表、设置字段（MySQLWorkbench中）\"><a href=\"#（1）创建数据库、创建数据表、设置字段（MySQLWorkbench中）\" class=\"headerlink\" title=\"（1）创建数据库、创建数据表、设置字段（MySQLWorkbench中）\"></a>（1）创建数据库、创建数据表、设置字段（MySQLWorkbench中）</h3><h5 id=\"设置字段的唯一标识：\"><a href=\"#设置字段的唯一标识：\" class=\"headerlink\" title=\"设置字段的唯一标识：\"></a>设置字段的唯一标识：</h5><p>①PK      (Primary Key主键、唯一标识)   </p>\n<p>②NN      (Not Null值不为空)   </p>\n<p>③UQ      (Unique值唯一)   </p>\n<p>④AI        (Auto Increment值自动增长)</p>\n<p>⑤设置默认值</p>\n<h3 id=\"（2）向数据库中写入数据\"><a href=\"#（2）向数据库中写入数据\" class=\"headerlink\" title=\"（2）向数据库中写入数据\"></a>（2）向数据库中写入数据</h3><p>①右键table –&gt; Select Rows - Limit 1000 (设置AI和默认值的字段不必完全填写)</p>\n<h3 id=\"3、用SQL管理数据库\"><a href=\"#3、用SQL管理数据库\" class=\"headerlink\" title=\"3、用SQL管理数据库\"></a>3、用SQL管理数据库</h3><h4 id=\"（1）介绍SQL\"><a href=\"#（1）介绍SQL\" class=\"headerlink\" title=\"（1）介绍SQL\"></a>（1）介绍SQL</h4><p>①SQL是结构化查询语言，专门用来访问和处理数据库的编程语言，能够让我们以编程的形式，操作数据库里面的数据</p>\n<p>②SQL是一门数据库编程语言，用SQL语言编写出的代码叫做SQL语句，SQL只能在关系型数据库中使用，非关系型（mongodb）不支持</p>\n<p>③SQL能查询数据，插入数据，跟新数据，删除数据，创建数据库，在数据库中创建表，数据库中创建存储过程、视图等</p>\n<h4 id=\"（2）SQL语法（关键字大小写相同，-lt-gt-和-x3D-都表示不等于）\"><a href=\"#（2）SQL语法（关键字大小写相同，-lt-gt-和-x3D-都表示不等于）\" class=\"headerlink\" title=\"（2）SQL语法（关键字大小写相同，&lt;&gt; 和 !&#x3D;  都表示不等于）\"></a>（2）SQL语法（关键字大小写相同，&lt;&gt; 和 !&#x3D;  都表示不等于）</h4><p>①查询数据</p>\n<p><code>select   *  from  表名称                              //指定表中，查询所有数据</code></p>\n<p><code>select   列名称1 , 名称2   from   表名称               //指定表中，查询指定列（字段） 的数据</code></p>\n<p>②数据表中插入新的数据行</p>\n<p><code>insert  into  表名 （列1  ,  列2.....） values  (值1  ,  值2 ,.......)      //指定表中，插入指定的数据</code></p>\n<p>③修改（更新）表中的数据</p>\n<p><code>update 表名称 set 列名称  =  新值 where 列名称 = 指定值   //指定表中，更新某一列的指定值为新值（不加where更新全部）</code></p>\n<p><code>update  表名称  set  列名称  = 新值  ,  列名称2 = 新值   where   列名称 = 指定     //指定表中，更新指定一行中多列</code></p>\n<p>④删除表中数据</p>\n<p><code>delete  from  表名  where  列名称  =  指定值     //删除指定行数据</code></p>\n<p>⑤运算符</p>\n<p>!&#x3D;  和 &lt;&gt;表示不等于  、 and  相当于&amp;&amp; 、 or  相当于 ||</p>\n<p>⑥order  by 子句（对结果集进行排序）</p>\n<p>默认升序(  asc  )对记录进行排序，降序需要使用 desc  关键字 </p>\n<p><code>例如： select * from  表名称  order  by  status  desc       //降序</code></p>\n<p><code>select * from  表名称  order  by  status  desc , id  asc     //多重排序（status降序，id升序）</code></p>\n<p>⑦count(*)      (统计查询结果的总数据条数)</p>\n<p><code>例如： select  count(*)  from  表名称  where  status  =  0     //统计表中status为0的数据条数</code></p>\n<p>⑧使用AS为列设置别名</p>\n<p><code>例如： select count(*) AS  total  from  users  where  status  =  0    //设置统计表中数据条数的列名为total</code></p>\n<h3 id=\"4、在项目中操作MySQL\"><a href=\"#4、在项目中操作MySQL\" class=\"headerlink\" title=\"4、在项目中操作MySQL\"></a>4、在项目中操作MySQL</h3><p>（1）、安装MySQL数据库的第三方模块(mysql)</p>\n<p><code>npm  install  mysql</code></p>\n<p>（2）、通过mysql模块配置并连接到MySQL数据库</p>\n<p><code>const  mysql  = require(&#39;mysql&#39;) ;         //导入mysql模块</code></p>\n<p><code>const   db  =  mysql.createPool(&#123;          //建立与MySQL数据库的连接</code></p>\n<p><code>host:&#39;127.0.0.1&#39;  , user:&#39;root&#39;  , password:&#39;dmq0216&#39;  , database:&#39;mydb01&#39;</code></p>\n<p>​                                                                                                                                      <code>//连接数据库ip，登录账号和密码、连接待操作的数据库</code></p>\n<p><code>&#125;)</code></p>\n<p>（3）、通过mysql模块执行SQL语句</p>\n<h6 id=\"①测试mysql模块能否正常工作\"><a href=\"#①测试mysql模块能否正常工作\" class=\"headerlink\" title=\"①测试mysql模块能否正常工作\"></a>①测试mysql模块能否正常工作</h6><p><code>db.query(&#39;select  1&#39; ,(err,result)=&gt;&#123;         </code></p>\n<p><code>if(err)  return  console.log(err.message)</code></p>\n<p><code>console.log(result)</code></p>\n<p><code>&#125;)</code></p>\n<h6 id=\"②查询users表中所有的数据-（执行select语句查询到的是数组）\"><a href=\"#②查询users表中所有的数据-（执行select语句查询到的是数组）\" class=\"headerlink\" title=\"②查询users表中所有的数据  （执行select语句查询到的是数组）\"></a>②查询users表中所有的数据  （执行select语句查询到的是数组）</h6><p><code>db.query(&#39;select * from users&#39; ,(err,result)=&gt;&#123;         </code></p>\n<p><code>if(err)  return  console.log(err.message)</code></p>\n<p><code>console.log(result)</code></p>\n<p><code>&#125;)</code></p>\n<h6 id=\"③插入数据-用（？，？）符进行占位\"><a href=\"#③插入数据-用（？，？）符进行占位\" class=\"headerlink\" title=\"③插入数据    (  用（？，？）符进行占位  )\"></a>③插入数据    (  用（？，？）符进行占位  )</h6><p><code>const  user  =  &#123; username:&#39;Spider-Man&#39; , password:&#39;dmq0216&#39; &#125;</code></p>\n<p><code>const  sqlStr &#39;insert  into  users  ( username , password ) values ( ? , ? )&#39;</code></p>\n<p><code>db.query(sqlStr , [user.username , user.password ] , (err , result) =&gt; &#123;</code></p>\n<p><code>if(err) return console.log(err.message)</code></p>\n<p><code>if( result.affectedRows === 1 )&#123;  console.log(&#39;插入数据成功&#39;  )  &#125;</code></p>\n<p><code>&#125;)</code></p>\n<p>或  便捷方式：</p>\n<p><code>const  user  =  &#123; username:&#39;Spider-Man&#39; , password:&#39;dmq0216&#39; &#125;</code></p>\n<p><code>const  sqlStr &#39;insert  into  users  set ?&#39;</code></p>\n<p><code>db.query(sqlStr , user , (err , result) =&gt; &#123;</code></p>\n<p><code>if(err) return console.log(err.message)</code></p>\n<p><code>if( result.affectedRows === 1 )&#123;  console.log(&#39;插入数据成功&#39;  )  &#125;</code></p>\n<p><code>&#125;)</code></p>\n<h6 id=\"④更新数据-（使用？占位符）\"><a href=\"#④更新数据-（使用？占位符）\" class=\"headerlink\" title=\"④更新数据     （使用？占位符）\"></a>④更新数据     （使用？占位符）</h6><p><code>const  user  =  &#123;id=6, username:&#39;Spider-Man&#39; , password:&#39;dmq0216&#39; &#125;</code></p>\n<p><code>const  sqlStr &#39;update users set username=? , password=? where id=?&#39;</code></p>\n<p><code>db.query(sqlStr , user.username , user.password , user.id, (err , result) =&gt; &#123;</code></p>\n<p><code>if(err) return console.log(err.message)</code></p>\n<p><code>if( result.affectedRows === 1 )&#123;  console.log(&#39;更新数据成功&#39;  )  &#125;</code></p>\n<p><code>&#125;)</code></p>\n<p>或   便捷方式：</p>\n<p><code>const  user  =  &#123;id=6 , username:&#39;Spider-Man&#39; , password:&#39;dmq0216&#39; &#125;</code></p>\n<p><code>const  sqlStr &#39;update users set ? where id=?&#39;</code></p>\n<p><code>db.query(sqlStr , [ user , user.id ], (err , result) =&gt; &#123;</code></p>\n<p><code>if(err) return console.log(err.message)</code></p>\n<p><code>if( result.affectedRows === 1 )&#123;  console.log(&#39;更新数据成功&#39;  )  &#125;</code></p>\n<p><code>&#125;)</code></p>\n<h6 id=\"⑤删除数据-（-推荐使用id-）\"><a href=\"#⑤删除数据-（-推荐使用id-）\" class=\"headerlink\" title=\"⑤删除数据  （ 推荐使用id ）\"></a>⑤删除数据  （ 推荐使用id ）</h6><p><code>const  sqlStr &#39; delete from users where id=? &#39;</code></p>\n<p><code>db.query(sqlStr , 6 , (err , result) =&gt; &#123;</code></p>\n<p><code>if(err) return console.log(err.message)</code></p>\n<p><code>if( result.affectedRows === 1 )&#123;  console.log(&#39;删除数据成功&#39;  )  &#125;</code></p>\n<p><code>&#125;)</code></p>\n<p>标记删除   （为了考虑安全性：在表中设置类似于status的状态字段，标记当前数据是否被删除，实际上是update语句）</p>\n<p><code>db.query(&#39;update users set status=1 where id=?&#39;, 6 , (err , result) =&gt; &#123;</code></p>\n<p><code>if(err) return console.log(err.message)</code></p>\n<p><code>if( result.affectedRows === 1 )&#123;  console.log(&#39;删除数据成功&#39;  )  &#125;</code></p>\n<p><code>&#125;)</code></p>\n<h2 id=\"四、Mongodb数据库\"><a href=\"#四、Mongodb数据库\" class=\"headerlink\" title=\"四、Mongodb数据库\"></a>四、Mongodb数据库</h2><h3 id=\"1、使用Mongodb数据库\"><a href=\"#1、使用Mongodb数据库\" class=\"headerlink\" title=\"1、使用Mongodb数据库\"></a>1、使用Mongodb数据库</h3><h5 id=\"【1】-MongDB学习原因以及优势：\"><a href=\"#【1】-MongDB学习原因以及优势：\" class=\"headerlink\" title=\"【1】    MongDB学习原因以及优势：\"></a>【1】    MongDB学习原因以及优势：</h5><p>（1）MongoDB是一个基于分布式文件存储的数据库，官方地址为<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5tb25nb2RiLmNvbS8=\">http://www.mongodb.com/</span></p>\n<p>（2）数据库是按照数据结构来组织、存储和管理数据的应用程序</p>\n<p>数据库的主要作用就是管理数据，对数据进行增、删、改、查</p>\n<p>（3）相比于纯文件管理数据，数据库管理数据的特点：①速度更快②扩展性更强③安全性更高·</p>\n<p>（4法与javascript相似，容易上手</p>\n<h5 id=\"【2】-MongoDB中三个重要概念\"><a href=\"#【2】-MongoDB中三个重要概念\" class=\"headerlink\" title=\"【2】    MongoDB中三个重要概念\"></a>【2】    MongoDB中三个重要概念</h5><p>（1）   数据库（database）</p>\n<p>（2）   集合（collection）</p>\n<p>（3）   文档（document）</p>\n<h5 id=\"【3】-MongoDB安装，与创建默认文件（-c：-x2F-data-x2F-db-）\"><a href=\"#【3】-MongoDB安装，与创建默认文件（-c：-x2F-data-x2F-db-）\" class=\"headerlink\" title=\"【3】    MongoDB安装，与创建默认文件（ c：&#x2F;data&#x2F;db ）\"></a>【3】    MongoDB安装，与创建默认文件（ c：&#x2F;data&#x2F;db ）</h5><h5 id=\"【4】-文件中打开cmd，输入命令mongod，启动数据库服务（端口号为27017）\"><a href=\"#【4】-文件中打开cmd，输入命令mongod，启动数据库服务（端口号为27017）\" class=\"headerlink\" title=\"【4】    文件中打开cmd，输入命令mongod，启动数据库服务（端口号为27017）\"></a>【4】    文件中打开cmd，输入命令mongod，启动数据库服务（端口号为27017）</h5><h5 id=\"【5】-文件中新开cmd，输入命令mongo-请求数据库服务，输入命令show-dbs显示数据库信息\"><a href=\"#【5】-文件中新开cmd，输入命令mongo-请求数据库服务，输入命令show-dbs显示数据库信息\" class=\"headerlink\" title=\"【5】    文件中新开cmd，输入命令mongo , 请求数据库服务，输入命令show dbs显示数据库信息\"></a>【5】    文件中新开cmd，输入命令mongo , 请求数据库服务，输入命令show dbs显示数据库信息</h5><h5 id=\"【6】-配置文件环境变量，以方便全局使用\"><a href=\"#【6】-配置文件环境变量，以方便全局使用\" class=\"headerlink\" title=\"【6】    配置文件环境变量，以方便全局使用\"></a>【6】    配置文件环境变量，以方便全局使用</h5><p>全局命令：mongo使用数据库、mongoose启动数据库服务</p>\n<h5 id=\"【7】-数据库与集合命令\"><a href=\"#【7】-数据库与集合命令\" class=\"headerlink\" title=\"【7】    数据库与集合命令\"></a>【7】    数据库与集合命令</h5><p>（1）   数据库命令：</p>\n<p>show dbs              查看当前数据库下有哪些服务</p>\n<p>use 库名             切换到指定的数据库下，没有则创建</p>\n<p>db                 显示当前所在的数据库</p>\n<p>use 库名 </p>\n<p>switched to db 库名          转到那个数据库</p>\n<p>db.dropDatabase()           删除当前数据库</p>\n<p>（2）   集合命令</p>\n<p>db.createCollection()           创建集合</p>\n<p>show collections             显示当前数据库中的所在</p>\n<p>db.集合名.drop()             删除某个集合</p>\n<p>db.集合名.renameCollection(‘newName’)   重命名集合</p>\n<p>（3）   文档命令</p>\n<p>db.集合名.insert({文档对象})              插入文档</p>\n<p>db.集合名.find({查询条件})               查询文档</p>\n<p>db.集合名.update({查询条件}，{新的文档内容})     更新新的文档（属性全部更新）</p>\n<p>db.集合名.update({name:’张三’},{$set:{age:19}})     更新文档（部分更新）</p>\n<p>db.集合名.remove({查询条件})</p>\n<h5 id=\"【8】-数据库操作的应用场景\"><a href=\"#【8】-数据库操作的应用场景\" class=\"headerlink\" title=\"【8】    数据库操作的应用场景\"></a>【8】    数据库操作的应用场景</h5><p>（1）   新增：用户注册、发布视频、发布商品、发布评论等</p>\n<p>（2）   删除：删除评论、删除商品、删除文章等</p>\n<p>（3）   更新：更新个人信息、修改商品价格等</p>\n<p>（4）   查询：商品列表、朋友圈列表等</p>\n<h3 id=\"2、Mongoose文档对象模型链接mongdb数据库\"><a href=\"#2、Mongoose文档对象模型链接mongdb数据库\" class=\"headerlink\" title=\"2、Mongoose文档对象模型链接mongdb数据库\"></a>2、Mongoose文档对象模型链接mongdb数据库</h3><h5 id=\"【1】-介绍：mongoose文档对象模型库，官网：http-www-mongoosejs-net\"><a href=\"#【1】-介绍：mongoose文档对象模型库，官网：http-www-mongoosejs-net\" class=\"headerlink\" title=\"【1】   介绍：mongoose文档对象模型库，官网：http://www.mongoosejs.net/\"></a>【1】   介绍：mongoose文档对象模型库，官网：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5tb25nb29zZWpzLm5ldC8=\">http://www.mongoosejs.net/</span></h5><h5 id=\"【2】便使用代码操作mongodb数据库-避免手动敲代码进行数据库操作\"><a href=\"#【2】便使用代码操作mongodb数据库-避免手动敲代码进行数据库操作\" class=\"headerlink\" title=\"【2】便使用代码操作mongodb数据库,避免手动敲代码进行数据库操作\"></a>【2】便使用代码操作mongodb数据库,避免手动敲代码进行数据库操作</h5><h5 id=\"【2】-使用mongoose连接数据库：\"><a href=\"#【2】-使用mongoose连接数据库：\" class=\"headerlink\" title=\"【2】   使用mongoose连接数据库：\"></a>【2】   使用mongoose连接数据库：</h5><p> (<strong>发送请求服务时必须确保数据库服务启动中</strong>)</p>\n<p>1 项目初始化  <code>npm init</code><br>2  <code>mongoose  npm i mongoose@6.8.0</code><br>3 导入 mongoose<br><code>const mongoose = require(&#39;mongoose&#39;);</code><br>设置取消部分提示<br><code>mongoose.set(&#39;strictQuery&#39;, true);</code><br>4 连接 mongodb数据库服务<br><code>mongoose.connect(&#39;mongodb://127.0.0.1:27017/bilibili&#39;);</code></p>\n<pre><code>    (协议名称://ip**地址**:**端口号**/**数据库名称**)\n</code></pre>\n<p>5 设置回调</p>\n<p> 设置连接成功的回调</p>\n<p><code>mongoose.connection.once(&#39;open&#39;, () =&gt;&#123;</code></p>\n<p>   6 创建文档的结构对象</p>\n<p>  设置集合中文档的属性以及属性值的类型</p>\n<pre><code class=\"js\">let BookSchema =new mongoose.Schema(&#123;\n​    name: String,\n​    author: String,\n​    price: Number,\n​    ishot: Boolean\n&#125;);\n</code></pre>\n<p> 7创建模型对象  对文档操作的封装对象 (mongoose.model(‘<strong>集合名称</strong>‘,<strong>结构对象</strong>))</p>\n<p>  let BookModel <strong>&#x3D;</strong> mongoose**.**model(‘books’, BookSchema);<br> 8 文档中新增内容</p>\n<pre><code class=\"js\">BookModel.create(&#123;\n​    name: &#39;西游记&#39;,\n​    author: &#39;吴承恩&#39;,\n​    price: 20,\n​    ishot: true\n  &#125;,((err, data) =&gt; &#123;\n​    if (err) &#123;\n​      console.log(err);\n​      return;\n​    &#125; console.log(data);\n\n  &#125;))\n  // 关闭数据库连接(项目运行时不使用)\n   mongoose.disconnect();\n//设置连接错误的回调\nmongoose.connection.on(&#39;error&#39;, () =&gt; &#123;\n  console.log(&#39;连接失败&#39;);\n&#125;);\n//设置连接关闭的回调\nmongoose.connection.on(&#39;close&#39;, () =&gt; &#123;\n  console.log(&#39;连接关闭&#39;);\n&#125;);\n// 手动关闭mongodb的连接\n setTimeout(() =&gt; &#123;\n   mongoose.disconnect();\n &#125;, 2000);\n</code></pre>\n<h5 id=\"【3】-mongoose字段类型（在new的mongoose-Schema和创建的mongoose-model-create中注册和写入）\"><a href=\"#【3】-mongoose字段类型（在new的mongoose-Schema和创建的mongoose-model-create中注册和写入）\" class=\"headerlink\" title=\"【3】   mongoose字段类型（在new的mongoose.Schema和创建的mongoose.model.create中注册和写入）\"></a>【3】   mongoose字段类型（在new的mongoose.Schema和创建的mongoose.model.create中注册和写入）</h5><p>（1）   String类型（字符串）</p>\n<p>（2）   Number类型（数字）</p>\n<p>（3）   Boolean类型（布尔值）</p>\n<p>（4）   Array类型（数组，也可以用[ ]来标识）</p>\n<p>（5）   Date类型（日期）</p>\n<p>（6）   Buffer类型（Buffer对象）</p>\n<p>（7）   Mixed类型（任意对象，需要使用mongoose.Schema.Types.Mixed指定）</p>\n<p>（8）   Objectld类型（对象ID，需要使用mongoose.Schema.Types.Objected指定）</p>\n<p>（9）   Decimal128类型（高精度数字，需要使用mongoose.Schema.Types.Decimal128指定）  </p>\n<h5 id=\"【4】-字段值验证（对文档属性的值进行校验，校验通过的值才会被存入数据库，在创建文档结构对象中操作）\"><a href=\"#【4】-字段值验证（对文档属性的值进行校验，校验通过的值才会被存入数据库，在创建文档结构对象中操作）\" class=\"headerlink\" title=\"【4】   字段值验证（对文档属性的值进行校验，校验通过的值才会被存入数据库，在创建文档结构对象中操作）\"></a>【4】   字段值验证（对文档属性的值进行校验，校验通过的值才会被存入数据库，在创建文档结构对象中操作）</h5><p>（1）   例如给数据库文档中的name属性添加字段</p>\n<p> name: {</p>\n<p>​      type: String,</p>\n<p>​      <em>&#x2F;&#x2F;</em> <em>必填项</em></p>\n<p>​      required: true,</p>\n<p>​      <em>&#x2F;&#x2F;</em> <em>默认值</em></p>\n<p>​      default: ‘西游记’,</p>\n<p>​      <em>&#x2F;&#x2F;</em> <em>枚举值</em> *,*<em>设置后只能设置在枚举项内的值</em></p>\n<p>​      enum: [‘言情’, ‘城市’, ‘志怪’, ‘恐怖’],</p>\n<p>​      <em>&#x2F;&#x2F;</em> <em>唯一值</em> <em>,<strong>设置为独一无二的值</strong>(<strong>在集合里面不能重复</strong>)</em></p>\n<p>​      unique: true </p>\n<p>​    },</p>\n<h5 id=\"【5】-mongoose删除文档数据\"><a href=\"#【5】-mongoose删除文档数据\" class=\"headerlink\" title=\"【5】   mongoose删除文档数据\"></a>【5】   mongoose删除文档数据</h5><p>(1)  删除单条文档数据</p>\n<p> <em>&#x2F;&#x2F; 9**删除单条文档</em></p>\n<p>  BookModel**.**deleteOne({ _id: ‘647ec30caecaf3c1f3724a84’ }, ((<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘删除失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  }))</p>\n<p>（2）   批量删除文档数据</p>\n<p>   <em>&#x2F;&#x2F; 10**批量删除</em></p>\n<p>  BookModel**.**deleteMany({ ishot: true }, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘删除失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  });</p>\n<h5 id=\"【6】-更新文档数据\"><a href=\"#【6】-更新文档数据\" class=\"headerlink\" title=\"【6】   更新文档数据\"></a>【6】   更新文档数据</h5><p>（1）  <em>&#x2F;&#x2F; 11**更新单条文档数据</em></p>\n<p>  BookModel**.**updateOne({ name: ‘西游记’ }, { price: 5 }, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘更新失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  })</p>\n<p>（3）   更新多条文档数据</p>\n<p>  <em>&#x2F;&#x2F; 12**更新多条文档数据</em></p>\n<p>  BookModel**.**updateMany({ name: ‘西游记’ }, { ishot: false }, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘更新失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  });</p>\n<h5 id=\"【7】-mongoose读取文档\"><a href=\"#【7】-mongoose读取文档\" class=\"headerlink\" title=\"【7】   mongoose读取文档\"></a>【7】   mongoose读取文档</h5><p>（1）   获取单条文档数据</p>\n<p>   <em>&#x2F;&#x2F; 13**读取文档</em></p>\n<p>  BookModel**.**findOne({ price: ‘5’ }, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  });</p>\n<p>（*）根据id获取单条数据</p>\n<p>  <em>&#x2F;&#x2F; 13**读取文档</em></p>\n<p>  BookModel**.**findOne({ ‘647f11344d39a14410f61725’}, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  });</p>\n<p>（2）   获得多条文档数据</p>\n<p>   <em>&#x2F;&#x2F; 14**读取多条文档数据</em></p>\n<p>  BookModel**.**find({ name: ‘西游记’ }, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  });</p>\n<p>（*）不加条件时获取全部文档数据</p>\n<h5 id=\"【8】-moogose条件控制\"><a href=\"#【8】-moogose条件控制\" class=\"headerlink\" title=\"【8】   moogose条件控制\"></a>【8】   moogose条件控制</h5><p>（1）   运算符：</p>\n<p>&gt;使用 $gt</p>\n<p>&lt;使用 $gt</p>\n<p>&gt;&#x3D;使用 $gte</p>\n<p>&lt;&#x3D;使用 $lte</p>\n<p>!&#x3D;&#x3D;使用 $ne</p>\n<p>  <em>&#x2F;&#x2F; 14**读取多条文档数据</em></p>\n<p>  BookModel**.**find({ name: ‘西游记’ }, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  });</p>\n<p>(2)  逻辑运算</p>\n<p> $or逻辑或的情况</p>\n<p>db.students.find({$or:[{age:18},{age:24}]}) ;</p>\n<p> $and逻辑与的情况</p>\n<p>db.students.find({$and:[{age:{$lt:20}},{age:{$gt:15}}]}) ;</p>\n<p>BookModel**.**find({$or:[{author:’曹雪芹’},{author:’余华’}]}, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    }</p>\n<p>​    console**.**log(data);</p>\n<p>  })</p>\n<p>});</p>\n<p>(3)  正则匹配（条件中可以使用js的正则语法，通过正则进行模糊查询）</p>\n<p>普通正则表达式：</p>\n<p>   BookModel**.**find({name:&#x2F;三&#x2F;}, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    }</p>\n<p>​    console**.**log(data);</p>\n<p>  })</p>\n<p> 使用变量的正则表达式</p>\n<p>  BookModel**.**find({name:<strong>new</strong> RegExp(‘三’)}, (<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    }</p>\n<p>​    console**.**log(data);</p>\n<p>  })</p>\n<h5 id=\"【9】-个性化读取\"><a href=\"#【9】-个性化读取\" class=\"headerlink\" title=\"【9】   个性化读取\"></a>【9】   个性化读取</h5><p>（1）   select做字段的筛选（0表示不要的字段，1表示要的字段）</p>\n<p>   BookModel**.<strong>find()</strong>.<strong>select({ name: 1, author:1 })</strong>.**exec((<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  })</p>\n<p>（2）   sort进行数据排序（1是升序，-1是倒序）</p>\n<p>  BookModel**.<strong>find()</strong>.<strong>sort({price:</strong>-<strong>1})</strong>.**exec((<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  })</p>\n<p>​    （3）limit进行数据截取，skip进行第几个数据开始取</p>\n<p> BookModel**.<strong>skip(3)</strong>.<strong>limit(3)</strong>.**exec((<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​    <strong>if</strong> (err) {</p>\n<p>​      console**.**log(‘读取失败’);</p>\n<p>​      <strong>return</strong>;</p>\n<p>​    } console**.**log(data);</p>\n<p>  })</p>\n<p>（*）注意多个属性之间可以复用</p>\n<p> BookModel**.**find()</p>\n<p>​    **.**select({ name: 1, price: 1 })</p>\n<p>​    **.**sort({ price: **-**1 })</p>\n<p>​    **.**skip(3)</p>\n<p>​    **.**limit(3)</p>\n<p>​    **.**exec((<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​      <strong>if</strong> (err) {</p>\n<p>​        console**.**log(‘读取失败’);</p>\n<p>​        <strong>return</strong>;</p>\n<p>​      } console**.**log(data);</p>\n<p>​    })</p>\n<h5 id=\"【10】-mongoose模块化\"><a href=\"#【10】-mongoose模块化\" class=\"headerlink\" title=\"【10】 mongoose模块化\"></a>【10】 mongoose模块化</h5><p>一、代码模块化</p>\n<p>（1）   db.js中创建模块</p>\n<p> module**.**exports <strong>&#x3D;</strong> function (<strong>success</strong>, <strong>error</strong>) {</p>\n<p>  <em>&#x2F;&#x2F;3</em> <em>导入</em> <em>mongoose</em></p>\n<p>  const mongoose <strong>&#x3D;</strong> require(‘mongoose’);</p>\n<p>  <em>&#x2F;&#x2F;</em> <em>设置取消部分提示</em></p>\n<p>  mongoose**.**set(‘strictQuery’, true);</p>\n<p>  <em>&#x2F;&#x2F;4</em> <em>连接</em> <em>mongodb**数据库服务</em></p>\n<p>  mongoose**.**connect(‘mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;bilibili’);</p>\n<p>  <em>&#x2F;&#x2F;        (<strong>协议名称</strong>:&#x2F;&#x2F;ip*<em>地址</em></em>:<strong>端口号</strong>&#x2F;<strong>数据库名称</strong>)*</p>\n<p>  <em>&#x2F;&#x2F;</em> <em>设置连接成功的回调</em></p>\n<p>  mongoose**.<em><strong>connection</strong></em>.**once(‘open’, () <strong>&#x3D;&gt;</strong> {</p>\n<p>​    success();</p>\n<p>  });</p>\n<p>  *&#x2F;&#x2F;*<em>设置连接错误的回调</em></p>\n<p>  mongoose**.<em><strong>connection</strong></em>.**on(‘error’, () <strong>&#x3D;&gt;</strong> {</p>\n<p>​    error();</p>\n<p>  });</p>\n<p>  <em>&#x2F;&#x2F;</em> <em>设置连接关闭的回调</em></p>\n<p>  mongoose**.<em><strong>connection</strong></em>.**on(‘close’, () <strong>&#x3D;&gt;</strong> {</p>\n<p>​    console**.**log(‘连接关闭’);</p>\n<p>  });</p>\n<p>}</p>\n<p>（2）   BookModel中创建模块</p>\n<p> const mongoose <strong>&#x3D;</strong> require(‘mongoose’);</p>\n<p><em>&#x2F;&#x2F; 6</em> <em>创建文档的结构对象</em></p>\n<p><em>&#x2F;&#x2F;</em> <em>设置集合中文档的属性以及属性值的类型</em></p>\n<p>let BookSchema <strong>&#x3D;</strong> <strong>new</strong> mongoose**.**Schema({</p>\n<p>  name: {</p>\n<p>​    type: String,</p>\n<p>​    <em>&#x2F;&#x2F;</em> <em>必填项</em></p>\n<p>​    required: true,</p>\n<p>​    <em>&#x2F;&#x2F;</em> <em>默认值</em></p>\n<p>​    default: ‘西游记’,</p>\n<p>​    <em>&#x2F;&#x2F;</em> <em>枚举值</em> *,*<em>设置后只能设置在枚举项内的值</em></p>\n<p>​    <em>&#x2F;&#x2F; enum: [‘<strong>言情</strong>‘, ‘<strong>城市</strong>‘, ‘<strong>志怪</strong>‘, ‘<strong>恐怖</strong>‘],</em></p>\n<p>​    <em>&#x2F;&#x2F;</em> <em>唯一值</em> <em>,<strong>设置为独一无二的值</strong>(<strong>在集合里面不能重复</strong>)</em></p>\n<p>​    <em>&#x2F;&#x2F; unique: true</em> </p>\n<p>  },</p>\n<p>  author: String,</p>\n<p>  price: Number,</p>\n<p>  ishot: Boolean,</p>\n<p>  tags: Array,</p>\n<p>  pubtime: Date</p>\n<p>});</p>\n<p><em>&#x2F;&#x2F; 7</em> <em>创建模型对象</em>  <em>对文档操作的封装对象</em> <em>(mongoose.model(‘<strong>集合名称</strong>‘,<strong>结构对象</strong>))</em></p>\n<p>let BookModel <strong>&#x3D;</strong> mongoose**.**model(‘books’, BookSchema);</p>\n<p><em>&#x2F;&#x2F;</em>  <em>暴露模型对象</em></p>\n<p>module**.**exports <strong>&#x3D;</strong> BookModel;</p>\n<p>（3）   index文件中引用模块</p>\n<p> <em>&#x2F;&#x2F;</em> <em>导入<strong>db</strong>文件</em></p>\n<p>const db <strong>&#x3D;</strong> require(‘.&#x2F;db&#x2F;db’);</p>\n<p><em>&#x2F;&#x2F;</em> <em>导入**monfoose</em></p>\n<p>const mongoose <strong>&#x3D;</strong> require(‘mongoose’);</p>\n<p><em>&#x2F;&#x2F;</em> <em>导入**BookModel</em></p>\n<p>const BookModel <strong>&#x3D;</strong> require(‘.&#x2F;models&#x2F;BookModel’);</p>\n<p><em>&#x2F;&#x2F;</em> <em>调用函数</em></p>\n<p>db(() <strong>&#x3D;&gt;</strong> {</p>\n<p>   <em>&#x2F;&#x2F; 8</em> <em>文档中新增内容</em></p>\n<p>   BookModel**.**create({</p>\n<p>​     name: ‘西游记’,</p>\n<p>​     author: ‘吴承恩’,</p>\n<p>​     price: 20,</p>\n<p>​     ishot: true</p>\n<p>   },((<strong>err</strong>, <strong>data</strong>) <strong>&#x3D;&gt;</strong> {</p>\n<p>​     <strong>if</strong> (err) {</p>\n<p>​       console**.**log(err);</p>\n<p>​       <strong>return</strong>;</p>\n<p>​     } console**.**log(data);</p>\n<p>   }))</p>\n<p>}, () <strong>&#x3D;&gt;</strong> {</p>\n<p>  console**.**log(‘连接失败’);</p>\n<p>});</p>\n<p>二、配置文件模块化</p>\n<p>（1）config.js中暴露模块</p>\n<p><em>&#x2F;&#x2F;</em> <em>配置文件</em></p>\n<p>module**.**exports <strong>&#x3D;</strong> {</p>\n<p>  DBHOST: ‘127.0.0.1’,</p>\n<p>  DBPORT: 27017,</p>\n<p>  DBNAME: ‘bilibili’</p>\n<p>}</p>\n<p>（2）db.js中使用模块</p>\n<p>   <em>&#x2F;&#x2F;</em> <em>导入配置文件</em></p>\n<p>  const {DBHOST,DBPORT,DBNAME}**&#x3D;**require(‘..&#x2F;config&#x2F;config.js’);</p>\n<p>  <em>&#x2F;&#x2F;4</em> <em>连接</em> <em>mongodb**数据库服务</em></p>\n<p>  mongoose**.**connect(<code>mongodb://$&#123;DBHOST&#125;:$&#123;DBPORT&#125;/$&#123;DBNAME&#125;</code>);</p>\n<h5 id=\"【11】-mongodb图形化工具（Robo3T和navicate）\"><a href=\"#【11】-mongodb图形化工具（Robo3T和navicate）\" class=\"headerlink\" title=\"【11】 mongodb图形化工具（Robo3T和navicate）\"></a>【11】 mongodb图形化工具（Robo3T和navicate）</h5><p>(1)  作用：代替mongo命令进行操作数据库，便于操作</p>\n<p>(2)  mongod数据库服务启动再去进行操作</p>\n<p>(3)   </p>\n","categories":["数据库"],"tags":["数据库"]},{"title":"本地文件链接","url":"/2024/03/30/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/","content":"<h1 id=\"链接本地文件的方式\"><a href=\"#链接本地文件的方式\" class=\"headerlink\" title=\"链接本地文件的方式\"></a>链接本地文件的方式</h1><h3 id=\"npm-link\"><a href=\"#npm-link\" class=\"headerlink\" title=\"npm link\"></a>npm link</h3><p>1、带有package.json文件的文件夹内运行：npm link ，即可在用户全局中创建该文件夹的全局链接。</p>\n<p>2、在需要使用文件的地方执行：npm link  文件名，注意文件名是package.json中的name字段值。</p>\n<h3 id=\"file路径\"><a href=\"#file路径\" class=\"headerlink\" title=\"file路径\"></a>file路径</h3><p>在需要使用的package.json的dependence中添加：文件名：”file:  ….”，添加上file路径指向本地文件。</p>\n<h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><p>两种方式的区别在于如果项目较为简单，使用file:路径即可解决，但如果项目较为复杂，且文件包括文件地址需要不断移动时，使用npm  link的方式更好。</p>\n","categories":["脚手架开发"],"tags":["脚手架 cli"]},{"title":"桌面端开发","url":"/2024/05/21/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E5%BC%80%E5%8F%91/","content":"<h1 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h1><p>Electron和Tauri两种桌面端优势对比：</p>\n<ul>\n<li>生态：Electron &gt; Tauri</li>\n<li>性能：Electron &gt; Tauri （Tauri底层基于Tust，并不具备Electron的多进程模型）</li>\n<li>扩展性：Electron &gt; Tauri（Tauri基于Web技术栈，会受到浏览器的限制，而Electron可以直接访问操作系统的API）</li>\n<li>打包：Tauri &gt; Electron（Tauri基于Rust实现，打包产物更小）</li>\n<li>安全性：Tauri &gt; Electron（Tauri打包生成二进制文件，而Electron会将node_modules打包进去，并且没有加密）</li>\n</ul>\n","categories":["桌面端开发"],"tags":["桌面端开发","electron","tauri"]},{"title":"最大安全数与最大安全整数","url":"/2023/12/21/%E6%9C%80%E5%A4%A7%E5%AE%89%E5%85%A8%E6%95%B0/","content":"<h1 id=\"Number-MAX-VALUE最大数\"><a href=\"#Number-MAX-VALUE最大数\" class=\"headerlink\" title=\"Number.MAX_VALUE最大数\"></a>Number.MAX_VALUE最大数</h1><p>Number.MAX_VALUE 静态数据属性表示在 JavaScript 中可表示的最大数值，数值为：2的1024次方 - 1，或大约 1.7976931348623157E+308。<br>（原因是由于：一个字节（byte）8比特（bit），但是数字类型占用一个字节，JS最大用1kb（1024个字节）来存储number）<br>大于最大数的数据会被返回:Infinity</p>\n<h1 id=\"Number-MAX-SAFE-INTEGER最大安全整数\"><a href=\"#Number-MAX-SAFE-INTEGER最大安全整数\" class=\"headerlink\" title=\"Number.MAX_SAFE_INTEGER最大安全整数\"></a>Number.MAX_SAFE_INTEGER最大安全整数</h1><p>Number.MAX_SAFE_INTEGER为：（253 – 1），表示能够一对一匹配到浮点数的最大整数。</p>\n<p>对于更大的整数，请考虑使用 BigInt。</p>\n<p>双精度浮点格式只有 52 位用于表示尾数，因此它只能安全地表示介于 -(253 – 1) 和 253 – 1 之间的整数。本文中，“安全”指的是能够精确表示整数并正确比较它们。例如，Number.MAX_SAFE_INTEGER + 1 &#x3D;&#x3D;&#x3D; Number.MAX_SAFE_INTEGER + 2 的结果将为真，这在数学上是不正确的。有关更多信息，请参阅 Number.isSafeInteger()。</p>\n<p>由于 MAX_SAFE_INTEGER 是 Number 的静态属性，你应该始终将其使用为 Number.MAX_SAFE_INTEGER，而不是一个数字值的属性。</p>\n","categories":["JS"],"tags":["JS","最大安全数","最大安全整数"]},{"title":"本地预览图片","url":"/2024/03/29/%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87/","content":"<h1 id=\"图片上传预览\"><a href=\"#图片上传预览\" class=\"headerlink\" title=\"图片上传预览\"></a>图片上传预览</h1><p>业务中经常有上传图片的需求在，有时我们需要去尽快预览要上传的图片，此时会有两种常见的方法：</p>\n<h3 id=\"URL-createObjectURL\"><a href=\"#URL-createObjectURL\" class=\"headerlink\" title=\"URL.createObjectURL\"></a>URL.createObjectURL</h3><p>直接返回，同步执行，会为图片文件创建一个地址，存储在document中，并且不会被垃圾回收机制所回收。清除方式只有unload事件或revokeObjectURL进行手动清除。</p>\n<h3 id=\"FileReader-readAsDataURL\"><a href=\"#FileReader-readAsDataURL\" class=\"headerlink\" title=\"FileReader.readAsDataURL\"></a>FileReader.readAsDataURL</h3><p>通过回调的形式返回，异步执行，将图片文件转为base64格式，可以通过链接形式直接引用，会依据垃圾回收机制进行回收，<br>2</p>\n","categories":["业务处理"],"tags":["业务","图片"]},{"title":"持续集成与持续部署","url":"/2024/02/03/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/","content":"<h1 id=\"5-4-持续集成与持续部署\"><a href=\"#5-4-持续集成与持续部署\" class=\"headerlink\" title=\"5-4 持续集成与持续部署\"></a>5-4 持续集成与持续部署</h1><h2 id=\"课程介绍\"><a href=\"#课程介绍\" class=\"headerlink\" title=\"课程介绍\"></a>课程介绍</h2><p>那些大厂们，天天DevOps、持续集成的？到底在讲些什么？这堂课来给你揭开持续集成与持续部署的面纱！！没有什么难的，盘它！</p>\n<p><strong>传统的开发过程中的坑：</strong></p>\n<ul>\n<li>BUG总是在最后才发现</li>\n<li>越到项目后期，加班越严重</li>\n<li>交付无法保障</li>\n<li>变更频繁导致效率低下</li>\n<li>无效的等待多，用户满足度低</li>\n</ul>\n<p><img data-src=\"/./assets/1460000014924499.png\" alt=\"img\"></p>\n<p><strong>你有没有想过&#x2F;用过？当你哪一天…</strong></p>\n<ul>\n<li>不用为开发&#x2F;测试环境不一致而苦恼</li>\n<li>不用麻烦运维人员帮忙调试环境</li>\n<li>不用手动进行测试，模拟环境中进行自测</li>\n<li>不用手动发布、部署，自动化实现发布部署</li>\n<li>不用管开发&#x2F;测试环境，只用专注代码的开发？</li>\n</ul>\n<p><strong>持续集成解决了什么问题？</strong></p>\n<ul>\n<li>提高软件质量</li>\n<li>效率迭代</li>\n<li>便捷部署</li>\n<li>快速交付、便于管理</li>\n</ul>\n<p><strong>课程的主要内容：</strong></p>\n<ul>\n<li><p>什么是CI&#x2F;CD</p>\n</li>\n<li><p>介绍CI&#x2F;CD流程</p>\n</li>\n<li><p>前端项目：结合CI&#x2F;CD流程，实现快速迭代</p>\n</li>\n<li><p>Docker的使用，Jenkins+gitlab+nodejs自动化项目</p>\n</li>\n<li><p>持续集成工具介绍：Jenkins、Travis CI、Circle CI</p>\n</li>\n</ul>\n<p><strong>环境准备：</strong></p>\n<ul>\n<li>Linux服务器(Centos 7.6&#x2F;Ubuntu 16.04LTS)</li>\n<li>VSCode+插件 Dockerfile</li>\n<li>注册github账号</li>\n</ul>\n<h2 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h2><h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><p><strong>集成，就是一些孤立的事物或元素通过某种方式集中在一起，产生联系，从而构成一个有机整体的过程</strong>。知识经济的社会，集成已经成了很重要的一个名词。各行各业基本都会用到集成。比如汽车行业，那么复杂的一台跑车愣是通过一大堆零件组装起来。对于这些传统行业，它们在研发成功以后，可以通过流水线的方法批量生产进行集成。而在软件行业中，集成并不是一个简单的“搬箱子”的过程。因为软件工业是一个知识生产活动，其内在逻辑非常复杂，需求又很难一次性确定，完成的产品与最初的设计往往相差很远。敏捷宣言中就有一条是说响应变化重于遵循计划。而且由于软件行业的迅猛发展，软件变的越来越复杂，单靠个人是根本无法完成。大型软件为了重用及解耦，往往还需要分成好几个模块，这样集成就成了软件开发中不可或缺的一部分。</p>\n<p>持续，不言而喻，就是指<strong>长期的对项目代码进行集成。</strong></p>\n<h4 id=\"持续集成-1\"><a href=\"#持续集成-1\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h4><p>持续集成（英文：Continuous Integration，简称CI）</p>\n<p>在软件工程中，持续集成是指将所有开发者工作副本每天多次合并到主干的做法。 </p>\n<blockquote>\n<p>Grady Booch 在1991年的 Booch method 中首次命名并提出了 CI 的概念，尽管在当时他并不主张每天多次集成。而 XP（Extreme programming，极限编程）采用了 CI 的概念，并提倡每天不止一次集成。</p>\n<p>在《持续集成》一书中，对持续集成的定义如下：<code>持续集成</code>是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，一般每人每天至少集成一次,也可以多次。每次集成会经过自动构建(包括自动测试)的检验，以尽快发现集成错误。自从在团队中引入这样的实践之后，<code>Martin Fowler</code>发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。</p>\n</blockquote>\n<p><img data-src=\"/./assets/c5c8e6f40c7c133e22402c00bb7e1a25_hd.jpg\" alt=\"img\"></p>\n<p>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</p>\n<p>对于一天需要集成多少次数，并没有一个明确的定义。一般就是按照自己项目的实际需要来设置一定的频率，少则可能几次，多则可能达几十次。可以设置按照代码的变更来触发集成，或者设置一个固定时间周期来集成，也可以手工点击集成的按钮来“一键集成”。</p>\n<h4 id=\"持续交付\"><a href=\"#持续交付\" class=\"headerlink\" title=\"持续交付\"></a>持续交付</h4><p>持续交付（英文：Continuous Delivery，简称CD）</p>\n<p>完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p>\n<p><img data-src=\"/./assets/db7198e3c39e4656e18efcb4bd1b20b1_hd.jpg\" alt=\"img\"></p>\n<p>在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。</p>\n<p>比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续<code>手动</code>部署到生产环境中。</p>\n<h4 id=\"持续部署\"><a href=\"#持续部署\" class=\"headerlink\" title=\"持续部署\"></a>持续部署</h4><p>持续部署（英文：Continuous Deployment，简称CD）</p>\n<p>对于一个成熟的 CI&#x2F;CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。</p>\n<p><img data-src=\"/./assets/f96f19e4d567aad5006d841963a86e41_hd.jpg\" alt=\"img\"></p>\n<p>实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI&#x2F;CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI&#x2F;CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。</p>\n<p>持续部署则是在持续交付的基础上，把部署到生产环境的过程<code>自动化</code>。</p>\n<h3 id=\"持续集成组成要素\"><a href=\"#持续集成组成要素\" class=\"headerlink\" title=\"持续集成组成要素\"></a>持续集成组成要素</h3><p><strong>一个最小化的持续集成系统需要包含以下几个要素：</strong></p>\n<ol>\n<li><strong>版本管理系统：</strong>项目的源代码需要托管到适合的版本管理系统中，一般我们使用git作为版本控制库，版本管理软件可以使用github、<code>gitlab</code>、stash等。</li>\n<li><strong>构建脚本&amp;工具：</strong>每个项目都需要有构建脚本来实现对整个项目的自动化构建。比如Java的项目就可以使用gradle作为构建工具。通过构建工具实现对编译、静态扫描、运行测试、样式检查、打包、发布等活动串起来，可以通过命令行自动执行。</li>\n<li><strong>CI服务器：</strong>CI服务器可以检测项目中的代码变动，并及时的通过构建机器运行构建脚本，并将集成结果通过某种方式反馈给团队成员。</li>\n</ol>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><p>打包平台</p>\n<p>常见的打包，Java应用（Gradle&#x2F;Maven）、Nodejs前端应用(npm&#x2F;yarn)</p>\n<p>移动端打包：Android&#x2F;iOS</p>\n</li>\n<li><p>测试平台</p>\n<p>接口测试</p>\n<p>自动化测试Robotium、Testlink</p>\n<p>单元测试junit</p>\n<p>性能测试Jmeter</p>\n</li>\n<li><p>自动部署</p>\n<p>FTP</p>\n<p>Shell</p>\n<p>Tomcat&#x2F;Dokcer</p>\n<p>Kubernetes&#x2F;Rancher&#x2F;Cluster</p>\n</li>\n<li><p>持续集成</p>\n<p>Git: gitlab github gitee等</p>\n<p>Jenkins&#x2F;TravisCi&#x2F;CircleCI</p>\n<p>Docker</p>\n</li>\n</ul>\n<h3 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h3><h4 id=\"传统的工作流\"><a href=\"#传统的工作流\" class=\"headerlink\" title=\"传统的工作流\"></a>传统的工作流</h4><p>参与人员：开发、项目经理、测试</p>\n<p>主要流程：</p>\n<ul>\n<li>项目一开始是先划分好模块，<code>分配模块</code>给相应的开发人员；</li>\n<li>开发人员<code>开发好</code>一个模块就进行<code>单元测试</code>；</li>\n<li>等所有的模块都开发完成之后，由项目经理对<code>所有代码进行集成</code>；</li>\n<li>集成后的项目由项目经理<code>部署到测试服务器</code>上，被交由测试人员进行集成测试；</li>\n<li>测试过程中出现 Bug 就提把问题<code>记录</code>进行 <code>Bug</code> 列表中；</li>\n<li><code>项目经理分配 Bug</code> 给相应的责任人进行修改；</li>\n<li>修改完成后，项目经理<code>再次</code>对项目进行集成，并<code>部署</code>到测试服务器上；</li>\n<li>测试人员在下一次的集成测试中进行<code>回归测试</code>；</li>\n<li>通过通过之后就<code>部署到生产环境</code>中；</li>\n<li>如果测试不通过，则重复上述“分配 Bug -&gt; 修改 Bug -&gt; 集成代码 -&gt; 部署到测试服务器上 -&gt; 集成测试”工作。</li>\n</ul>\n<blockquote>\n<p>这也是传统的瀑布式开发模型，请参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vLU9ZSy9hcmNoaXZlLzIwMTIvMTAvMDgvMjcxNDY2OS5odG1s\">软件开发模式对比(瀑布、迭代、螺旋、敏捷)</span></p>\n</blockquote>\n<p>带来的问题：</p>\n<ol>\n<li><p><strong>重复性劳动，无效的等待变多</strong></p>\n<p>重复的进行发布部署。</p>\n<p>流程上：有可能开发在等集成其他人的模块；测试人员在等待开发人员修复 Bug；产品经理在等待新版本上线好给客户做演示；项目经理在等待其他人提交代码。不管怎么样，等待意味低效。</p>\n<p>自动化部署工作可以解放了集成、测试、部署等重复性劳动，而且机器集成的频率明显可以比手工的高很多。</p>\n</li>\n<li><p><strong>很晚才发现缺陷，并且难以修复</strong>。</p>\n<p>实践证明，缺陷发现的越晚，需要修复的时间和精力也就越大。从上一个可工作的软件到发现缺陷之间可能存在很多次提交，而要从这些提交中找出问题并修复的成本会很大，因为开发人员需要回忆每个提交的上下文来评估影响点。</p>\n</li>\n<li><p><strong>低品质的软件，软件交付时机无法保障</strong></p>\n<p>由于集成时每次包含的代码很多，所以大家的关注点主要都是如何保证编译通过、自动化测试通过，而往往很容易忽略代码是否遵守了编码规范、是否包含有重复代码、是否有重构的空间等问题。而这些问题又反过来会影响今后的开发和集成，久而久之集成变得越来越困难，软件的质量可想而知。</p>\n</li>\n<li><p><strong>项目缺少可见性</strong></p>\n<p>某些项目，程序会经常需要变更，特别是敏捷开发的实践者。由于产品经理在与客户交流过程中，往往实际的软件就是最好的原型，所以软件会被当作原型作为跟客户交流的工具。当然，客户最希望的当然是客户的想法能够马上反映到原型上，这会导致程序会经常被修改的。那么也就意味着“分配 Bug -&gt; 修改 Bug -&gt; 集成代码 -&gt; 部署到测试服务器上 -&gt; 集成测试”工作无形又爆增了。</p>\n</li>\n</ol>\n<h4 id=\"常见的工作流\"><a href=\"#常见的工作流\" class=\"headerlink\" title=\"常见的工作流\"></a>常见的工作流</h4><p><img data-src=\"/./assets/DevOps.png\" alt=\"DevOps\"></p>\n<p>该系统的各个组成部分是按如下顺序来发挥作用的：</p>\n<ol>\n<li><p>开发者检入代码到源代码仓库。</p>\n</li>\n<li><p>CI系统会为每一个项目创建了一个单独的工作区。当预设或请求一次新的构建时，它将把源代码仓库的源码存放到对应的工作区。</p>\n</li>\n<li><p>CI系统会在对应的工作区内执行构建过程。</p>\n</li>\n<li><p>配置如果存在）构建完成后，CI系统会在一个新的构件中执行定义的一套测试。完成后触发通知(Email,RSS等等)给相关的当事人。</p>\n</li>\n<li><p>配置如果存在）如果构建成功，这个构件会被打包并转移到一个部署目标(如应用服务器)或存储为软件仓库中的一个新版本。软件仓库可以是CI系统的一部分，也可以是一个外部的仓库，诸如一个文件服务器或者像Java.net、SourceForge之类的网站。</p>\n</li>\n<li><p>CI系统通常会根据请求发起相应的操作，诸如即时构建、生成报告，或者检索一些构建好的构件。</p>\n</li>\n</ol>\n<blockquote>\n<p>“You build it, you run it”，这是 Amazon 一年可以完成 5000 万次部署，平均每个工程师每天部署超过 50 次的核心秘籍。</p>\n</blockquote>\n<h4 id=\"解决的问题\"><a href=\"#解决的问题\" class=\"headerlink\" title=\"解决的问题\"></a>解决的问题</h4><ul>\n<li><p>高效率</p>\n<p>高效率的发布，避免了重复性的劳动；</p>\n<p>更快的修复BUG，更快的交付成果，减少了等待时间。</p>\n</li>\n<li><p>高质量</p>\n<p>只有在完成集成测试、系统测试后，才能得到可用的软件，整个过程中只有最后时刻才能拿到可运行软件。集成活动不一定在一个标准的构建机器上生成，而是在某个开发人员的机器上构建的，那么可能存在在其他机器上无法运行的问题。</p>\n<p>人与机器的一个最大的区别是，在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。所以，当我们搭建完成集成服务器后，以后的事就交给集成服务器来打理吧。</p>\n</li>\n<li><p>高产出</p>\n<p>快速开发和上市一个新产品，并快速取得预期的投资回报是每个企业孜孜以求的目标。</p>\n<p>便捷的部署+项目的可预期，使得团队的开发变成了一种开心的事情。</p>\n<p>持续集成可以让你在任何时间发布可以部署的软件。在外界看来，这是持续集成最明显的好处，对客户来说，可以部署的软件产品是最实际的资产。利用持续集成，你可以经常对源代码进行一些小改动，并将这些改动和其他代码进行集成。</p>\n</li>\n</ul>\n<h4 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h4><ol>\n<li><p>思维转变后，新技术抵触</p>\n<ul>\n<li>无法接受新事物：不管怎么样，求稳心态的人还是多。总是有人认为老的技术代表稳定，新的事物往往会带来问题。</li>\n<li>认为手工集成也没有多少工作量：不是所有的人都参与到了整个持续集成的环节，所以没有办法认识到问题全貌。</li>\n</ul>\n<p><strong>针对这个问题，可以通过设置一定的持续集成技术培训、宣讲得到改观</strong></p>\n</li>\n<li><p>管理层的抵触</p>\n<ul>\n<li>培训持续集成需要投入资金啊，没钱。</li>\n<li>持续集成服务器要增加软硬件成本啊，没钱。</li>\n<li>开发人员领了那么高的工资，多干活多加班应该啊。</li>\n</ul>\n<p><strong>针对这一点，可以从开发人员的成本和持续集成的投入（软硬件）的成本上两者做下估算。</strong></p>\n<blockquote>\n<p>硬件参考：</p>\n<p>Jenkins主服务器一般2C4G，slave服务器根据生产需要进行选购。</p>\n<p>git服务器一般2C4G(10人团队)</p>\n<p>Docker服务器8C32G(Rancher + harbor)</p>\n</blockquote>\n</li>\n<li><p>生产环境的复杂</p>\n<ul>\n<li>比如部署的生成环境是在政务外网，无法从互联网直接访问等。</li>\n<li>构建效率低下，任务多</li>\n</ul>\n<p>目前，这个是最麻烦的，还在研究中。初步设想是让政务外网开辟一个白名单，给持续集成服务器设置一个单独的通道。只是思路，未验证。</p>\n</li>\n</ol>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>实施持续集成的开发人员可以尽早并经常提交。这允许他们尽早发现冲突。并且，如果存在任何问题，则使用较小的提交可以更轻松地对代码进行故障排除。每天或甚至更频繁地提交软件对于持续集成是必要的，但还不够。</p>\n<p>要成功使用持续集成，团队必须：</p>\n<ul>\n<li><p>使测试成为开发过程中不可或缺的一部分。应该在创建代码时编写测试。</p>\n<p>公司成功持续整合所需的最重要因素是严格的测试文化。为了将新代码自信地集成到主线中，团队需要确信代码是健全的。这是通过测试来实现的，这应该定期进行。工程师应该在开发每个功能时编写测试。</p>\n</li>\n<li><p>确保测试环境反映生产一致。</p>\n<p>为了支持您严格的测试文化，测试环境必须反映生产环境。否则，您无法保证您正在测试的内容将在生产中起作用。这意味着测试环境应使用相同版本的数据库，Web服务器配置，工件等。</p>\n</li>\n<li><p>使用编码最佳实践，例如结对编程。</p>\n<p>软件开发的另一个最佳实践是在编码期间进行配对。对于更复杂的功能，团队在编写单行代码之前讨论体系结构方法。在将任何代码合并到生产环境之前，其他开发人员始终会检查代码。这有助于确保使用编码最佳实践，代码不会与其他开发人员正在处理的现有代码或代码冲突，并且新功能是可扩展的。</p>\n<blockquote>\n<p><strong>Pair programming</strong> is an <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWdpbGVfc29mdHdhcmVfZGV2ZWxvcG1lbnQ=\">agile software development</span> technique in which two <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcHV0ZXJfcHJvZ3JhbW1lcg==\">programmers</span> work together at one workstation. One, the <em>driver</em>, writes <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU291cmNlX2NvZGU=\">code</span> while the other, the <em>observer</em> or <em>navigator</em>,[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFpcl9wcm9ncmFtbWluZyNjaXRlX25vdGUtMQ==\">1]</span> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29kZV9yZXZpZXc=\">reviews</span> each line of code as it is typed in. The two programmers switch roles frequently.</p>\n<p>While reviewing, the observer also considers the “strategic” direction of the work, coming up with ideas for improvements and likely future problems to address. This is intended to free the driver to focus all of their attention on the “tactical” aspects of completing the current task, using the observer as a safety net and guide.</p>\n</blockquote>\n</li>\n<li><p>自动化部署工作流程。</p>\n<p>最后，为确保整个软件开发流程快速高效，构建需要快速，部署工作流程应自动化。代码构建的每一分钟都浪费了一分钟。通过自动化部署工作流程，团队可以更快地将完成的代码生成。因为，毕竟，如果没有接触到客户，那么快速开发软件有什么意义呢？</p>\n</li>\n</ul>\n<h3 id=\"效率工具对比\"><a href=\"#效率工具对比\" class=\"headerlink\" title=\"效率工具对比\"></a>效率工具对比</h3><p>![img](&#x2F;Users&#x2F;Shared&#x2F;Target&#x2F;5-4 持续集成与持续部署&#x2F;resource&#x2F;assets&#x2F;CICD-resource.png)</p>\n<p><a href=\"#%E5%A4%8D%E6%9D%82%E7%9A%84DevOps%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7\">点击查看</a>效率工具</p>\n<p><strong>1. Jenkins</strong></p>\n<blockquote>\n<p>Jenkins，原名Hudson，2011年改为现在的名字，它 是一个开源的实现持续集成的软件工具。官方网站：<span class=\"exturl\" data-url=\"aHR0cDovL2plbmtpbnMtY2kub3JnLw==\">http://jenkins-ci.org/</span>。</p>\n<p>Jenkins 能实时<strong>监控集成中存在的错误</strong>，提供<strong>详细的日志文件和提醒</strong>功能，还能用图表的形式形象地展示<strong>项目构建的趋势和稳定性</strong>。</p>\n</blockquote>\n<p><strong>Jenkins特点:</strong></p>\n<ul>\n<li><strong>易安装</strong>：Jenkins是一个独立的基于Java的程序，随时可以运行，包含Windows，Mac OS X和其他类Unix操作系统的软件包。仅仅一个 java -jar jenkins.war，从官网下载该文件后，直接运行，无需额外的安装，更无需安装数据库；</li>\n<li><strong>易配置</strong>：提供友好的GUI配置界面；</li>\n<li><strong>变更支持</strong>：Jenkins能从代码仓库（Subversion&#x2F;CVS）中获取并产生代码更新列表并输出到编译输出信息中；</li>\n<li><strong>支持永久链接</strong>：用户是通过web来访问Jenkins的，而这些web页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接；</li>\n<li><strong>集成E-Mail&#x2F;RSS&#x2F;IM：</strong>当完成一次集成时，可通过这些工具实时告诉你集成结果（据我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程中，干别的事情）；</li>\n<li><strong>JUnit&#x2F;TestNG测试报告</strong>：也就是用以图表等形式提供详细的测试报表功能；</li>\n<li><strong>支持分布式构建</strong>：Jenkins可以把<strong>集成构建等工作分发到多台计算机中完成</strong>；</li>\n<li><strong>文件指纹信息</strong>：Jenkins会保存哪次集成构建产生了哪些jars文件，哪一次集成构建使用了哪个版本的jars文件等构建记录；</li>\n<li><strong>支持第三方插件</strong>：使得 Jenkins 变得越来越强大；凭借更新中心中的数百个插件，Jenkins几乎集成了持续集成和持续交付工具链中的所有工具。</li>\n<li><strong>Rest API</strong> - 可以访问控制您获取的数据量，获取&#x2F;更新config.xml，删除作业，检索所有构建，获取&#x2F;更新作业说明，执行构建，禁用&#x2F;启用作业</li>\n</ul>\n<p><strong>Jenkins优点：</strong></p>\n<ul>\n<li>价格（免费）</li>\n<li>定制</li>\n<li>插件系统</li>\n<li>完全控制系统</li>\n</ul>\n<p><strong>Jenkins缺点：</strong></p>\n<ul>\n<li>需要专用服务器（或多个服务器）。这导致额外的费用。对于服务器本身，DevOps等…</li>\n<li>配置&#x2F;定制所需的时间</li>\n</ul>\n<p><strong>2. Travis CI</strong></p>\n<p><strong>Travis CI</strong>是一个托管的持续集成服务，用于构建和测试在GitHub上托管的软件项目。</p>\n<blockquote>\n<p><strong>Travis CI</strong> is a hosted continuous integration service used to build and test software projects hosted at GitHub</p>\n</blockquote>\n<p><strong>Travis CI的特点：</strong></p>\n<ul>\n<li><p>基于云：TravisCI是一个<strong>基于云</strong>的系统 - 不需要专用服务器，您无需管理它。</p>\n</li>\n<li><p>支持Docker运行测试</p>\n</li>\n<li><p>使用YAML文件进行配置</p>\n</li>\n<li><p>可选择Linux和Mac OSX上同时运行测试</p>\n</li>\n<li><p>开箱即用的支持的语言</p>\n<p>Android，C，C＃，C ++，Clojure，Crystal，D，Dart，Erlang，Elixir，F＃，Go，Groovy，Haskell，Haxe，Java，JavaScript（使用Node.js），Julia，Objective-C，Perl，Perl6， PHP，Python，R，Ruby，Rust，Scala，Smalltalk，Visual Basic</p>\n</li>\n<li><p><strong>支持多环境构建矩阵</strong>：如Python 2.7 , 3.4, 3.5 +  Django 1.8, 1.9, 1.10</p>\n<p>构建矩阵是一种工具，可以使用不同版本的语言和包运行测试。您可以以不同的方式自定义它。例如，某些环境的失败可以触发通知但不会使所有构建失败（这对包的开发版本有帮助）</p>\n</li>\n</ul>\n<p><strong>Travis CI优点：</strong></p>\n<ul>\n<li>开箱即用构建矩阵</li>\n<li>快速启动</li>\n<li>轻量级YAML配置</li>\n<li>开源项目的免费计划</li>\n<li>无需专用服务器</li>\n</ul>\n<p><strong>Travis CI缺点：</strong></p>\n<ul>\n<li>与CircleCI相比，价格更高，没有免费的企业计划</li>\n<li>定制（对于某些你需要第三方的东西）</li>\n</ul>\n<p><strong>3. Circle CI</strong></p>\n<p>在GitHub或Bitbucket上的软件存储库被授权并作为项目添加到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaXJjbGVjaS5jb20v\">circleci.com之后</span>，每个代码更改都会在干净的容器或VM中触发自动化测试。</p>\n<p>CircleCI在2017年被Forrester评为持续集成领导者，并被命名为多个最佳DevOps工具列表。CircleCI成立于2011年，总部位于旧金山，拥有全球性的远程员工队伍，由Scale Venture Partners，DFJ，Baseline Ventures，Top Tier Capital，Industry Ventures，Heavybit和Harrison Metal Capital提供风险投资。</p>\n<p><strong>Circle CI的特点：</strong></p>\n<ul>\n<li><strong>云&amp;本地化</strong>：CircleCI是一个<strong>基于云</strong>的系统 - 不需要专用服务器，您无需管理它。 但是，它还<strong>提供了一个本地解决方案</strong>，允许您在私有云或数据中心中运行它。</li>\n<li><strong>商业&amp;免费</strong>：即使是商业帐户，它也<strong>有免费计划</strong></li>\n<li><strong>Rest API</strong> - 您可以访问项目，构建和工件（artifacts）。构建的结果将是工件或工件组。 工件可以是已编译的应用程序或可执行文件（例如，android APK）或元数据（例如，关于测试&#96;成功的信息）</li>\n<li><strong>按需安装</strong>：CircleCI 缓存<strong>必要的安装</strong>（requirements installation）。 它会检查第三方依赖项，而不是持续安装所需的环境</li>\n<li><strong>SSH模式</strong>：您可以触发<strong>SSH模式</strong>访问容器并进行自己的调查（如果出现任何问题）</li>\n<li><strong>最小化配置</strong>：这是一个完整的开箱即用解决方案，需要<strong>最少的配置\\调整</strong></li>\n</ul>\n<p><strong>CircleCI优点：</strong></p>\n<ul>\n<li>快速启动</li>\n<li>CircleCI有一个免费的企业项目计划</li>\n<li>这很容易，也很快开始</li>\n<li>轻量级，易读的YAML配置</li>\n<li>您不需要任何专用服务器来运行CircleCI</li>\n</ul>\n<p><strong>CircleCI缺点：</strong></p>\n<ul>\n<li><p>CircleCI仅支持2个版本的Ubuntu免费（12.04和14.04）和MacOS作为付费部分</p>\n</li>\n<li><p>尽管CircleCI可以使用并运行所有语言，但tt仅支持“开箱即用”的以下编程语言：Go（Golang），Haskell，Java，PHP，Python，Ruby &#x2F; Rails，Scala</p>\n</li>\n<li><p>如果您想进行自定义，可能会出现一些问题：您可能需要一些第三方软件来进行这些调整</p>\n</li>\n<li><p>此外，虽然作为基于云的系统是一方的优势，它也可以停止支持任何软件，你将无法阻止</p>\n</li>\n</ul>\n<p>总结一下：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Jenkins</th>\n<th>Travis CI</th>\n<th>Circle CI</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>本地部署</td>\n<td>支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>REST API</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>配置</td>\n<td>复杂，高度可配置</td>\n<td>YAML文件</td>\n<td>YAML文件</td>\n</tr>\n<tr>\n<td>按需安装</td>\n<td>是</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>跨平台支持</td>\n<td>是</td>\n<td>Linux + MacOS</td>\n<td>Linux + MacOS(付费)</td>\n</tr>\n<tr>\n<td>多服务器</td>\n<td>是</td>\n<td>按需</td>\n<td>否</td>\n</tr>\n<tr>\n<td>快速构建</td>\n<td>手动配置复杂</td>\n<td>快(需要写配置文件)</td>\n<td>最快</td>\n</tr>\n<tr>\n<td>基本环境</td>\n<td>Java</td>\n<td>云环境</td>\n<td>云环境</td>\n</tr>\n<tr>\n<td>费用</td>\n<td>免费</td>\n<td>特定免费(69$&#x2F;c)</td>\n<td>特定免费(50$&#x2F;c)</td>\n</tr>\n</tbody></table>\n<p>Travis CI的价格（非常感人）：</p>\n<p><img data-src=\"/./assets/image-20190611100501785.png\" alt=\"/images/image-20190611100501785\"></p>\n<p>CirCle CI的价格：</p>\n<p><img data-src=\"/./assets/image-20190611100534676.png\" alt=\"/images/image-20190611100534676\"></p>\n<p>其他的一些持续集成的工具：CruiseControl，TeamCity，Continuum等</p>\n<ul>\n<li>AnthillPro：商业的构建管理服务器，提供C功能</li>\n<li>Bamboo：商业的CI服务器，对于开源项目免费</li>\n<li>Build Forge：多功能商业构建管理工具，特点：高性能、分布式构建</li>\n<li>Cruise Control：基于java实现的持续集成构建工具</li>\n<li>CruiseControl.NET：基于C#实现的持续集成构建工具</li>\n<li>Lunt build：开源的自动化构建工具</li>\n<li>Para Build：商业的自动化软件构建管理服务器</li>\n</ul>\n<h2 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h2><h3 id=\"使用简介\"><a href=\"#使用简介\" class=\"headerlink\" title=\"使用简介\"></a>使用简介</h3><p>Jenkins是开源CI&amp;CD软件领导者， 提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。</p>\n<p><img data-src=\"/./assets/image-20190611103941326.png\" alt=\"/images/image-20190611103941326\"></p>\n<p>相关概念：</p>\n<ul>\n<li><p>流水线：<strong>Jenkins Pipeline</strong>（或简称为 “Pipeline”）是一套插件，将持续交付的实现和实施集成到 Jenkins 中。</p>\n<p>Jenkins Pipeline 提供了一套可扩展的工具，用于将“简单到复杂”的交付流程实现为“持续交付即代码”。Jenkins Pipeline 的定义通常被写入到一个文本文件（称为 <code>Jenkinsfile</code> ）中，该文件可以被放入项目的源代码控制库中。</p>\n</li>\n<li><p>节点：节点是一个机器，主要用于执行jenkins任务</p>\n</li>\n<li><p>阶段：定义不同的执行任务，比如：构建、测试、发布(部署)</p>\n</li>\n<li><p>步骤：相当于告诉Jenkins现在要做些什么，比如shell命令。</p>\n</li>\n</ul>\n<p><img data-src=\"/./assets/image-20190611163108298.png\" alt=\"/images/image-20190611163108298\"></p>\n<p>Jenkins的界面</p>\n<p><img data-src=\"/./assets/image-20190611163727975.png\" alt=\"/images/image-20190611163727975\"></p>\n<p>任务详情页面</p>\n<p><img data-src=\"/./assets/image-20190611163855257.png\" alt=\"/images/image-20190611163855257\"></p>\n<p>Jenkins任务日志</p>\n<h3 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a>安装方式</h3><ol>\n<li><p>环境要求</p>\n<ul>\n<li>机器要求：<ul>\n<li>256 MB 内存，建议大于 512 MB</li>\n<li>10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）</li>\n</ul>\n</li>\n<li>需要安装以下软件：<ul>\n<li>Java 8 ( JRE 或者 JDK 都可以)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=\">Docker</span> （导航到网站顶部的Get Docker链接以访问适合您平台的Docker下载）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>常规安装</p>\n<ul>\n<li><p>安装JDK</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9qYXZhL2phdmFzZS9kb3dubG9hZHMvamRrOC1kb3dubG9hZHMtMjEzMzE1MS5odG1s\">官方地址</span></p>\n<p>下载对应的操作系统的JDK，然后解压进行安装。以Linux为例：</p>\n<p>下载最新版本，上传到Linux服务器</p>\n<pre><code class=\"bash\"># 上传到 /opt/jdk8目录下\n\n# tar解压JDK安装包\nmkdir -p /opt/jdk8\ntar zxvf jdk-8u211-linux-x64.tar.gz -C /opt/jdk8 --strip-components 1\n\n# vi /etc/profile\nexport JAVA_HOME=/opt/jdk8\nexport JRE_HOME=$&#123;JAVA_HOME&#125;/jre\nexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib\nexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH\n</code></pre>\n</li>\n<li><p>安装Jenkins</p>\n<p>下载Jenkins最新的war包：<span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuamVua2lucy5pby93YXItc3RhYmxlL2xhdGVzdC9qZW5raW5zLndhcg==\">Latest</span></p>\n<pre><code class=\"bash\">mkdir -p /opt/jenkins &amp;&amp; cd /opt/jenkins\n\nwget -O /opt/jenkins/jenkins.war http://mirrors.jenkins.io/war-stable/latest/jenkins.war\n\njava -jar jenkins.war --httpPort=8080\n</code></pre>\n<p>就嗯可以打开，<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgw5LqG\">http://localhost:8080了</span></p>\n<p>注意一段这样的话：</p>\n<pre><code class=\"bash\">*************************************************************\n*************************************************************\n*************************************************************\n\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n63196690ae7d47c49506480ee0e1af4a\n\nThis may also be found at: /root/.jenkins/secrets/initialAdminPassword\n\n*************************************************************\n*************************************************************\n*************************************************************\n</code></pre>\n<p>这里的<code>63196690ae7d47c49506480ee0e1af4a</code>就是初始的安装的管理员密码。</p>\n</li>\n</ul>\n</li>\n<li><p>使用Docker安装</p>\n<ul>\n<li><p>安装Docker</p>\n<pre><code class=\"bash\"># From https://get.docker.com:\ncurl -fsSL https://get.docker.com -o get-docker.sh\nsh get-docker.sh\n\n#From https://test.docker.com:\ncurl -fsSL https://test.docker.com -o test-docker.sh\nsh test-docker.sh\n\n# From the source repo (This will install latest from the test channel):\nsh install.sh\n</code></pre>\n</li>\n<li><p>配置Docker镜像加速，使用阿里云<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20vP3NwbT1hMmM0ZS4xMTE1Mzk0MC5ibG9nY29udDI5OTQxLjkuNTIwMjdlMjl3Mmp2OVA=\">容器加速服务</span></p>\n<p>左侧的加速器帮助页面就会显示为你独立分配的加速地址</p>\n<pre><code class=\"bash\">例如：\n公网Mirror：[系统分配前缀].mirror.aliyuncs.com\n</code></pre>\n<p>使用配置文件 <code>/etc/docker/daemon.json</code>（没有时新建该文件）</p>\n<pre><code class=\"bash\">&#123;\n    &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]\n&#125;\n</code></pre>\n<p>重启Docker Daemon就可以了</p>\n<pre><code class=\"bash\">systemctl daemon-reload\nsystemctl restart docker\n</code></pre>\n<p><code>docker ps</code> 查看容器运行状态</p>\n<p><code>docker logs 容器ID/容器名称</code> 查看管理员初始密码</p>\n</li>\n<li><p>安装Docker-compose.yml文件(可选)</p>\n<p><strong>安装方法：</strong></p>\n<pre><code class=\"bash\">#下载\nsudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\n#安装\nchmod +x /usr/local/bin/docker-compose\n#查看版本\ndocker-compose --version\n</code></pre>\n</li>\n<li><p>安装Jenkins</p>\n<p><strong>版本选择：</strong></p>\n<p>Jenkins: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2plbmtpbnMvamVua2lucy8=\">https://hub.docker.com/r/jenkins/jenkins/</span></p>\n<p>Jenkins with Blue Ocean: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2plbmtpbnNjaS9ibHVlb2NlYW4=\">https://hub.docker.com/r/jenkinsci/blueocean</span></p>\n<blockquote>\n<p>Blue Ocean 重新思考Jenkins的用户体验，从头开始设计<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZW5raW5zLmlvL3poL2RvYy9ib29rL3BpcGVsaW5lLw==\">Jenkins Pipeline</span>, 但仍然与自由式作业兼容，Blue Ocean减少了混乱而且进一步明确了团队中每个成员 Blue Ocean 的主要特性包括：</p>\n<ul>\n<li>持续交付(CD)Pipeline的 <strong>复杂可视化</strong> ，可以让您快速直观地理解管道状态。</li>\n<li><strong>Pipeline 编辑器</strong> - 引导用户通过直观的、可视化的过程来创建Pipeline，从而使Pipeline的创建变得平易近人。</li>\n<li><strong>个性化</strong> 以适应团队中每个成员不同角色的需求。</li>\n<li>在需要干预和&#x2F;或出现问题时 <strong>精确定位</strong> 。 Blue Ocean 展示 Pipeline中需要关注的地方， 简化异常处理，提高生产力</li>\n<li><strong>本地集成分支和合并请求</strong>, 在与GitHub 和 Bitbucket中的其他人协作编码时实现最大程度的开发人员生产力。****</li>\n</ul>\n</blockquote>\n<p><strong>安装命令：</strong></p>\n<pre><code class=\"bash\"># Jenkins\ndocker run \\\n  -itd \\\n  -u root \\\n  -p 8080:8080 \\\n  -v jenkins-data:/var/jenkins_home \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v /usr/bin/docker:/usr/bin/docker \\\n  --name jenkins-master \\\n  jenkins/jenkins\n  \n# Jenkins blueocean\ndocker run \\\n  -itd \\\n  -u root \\\n  -p 8080:8080 \\\n  -v jenkins-data:/var/jenkins_home \\ \n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v /usr/bin/docker:/usr/bin/docker \\\n  --name jenkins-master \\\n  jenkinsci/blueocean\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>配置Jenkins插件加速</p>\n<p>进入jenkins系统管理-&gt;插件管理中-&gt;高级选项卡-&gt;升级站点，使用清华源：</p>\n<pre><code class=\"html\">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/current/update-center.json\n</code></pre>\n<p><img data-src=\"/./assets/70.png\" alt=\"ç³»ç»ç®¡ç\"></p>\n<p><img data-src=\"/./assets/70-20190611152837311.png\" alt=\"æä»¶ç®¡ç\"></p>\n<p>关于官方所有的镜像列表：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuamVua2lucy1jaS5vcmcvc3RhdHVzLmh0bWw=\">http://mirrors.jenkins-ci.org/status.html</span></p>\n</li>\n<li><p>环境配置</p>\n<ul>\n<li>Jenkins 的URL路径</li>\n<li>全局工具的配置：Docker, JDK(JAVA)…</li>\n</ul>\n</li>\n<li><p>用户权限配置</p>\n<ul>\n<li>矩阵权限的配置</li>\n<li>添加管理员用户所有的权限</li>\n<li>添加<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmplbmtpbnMtY2kub3JnL2Rpc3BsYXkvSkVOS0lOUy9BdXRob3JpemUrUHJvamVjdCtwbHVnaW4=\">Authorize Project</span>插件，并且在系统管理中进行配置。配置逻辑，就给用户当前项目的矩阵权限！</li>\n</ul>\n</li>\n<li><p>与gitlab进行联接</p>\n<ul>\n<li>设置一个SSH Key，方便Jenkins去拉取Gitlab中的项目</li>\n<li>GItlab项目中去配置SSH Key的Deploy权限。<code>Settings -&gt; Repository -&gt; Deploy keys -&gt; Public Deploy Keys</code></li>\n<li>Jenkins添加SSH的私钥</li>\n</ul>\n<p>这样就完成了Jenkins可以访问gitlab的联接的过程。</p>\n<p>Jenkins层面，需要去安装Gitlab相关插件。</p>\n</li>\n</ol>\n<h3 id=\"插件介绍\"><a href=\"#插件介绍\" class=\"headerlink\" title=\"插件介绍\"></a>插件介绍</h3><ul>\n<li><p>Publish over SSH</p>\n<p>这个是一个远程Shell工具，可以远程去执行一些shell命令</p>\n</li>\n<li><p>HTTP Request Plugin</p>\n<p>跨平台调用，在构建前后可以通过该插件以http形式调用各种api接口实现和内部系统的联动</p>\n</li>\n<li><p>Publish Over FTP</p>\n<p>用于远程使用FTP发布，比较合适于静态资源的发布。</p>\n<p><img data-src=\"/./assets/20181225153134962.jpeg\" alt=\"img\"></p>\n</li>\n<li><p>Performance Plugin</p>\n</li>\n</ul>\n<p>​        该插件可以读取和解析测试框架输出的报告，并且在 Jenkins 上绘制性能和稳定性相关的图表。Performance Plugin 支持的测试框架有 JUnit、JMeter, Twitter 的 Lago 和 Taurus。下图是该插件输出的示例图：</p>\n<p><img data-src=\"/./assets/3dee2f58ccdf7cf25fa86074c5485184a9f.jpg\" alt=\"img\"></p>\n<p>​        <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbHVnaW5zLmplbmtpbnMuaW8vcGVyZm9ybWFuY2U=\">https://plugins.jenkins.io/performance</span></p>\n<ul>\n<li>Gitlab Merge Request Builder Plugin</li>\n</ul>\n<p>​        Gitlab Merge Request Builder Plugin 可以方便的自动发起代码审查，它在创建 pull request 的时候，会自动带上关联任务的运行结果，以方便代码审查着确认改动的正确性。</p>\n<p>​        同时，这款插件还支持自动合并，既在代码审查通过后自动合并该 pull request 内容。</p>\n<p>​        <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RpbW9scy9qZW5raW5zLWdpdGxhYi1tZXJnZS1yZXF1ZXN0LWJ1aWxkZXItcGx1Z2lu\">https://github.com/timols/jenkins-gitlab-merge-request-builder-plugin</span></p>\n<ul>\n<li>JIRA Plugin</li>\n</ul>\n<p>​        JIRA Plugin 可以让 Jenkins 任务和 JIRA 集成起来，这样项目管理者可以通过 JIRA 了解项目进度，开发者也可以通过该插件直接更改 JIRA 上的 issue 状态。</p>\n<p>​        <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbHVnaW5zLmplbmtpbnMuaW8vamlyYQ==\">https://plugins.jenkins.io/jira</span></p>\n<ul>\n<li>Kubernetes Plugin</li>\n</ul>\n<p>​        和最近大热的容器编排框架 Kubernetes 集成当然不能落下了。另外，Jenkins 对执行机的管理一直比较弱，无法做到快速的扩容和缩容。Kubernetes Plugin 通过引入 Kubernetes 的容器编排能力，让 Jenkins 执行机运行在 Kubernetes 环境中。</p>\n<p>​        <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2plbmtpbnNjaS9rdWJlcm5ldGVzLXBsdWdpbg==\">https://github.com/jenkinsci/kubernetes-plugin</span></p>\n<ul>\n<li>Build Pipeline plugin</li>\n</ul>\n<p>​        对一个系统的持续集成会包含很多个方面，如果将它们都杂糅在一个 Jenkins 任务中，会提高排查成本，也不利于整个持续集成的运作。Build Pipeline plugin 可以让项目管理员针对系统持续集成步骤设置一系列关联的任务，任务之间可以设置不同的触发条件，以确认何时需要人工介入。该插件可以让整个持续集成流程变得非常直观：</p>\n<p><img data-src=\"https://oscimg.oschina.net/oscnet/abf7ec185c847b72cd61181562f940557a2.jpg\" alt=\"img\"></p>\n<p>​        <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2plbmtpbnNjaS9idWlsZC1waXBlbGluZS1wbHVnaW4=\">https://github.com/jenkinsci/build-pipeline-plugin</span></p>\n<h3 id=\"配置自动化任务\"><a href=\"#配置自动化任务\" class=\"headerlink\" title=\"配置自动化任务\"></a>配置自动化任务</h3><p>两种执行方法：</p>\n<ol>\n<li>配置自由风格的项目</li>\n<li>配置Pipeline使用Jenkinsfile</li>\n</ol>\n<p>需要注意的地方</p>\n<ul>\n<li><p>SSH插件：</p>\n<p>SSH</p>\n<p>SSH Agent</p>\n<p>SSH Pipeline Steps</p>\n<p>Publish Over SSH</p>\n</li>\n<li><p>git相关插件：</p>\n<p>Gitlab</p>\n<p>Github</p>\n</li>\n<li><p>管理员界面配置：</p>\n<p><code>Settings -&gt; network -&gt; Outbound requests</code></p>\n<p>Allow requests to the local network from hooks and services 进行勾选</p>\n</li>\n</ul>\n<p>其他的一些用法：</p>\n<ul>\n<li>使用Jenkins配合Docker Hub，把前端代码打包成镜像，再远程部署</li>\n<li>Jenkins配合自建Docker容器服务，把前端代码打包，使用Kubernetes进行发布。</li>\n<li>使用Docker进行远程发布(远程服务器上有Docker服务，并且设置了远程连接)</li>\n</ul>\n<h2 id=\"TravisCI\"><a href=\"#TravisCI\" class=\"headerlink\" title=\"TravisCI\"></a>TravisCI</h2><h3 id=\"使用简介-1\"><a href=\"#使用简介-1\" class=\"headerlink\" title=\"使用简介\"></a>使用简介</h3><p>Travis CI 只支持 Github，不支持其他代码托管服务。这意味着，你必须满足以下条件，才能使用 Travis CI。</p>\n<blockquote>\n<ul>\n<li>拥有 GitHub 帐号</li>\n<li>该帐号下面有一个项目</li>\n<li>该项目里面有可运行的代码</li>\n<li>该项目还包含构建或测试脚本</li>\n</ul>\n</blockquote>\n<p>Travis简单的使用步骤:</p>\n<ul>\n<li>github授权及面板</li>\n<li>获取github的Tokens</li>\n<li>配置项目.travis.yml<ul>\n<li>Node项目</li>\n<li>Script脚本</li>\n<li>部署到github pages</li>\n<li>钩子用法</li>\n</ul>\n</li>\n<li>其他</li>\n</ul>\n<p><strong>github授权及面板</strong></p>\n<p>首先，访问官方网站 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmF2aXMtY2kub3JnLw==\">travis-ci.org</span>，点击右上角的个人头像，使用 Github 账户登入 Travis CI。</p>\n<p>会进入到授权页面，这里跟微博、QQ是一回事，主要是读取你的用户信息。</p>\n<p><img data-src=\"/./assets/image-20190612205411602.png\" alt=\"/images/image-20190612205411602\"></p>\n<p>这里第二步在，<code>Dashboard</code>这个选项卡中，点击<code>Activate</code>这个按钮</p>\n<p><img data-src=\"/./assets/image-20190612212459194.png\" alt=\"/images/image-20190612212459194\"></p>\n<p>完了之后，Dashboard会列出所有Github中有<code>.travis.yml</code>配置文件的仓库：</p>\n<p><img data-src=\"/./assets/image-20190612212731186.png\" alt=\"/images/image-20190612212731186\"></p>\n<p>Travis 会列出 Github 上面你的所有仓库，以及你所属于的组织。此时，选择你需要 Travis 帮你构建的仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。</p>\n<p><img data-src=\"/./assets/image-20190612213022380.png\" alt=\"/images/image-20190612213022380\"></p>\n<ul>\n<li><p><code>Settings</code>中用于配置项目的构建条件</p>\n<p><img data-src=\"/./assets/image-20190612214434173.png\" alt=\"/images/image-20190612214434173\"></p>\n</li>\n<li><p><code>Requests</code>可以查看构建记录</p>\n<p><img data-src=\"/./assets/image-20190612214519926.png\" alt=\"/images/image-20190612214519926\"></p>\n</li>\n<li><p><code>Caches</code>主要是缓存文件</p>\n</li>\n<li><p><code>Trigger build</code>手动触发构建</p>\n</li>\n</ul>\n<p><strong>获取github的token</strong></p>\n<p>在settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Generate new token</p>\n<p><img data-src=\"/./assets/image-20190612225000955.png\" alt=\"/images/image-20190612225000955\"></p>\n<p><strong>配置项目的.travis.yml文件</strong></p>\n<ul>\n<li><p>设置项目语言</p>\n<pre><code class=\"yaml\">language: node_js\nnode_js:\n  - &quot;10&quot;\n</code></pre>\n</li>\n<li><p>Script脚本</p>\n<p>Travis 的运行流程很简单，任何项目都会经过两个阶段。</p>\n<blockquote>\n<ul>\n<li>install 阶段：安装依赖</li>\n<li>script 阶段：运行脚本</li>\n</ul>\n</blockquote>\n<p>配置文件：</p>\n<pre><code class=\"yaml\"># S: Build Lifecycle\ninstall:\n  - yarn install\n\n// 钩子方法\nbefore_script:\n\n# 无其他依赖项所以执行npm run build 构建就行了\nscript:\n  - npm run build\n</code></pre>\n<p>如果不需要安装，即跳过安装阶段，就直接设为<code>true</code>。</p>\n<pre><code class=\"javascript\">install: true\n</code></pre>\n<p><code>script</code>字段用来指定构建或测试脚本。</p>\n<pre><code class=\"javascript\">script: bundle exec thor build\n</code></pre>\n<p>如果有多个脚本，可以写成下面的形式。</p>\n<pre><code class=\"javascript\">script:\n  - command1\n  - command2\n</code></pre>\n</li>\n<li><p>部署到github pages</p>\n<pre><code class=\"yaml\">deploy:\n    # 其他的一些配置项，可以参考：https://docs.travis-ci.com/user/deployment/pages/\n  provider: pages\n  skip_cleanup: true\n  local_dir: dist/\n  github_token: $GITHUB_TOKEN # Set in the settings page of your repository, as a secure variable\n  keep_history: false\n  on:\n    branch: master\n</code></pre>\n</li>\n<li><p>钩子用法</p>\n<p>Travis 为上面这些阶段提供了7个钩子。</p>\n<ul>\n<li>before_install：install 阶段之前执行</li>\n<li>before_script：script 阶段之前执行</li>\n<li>after_failure：script 阶段失败时执行</li>\n<li>after_success：script 阶段成功时执行</li>\n<li>before_deploy：deploy 步骤之前执行</li>\n<li>after_deploy：deploy 步骤之后执行</li>\n<li>after_script：script 阶段之后执行</li>\n</ul>\n<p>完整的生命周期，从开始到结束是下面的流程。</p>\n<ol>\n<li>before_install</li>\n<li>install</li>\n<li>before_script</li>\n<li>script</li>\n<li>after<em>success or after</em>failure</li>\n<li>[OPTIONAL] before_deploy</li>\n<li>[OPTIONAL] deploy</li>\n<li>[OPTIONAL] after_deploy</li>\n<li>after_script</li>\n</ol>\n</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZG9tZW5pYy9lYzhiMGZjOGFiNDVmMzk0MDNkZA==\">Auto-deploying built products to gh-pages with Travis</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vbmNsZXRvbS5pby8yMDE2L3RyYXZpcy1zc2gtZGVwbG95Lw==\">SSH deploys with Travis CI</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMTIvdHJhdmlzX2NpX3R1dG9yaWFsLmh0bWw=\">持续集成服务 Travis CI 教程</span></li>\n</ul>\n<h3 id=\"配置Node-js应用\"><a href=\"#配置Node-js应用\" class=\"headerlink\" title=\"配置Node.js应用\"></a>配置Node.js应用</h3><p>配置一个Vue实例并发布到github pages</p>\n<p>.travis.yml文件：</p>\n<pre><code class=\"yaml\">language: node_js\nnode_js:\n  - &quot;10&quot;\n\n# Travis-CI Caching\ncache:\n  directories:\n    - node_modules\n\n# S: Build Lifecycle\ninstall:\n  - yarn install\n\nbefore_script:\n\n# 无其他依赖项所以执行npm run build 构建就行了\nscript:\n  - npm run build\n\ndeploy:\n    # 其他的一些配置项，可以参考：https://docs.travis-ci.com/user/deployment/pages/\n  provider: pages\n  skip_cleanup: true\n  local_dir: dist/\n  github_token: $GITHUB_TOKEN # Set in the settings page of your repository, as a secure variable\n  keep_history: false\n  on:\n    branch: master\n</code></pre>\n<h2 id=\"CircleCI\"><a href=\"#CircleCI\" class=\"headerlink\" title=\"CircleCI\"></a>CircleCI</h2><h3 id=\"使用简介-2\"><a href=\"#使用简介-2\" class=\"headerlink\" title=\"使用简介\"></a>使用简介</h3><ol>\n<li><p>注册 CircleCI</p>\n<p>打开 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaXJjbGVjaS5jb20v\">CircleCI</span> 官方网站，使用您的GitHub帐户登录。</p>\n<p><img data-src=\"/./assets/image-20190613093550553.png\" alt=\"/images/image-20190613093550553\"></p>\n<p>进行授权：</p>\n<p><img data-src=\"/./assets/image-20190613093732415.png\" alt=\"/images/image-20190613093732415\"></p>\n</li>\n<li><p>启动存储库</p>\n</li>\n</ol>\n<p>检查要在 CircleCI 上管理的存储库的开关按钮。</p>\n<p><img data-src=\"/./assets/image-20190613094115350.png\" alt=\"/images/image-20190613094115350\"></p>\n<ol start=\"3\">\n<li><p>编写 config.yml</p>\n<pre><code class=\"yaml\">version: 2\njobs:\n  build:\n    docker:\n      ...\n    branches:\n      ...\n    steps:\n      ...\n        environment:\n            ...\n</code></pre>\n<p>官方参考文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaXJjbGVjaS5jb20vZG9jcy8yLjAvY29uZmlndXJhdGlvbi1yZWZlcmVuY2UvI3ZlcnNpb24=\">https://circleci.com/docs/2.0/configuration-reference/#version</span></p>\n<p>来看一个完事版的配置</p>\n<pre><code class=\"yaml\">version: 2\njobs:\n  build:\n    docker:\n      - image: ubuntu:14.04\n\n      - image: mongo:2.6.8\n        command: [mongod, --smallfiles]\n\n      - image: postgres:9.4.1\n        # some containers require setting environment variables\n        environment:\n          POSTGRES_USER: root\n\n      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673\n\n      - image: rabbitmq:3.5.4\n\n    environment:\n      TEST_REPORTS: /tmp/test-reports\n\n    working_directory: ~/my-project\n\n    steps:\n      - checkout\n\n      - run:\n          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts\n\n      # Create Postgres users and database\n      # Note the YAML heredoc &#39;|&#39; for nicer formatting\n      - run: |\n          sudo -u root createuser -h localhost --superuser ubuntu &amp;&amp;\n          sudo createdb -h localhost test_db\n\n      - restore_cache:\n          keys:\n            - v1-my-project-&#123;&#123; checksum \"project.clj\" &#125;&#125;\n            - v1-my-project-\n\n      - run:\n          environment:\n            SSH_TARGET: &quot;localhost&quot;\n            TEST_ENV: &quot;linux&quot;\n          command: |\n            set -xu\n            mkdir -p $&#123;TEST_REPORTS&#125;\n            run-tests.sh\n            cp out/tests/*.xml $&#123;TEST_REPORTS&#125;\n\n      - run: |\n          set -xu\n          mkdir -p /tmp/artifacts\n          create_jars.sh $&#123;CIRCLE_BUILD_NUM&#125;\n          cp *.jar /tmp/artifacts\n\n      - save_cache:\n          key: v1-my-project-&#123;&#123; checksum \"project.clj\" &#125;&#125;\n          paths:\n            - ~/.m2\n\n      # Save artifacts\n      - store_artifacts:\n          path: /tmp/artifacts\n          destination: build\n\n      # Upload test results\n      - store_test_results:\n          path: /tmp/test-reports\n\n  deploy-stage:\n    docker:\n      - image: ubuntu:14.04\n    working_directory: /tmp/my-project\n    steps:\n      - run:\n          name: Deploy if tests pass and branch is Staging\n          command: ansible-playbook site.yml -i staging\n\n  deploy-prod:\n    docker:\n      - image: ubuntu:14.04\n    working_directory: /tmp/my-project\n    steps:\n      - run:\n          name: Deploy if tests pass and branch is Master\n          command: ansible-playbook site.yml -i production\n\nworkflows:\n  version: 2\n  build-deploy:\n    jobs:\n      - build:\n          filters:\n            branches:\n              ignore:\n                - develop\n                - /feature-.*/\n      - deploy-stage:\n          requires:\n            - build\n          filters:\n            branches:\n              only: staging\n      - deploy-prod:\n          requires:\n            - build\n          filters:\n            branches:\n              only: master\n</code></pre>\n</li>\n<li><p>设置&#x2F;查看任务</p>\n<p><img data-src=\"/./assets/image-20190613093327981.png\" alt=\"/images/image-20190613093327981\"></p>\n</li>\n</ol>\n<h3 id=\"配置Node-js应用-1\"><a href=\"#配置Node-js应用-1\" class=\"headerlink\" title=\"配置Node.js应用\"></a>配置Node.js应用</h3><p><code>.circleci/config.yml</code>配置文件</p>\n<pre><code class=\"yaml\">version: 2\njobs:\n  build:\n    docker:\n      - image: circleci/node:10\n    branches:\n      only:\n        - master\n    steps:\n      - add_ssh_keys:\n          fingerprints:\n            - &quot;c5:20:8e:79:81:19:fd:c1:6c:c4:fb:41:58:92:9d:4f&quot;\n      - checkout\n      - restore_cache:\n          keys:\n            # fallback to using the latest cache if no exact match is found\n            - dependencies-\n      - run:\n          name: Install\n          command: yarn install\n      - save_cache:\n          paths:\n            - node_modules\n          key: dependencies-\n      - run:\n          name: build github pages\n          command: yarn build\n      - run:\n          name: Prepare shell commands\n          command: chmod +x scripts/deploy.sh\n      - run:\n          name: Run deploy scripts\n          command: ./scripts/deploy.sh\n</code></pre>\n<p>这里以发布到github page为示例：</p>\n<p>deploy.sh文件的内容：</p>\n<pre><code class=\"bash\">#!/bin/sh\n# ideas used from https://gist.github.com/motemen/8595451\n\n# Based on https://github.com/eldarlabs/ghpages-deploy-script/blob/master/scripts/deploy-ghpages.sh\n# Used with their MIT license https://github.com/eldarlabs/ghpages-deploy-script/blob/master/LICENSE\n\n# abort the script if there is a non-zero error\nset -e\n\n# show where we are on the machine\npwd\nremote=$(git config remote.origin.url)\n\necho &#39;remote is: &#39;$remote\n\n# make a directory to put the gp-pages branch\nmkdir gh-pages-branch\ncd gh-pages-branch\n# now lets setup a new repo so we can update the gh-pages branch\ngit config --global user.email &quot;$GH_EMAIL&quot; &gt; /dev/null 2&gt;&amp;1\ngit config --global user.name &quot;$GH_NAME&quot; &gt; /dev/null 2&gt;&amp;1\ngit init\ngit remote add --fetch origin &quot;$remote&quot;\n\necho &#39;email is: &#39;$GH_EMAIL\necho &#39;name is: &#39;$GH_NAME\necho &#39;sitesource is: &#39;$siteSource\n\n# switch into the the gh-pages branch\nif git rev-parse --verify origin/gh-pages &gt; /dev/null 2&gt;&amp;1\nthen\n    git checkout gh-pages\n    # delete any old site as we are going to replace it\n    # Note: this explodes if there aren&#39;t any, so moving it here for now\n    git rm -rf .\nelse\n    git checkout --orphan gh-pages\nfi\n\n# copy over or recompile the new site\ncp -a &quot;../$&#123;siteSource&#125;/.&quot; .\n\nls -la\n\n# stage any changes and new files\ngit add -A\n# now commit, ignoring branch gh-pages doesn&#39;t seem to work, so trying skip\ngit commit --allow-empty -m &quot;Deploy to GitHub pages [ci skip]&quot;\n# and push, but send any output to /dev/null to hide anything sensitive\ngit push --force --quiet origin gh-pages\n# go back to where we started and remove the gh-pages git repo we made and used\n# for deployment\ncd ..\nrm -rf gh-pages-branch\n\necho &quot;Finished Deployment!&quot;\n</code></pre>\n<p>说明：</p>\n<p><strong>&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1的含义</strong> </p>\n<p><strong>文件描述符</strong></p>\n<p>当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">文件描述符</th>\n<th align=\"left\">默认情况</th>\n<th align=\"left\">对应文件句柄位置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">标准输入（standard input）</td>\n<td align=\"left\">0</td>\n<td align=\"left\">从键盘获得输入</td>\n<td align=\"left\">&#x2F;proc&#x2F;slef&#x2F;fd&#x2F;0</td>\n</tr>\n<tr>\n<td align=\"left\">标准输出（standard output）</td>\n<td align=\"left\">1</td>\n<td align=\"left\">输出到屏幕（即控制台）</td>\n<td align=\"left\">&#x2F;proc&#x2F;slef&#x2F;fd&#x2F;1</td>\n</tr>\n<tr>\n<td align=\"left\">错误输出（error output）</td>\n<td align=\"left\">2</td>\n<td align=\"left\">输出到屏幕（即控制台）</td>\n<td align=\"left\">&#x2F;proc&#x2F;slef&#x2F;fd&#x2F;2</td>\n</tr>\n</tbody></table>\n<p><code>&gt;</code> 代表重定向到哪里?</p>\n<p>例如：<code>echo &quot;123&quot; &gt; /home/123.txt</code><br><code>1</code> 表示<code>stdout</code>标准输出，系统默认值是<code>1</code>，所以<code>&gt;/dev/null</code>等同于<code>1&gt;/dev/null</code><br><code>2</code> 表示<code>stderr</code>标准错误<br><code>&amp;</code> 表示等同于的意思，<code>2&gt;&amp;1</code>，表示<code>2</code>的输出重定向等同于<code>1</code> </p>\n<p>参考资料：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGlueXdhbi9wLzYwMjU0NjguaHRtbA==\">Shell脚本———— &#x2F;dev&#x2F;null 2&gt;&amp;1详解</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2t5ZWNoaW5hL2FydGljbGUvZGV0YWlscy81NDU4MjE0Ng==\">shell中&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0aG9tZXIvYXJ0aWNsZS9kZXRhaWxzLzkyODgzNTM=\">Linux Shell 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 含义</span></p>\n<h2 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h2><h3 id=\"自动化流程的发展趋势\"><a href=\"#自动化流程的发展趋势\" class=\"headerlink\" title=\"自动化流程的发展趋势\"></a>自动化流程的发展趋势</h3><ol>\n<li><p>集中化</p>\n<p>以集群为基础，服务采用Saas方式进行交付。所有折构建、测试、发布全集中进行管理。</p>\n</li>\n<li><p>微服务+无服务的应用模式</p>\n<p>应用程序执行环境的管理被新的编程模型和平台取代后，团队的交付生产率得到了进一步的提升。一方面它免去了很多环境管理的工作，包括设备、网络、主机以及对应的软件和配置工作，使得软件运行时环境更加稳定。另一方面，它大大降低了团队采用DevOps的技术门槛。</p>\n<p><strong>无服务器风格的架构（Serverless architecture）</strong>把DevOps技术在微服务领域的应用推向极致。当应用程序执行环境的管理被新的编程模型和平台取代后，团队的交付生产率得到了进一步的提升。一方面它免去了很多环境管理的工作，包括设备、网络、主机以及对应的软件和配置工作，使得软件运行时环境更加稳定。另一方面，它大大降低了团队采用DevOps的技术门槛。</p>\n<p>在微服务端到端交付流程上，Netflix开源了自家的<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zcGlubmFrZXIuaW8v\">Spinnaker</span>，Netflix作为微服务实践的先锋，不断推出新的开源工具来弥补社区中微服务技术和最佳实践的缺失。而<span class=\"exturl\" data-url=\"aHR0cDovL3Byb2plY3RzLnNwcmluZy5pby9zcHJpbmctY2xvdWQv\">Spring Cloud</span>则为开发者提供了一系列工具，以便他们在所熟悉的Spring技术栈下使用这些服务协调技术(coordination techniques)，如服务发现、负载均衡、熔断和健康检查。</p>\n</li>\n<li><p>人工智能领域的应用</p>\n<p>DevOps的最早实践来自于互联网企业的Web应用，相应的思想被引入企业级应用并促进了一系列工具的发展。在人工智能领域，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcv\">TensorFlow</span>就是这样一个例子，它可以有多种DevOps友好的安装和部署方式 ，例如采用Docker进行部署。</p>\n<p>随着Python在大数据、人工智能、区块链、微服务以及Docker中的发展，可以预见Python在日后的领域仍然会发挥重要的作用。</p>\n</li>\n<li><p>安全推动DevOps的发展</p>\n<p>全是DevOps永远绕不开的话题，也往往是新技术在传统行业（例如金融和电信）应用中的最大阻碍。一方面，组织结构的转型迫使企业要打破原先的部门墙，这意味着很多原先的控制流程不再适用。另一方面，由于大量的DevOps技术来源于开源社区，缺乏强大技术实力的企业在应用相关技术时不免会有所担忧。</p>\n</li>\n<li><p>Windows平台下.net的技术潜力巨大</p>\n<p>长期以来，Windows和.NET平台下的DevOps一直都是一个被低估的领域。一方面，社区缺乏对 Windows Server平台的兴趣。另一方面，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21tdW5pdHkuc3BpY2V3b3Jrcy5jb20vbmV0d29ya2luZy9hcnRpY2xlcy8yNDYyLXNlcnZlci12aXJ0dWFsaXphdGlvbi1hbmQtb3MtdHJlbmRz\">Windows Server却有接近90%的市场占用率</span>，在Web服务器领域则有<span class=\"exturl\" data-url=\"aHR0cHM6Ly93M3RlY2hzLmNvbS90ZWNobm9sb2dpZXMvb3ZlcnZpZXcvb3BlcmF0aW5nX3N5c3RlbS9hbGw=\">33.5%的市场占有率</span>。</p>\n</li>\n<li><p>非功能性自动化测试工具逐渐完善</p>\n<p>自动化测试水平往往是衡量DevOps技术能力高低的重要指标，尤其是针对生产环境应用程序的非功能性自动化测试工具。一直以来，技术雷达都在尝试从不同的角度宣扬自动化测试的重要性，从软件的开发阶段延展到了整个应用生命周期甚至整体IT资产的管理上。</p>\n</li>\n</ol>\n<h3 id=\"复杂的DevOps相关工具\"><a href=\"#复杂的DevOps相关工具\" class=\"headerlink\" title=\"复杂的DevOps相关工具\"></a>复杂的DevOps相关工具</h3><p><img data-src=\"/./assets/devops-hero-1-87966cfbc9c5713ae047551c7b22985c.png\" alt=\"DevOps\"></p>\n<h3 id=\"Jenkins的一些应用场景\"><a href=\"#Jenkins的一些应用场景\" class=\"headerlink\" title=\"Jenkins的一些应用场景\"></a>Jenkins的一些应用场景</h3><p>打包平台：</p>\n<p>使用Jenkins搭建iOS&#x2F;Android</p>\n<p>测试平台：</p>\n<p>jenkins + python + selenium</p>\n<p>Jmeter+maven+Jenkins构建云性能测试平台</p>\n<p>Jenkins+PMD构建自动化静态代码检测</p>\n<p>使用jenkins+Emma统计</p>\n<p>客户端单元测试覆盖率</p>\n<p>Jenkins+Ant+Java+Junit+SVN执行junit单元测试</p>\n<p>jenkins+ant+jmeter搭建持续集成的接口测试平台</p>\n<p>自动部署：</p>\n<p>Jenkins+GitLab+蒲公英+FTP</p>\n<p>jenkins结合ansible用shell实现自动化部署和回滚</p>\n<p>持续集成：</p>\n<p>Tomcat+Sonar搭建持续集成环境</p>\n<p>Maven+Nexus+Jenkins+git&#x2F;SVN</p>\n<h3 id=\"Jenkins的Docker-compose-yml创建文件\"><a href=\"#Jenkins的Docker-compose-yml创建文件\" class=\"headerlink\" title=\"Jenkins的Docker-compose.yml创建文件\"></a>Jenkins的Docker-compose.yml创建文件</h3><pre><code class=\"bash\">version: &#39;3&#39;\nservices:\n  jenkins:\n    container_name: &#39;jenkins&#39;\n    image: jenkins/jenkins\n    restart: always\n    user: jenkins:&lt;这里填Docker用户组的ID，见下面&gt;\n    ports:\n    - &quot;8080:8080&quot;\n    - &quot;50000:50000&quot;\n    volumes:\n    - /home/jenkins/data:/var/jenkins_home\n    - /usr/bin/docker:/usr/bin/docker\n    - /var/run/docker.sock:/var/run/docker.sock\n</code></pre>\n<p>上面的脚本使用注意：</p>\n<ol>\n<li><p>创建本地jenkins数据目录</p>\n<pre><code class=\"bash\">mkdir -p /home/jenkins\n</code></pre>\n</li>\n<li><p>查看docker用户组的ID</p>\n<pre><code class=\"bash\">cat /etc/group |grep docker\n</code></pre>\n</li>\n<li><p>执行<code>docker-compose up -d</code></p>\n</li>\n</ol>\n<h3 id=\"gitlab的docker启动配置文件\"><a href=\"#gitlab的docker启动配置文件\" class=\"headerlink\" title=\"gitlab的docker启动配置文件\"></a>gitlab的docker启动配置文件</h3><p>项目地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NhbWVlcnNibi9kb2NrZXItZ2l0bGFi\">https://github.com/sameersbn/docker-gitlab</span></p>\n<pre><code class=\"yaml\">version: &#39;2&#39;\n\nservices:\n  redis:\n    restart: always\n    image: sameersbn/redis:4.0.9-1\n    command:\n    - --loglevel warning\n    volumes:\n    - /srv/docker/gitlab/redis:/var/lib/redis:Z\n\n  postgresql:\n    restart: always\n    image: sameersbn/postgresql:10\n    volumes:\n    - /srv/docker/gitlab/postgresql:/var/lib/postgresql:Z\n    environment:\n    - DB_USER=gitlab\n    - DB_PASS=password\n    - DB_NAME=gitlabhq_production\n    - DB_EXTENSION=pg_trgm\n\n  gitlab:\n    restart: always\n    image: sameersbn/gitlab:11.11.2\n    depends_on:\n    - redis\n    - postgresql\n    ports:\n    - &quot;10080:80&quot;\n    - &quot;10022:22&quot;\n    volumes:\n    - /srv/docker/gitlab/gitlab:/home/git/data:Z\n    environment:\n    - DEBUG=false\n\n    - DB_ADAPTER=postgresql\n    - DB_HOST=postgresql\n    - DB_PORT=5432\n    - DB_USER=gitlab\n    - DB_PASS=password\n    - DB_NAME=gitlabhq_production\n\n    - REDIS_HOST=redis\n    - REDIS_PORT=6379\n\n    - TZ=Asia/Kolkata\n    - GITLAB_TIMEZONE=Kolkata\n\n    - GITLAB_HTTPS=false\n    - SSL_SELF_SIGNED=false\n\n    # 这里修改成服务器的IP或者域名\n    - GITLAB_HOST=localhost\n    - GITLAB_PORT=10080\n    - GITLAB_SSH_PORT=10022\n    - GITLAB_RELATIVE_URL_ROOT=\n    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string\n    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string\n    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string\n\n        # 这里给一个长度大于8的密码\n    - GITLAB_ROOT_PASSWORD=12345678\n    - GITLAB_ROOT_EMAIL=itheima@itcast.cn\n\n    - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true\n    - GITLAB_NOTIFY_PUSHER=false\n\n    - GITLAB_EMAIL=notifications@example.com\n    - GITLAB_EMAIL_REPLY_TO=noreply@example.com\n    - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com\n\n    - GITLAB_BACKUP_SCHEDULE=daily\n    - GITLAB_BACKUP_TIME=01:00\n\n    - SMTP_ENABLED=false\n    - SMTP_DOMAIN=www.example.com\n    - SMTP_HOST=smtp.gmail.com\n    - SMTP_PORT=587\n    - SMTP_USER=mailer@example.com\n    - SMTP_PASS=password\n    - SMTP_STARTTLS=true\n    - SMTP_AUTHENTICATION=login\n\n    - IMAP_ENABLED=false\n    - IMAP_HOST=imap.gmail.com\n    - IMAP_PORT=993\n    - IMAP_USER=mailer@example.com\n    - IMAP_PASS=password\n    - IMAP_SSL=true\n    - IMAP_STARTTLS=false\n\n    - OAUTH_ENABLED=false\n    - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER=\n    - OAUTH_ALLOW_SSO=\n    - OAUTH_BLOCK_AUTO_CREATED_USERS=true\n    - OAUTH_AUTO_LINK_LDAP_USER=false\n    - OAUTH_AUTO_LINK_SAML_USER=false\n    - OAUTH_EXTERNAL_PROVIDERS=\n\n    - OAUTH_CAS3_LABEL=cas3\n    - OAUTH_CAS3_SERVER=\n    - OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false\n    - OAUTH_CAS3_LOGIN_URL=/cas/login\n    - OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate\n    - OAUTH_CAS3_LOGOUT_URL=/cas/logout\n\n    - OAUTH_GOOGLE_API_KEY=\n    - OAUTH_GOOGLE_APP_SECRET=\n    - OAUTH_GOOGLE_RESTRICT_DOMAIN=\n\n    - OAUTH_FACEBOOK_API_KEY=\n    - OAUTH_FACEBOOK_APP_SECRET=\n\n    - OAUTH_TWITTER_API_KEY=\n    - OAUTH_TWITTER_APP_SECRET=\n\n    - OAUTH_GITHUB_API_KEY=\n    - OAUTH_GITHUB_APP_SECRET=\n    - OAUTH_GITHUB_URL=\n    - OAUTH_GITHUB_VERIFY_SSL=\n\n    - OAUTH_GITLAB_API_KEY=\n    - OAUTH_GITLAB_APP_SECRET=\n\n    - OAUTH_BITBUCKET_API_KEY=\n    - OAUTH_BITBUCKET_APP_SECRET=\n\n    - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL=\n    - OAUTH_SAML_IDP_CERT_FINGERPRINT=\n    - OAUTH_SAML_IDP_SSO_TARGET_URL=\n    - OAUTH_SAML_ISSUER=\n    - OAUTH_SAML_LABEL=&quot;Our SAML Provider&quot;\n    - OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient\n    - OAUTH_SAML_GROUPS_ATTRIBUTE=\n    - OAUTH_SAML_EXTERNAL_GROUPS=\n    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL=\n    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME=\n    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_USERNAME=\n    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME=\n    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME=\n\n    - OAUTH_CROWD_SERVER_URL=\n    - OAUTH_CROWD_APP_NAME=\n    - OAUTH_CROWD_APP_PASSWORD=\n\n    - OAUTH_AUTH0_CLIENT_ID=\n    - OAUTH_AUTH0_CLIENT_SECRET=\n    - OAUTH_AUTH0_DOMAIN=\n\n    - OAUTH_AZURE_API_KEY=\n    - OAUTH_AZURE_API_SECRET=\n    - OAUTH_AZURE_TENANT_ID=\n</code></pre>\n","categories":["持续集成与部署"],"tags":["持续集成","持续部署"]},{"title":"正则编写方式","url":"/2024/01/10/%E6%AD%A3%E5%88%99/","content":"<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><blockquote>\n<p>regular expression : RegExp</p>\n<p>用来处理字符串的规则</p>\n<ul>\n<li>只能处理字符串</li>\n<li>它是一个规则 : 可以验证字符串是否符合某个规则 (test) ，也可以把字符串中符合规则的内容捕获到 (exec &#x2F; match …)</li>\n</ul>\n</blockquote>\n<pre><code class=\"js\">let str = &quot;good good study, day day up! &quot;;\n//=&gt; 学正则就是用来制定规则 (是否包含数字)\nlet reg = /\\d+/;\nreg.test(str); //=&gt; false\n\nstr = &quot;2022-08-05&quot;;\nreg.exec(str); //=&gt;[&quot;2019&quot;,index:0,inputs:&quot;原始字符串&quot;]\n</code></pre>\n<h2 id=\"编写正则表达式\"><a href=\"#编写正则表达式\" class=\"headerlink\" title=\"编写正则表达式\"></a><strong>编写正则表达式</strong></h2><h3 id=\"创建方式有两种\"><a href=\"#创建方式有两种\" class=\"headerlink\" title=\"创建方式有两种\"></a>创建方式有两种</h3><pre><code class=\"js\">//=&gt;字面量创建方式 (两个斜杆之间包起来的，都是用来描述规则的元字符)\nlet reg1 = /\\d+/;\n\n//=&gt;构造函数模式创建  两个参数: 元字符字符串 , 修饰符字符串\nlet reg2 = new RegExp(&quot;\\\\d+&quot;);\n</code></pre>\n<p>正则表达式由两部分组成</p>\n<ul>\n<li>元字符</li>\n<li>修饰符</li>\n</ul>\n<pre><code class=\"js\">/*常用的元字符*/\n//=&gt;1.量词元字符: 设置出现的次数\n*  零到多次\n+  一到多次\n?  零次或者一次\n&#123;n&#125;  出现n次 (n需为0或者正整数)\n&#123;n,&#125;  出现n到多次\n&#123;n,m&#125;  出现n到m次 (包含n和m)\n\n//=&gt;2.特殊元字符: 单个或者组合在一起代表特殊的含义\n\\    转义字符(普通-&gt;特殊-&gt;普通)\n.    除\\n (换行符) 以外的任意字符\n^    以哪一个元字符作为开始\n$    以哪一个元字符作为结束\n\\n   换行符\n\\d   0~9之间的数字\n\\D   非0~9之间的数字 (大写和小写的意思是相反的)\n\\w   数字、字母、下划线中的任意一个字符\n\\s   一个空白字符 (包含空格、制表符、换页符等)\n\\t   一个制表符 (一个TAb键:四个空格)\n\\b   匹配一个单词的边界\nx|y  x或者y中的一个字符  (1|5|9)\n[xyz] x或者y或者z中的一个字符  [adghve2375]\n[^xy] 除了x/y以外的任意字符\n[a-z] 指定a-z这个范围中的任意字符  [0-9a-zA-Z_](0-9或者a-z或者A-Z或者_中的一个字符) === \\w\n[^a-z] 上一个取反&quot;非&quot;\n()    正则中的分组符号\n(?:)  只匹配不捕获\n(?=)  正向预查\n(?!)  负向预查\n\n//=&gt;3.普通元字符: 代表本身含义\n/jiangbing/ 此正则匹配的就是&quot;jiangbing&quot;\n</code></pre>\n<pre><code class=\"js\">/*正则表达式常用的修饰符: img*/\ni =&gt;ignoreCase  忽略单词大小写匹配\nm =&gt;multiline   可以进行多行匹配\ng =&gt;global      全局匹配\n\n/*\n *\t/A/.test(&#39;lalala&#39;); //=&gt;fasle\n *\t/A/i.test(&#39;lalala&#39;); //=&gt;true\n */\n</code></pre>\n<h3 id=\"元字符详细解析\"><a href=\"#元字符详细解析\" class=\"headerlink\" title=\"元字符详细解析\"></a><strong>元字符详细解析</strong></h3><p><code>^$</code></p>\n<pre><code class=\"js\">let reg = /^\\d/;\nconsole.log(reg.test(&quot;jiangbing&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;2022jiangbing&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;jiangbing2022&quot;)); //=&gt;false\n</code></pre>\n<pre><code class=\"js\">let reg = /\\d$/;\nconsole.log(reg.test(&quot;jiangbing&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;2022jiangbing&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;jiangbing2022&quot;)); //=&gt;true\n</code></pre>\n<pre><code class=\"js\">//=&gt;^/$两个都不加: 字符串中包含符合规则的内容即可\nlet reg = /\\d+/;\n//=^/$两个都加: 字符串只能是和规则一致的内容\nlet reg = /^\\d+$/;\n\n//=&gt;举个例子: 验证手机号码(11位，第一个数字是1即可)\nlet reg = /^1\\d&#123;10&#125;$/;\n</code></pre>\n<p><code>\\</code></p>\n<pre><code class=\"js\">//=&gt;.不是小数点，是除\\n外的任意字符\nlet reg = /^2.3$/;\nconsole.log(reg.test(&quot;2.3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2@3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;23&quot;)); //=&gt;fasle\n\n//=&gt;基于转义字符，让其只能代表小数点\nlet reg = /^2\\.3$/;\nconsole.log(reg.test(&quot;2.3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2@3&quot;)); //=&gt;false\n\nlet str = &quot;\\\\d&quot;;\nreg = /^\\d$/;  //=&gt;\\d代表0-9的数字\nconsole.log(reg.test(&quot;str&quot;)); //=&gt;fasle\nreg = /^\\\\d$/;  //=&gt;把特殊符号转换为普通的\nconsole.log(reg.test(&quot;str&quot;)); //=&gt;true\n</code></pre>\n<p><code>x|y</code></p>\n<pre><code class=\"js\">let reg = /^18|29$/;\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;29&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;129&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;189&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;1829&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;829&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;182&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;82&quot;)); //=&gt;fasle\n\n//---直接x|y会存在很乱的优先级问题，一般我们写的时候都伴随着小括号进行分组，因为小括号改变处理的优先级 =&gt;小括号: 分组\nlet reg = /^(18|29)$/;\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;29&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;129&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;189&quot;)); //=&gt;fasle\n//=&gt;只能是18或者29中的一个了\n</code></pre>\n<p><code>[]</code></p>\n<pre><code class=\"js\">//1.中括号中出现的字符一般都代表本身的含义\nlet reg = /^[@+]$/;\nconsole.log(reg.test(&quot;@&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;+&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;@@&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;@+&quot;)); //=&gt;false\n\nreg = /^[\\d]$/; //=&gt;\\d在中括号中还是0-9\nconsole.log(reg.test(&quot;d&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;\\\\&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;true\n\nreg = /^[\\\\d]$/; //=&gt;\\d已经被\\转义\nconsole.log(reg.test(&quot;d&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;\\\\&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;false\n\n//2.中括号中不存在多位数\nreg = /^[18]$/;\nconsole.log(reg.test(&quot;1&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;8&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;false\n\nreg = /^[10-29]$/; //=&gt;1或者0-2或者9\nconsole.log(reg.test(&quot;1&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;0&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;10&quot;)); //=&gt;false\n</code></pre>\n<h3 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a><strong>常用的正则表达式</strong></h3><p>1.验证是否为有效数字</p>\n<pre><code class=\"js\">/*\n *\t规则分析\n *\t\t1.可能出现 + - 号，也可能不出现  [+-]?\n *\t\t2.一位0-9都可以，多位首位不能为0  (\\d|([1-9]\\d+)\n *\t\t3.小数点部分可能有可能没有，一旦有后面必须有小数点+数字  (\\.\\d+)?\n */\nlet reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/;\n</code></pre>\n<p>2.验证密码</p>\n<pre><code class=\"js\">//=&gt;数字、字母、下划线\n//=&gt;6~16位\nlet val = userPassInp.value,\n    reg = /^\\w&#123;6,16&#125;$/;\nlet flag = reg.test(val);\n\n/*\nfunction checkPass(val)&#123;\n    if(val.length &lt;6 || val.length &gt;16)&#123;\n        alert(&#39;长度必须介于6-16位之间!&#39;);\n        retrun;\n    &#125;\n    let area = [&#39;a&#39;,&#39;b&#39;...&#39;_&#39;]; //=&gt;包含数字、字母、下划线\n    for(let i=0;i&lt;val.length;i++)&#123;\n        let char = val[i];\n        if(!area.includes(char))&#123;\n            alert(&quot;格式不正确&quot;);\n            return;\n        &#125;\n    &#125;\n&#125;\n*/\n</code></pre>\n<p>3.验证真实姓名</p>\n<pre><code class=\"js\">/*\n *\t1.验证汉字  /^[\\u4E00-\\u9FA5]$/\n *\t2.名字长度 2~10位\n *\t3.可能有译名 ·汉字  (·[\\u4E00-\\u9FA5]&#123;2,10&#125;)&#123;0,2&#125;\n */\nlet reg = /^[\\u4E00-\\u9FA5]&#123;2,10&#125;(·[\\u4E00-\\u9FA5]&#123;2,10&#125;)&#123;0,2&#125;$/;\n</code></pre>\n<p>4.验证邮箱</p>\n<pre><code class=\"js\">let reg = /^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/;\n\n//=&gt; \\w+((-\\w+)|(\\.\\w+))*\n// 1.开头是数字字母下划线 (1到多位)\n// 2.还可以是 &quot;-数字字母下划线 或者 .数字字母下划线&quot;，整体零到多次\n// 邮箱的名字由&quot;数字、字母、下划线、-、.&quot;几部分组成，但是-/.不能连续出现也不能作为开始\n\n//=&gt; @[A-Za-z0-9]+\n// 1.@后面紧跟着: 数字、字母 (1-多位)\n\n//=&gt; ((\\.|-)[A-Za-z0-9]+)*\n// 1.对@后面名字的补充\n// 多域名   .com.cn\n// 企业域名  zxt@zhufeng-peixun-office.com\n\n//=&gt; \\.[A-Za-z0-9]+\n// 1. @xxx.com / @xxx.cn 这个匹配的是最后的域名 (.com/.cn/.org/.edu/.net/.vip...)\n</code></pre>\n<p>5.身份证号码</p>\n<pre><code class=\"js\">/*\n *\t1.一共18位\n *\t2.最后一位可能是X\n *\n *\t身份证前六位: 省市县 130828\n *\t中间八位: 年月日\n *\t最后四位:\n *\t\t最后一位 =&gt; X或者数字\n *\t\t倒数第二位 =&gt; 偶数 女  奇数 男\n *\t\t其余的是经过算法算出来的\n */\n//let reg = /^\\d&#123;17&#125;(\\d|X)$/;\n//=&gt;小括号分组的第二个作用: 分组捕获，不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容\nlet reg = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)\\d&#123;2&#125;(\\d)(\\d|X)$/;\nreg.exec(&quot;130828199012040617&quot;);//=&gt;[&#39;130828199012040617&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, &#39;7&#39;, index: 0, input: &#39;130828199012040617&#39;, groups: undefined] 捕获结果是一个数组，包含每一个小分组单独获取的内容\n</code></pre>\n<p><strong>正则两种创建方式的区别</strong></p>\n<pre><code class=\"js\">//=&gt;构造函数因为传递的是字符串，\\需要写两个才代表斜杆\nlet reg = /\\d+/g;\nreg = new RegExp(&quot;\\\\d+&quot;,&quot;g&quot;);\n\n//=&gt;正则表达式中的部分内容是变量存储的值\n// 1.两个斜杆中间包起来的都是元字符 (如果正则中要包含某个变量的值，则不能使用字面量方式创建)\nlet type = &#39;zhufeng&#39;;\nreg = /^@&quot;+type+&quot;@$/;\nconsole.log(reg.test(&quot;@zhufeng@&quot;)); //=&gt;false\nconsole.log(reg.test(&#39;@&quot;&quot;&quot;typeeee&quot;@&#39;)); //=true\n// 2.这种情况只能使用构造函数方式(因为它传递的规则是字符串，只有这样才能进行字符拼接)\nreg = new RegExp(&quot;^@&quot;+type+&quot;@$&quot;);\nconsole.log(reg.test(&quot;@zhufeng@&quot;)); //=&gt;true\n</code></pre>\n<hr>\n<h2 id=\"正则的捕获\"><a href=\"#正则的捕获\" class=\"headerlink\" title=\"正则的捕获\"></a><strong>正则的捕获</strong></h2><blockquote>\n<p>实现正则捕获的办法</p>\n<ul>\n<li>正则RegExp.prototype上的方法<ul>\n<li>exec</li>\n<li>test</li>\n</ul>\n</li>\n<li>字符串String.prototype上支持正则表达式处理的方法<ul>\n<li>replace</li>\n<li>match</li>\n<li>splite</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"js\">let str = &quot;zhufeng2022yangfan2023qihang2024&quot;;\nlet reg = /\\d+/;\n/*\n *\t基于exec实现正则的捕获\n *\t\t1.捕获到的结果是null或者一个数组\n *\t\t\t数组第一项: 本次捕获到的内容\n *\t\t\t其余项: 对应小分组本次单独捕获的内容\n *\t\t\tindex: 当前捕获内容在字符串中的起始索引\n *\t\t\tinput: 原始字符串\n *\t\t2.每执行一次exec，只能捕获到一个符合正则规则的，但是默认情况下，我们执行100遍，获取的结果永远都是第一个匹配到的，其余的捕获不到\n *\t\t=&gt;&quot;正则捕获的懒惰性&quot;: 默认只捕获第一个\n */\nconsole.log(reg.exec(str)); //=&gt;[&#39;2022&#39;, index: 7, input: &#39;zhufeng2022yangfan2023qihang2023&#39;]\n\n/*\n//=&gt;实现正则捕获的前提是: 当前正则要和字符串匹配，如果不匹配捕获的结果是null\nlet reg = /^\\d+$/;\nconsole.log(reg.test(str)); //=&gt;fasle\nconsole.log(reg.exec(str)); //=&gt;null\n</code></pre>\n<h3 id=\"懒做性的解决办法\"><a href=\"#懒做性的解决办法\" class=\"headerlink\" title=\"懒做性的解决办法\"></a>懒做性的解决办法</h3><pre><code class=\"js\">let str = &quot;zhufeng2022yangfan2023qihang2024&quot;;\nlet reg = /\\d+/;\n/* \n *  reg.lastIndex: 当前正则下一次匹配的起始索引位置\n *  懒惰性捕获的原因: 默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远只是第一个\n *  解决办法: 全局修饰符g\n */\n/* console.log(reg.lastIndex); //=&gt;0 下面匹配捕获是从str索引零的位置开始找\n   console.log(reg.exec(str));\n   console.log(reg.lastIndex); //=&gt;0 第一次匹配捕获完成，lastIndex没有改变，所以下一次exec依然是从字符串最开始找，找到的永远是第一个匹配到的 \n */\n\n/* reg = /\\d+/g;\n   console.log(reg.exec(str)); //=&gt;[&quot;2022&quot;...]\n   console.log(reg.lastIndex); //=&gt;11 设置全局匹配修饰符g后，第一次匹配完，lastIndex会自己修改\n   console.log(reg.exec(str)); //=&gt;[&quot;2023&quot;...]\n   console.log(reg.lastIndex); //=&gt;22\n   console.log(reg.exec(str)); //=&gt;[&quot;2024&quot;...]\n   console.log(reg.lastIndex); //=&gt;32\n   console.log(reg.exec(str)); //=&gt;null  当全部捕获后，再次捕获的结果是null，但是lastIndex又回归了初始值零，再次捕获又从第一个开始了...\n   console.log(reg.lastIndex); //=&gt;0\n   console.log(reg.exec(str)); //=&gt;[&quot;2019&quot;...] \n */\n\n/* reg = /\\d+/g;\n   if (reg.test(str)) &#123;\n           //=&gt;验证一下: 只有正则和字符串匹配我们再捕获\n        console.log(reg.lastIndex); //=&gt;11  基于test匹配验证后，lastIndex已经被修改为第一次匹配后的结果，所以下一次捕获不再从头开始\n        console.log(reg.exec(str)); //=&gt;[&quot;2023&quot;...]\n    &#125; \n */\n\n\n//=&gt;需求: 编写一个execAll，执行一次可以把所有匹配的结果捕获到 (前提正则一定要设置全局修饰符g)\n~ function() &#123;\n    function execAll(str = &quot;&quot;) &#123;\n        //=&gt;str: 需要匹配的字符串\n        //=&gt;this: RegExp的实例 (当前操作的正则)\n        //=&gt;进来后第一件事，是验证当前正则是否设置了g，不设置则不能在进行循环捕获了，否则会导致死循环\n        if (!this.global) return this.exec(str);\n        //=&gt;ary存储最后所有捕获的信息   res存储每一次捕获的内容\n        let ary = [],\n            res = this.exec(str);\n        while (res) &#123;\n            //=&gt;把每一次捕获的内容res[0]存放到数组中\n            ary.push(res[0]);\n            //=&gt;只要捕获的内容不为null，则继续捕获下去\n            res = this.exec(str);\n\n        &#125;\n        return ary.length === 0 ? null : ary;\n    &#125;\n    RegExp.prototype.execAll = execAll;\n&#125;();\n\nreg = /\\d+/g;\nconsole.log(reg.execAll(str));\n//=&gt;字符串中的match方法，可以在执行一次的情况下，捕获到所有匹配的数据 (前提: 正则也得设置g才可以)\nconsole.log(str.match(reg));\n</code></pre>\n<h3 id=\"正则的分组捕获\"><a href=\"#正则的分组捕获\" class=\"headerlink\" title=\"正则的分组捕获\"></a>正则的分组捕获</h3><pre><code class=\"js\">//=&gt;身份证号码\nlet str = &quot;130828199012040112&quot;;\nlet reg = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)\\d&#123;2&#125;(\\d)(?:\\d|X)$/;\nconsole.log(reg.exec(str)); //=&gt;[&#39;130828199012040112&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, index: 0, input: &#39;130828199012040112&#39;]\nconsole.log(str.match(reg)); //=&gt;[&#39;130828199012040112&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, index: 0, input: &#39;130828199012040112&#39;]\n//=&gt;第一项: 大正则匹配的结果\n//=&gt;其余项: 每一个小分组单独匹配捕获的结果\n//=&gt;如果设置了分组 (改变优先级)，但是捕获的时候不需要单独捕获，可以基于?:来处理\n</code></pre>\n<pre><code class=\"js\">//=&gt;既要捕获到&#123;数字&#125;，也想单独的把数字也获取到，例如:第一次找到&#123;0&#125; 还需单独获取0\nlet str = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;;\n\n/*\n    //=&gt;不设置g只匹配一次，exec和match获取的结果一致 (既有大正则匹配的信息，也有小分组匹配的信息)\n    let reg = /\\&#123;(\\d+)\\&#125;/;\n    console.log(reg.exec(str)); //=&gt;[&#39;&#123;0&#125;&#39;,&#39;0&#39;,...]\n    console.log(str.match(reg)); //=&gt;[&#39;&#123;0&#125;&#39;,&#39;0&#39;,...]\n*/\n\nlet reg = /\\&#123;(\\d+)\\&#125;/g;\n//console.log(str.match(reg)); //=&gt; [&#39;&#123;0&#125;&#39;, &#39;&#123;1&#125;&#39;, &#39;&#123;2&#125;&#39;]\t 多次匹配的情况下，match只能把大正则匹配的内容获取到，小分组匹配的信息无法获取\nlet aryBig = [],\n    arySmall = [],\n    res = reg.exec(str);\nwhile(res)&#123;\n    let [big,small] = res;\n    aryBig.push(big);\n    arySmall.push(small);\n    res = reg.exec(str);\n&#125;\nconsole.log(aryBig,arySmall); //=&gt;[&#39;&#123;0&#125;&#39;, &#39;&#123;1&#125;&#39;, &#39;&#123;2&#125;&#39;] (3) [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]\n</code></pre>\n<pre><code class=\"js\">//=&gt;分组的第三个作用: &quot;分组引用&quot;\nlet str = &quot;book&quot;; //=&gt;&quot;good&quot;、&quot;look&quot;、&quot;moon&quot;、&quot;foot&quot;...\nlet reg = /^[a-zA-Z]([a-zA-Z])\\1[a-zA-Z]$/; //=&gt;分组引用就是通过&quot;\\数字&quot;让其代表和对应分组出现一模一样的内容\nconsole.log(reg.test(&quot;book&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;deep&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;some&quot;)); //=&gt;false\n</code></pre>\n<h3 id=\"正则捕获的贪婪性\"><a href=\"#正则捕获的贪婪性\" class=\"headerlink\" title=\"正则捕获的贪婪性\"></a>正则捕获的贪婪性</h3><pre><code class=\"js\">let str = &quot;珠峰2022@2023培训&quot;;\n//=&gt;正则捕获的贪婪性: 默认情况下，正则捕获的时候，是按照当前正则所匹配的最长结果来获取的\nlet reg = /\\d+/g;\nconsole.log(str.match(reg)); //=&gt;[&quot;2019&quot;,&quot;2022&quot;]\n\n//=&gt;在量词元字符后面设置? : 取消捕获时候的贪婪性 (按照正则匹配的最短结果来获取) \nreg = /\\d+?/g;\nconsole.log(str.match(reg)); //=&gt;[&#39;2&#39;, &#39;0&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;0&#39;, &#39;2&#39;, &#39;3&#39;]\n</code></pre>\n<p><code>?\t问号在正则中的五大作用</code></p>\n<ul>\n<li>问号左边是非量词元字符 : 本身代表量词元字符，出现零到一次</li>\n<li>问号左边是量词元字符 : 取消捕获时候的贪婪性</li>\n<li>(?:) 只匹配不捕获</li>\n<li>(?&#x3D;) 正向预查</li>\n<li>(?!) 负向预查</li>\n</ul>\n<h3 id=\"其他正则捕获的方法\"><a href=\"#其他正则捕获的方法\" class=\"headerlink\" title=\"其他正则捕获的方法\"></a>其他正则捕获的方法</h3><p>1.test也能捕获 (本意是匹配)</p>\n<pre><code class=\"js\">let str = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;;\nlet reg = /\\&#123;(\\d+)\\&#125;/g;\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;0&quot;\n\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;1&quot;\n\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;2&quot;\n\nconsole.log(reg.test(str)); //=&gt;fasle\nconsole.log(RegExp.$1); //=&gt;&quot;2&quot;\t存储的是上次捕获的结果\n\n//=&gt;RegExp.$1~RegExp.$9: 获取当前本次正则匹配后，第一个到第九个分组的信息\n</code></pre>\n<p>2.replace 字符串中实现替换的方法 (一般都是伴随正则一起使用的)</p>\n<pre><code class=\"js\">let str = &quot;zhufeng@2022|zhufeng@2023&quot;;\n//=&gt;把&quot;zhufeng&quot;替换成&quot;珠峰&quot;\n// 1.不用正则，执行一次只能替换一个\nstr = str.replace(&quot;zhufeng&quot;,&quot;珠峰&quot;).replace(&quot;zhufeng&quot;,&quot;珠峰&quot;);\nconsole.log(str); //=&gt;&quot;珠峰@2022|珠峰@2023&quot;\n\n// 2.使用正则会简单点\nstr = str.replace(/zhufeng/g,&quot;珠峰&quot;);\nconsole.log(str); //=&gt;&quot;珠峰@2022|珠峰@2023&quot;\n</code></pre>\n<pre><code class=\"js\">let str = &quot;zhufeng@2022|zhufeng@2023&quot;;\n//=&gt;把&quot;zhufeng&quot;替换成&quot;zhufengpeixun&quot;\nstr = str.replace(&quot;zhufeng&quot;,&quot;zhufengpeixun&quot;).replace(&quot;zhufeng&quot;,&quot;zhufengpeixun&quot;);\nconsole.log(str); //=&gt;&quot;zhufengpeixunpeixun@2022|zhufeng@2023&quot; 每一次替换都是从字符串第一个位置开始找的 (类似于正则捕获的懒惰性)\n\n//=&gt;基于正则g可以实现\nstr = str.replace(/zhufeng/g,&quot;zhufengpeixun&quot;);\nconsole.log(str); //=&gt;&quot;zhufengpeixun@2022|zhufengpeixun@2023&quot;\n</code></pre>\n<p><strong>案例 : 把时间字符串进行处理</strong> </p>\n<pre><code class=\"js\">let time = &quot;2022-08-09&quot;;\n//=&gt;变为&quot;2022年08月09日&quot;\nlet reg = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/;\n\n//=&gt;这样可以实现\n//time = time.replace(reg,&quot;$1年$2月$3日&quot;);\n//console.log(time); //=&gt;&quot;2022年08月09日&quot;\n\n//=&gt;还可以这样处理 [str].replace([reg],[function])\n// 1.首先拿reg和time进行匹配捕获，能匹配到几次就会把传递的函数执行几次 (而且是匹配一次就执行一次)\n// 2.不仅把方法执行，而且replace还给方法传递了实参信息 (和exec捕获的内容一致的信息: 大正则匹配的内容，小分组匹配的信息....)\n// 3.在函数中我们返回的是啥，就把当前大正则匹配的内容替换成啥\n/*\n    time = time.replace(reg,(big,$1,$2,$3)=&gt;&#123;\n        //=&gt;这里的$1~$3是我们自己设置的变量\n        console.log(big,$1,$2,$3); //=&gt;&quot;2022-08-09 2022 08 09&quot;\n    &#125;);\n */\ntime = time.replace(reg,(...arg)=&gt;&#123; \n    console.log(arg);\n    let  [,$1,$2,$3] = arg;\n    $2.length&lt;2 ? $2=&quot;0&quot;+$2 : null;\n    $3.length&lt;2 ? $3=&quot;0&quot;+$3 : null;\n    return $1+&quot;年&quot;+$2+&quot;月&quot;+$3+&quot;日&quot;;\n&#125;); \n</code></pre>\n<p><strong>单词首字母大写</strong></p>\n<pre><code class=\"js\">let str = &quot;good good study, day day up! &quot;;\nlet reg = /\\b([a-zA-Z])[a-zA-Z]*\\b/g;\n//=&gt;函数被执行了六次，每一次都把正则匹配信息传递给函数\n//=&gt;每一次arg: [&#39;good&#39;,&#39;g&#39;] [&#39;good&#39;,&#39;g&#39;] [&#39;good&#39;,&#39;g&#39;] [&#39;study&#39;,&#39;s&#39;]...\nstr = str.replace(reg,(...arg)=&gt;&#123;\n    let [content,$1] = arg;\n    $1 = $1.toUpperCase();\n    content = content.substring(1);\n    return $1 + content;\n&#125;);\nconsole.log(str); //=&gt;&quot;Good Good Study, Day Day Up! &quot;\n</code></pre>\n<p><strong>验证一个字符串中哪个字母出现的次数最多，多少次?</strong></p>\n<pre><code class=\"js\">let str = &quot;zhufengpeixunzhoulaoshi&quot;;\n\n/*\n *\t去重思维\n */\nlet obj = &#123;&#125;;\n[].forEach.call(str,char=&gt;&#123;\n    if(typeof obj[char] !== &quot;undefined&quot;)&#123;\n        obj[char++];\n        return;\n    &#125;\n    obj[char] = 1; \n&#125;);\nconsole.log(obj);let obj = &#123;&#125;;\n[].forEach.call(str, char =&gt; &#123;\n    if (typeof obj[char] !== &quot;undefined&quot;) &#123;\n        obj[char]++;\n        return;\n    &#125;\n    obj[char] = 1;\n&#125;);\nlet max = 1,\n    res = [];\nfor (let key in obj) &#123;\n    let item = obj[key];\n    item &gt; max ? max = item : null;\n&#125;\nfor (let key in obj) &#123;\n    let item = obj[key];\n    if (item === max) &#123;\n        res.push(key);\n    &#125;\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n\n/*\n *\t排序\n */\nstr = str.split(&#39;&#39;).sort((a, b) =&gt; a.localeCompare(b)).join(&#39;&#39;);\n//console.log(str); //=&gt;&quot;aeefghhhiilnnoopsuuuxzz&quot;\nlet reg = /([a-zA-Z])\\1+/g;\nlet ary = str.match(reg); //=&gt;[&#39;ee&#39;, &#39;hhh&#39;, &#39;ii&#39;, &#39;nn&#39;, &#39;oo&#39;, &#39;uuu&#39;, &#39;zz&#39;]\nary.sort((a, b) =&gt; b.length - a.length);\nconsole.log(ary); //=&gt;[&#39;hhh&#39;, &#39;uuu&#39;, &#39;ee&#39;, &#39;ii&#39;, &#39;nn&#39;, &#39;oo&#39;, &#39;zz&#39;]\nlet max = ary[0].length,\n    res = [ary[0].substr(0, 1)];\nfor (let i = 1; i &lt; ary.length; i++) &#123;\n    let item = ary[i];\n    if (item.length &lt; max) &#123;\n        break;\n    &#125;\n    res.push(item.substr(0, 1));\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n\n/*\n *\t正则\n */\nlet max = 0,\n    res = [],\n    flag = false;\nstr = str.split(&#39;&#39;).sort((a, b) =&gt; a.localeCompare(b)).join(&#39;&#39;);\n// console.log(str); //=&gt;&quot;aeefghhhiilnnoopsuuuxzz&quot;\nfor (let i = str.length; i &gt; 0; i--) &#123;\n    let reg = new RegExp(&quot;([a-zA-Z])\\\\1&#123;&quot; + (i - 1) + &quot;&#125;&quot;, &quot;g&quot;);\n    // i=3  /([a-zA-Z])\\1&#123;2&#125;/  &quot;hhh&quot; &quot;uuu&quot;\n    str.replace(reg, (content, $1) =&gt; &#123;\n        res.push($1);\n        max = i;\n        flag = true;\n    &#125;);\n    if (flag) break;\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n</code></pre>\n<p><strong>时间字符串格式化</strong></p>\n<pre><code class=\"js\">~ function() &#123;\n    /* \n     *  formatTime: 时间字符串的格式化处理\n     */\n    /* function formatTime() &#123;\n        // 1.首先获取时间字符串中的年月日等信息\n        let timeAry = this.match(/\\d+/g);\n        // console.log(timeAry)//[&#39;2022&#39;, &#39;8&#39;, &#39;10&#39;, &#39;16&#39;, &#39;00&#39;, &#39;43&#39;]\n        let template = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;;\n        template = template.replace(/\\&#123;(\\d+)\\&#125;/g, (content, $1) =&gt; &#123;\n            //=&gt;content: 当前本次大正则匹配的信息   $1: 本次小分组单独匹配的信息\n            //以$1的值作为索引，到timeAry中找到对应的时间 (如果没有则用&quot;00&quot;补)\n            let time = timeAry[$1] || &quot;00&quot;;\n            time.length &lt; 2 ? time = &quot;0&quot; + time : null;\n            return time;\n        &#125;)\n        return template;\n    &#125;*/\n    //=&gt;简化版本\n    /* \n     *  formatTime: 时间字符串的格式化处理\n     *  @params\n     *      template: [string] 我们最后期望获取日期格式的模板\n     *      模板规则: &#123;0&#125;-&gt;年  &#123;1~5&#125;-&gt;月日时分秒\n     *  @return\n     *      [string]格式化后的时间字符串\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function formatTime(template = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;) &#123;\n        let timeAry = this.match(/\\d+/g);\n        return template = template.replace(/\\&#123;(\\d+)\\&#125;/g, (...[, $1]) =&gt; &#123;\n            let time = timeAry[$1] || &quot;00&quot;;\n            return time.length &lt; 2 ? time = &quot;0&quot; + time : time;\n        &#125;);\n    &#125;\n\n    /* 扩展到内置类String.prototype上 */\n    [&quot;formatTime&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\n\n//=&gt;服务器获取的\n// &quot;2022-8-10 16:00:43&quot;\n// &quot;2022/8/10 16:00:43&quot;\n// &quot;2022/8/10&quot;\n//=&gt;想要转变为的格式\n// &quot;08月10日 16时00分&quot;\n// &quot;2022年8月10日&quot;\n// ...\nlet time = &quot;2022-8-10 16:00:43&quot;;\nconsole.log(time.formatTime()); //=&gt;2022年08月10日 16时00分43秒\nconsole.log(time.formatTime(&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;)); //=&gt;2022年08月10日\nconsole.log(time.formatTime(&quot;&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;&quot;)); //=&gt;08-10 16:00\ntime = &quot;2022/8/13&quot;;\nconsole.log(time.formatTime()); //=&gt;2022年08月13日 00时00分00秒\nconsole.log(time.formatTime(&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;)); //=&gt;2022年08月13日\nconsole.log(time.formatTime(&quot;&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;&quot;)); //=&gt;08-13 00:00\n</code></pre>\n<p><em><strong>queryURLParams</strong></em></p>\n<pre><code class=\"js\">~ function() &#123;\n    /* \n     *  queryURLParams: 获取URl地址问号和后面的参数信息 (可能也包含HASH值)\n     *  @params   \n     *  @return\n     *      [object]把所有问号参数信息以键值对的方式存储起来并且返回\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function queryURLParams() &#123;\n        let obj = &#123;&#125;;\n        this.replace(/([^?=&amp;#]+)=([^?=&amp;#]+)/g, (...[, $1, $2]) =&gt; obj[$1] = $2);\n        this.replace(/#([^?=&amp;#]+)/g, (...[, $1]) =&gt; obj[&#39;HASH&#39;] = $1);\n        return obj;\n    &#125;\n    \n    /* 扩展到内置类String.prototype上 */\n    [&quot;queryURLParams&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\nlet url = &quot;http://www.zhufengpeixun.cn/?lx=1&amp;from=wx#video&quot;;\nconsole.log(url.queryURLParams()); //=&gt;&#123;lx: &#39;1&#39;, from: &#39;wx&#39;, HASH: &#39;video&#39;&#125;\n</code></pre>\n<p><strong>千分符</strong></p>\n<pre><code class=\"js\">~ function() &#123;\n    /* \n     *  millimeter: 实现大数字的千分符处理\n     *  @params    \n     *  @return\n     *      [string]千分符后的字符串\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function millimeter() &#123;\n        return this.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g, content =&gt; content + &#39;,&#39;);\n    &#125;\n\n    /* 扩展到内置类String.prototype上 */\n    [&quot;millimeter&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\nlet num = &quot;15628954&quot;; //=&gt;&quot;15,628,954&quot; 千分符\nconsole.log(num.millimeter()); //=&gt;&quot;15,628,954&quot;\n\n// 把字符串倒过来\nnum = num.split(&#39;&#39;).reverse().join(&#39;&#39;);\nfor (let i = 2; i &lt; num.length - 1; i += 4) &#123;\n    let prev = num.substring(0, i + 1),\n        next = num.substring(i + 1);\n    num = prev + &quot;,&quot; + next;\n&#125;\nnum = num.split(&#39;&#39;).reverse().join(&#39;&#39;);\nconsole.log(num); //=&gt;&quot;15,628,954&quot;\n</code></pre>\n<h1 id=\"常用的正则表达式-1\"><a href=\"#常用的正则表达式-1\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h1><pre><code class=\"js\">2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n//正整数\n/^[0-9]*[1-9][0-9]*$/;\n//负整数\n/^-[0-9]*[1-9][0-9]*$/;\n//正浮点数\n/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/;\n//负浮点数\n/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/;\n//浮点数\n/^(-?\\d+)(\\.\\d+)?$/;\n//email地址\n/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;\n//url地址\n/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;\n或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\&#39;:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$\n//年/月/日（年-月-日、年.月.日）\n/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;\n//匹配中文字符\n/[\\u4e00-\\u9fa5]/;\n//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)\n/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;\n//匹配空白行的正则表达式\n/\\n\\s*\\r/;\n//匹配中国邮政编码\n/[1-9]\\d&#123;5&#125;(?!\\d)/;\n//匹配身份证\n/\\d&#123;15&#125;|\\d&#123;18&#125;/;\n//匹配国内电话号码\n/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;\n//匹配IP地址\n/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;\n//匹配首尾空白字符的正则表达式\n/^\\s*|\\s*$/;\n//匹配HTML标记的正则表达式\n&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;\n//sql 语句\n^(select|drop|delete|create|update|insert).*$\n//提取信息中的网络链接\n(h|H)(r|R)(e|E)(f|F) *= *(&#39;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#39;|&quot;| *|&gt;)?\n//提取信息中的邮件地址\n\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\n//提取信息中的图片链接\n(s|S)(r|R)(c|C) *= *(&#39;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#39;|&quot;| *|&gt;)?\n//提取信息中的 IP 地址\n(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\n//取信息中的中国手机号码\n(86)*0*13\\d&#123;9&#125;\n//提取信息中的中国邮政编码\n[1-9]&#123;1&#125;(\\d+)&#123;5&#125;\n//提取信息中的浮点数（即小数）\n(-?\\d*)\\.?\\d+\n//提取信息中的任何数字\n(-?\\d*)(\\.\\d+)?\n//电话区号\n^0\\d&#123;2,3&#125;$\n//腾讯 QQ 号\n^[1-9]*[1-9][0-9]*$\n//帐号（字母开头，允许 5-16 字节，允许字母数字下划线）\n^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$\n//中文、英文、数字及下划线\n^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$\n</code></pre>\n","categories":["正则表达式"],"tags":["正则"]},{"title":"正则表达式","url":"/2023/02/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><p>​          <strong>正则表达式是一个对象</strong></p>\n<p>正则表达式并不是JS独有的技术，基本上所有语言都支持这个技术</p>\n<p>正则表达式的目的也很单纯，核心作用就是验证数据的合法性</p>\n<p>正则表达式的特点：</p>\n<p>1、正则表达式在JS中只针对字符串起作用</p>\n<p>2、正则表达式会根据你设置的规则，对字符串进行 提取，搜索、替换 等操作</p>\n<p>3、JavaScript中正则表达式是一个内置对象，这个对象通过RegExp() 创建，也可以直接通过赋值一个正则表达式来创建</p>\n<p>第一种：</p>\n<pre><code class=\"js\">var reg = new RegExp(正则表达式)\n</code></pre>\n<p>第二种:</p>\n<pre><code class=\"js\">var reg = /张/\n</code></pre>\n<p>方法：</p>\n<p>1、test() 用于验证某一个字符串是否符合正则的规则</p>\n<pre><code class=\"js\">var str =&quot;abc&quot;;\nvar reg = /a/;\nreg.test(str);\n</code></pre>\n<p>2、exec（）根据正则表达式提取字符串中符合要求的字符，用法与上面类似，注意：正则表达式是可以添加修饰符的，这个修饰符会影响提取字符串的结果</p>\n<h4 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h4><p>1、g代表global全局验证</p>\n<p>2、i 代表忽略大小写</p>\n<p>3、m 代表多行的意思，也就是可以换行匹配</p>\n<h3 id=\"正则表达式的规则\"><a href=\"#正则表达式的规则\" class=\"headerlink\" title=\"正则表达式的规则\"></a>正则表达式的规则</h3><h4 id=\"一元符号\"><a href=\"#一元符号\" class=\"headerlink\" title=\"一元符号\"></a>一元符号</h4><p><code>.</code> 匹配除换行符以外的任意符号</p>\n<p><code>\\w</code> 匹配字符数字和下划线</p>\n<p><code>\\S</code>匹配任何空白符</p>\n<p><code>\\d</code> 匹配所有数字 ,与 [0-9]</p>\n<p><code>\\b</code> 匹配单词边界</p>\n<p><code>|</code> 或匹配</p>\n<p><code>^</code> 匹配字符串的开始</p>\n<p><code>$</code> 匹配字符串的结束</p>\n<h3 id=\"原子组和原子表\"><a href=\"#原子组和原子表\" class=\"headerlink\" title=\"原子组和原子表\"></a>原子组和原子表</h3><h4 id=\"原子表\"><a href=\"#原子表\" class=\"headerlink\" title=\"原子表 [ ]\"></a>原子表 [ ]</h4><pre><code class=\"js\">var reg = /^[张王赵]三$/\nconsole.log(reg.test(&quot;张三&quot;));                        //true\nconsole.log(reg.test(&quot;王三&quot;));                        //true\nconsole.log(reg.test(&quot;赵三&quot;));                        //true\nconsole.log(reg.test(&quot;李三&quot;));                        //false\nconsole.log(reg.test(&quot;张四&quot;));                        //false\nconsole.log(reg.test(&quot;张三ssss&quot;));                    //false\nconsole.log(reg.test(&quot;张ssss三&quot;));                    //false\n</code></pre>\n<p>原子表是用中括号的形式存在，它会从这个表中拿出一个进行条件匹配</p>\n<p>在原子表中，还可以写范围</p>\n<pre><code class=\"js\">var reg1 = /[0-9]/\nvar reg2 = /[a-z]/\nvar reg3 = /[A-Z]/\n</code></pre>\n<blockquote>\n<p>注意：原子表中的范围不能倒写，会报错</p>\n</blockquote>\n<h4 id=\"原子组\"><a href=\"#原子组\" class=\"headerlink\" title=\"原子组( )\"></a>原子组( )</h4><pre><code class=\"js\">var reg = /张三|王三|赵三/;\nvar reg2 = /(张|王|赵)三/    //原子组用小括号表示\n</code></pre>\n<h3 id=\"反义字符\"><a href=\"#反义字符\" class=\"headerlink\" title=\"反义字符\"></a>反义字符</h3><p>**在 [ ]中使用</p>\n<p>[^x]  匹配处理x以外的所有字符，这里的x可以是任意字符</p>\n<p>[^xyz] 同上，匹配除了xyz以外的字符</p>\n<p>\\W 匹配除字母、数字、下划线以外的所有字符，等同 <code>[^\\w]</code></p>\n<p>\\B 匹配不是单词边界的字符</p>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>\\xnn 匹配十六进制数</p>\n<p>\\f 匹配换页符</p>\n<p>\\n 匹配换行符</p>\n<p>\\r 匹配回车符</p>\n<p>\\unnnn 匹配unicode编码</p>\n<h3 id=\"重复匹配\"><a href=\"#重复匹配\" class=\"headerlink\" title=\"重复匹配\"></a>重复匹配</h3><p><code>*</code> 重复匹配零次或多次</p>\n<p><code>+</code> 重复匹配1次或多次</p>\n<p><code>?</code> 重复匹配0次或1次</p>\n<p><code>&#123;n&#125;</code>  重复匹配n次</p>\n<p><code>&#123;n,&#125;</code> 至少重复匹配n次</p>\n<p><code>&#123;m,n&#125;</code> 重复普配m到n次  m &lt; n</p>\n<pre><code class=\"js\">//我希望验证一个字符串，它是a开始，c结束，中间有4个英文字母。怎么写？\nvar reg = /^a[a-zA-Z]&#123;4&#125;c$/\n\n//我希望验证一个字符串，它是a开始，c结束，中间有4-6个数字。怎么写？\nvar reg1 = /^a\\d&#123;4,6&#125;c$/\n\n//我希望验证一个字符串，它是a开始，c结束，中间至少有4个数字。怎么写？\nvar reg2 = /^a\\d&#123;4,&#125;c$/\n\n//我希望验证一个字符串，它是a开始，c结束，中间至少有1个或多个数字。怎么写？\nvar reg3 = /^a\\d+c$/\n\n//我希望验证一个字符串，它是a开始，c结束，中间至少有0个或多个数字。怎么写？\nvar reg4 = /^a\\d*c$/\n\n//我希望验证一个字符串，它以三结束，以张开头，中间有0或1个字符\nvar reg5 = /^张.?三$/\n</code></pre>\n<h3 id=\"贪婪与惰性\"><a href=\"#贪婪与惰性\" class=\"headerlink\" title=\"贪婪与惰性\"></a>贪婪与惰性</h3><p>重复匹配默认都是按照贪婪的特性去匹配较多的次数，如果我们需要按照惰性特征来匹配</p>\n<p>我们可以把上面的多有的重复匹配符号后面加上一个 ？表示惰性匹配</p>\n<pre><code class=\"js\">var str = &quot;cawqdewfeffwerderwe&quot;;\n//我要提取c开始到d结束中间任意长度的字符串\nvar reg = /c[a-z]*d/;\nvar newStr = reg.exec(str);\n//这个时候我们的正则表达式处在贪婪模式下，它会执行贪婪（0到贪婪多次）\n\nvar reg = /c[a-z]*?d/;  //执行惰性重复匹配\n</code></pre>\n<h3 id=\"原子组编号：-n\"><a href=\"#原子组编号：-n\" class=\"headerlink\" title=\"原子组编号：\\n\"></a>原子组编号：\\n</h3><p>原子组通过（）形成一个分组，这个分组会给一个分组编号</p>\n<pre><code class=\"js\">var str = &quot;&lt;div&gt;&lt;/div&gt;&quot;;\n//现在希望通过正则验证这个标签\nvar reg = /&lt;[a-zA-Z]+&gt;&lt;\\/[a-zA-Z]+&gt;/;\n//上面的问题在于，我们希望开始标签和结束标签里面匹配到的是相同的字符\nvar flag = reg.test(str);\n</code></pre>\n<p>在上面的表达式中，我们表面上看起来是完成了功能，但是又有隐患，如果我们要匹配的字符串是 <code>&lt;div&gt;&lt;/span&gt;</code> 这样也会验证成功，但是不符合要求</p>\n<p>我们的主要需求是开始标签和结束标签要一致，我们开始匹配的内容 <code>&lt;[a-zA-Z]+&gt;</code> 要与后面匹配的 <code>&lt;\\/[a-zA-Z]+&gt;</code> 保持一致，这个时候我们就要用到原子组</p>\n<pre><code class=\"js\">var str = &quot;&lt;div&gt;&lt;/span&gt;&quot;;\n//现在希望通过正则验证这个标签\nvar reg1 = /&lt;[a-zA-Z]+&gt;&lt;\\/[a-zA-Z]+&gt;/;\n//上面的问题在于，我们希望开始标签和结束标签里面匹配到的是相同的字符\nvar flag1 = reg1.test(str);\n\nvar reg2 = /&lt;([a-zA-Z]+)&gt;&lt;\\/\\1&gt;/;\nvar flag2 = reg2.test(str);\n</code></pre>\n<h3 id=\"前瞻后顾-：（）语法\"><a href=\"#前瞻后顾-：（）语法\" class=\"headerlink\" title=\"前瞻后顾 ：（）语法\"></a>前瞻后顾 ：（）语法</h3><p>首先我们要弄清除两个条件</p>\n<blockquote>\n<p>1、你的匹配条件是什么</p>\n<p>2、你的限制条件是什么</p>\n</blockquote>\n<h4 id=\"前瞻\"><a href=\"#前瞻\" class=\"headerlink\" title=\"前瞻\"></a>前瞻</h4><p>匹配条件是A，限制条件是B，B要出现在A的后面</p>\n<pre><code>A(?=B)\n</code></pre>\n<p>如果要匹配abc并且abc要在123的前面</p>\n<pre><code class=\"js\">/abc(?=123)/g //全局匹配abc后面紧跟123\n\n//abc123  true\n//abc456  false\n//123abc  false\n</code></pre>\n<h4 id=\"负前瞻\"><a href=\"#负前瞻\" class=\"headerlink\" title=\"负前瞻\"></a>负前瞻</h4><p>匹配条件是A，限制条件是B，B不能出现在A的后面</p>\n<pre><code class=\"js\">/abc(?!123)/g\n</code></pre>\n<h4 id=\"后顾\"><a href=\"#后顾\" class=\"headerlink\" title=\"后顾\"></a>后顾</h4><p>匹配条件是A，限制条件是B，B要出现在A的前面</p>\n<pre><code class=\"js\">(?&lt;=B)A\n</code></pre>\n<p>要匹配abc并且abc要在123的后面</p>\n<pre><code class=\"js\">/(?&lt;=123)abc/g\n\n//abc123  false\n//abc456  false\n//123abc  true\n</code></pre>\n<h4 id=\"负后顾\"><a href=\"#负后顾\" class=\"headerlink\" title=\"负后顾\"></a>负后顾</h4><p>匹配条件是A，限制条件是B，B要不能出现在A的前面</p>\n<pre><code class=\"js\">(?&lt;!B)A\n</code></pre>\n<h3 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h3><p>如何匹配中文</p>\n<pre><code class=\"js\">var reg = /^[\\u4E00-\\u9FA5]&#123;2,4&#125;$/\n</code></pre>\n<h1 id=\"正则表达式（github）\"><a href=\"#正则表达式（github）\" class=\"headerlink\" title=\"正则表达式（github）\"></a>正则表达式（github）</h1><blockquote>\n<p>regular expression : RegExp</p>\n<p>用来处理字符串的规则</p>\n<ul>\n<li>只能处理字符串</li>\n<li>它是一个规则 : 可以验证字符串是否符合某个规则 (test) ，也可以把字符串中符合规则的内容捕获到 (exec &#x2F; match …)</li>\n</ul>\n</blockquote>\n<pre><code class=\"js\">let str = &quot;good good study, day day up! &quot;;\n//=&gt; 学正则就是用来制定规则 (是否包含数字)\nlet reg = /\\d+/;\nreg.test(str); //=&gt; false\n\nstr = &quot;2022-08-05&quot;;\nreg.exec(str); //=&gt;[&quot;2019&quot;,index:0,inputs:&quot;原始字符串&quot;]\n</code></pre>\n<h2 id=\"编写正则表达式\"><a href=\"#编写正则表达式\" class=\"headerlink\" title=\"编写正则表达式\"></a><strong>编写正则表达式</strong></h2><h3 id=\"创建方式有两种\"><a href=\"#创建方式有两种\" class=\"headerlink\" title=\"创建方式有两种\"></a>创建方式有两种</h3><pre><code class=\"js\">//=&gt;字面量创建方式 (两个斜杆之间包起来的，都是用来描述规则的元字符)\nlet reg1 = /\\d+/;\n\n//=&gt;构造函数模式创建  两个参数: 元字符字符串 , 修饰符字符串\nlet reg2 = new RegExp(&quot;\\\\d+&quot;);\n</code></pre>\n<p>正则表达式由两部分组成</p>\n<ul>\n<li>元字符</li>\n<li>修饰符</li>\n</ul>\n<pre><code class=\"js\">/*常用的元字符*/\n//=&gt;1.量词元字符: 设置出现的次数\n*  零到多次\n+  一到多次\n?  零次或者一次\n&#123;n&#125;  出现n次 (n需为0或者正整数)\n&#123;n,&#125;  出现n到多次\n&#123;n,m&#125;  出现n到m次 (包含n和m)\n\n//=&gt;2.特殊元字符: 单个或者组合在一起代表特殊的含义\n\\    转义字符(普通-&gt;特殊-&gt;普通)\n.    除\\n (换行符) 以外的任意字符\n^    以哪一个元字符作为开始\n$    以哪一个元字符作为结束\n\\n   换行符\n\\d   0~9之间的数字\n\\D   非0~9之间的数字 (大写和小写的意思是相反的)\n\\w   数字、字母、下划线中的任意一个字符\n\\s   一个空白字符 (包含空格、制表符、换页符等)\n\\t   一个制表符 (一个TAb键:四个空格)\n\\b   匹配一个单词的边界\nx|y  x或者y中的一个字符  (1|5|9)\n[xyz] x或者y或者z中的一个字符  [adghve2375]\n[^xy] 除了x/y以外的任意字符\n[a-z] 指定a-z这个范围中的任意字符  [0-9a-zA-Z_](0-9或者a-z或者A-Z或者_中的一个字符) === \\w\n[^a-z] 上一个取反&quot;非&quot;\n()    正则中的分组符号\n(?:)  只匹配不捕获\n(?=)  正向预查\n(?!)  负向预查\n\n//=&gt;3.普通元字符: 代表本身含义\n/jiangbing/ 此正则匹配的就是&quot;jiangbing&quot;\n</code></pre>\n<pre><code class=\"js\">/*正则表达式常用的修饰符: img*/\ni =&gt;ignoreCase  忽略单词大小写匹配\nm =&gt;multiline   可以进行多行匹配\ng =&gt;global      全局匹配\n\n/*\n *\t/A/.test(&#39;lalala&#39;); //=&gt;fasle\n *\t/A/i.test(&#39;lalala&#39;); //=&gt;true\n */\n</code></pre>\n<h3 id=\"元字符详细解析\"><a href=\"#元字符详细解析\" class=\"headerlink\" title=\"元字符详细解析\"></a><strong>元字符详细解析</strong></h3><p><code>^$</code></p>\n<pre><code class=\"js\">let reg = /^\\d/;\nconsole.log(reg.test(&quot;jiangbing&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;2022jiangbing&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;jiangbing2022&quot;)); //=&gt;false\n</code></pre>\n<pre><code class=\"js\">let reg = /\\d$/;\nconsole.log(reg.test(&quot;jiangbing&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;2022jiangbing&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;jiangbing2022&quot;)); //=&gt;true\n</code></pre>\n<pre><code class=\"js\">//=&gt;^/$两个都不加: 字符串中包含符合规则的内容即可\nlet reg = /\\d+/;\n//=^/$两个都加: 字符串只能是和规则一致的内容\nlet reg = /^\\d+$/;\n\n//=&gt;举个例子: 验证手机号码(11位，第一个数字是1即可)\nlet reg = /^1\\d&#123;10&#125;$/;\n</code></pre>\n<p><code>\\</code></p>\n<pre><code class=\"js\">//=&gt;.不是小数点，是除\\n外的任意字符\nlet reg = /^2.3$/;\nconsole.log(reg.test(&quot;2.3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2@3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;23&quot;)); //=&gt;fasle\n\n//=&gt;基于转义字符，让其只能代表小数点\nlet reg = /^2\\.3$/;\nconsole.log(reg.test(&quot;2.3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2@3&quot;)); //=&gt;false\n\nlet str = &quot;\\\\d&quot;;\nreg = /^\\d$/;  //=&gt;\\d代表0-9的数字\nconsole.log(reg.test(&quot;str&quot;)); //=&gt;fasle\nreg = /^\\\\d$/;  //=&gt;把特殊符号转换为普通的\nconsole.log(reg.test(&quot;str&quot;)); //=&gt;true\n</code></pre>\n<p><code>x|y</code></p>\n<pre><code class=\"js\">let reg = /^18|29$/;\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;29&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;129&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;189&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;1829&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;829&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;182&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;82&quot;)); //=&gt;fasle\n\n//---直接x|y会存在很乱的优先级问题，一般我们写的时候都伴随着小括号进行分组，因为小括号改变处理的优先级 =&gt;小括号: 分组\nlet reg = /^(18|29)$/;\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;29&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;129&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;189&quot;)); //=&gt;fasle\n//=&gt;只能是18或者29中的一个了\n</code></pre>\n<p><code>[]</code></p>\n<pre><code class=\"js\">//1.中括号中出现的字符一般都代表本身的含义\nlet reg = /^[@+]$/;\nconsole.log(reg.test(&quot;@&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;+&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;@@&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;@+&quot;)); //=&gt;false\n\nreg = /^[\\d]$/; //=&gt;\\d在中括号中还是0-9\nconsole.log(reg.test(&quot;d&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;\\\\&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;true\n\nreg = /^[\\\\d]$/; //=&gt;\\d已经被\\转义\nconsole.log(reg.test(&quot;d&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;\\\\&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;false\n\n//2.中括号中不存在多位数\nreg = /^[18]$/;\nconsole.log(reg.test(&quot;1&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;8&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;false\n\nreg = /^[10-29]$/; //=&gt;1或者0-2或者9\nconsole.log(reg.test(&quot;1&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;0&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;10&quot;)); //=&gt;false\n</code></pre>\n<h3 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a><strong>常用的正则表达式</strong></h3><p>1.验证是否为有效数字</p>\n<pre><code class=\"js\">/*\n *\t规则分析\n *\t\t1.可能出现 + - 号，也可能不出现  [+-]?\n *\t\t2.一位0-9都可以，多位首位不能为0  (\\d|([1-9]\\d+)\n *\t\t3.小数点部分可能有可能没有，一旦有后面必须有小数点+数字  (\\.\\d+)?\n */\nlet reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/;\n</code></pre>\n<p>2.验证密码</p>\n<pre><code class=\"js\">//=&gt;数字、字母、下划线\n//=&gt;6~16位\nlet val = userPassInp.value,\n    reg = /^\\w&#123;6,16&#125;$/;\nlet flag = reg.test(val);\n\n/*\nfunction checkPass(val)&#123;\n    if(val.length &lt;6 || val.length &gt;16)&#123;\n        alert(&#39;长度必须介于6-16位之间!&#39;);\n        retrun;\n    &#125;\n    let area = [&#39;a&#39;,&#39;b&#39;...&#39;_&#39;]; //=&gt;包含数字、字母、下划线\n    for(let i=0;i&lt;val.length;i++)&#123;\n        let char = val[i];\n        if(!area.includes(char))&#123;\n            alert(&quot;格式不正确&quot;);\n            return;\n        &#125;\n    &#125;\n&#125;\n*/\n</code></pre>\n<p>3.验证真实姓名</p>\n<pre><code class=\"js\">/*\n *\t1.验证汉字  /^[\\u4E00-\\u9FA5]$/\n *\t2.名字长度 2~10位\n *\t3.可能有译名 ·汉字  (·[\\u4E00-\\u9FA5]&#123;2,10&#125;)&#123;0,2&#125;\n */\nlet reg = /^[\\u4E00-\\u9FA5]&#123;2,10&#125;(·[\\u4E00-\\u9FA5]&#123;2,10&#125;)&#123;0,2&#125;$/;\n</code></pre>\n<p>4.验证邮箱</p>\n<pre><code class=\"js\">let reg = /^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/;\n\n//=&gt; \\w+((-\\w+)|(\\.\\w+))*\n// 1.开头是数字字母下划线 (1到多位)\n// 2.还可以是 &quot;-数字字母下划线 或者 .数字字母下划线&quot;，整体零到多次\n// 邮箱的名字由&quot;数字、字母、下划线、-、.&quot;几部分组成，但是-/.不能连续出现也不能作为开始\n\n//=&gt; @[A-Za-z0-9]+\n// 1.@后面紧跟着: 数字、字母 (1-多位)\n\n//=&gt; ((\\.|-)[A-Za-z0-9]+)*\n// 1.对@后面名字的补充\n// 多域名   .com.cn\n// 企业域名  zxt@zhufeng-peixun-office.com\n\n//=&gt; \\.[A-Za-z0-9]+\n// 1. @xxx.com / @xxx.cn 这个匹配的是最后的域名 (.com/.cn/.org/.edu/.net/.vip...)\n</code></pre>\n<p>5.身份证号码</p>\n<pre><code class=\"js\">/*\n *\t1.一共18位\n *\t2.最后一位可能是X\n *\n *\t身份证前六位: 省市县 130828\n *\t中间八位: 年月日\n *\t最后四位:\n *\t\t最后一位 =&gt; X或者数字\n *\t\t倒数第二位 =&gt; 偶数 女  奇数 男\n *\t\t其余的是经过算法算出来的\n */\n//let reg = /^\\d&#123;17&#125;(\\d|X)$/;\n//=&gt;小括号分组的第二个作用: 分组捕获，不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容\nlet reg = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)\\d&#123;2&#125;(\\d)(\\d|X)$/;\nreg.exec(&quot;130828199012040617&quot;);//=&gt;[&#39;130828199012040617&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, &#39;7&#39;, index: 0, input: &#39;130828199012040617&#39;, groups: undefined] 捕获结果是一个数组，包含每一个小分组单独获取的内容\n</code></pre>\n<p><strong>正则两种创建方式的区别</strong></p>\n<pre><code class=\"js\">//=&gt;构造函数因为传递的是字符串，\\需要写两个才代表斜杆\nlet reg = /\\d+/g;\nreg = new RegExp(&quot;\\\\d+&quot;,&quot;g&quot;);\n\n//=&gt;正则表达式中的部分内容是变量存储的值\n// 1.两个斜杆中间包起来的都是元字符 (如果正则中要包含某个变量的值，则不能使用字面量方式创建)\nlet type = &#39;zhufeng&#39;;\nreg = /^@&quot;+type+&quot;@$/;\nconsole.log(reg.test(&quot;@zhufeng@&quot;)); //=&gt;false\nconsole.log(reg.test(&#39;@&quot;&quot;&quot;typeeee&quot;@&#39;)); //=true\n// 2.这种情况只能使用构造函数方式(因为它传递的规则是字符串，只有这样才能进行字符拼接)\nreg = new RegExp(&quot;^@&quot;+type+&quot;@$&quot;);\nconsole.log(reg.test(&quot;@zhufeng@&quot;)); //=&gt;true\n</code></pre>\n<hr>\n<h2 id=\"正则的捕获\"><a href=\"#正则的捕获\" class=\"headerlink\" title=\"正则的捕获\"></a><strong>正则的捕获</strong></h2><blockquote>\n<p>实现正则捕获的办法</p>\n<ul>\n<li>正则RegExp.prototype上的方法<ul>\n<li>exec</li>\n<li>test</li>\n</ul>\n</li>\n<li>字符串String.prototype上支持正则表达式处理的方法<ul>\n<li>replace</li>\n<li>match</li>\n<li>splite</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"js\">let str = &quot;zhufeng2022yangfan2023qihang2024&quot;;\nlet reg = /\\d+/;\n/*\n *\t基于exec实现正则的捕获\n *\t\t1.捕获到的结果是null或者一个数组\n *\t\t\t数组第一项: 本次捕获到的内容\n *\t\t\t其余项: 对应小分组本次单独捕获的内容\n *\t\t\tindex: 当前捕获内容在字符串中的起始索引\n *\t\t\tinput: 原始字符串\n *\t\t2.每执行一次exec，只能捕获到一个符合正则规则的，但是默认情况下，我们执行100遍，获取的结果永远都是第一个匹配到的，其余的捕获不到\n *\t\t=&gt;&quot;正则捕获的懒惰性&quot;: 默认只捕获第一个\n */\nconsole.log(reg.exec(str)); //=&gt;[&#39;2022&#39;, index: 7, input: &#39;zhufeng2022yangfan2023qihang2023&#39;]\n\n/*\n//=&gt;实现正则捕获的前提是: 当前正则要和字符串匹配，如果不匹配捕获的结果是null\nlet reg = /^\\d+$/;\nconsole.log(reg.test(str)); //=&gt;fasle\nconsole.log(reg.exec(str)); //=&gt;null\n</code></pre>\n<h3 id=\"懒做性的解决办法\"><a href=\"#懒做性的解决办法\" class=\"headerlink\" title=\"懒做性的解决办法\"></a>懒做性的解决办法</h3><pre><code class=\"js\">let str = &quot;zhufeng2022yangfan2023qihang2024&quot;;\nlet reg = /\\d+/;\n/* \n *  reg.lastIndex: 当前正则下一次匹配的起始索引位置\n *  懒惰性捕获的原因: 默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远只是第一个\n *  解决办法: 全局修饰符g\n */\n/* console.log(reg.lastIndex); //=&gt;0 下面匹配捕获是从str索引零的位置开始找\n   console.log(reg.exec(str));\n   console.log(reg.lastIndex); //=&gt;0 第一次匹配捕获完成，lastIndex没有改变，所以下一次exec依然是从字符串最开始找，找到的永远是第一个匹配到的 \n */\n\n/* reg = /\\d+/g;\n   console.log(reg.exec(str)); //=&gt;[&quot;2022&quot;...]\n   console.log(reg.lastIndex); //=&gt;11 设置全局匹配修饰符g后，第一次匹配完，lastIndex会自己修改\n   console.log(reg.exec(str)); //=&gt;[&quot;2023&quot;...]\n   console.log(reg.lastIndex); //=&gt;22\n   console.log(reg.exec(str)); //=&gt;[&quot;2024&quot;...]\n   console.log(reg.lastIndex); //=&gt;32\n   console.log(reg.exec(str)); //=&gt;null  当全部捕获后，再次捕获的结果是null，但是lastIndex又回归了初始值零，再次捕获又从第一个开始了...\n   console.log(reg.lastIndex); //=&gt;0\n   console.log(reg.exec(str)); //=&gt;[&quot;2019&quot;...] \n */\n\n/* reg = /\\d+/g;\n   if (reg.test(str)) &#123;\n           //=&gt;验证一下: 只有正则和字符串匹配我们再捕获\n        console.log(reg.lastIndex); //=&gt;11  基于test匹配验证后，lastIndex已经被修改为第一次匹配后的结果，所以下一次捕获不再从头开始\n        console.log(reg.exec(str)); //=&gt;[&quot;2023&quot;...]\n    &#125; \n */\n\n\n//=&gt;需求: 编写一个execAll，执行一次可以把所有匹配的结果捕获到 (前提正则一定要设置全局修饰符g)\n~ function() &#123;\n    function execAll(str = &quot;&quot;) &#123;\n        //=&gt;str: 需要匹配的字符串\n        //=&gt;this: RegExp的实例 (当前操作的正则)\n        //=&gt;进来后第一件事，是验证当前正则是否设置了g，不设置则不能在进行循环捕获了，否则会导致死循环\n        if (!this.global) return this.exec(str);\n        //=&gt;ary存储最后所有捕获的信息   res存储每一次捕获的内容\n        let ary = [],\n            res = this.exec(str);\n        while (res) &#123;\n            //=&gt;把每一次捕获的内容res[0]存放到数组中\n            ary.push(res[0]);\n            //=&gt;只要捕获的内容不为null，则继续捕获下去\n            res = this.exec(str);\n\n        &#125;\n        return ary.length === 0 ? null : ary;\n    &#125;\n    RegExp.prototype.execAll = execAll;\n&#125;();\n\nreg = /\\d+/g;\nconsole.log(reg.execAll(str));\n//=&gt;字符串中的match方法，可以在执行一次的情况下，捕获到所有匹配的数据 (前提: 正则也得设置g才可以)\nconsole.log(str.match(reg));\n</code></pre>\n<h3 id=\"正则的分组捕获\"><a href=\"#正则的分组捕获\" class=\"headerlink\" title=\"正则的分组捕获\"></a>正则的分组捕获</h3><pre><code class=\"js\">//=&gt;身份证号码\nlet str = &quot;130828199012040112&quot;;\nlet reg = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)\\d&#123;2&#125;(\\d)(?:\\d|X)$/;\nconsole.log(reg.exec(str)); //=&gt;[&#39;130828199012040112&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, index: 0, input: &#39;130828199012040112&#39;]\nconsole.log(str.match(reg)); //=&gt;[&#39;130828199012040112&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, index: 0, input: &#39;130828199012040112&#39;]\n//=&gt;第一项: 大正则匹配的结果\n//=&gt;其余项: 每一个小分组单独匹配捕获的结果\n//=&gt;如果设置了分组 (改变优先级)，但是捕获的时候不需要单独捕获，可以基于?:来处理\n</code></pre>\n<pre><code class=\"js\">//=&gt;既要捕获到&#123;数字&#125;，也想单独的把数字也获取到，例如:第一次找到&#123;0&#125; 还需单独获取0\nlet str = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;;\n\n/*\n    //=&gt;不设置g只匹配一次，exec和match获取的结果一致 (既有大正则匹配的信息，也有小分组匹配的信息)\n    let reg = /\\&#123;(\\d+)\\&#125;/;\n    console.log(reg.exec(str)); //=&gt;[&#39;&#123;0&#125;&#39;,&#39;0&#39;,...]\n    console.log(str.match(reg)); //=&gt;[&#39;&#123;0&#125;&#39;,&#39;0&#39;,...]\n*/\n\nlet reg = /\\&#123;(\\d+)\\&#125;/g;\n//console.log(str.match(reg)); //=&gt; [&#39;&#123;0&#125;&#39;, &#39;&#123;1&#125;&#39;, &#39;&#123;2&#125;&#39;]\t 多次匹配的情况下，match只能把大正则匹配的内容获取到，小分组匹配的信息无法获取\nlet aryBig = [],\n    arySmall = [],\n    res = reg.exec(str);\nwhile(res)&#123;\n    let [big,small] = res;\n    aryBig.push(big);\n    arySmall.push(small);\n    res = reg.exec(str);\n&#125;\nconsole.log(aryBig,arySmall); //=&gt;[&#39;&#123;0&#125;&#39;, &#39;&#123;1&#125;&#39;, &#39;&#123;2&#125;&#39;] (3) [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]\n</code></pre>\n<pre><code class=\"js\">//=&gt;分组的第三个作用: &quot;分组引用&quot;\nlet str = &quot;book&quot;; //=&gt;&quot;good&quot;、&quot;look&quot;、&quot;moon&quot;、&quot;foot&quot;...\nlet reg = /^[a-zA-Z]([a-zA-Z])\\1[a-zA-Z]$/; //=&gt;分组引用就是通过&quot;\\数字&quot;让其代表和对应分组出现一模一样的内容\nconsole.log(reg.test(&quot;book&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;deep&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;some&quot;)); //=&gt;false\n</code></pre>\n<h3 id=\"正则捕获的贪婪性\"><a href=\"#正则捕获的贪婪性\" class=\"headerlink\" title=\"正则捕获的贪婪性\"></a>正则捕获的贪婪性</h3><pre><code class=\"js\">let str = &quot;珠峰2022@2023培训&quot;;\n//=&gt;正则捕获的贪婪性: 默认情况下，正则捕获的时候，是按照当前正则所匹配的最长结果来获取的\nlet reg = /\\d+/g;\nconsole.log(str.match(reg)); //=&gt;[&quot;2019&quot;,&quot;2022&quot;]\n\n//=&gt;在量词元字符后面设置? : 取消捕获时候的贪婪性 (按照正则匹配的最短结果来获取) \nreg = /\\d+?/g;\nconsole.log(str.match(reg)); //=&gt;[&#39;2&#39;, &#39;0&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;0&#39;, &#39;2&#39;, &#39;3&#39;]\n</code></pre>\n<p><code>?\t问号在正则中的五大作用</code></p>\n<ul>\n<li>问号左边是非量词元字符 : 本身代表量词元字符，出现零到一次</li>\n<li>问号左边是量词元字符 : 取消捕获时候的贪婪性</li>\n<li>(?:) 只匹配不捕获</li>\n<li>(?&#x3D;) 正向预查</li>\n<li>(?!) 负向预查</li>\n</ul>\n<h3 id=\"其他正则捕获的方法\"><a href=\"#其他正则捕获的方法\" class=\"headerlink\" title=\"其他正则捕获的方法\"></a>其他正则捕获的方法</h3><p>1.test也能捕获 (本意是匹配)</p>\n<pre><code class=\"js\">let str = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;;\nlet reg = /\\&#123;(\\d+)\\&#125;/g;\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;0&quot;\n\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;1&quot;\n\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;2&quot;\n\nconsole.log(reg.test(str)); //=&gt;fasle\nconsole.log(RegExp.$1); //=&gt;&quot;2&quot;\t存储的是上次捕获的结果\n\n//=&gt;RegExp.$1~RegExp.$9: 获取当前本次正则匹配后，第一个到第九个分组的信息\n</code></pre>\n<p>2.replace 字符串中实现替换的方法 (一般都是伴随正则一起使用的)</p>\n<pre><code class=\"js\">let str = &quot;zhufeng@2022|zhufeng@2023&quot;;\n//=&gt;把&quot;zhufeng&quot;替换成&quot;珠峰&quot;\n// 1.不用正则，执行一次只能替换一个\nstr = str.replace(&quot;zhufeng&quot;,&quot;珠峰&quot;).replace(&quot;zhufeng&quot;,&quot;珠峰&quot;);\nconsole.log(str); //=&gt;&quot;珠峰@2022|珠峰@2023&quot;\n\n// 2.使用正则会简单点\nstr = str.replace(/zhufeng/g,&quot;珠峰&quot;);\nconsole.log(str); //=&gt;&quot;珠峰@2022|珠峰@2023&quot;\n</code></pre>\n<pre><code class=\"js\">let str = &quot;zhufeng@2022|zhufeng@2023&quot;;\n//=&gt;把&quot;zhufeng&quot;替换成&quot;zhufengpeixun&quot;\nstr = str.replace(&quot;zhufeng&quot;,&quot;zhufengpeixun&quot;).replace(&quot;zhufeng&quot;,&quot;zhufengpeixun&quot;);\nconsole.log(str); //=&gt;&quot;zhufengpeixunpeixun@2022|zhufeng@2023&quot; 每一次替换都是从字符串第一个位置开始找的 (类似于正则捕获的懒惰性)\n\n//=&gt;基于正则g可以实现\nstr = str.replace(/zhufeng/g,&quot;zhufengpeixun&quot;);\nconsole.log(str); //=&gt;&quot;zhufengpeixun@2022|zhufengpeixun@2023&quot;\n</code></pre>\n<p><strong>案例 : 把时间字符串进行处理</strong> </p>\n<pre><code class=\"js\">let time = &quot;2022-08-09&quot;;\n//=&gt;变为&quot;2022年08月09日&quot;\nlet reg = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/;\n\n//=&gt;这样可以实现\n//time = time.replace(reg,&quot;$1年$2月$3日&quot;);\n//console.log(time); //=&gt;&quot;2022年08月09日&quot;\n\n//=&gt;还可以这样处理 [str].replace([reg],[function])\n// 1.首先拿reg和time进行匹配捕获，能匹配到几次就会把传递的函数执行几次 (而且是匹配一次就执行一次)\n// 2.不仅把方法执行，而且replace还给方法传递了实参信息 (和exec捕获的内容一致的信息: 大正则匹配的内容，小分组匹配的信息....)\n// 3.在函数中我们返回的是啥，就把当前大正则匹配的内容替换成啥\n/*\n    time = time.replace(reg,(big,$1,$2,$3)=&gt;&#123;\n        //=&gt;这里的$1~$3是我们自己设置的变量\n        console.log(big,$1,$2,$3); //=&gt;&quot;2022-08-09 2022 08 09&quot;\n    &#125;);\n */\ntime = time.replace(reg,(...arg)=&gt;&#123; \n    console.log(arg);\n    let  [,$1,$2,$3] = arg;\n    $2.length&lt;2 ? $2=&quot;0&quot;+$2 : null;\n    $3.length&lt;2 ? $3=&quot;0&quot;+$3 : null;\n    return $1+&quot;年&quot;+$2+&quot;月&quot;+$3+&quot;日&quot;;\n&#125;); \n</code></pre>\n<p><strong>单词首字母大写</strong></p>\n<pre><code class=\"js\">let str = &quot;good good study, day day up! &quot;;\nlet reg = /\\b([a-zA-Z])[a-zA-Z]*\\b/g;\n//=&gt;函数被执行了六次，每一次都把正则匹配信息传递给函数\n//=&gt;每一次arg: [&#39;good&#39;,&#39;g&#39;] [&#39;good&#39;,&#39;g&#39;] [&#39;good&#39;,&#39;g&#39;] [&#39;study&#39;,&#39;s&#39;]...\nstr = str.replace(reg,(...arg)=&gt;&#123;\n    let [content,$1] = arg;\n    $1 = $1.toUpperCase();\n    content = content.substring(1);\n    return $1 + content;\n&#125;);\nconsole.log(str); //=&gt;&quot;Good Good Study, Day Day Up! &quot;\n</code></pre>\n<p><strong>验证一个字符串中哪个字母出现的次数最多，多少次?</strong></p>\n<pre><code class=\"js\">let str = &quot;zhufengpeixunzhoulaoshi&quot;;\n\n/*\n *\t去重思维\n */\nlet obj = &#123;&#125;;\n[].forEach.call(str,char=&gt;&#123;\n    if(typeof obj[char] !== &quot;undefined&quot;)&#123;\n        obj[char++];\n        return;\n    &#125;\n    obj[char] = 1; \n&#125;);\nconsole.log(obj);let obj = &#123;&#125;;\n[].forEach.call(str, char =&gt; &#123;\n    if (typeof obj[char] !== &quot;undefined&quot;) &#123;\n        obj[char]++;\n        return;\n    &#125;\n    obj[char] = 1;\n&#125;);\nlet max = 1,\n    res = [];\nfor (let key in obj) &#123;\n    let item = obj[key];\n    item &gt; max ? max = item : null;\n&#125;\nfor (let key in obj) &#123;\n    let item = obj[key];\n    if (item === max) &#123;\n        res.push(key);\n    &#125;\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n\n/*\n *\t排序\n */\nstr = str.split(&#39;&#39;).sort((a, b) =&gt; a.localeCompare(b)).join(&#39;&#39;);\n//console.log(str); //=&gt;&quot;aeefghhhiilnnoopsuuuxzz&quot;\nlet reg = /([a-zA-Z])\\1+/g;\nlet ary = str.match(reg); //=&gt;[&#39;ee&#39;, &#39;hhh&#39;, &#39;ii&#39;, &#39;nn&#39;, &#39;oo&#39;, &#39;uuu&#39;, &#39;zz&#39;]\nary.sort((a, b) =&gt; b.length - a.length);\nconsole.log(ary); //=&gt;[&#39;hhh&#39;, &#39;uuu&#39;, &#39;ee&#39;, &#39;ii&#39;, &#39;nn&#39;, &#39;oo&#39;, &#39;zz&#39;]\nlet max = ary[0].length,\n    res = [ary[0].substr(0, 1)];\nfor (let i = 1; i &lt; ary.length; i++) &#123;\n    let item = ary[i];\n    if (item.length &lt; max) &#123;\n        break;\n    &#125;\n    res.push(item.substr(0, 1));\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n\n/*\n *\t正则\n */\nlet max = 0,\n    res = [],\n    flag = false;\nstr = str.split(&#39;&#39;).sort((a, b) =&gt; a.localeCompare(b)).join(&#39;&#39;);\n// console.log(str); //=&gt;&quot;aeefghhhiilnnoopsuuuxzz&quot;\nfor (let i = str.length; i &gt; 0; i--) &#123;\n    let reg = new RegExp(&quot;([a-zA-Z])\\\\1&#123;&quot; + (i - 1) + &quot;&#125;&quot;, &quot;g&quot;);\n    // i=3  /([a-zA-Z])\\1&#123;2&#125;/  &quot;hhh&quot; &quot;uuu&quot;\n    str.replace(reg, (content, $1) =&gt; &#123;\n        res.push($1);\n        max = i;\n        flag = true;\n    &#125;);\n    if (flag) break;\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n</code></pre>\n<p><strong>时间字符串格式化</strong></p>\n<pre><code class=\"js\">~ function() &#123;\n    /* \n     *  formatTime: 时间字符串的格式化处理\n     */\n    /* function formatTime() &#123;\n        // 1.首先获取时间字符串中的年月日等信息\n        let timeAry = this.match(/\\d+/g);\n        // console.log(timeAry)//[&#39;2022&#39;, &#39;8&#39;, &#39;10&#39;, &#39;16&#39;, &#39;00&#39;, &#39;43&#39;]\n        let template = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;;\n        template = template.replace(/\\&#123;(\\d+)\\&#125;/g, (content, $1) =&gt; &#123;\n            //=&gt;content: 当前本次大正则匹配的信息   $1: 本次小分组单独匹配的信息\n            //以$1的值作为索引，到timeAry中找到对应的时间 (如果没有则用&quot;00&quot;补)\n            let time = timeAry[$1] || &quot;00&quot;;\n            time.length &lt; 2 ? time = &quot;0&quot; + time : null;\n            return time;\n        &#125;)\n        return template;\n    &#125;*/\n    //=&gt;简化版本\n    /* \n     *  formatTime: 时间字符串的格式化处理\n     *  @params\n     *      template: [string] 我们最后期望获取日期格式的模板\n     *      模板规则: &#123;0&#125;-&gt;年  &#123;1~5&#125;-&gt;月日时分秒\n     *  @return\n     *      [string]格式化后的时间字符串\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function formatTime(template = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;) &#123;\n        let timeAry = this.match(/\\d+/g);\n        return template = template.replace(/\\&#123;(\\d+)\\&#125;/g, (...[, $1]) =&gt; &#123;\n            let time = timeAry[$1] || &quot;00&quot;;\n            return time.length &lt; 2 ? time = &quot;0&quot; + time : time;\n        &#125;);\n    &#125;\n\n    /* 扩展到内置类String.prototype上 */\n    [&quot;formatTime&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\n\n//=&gt;服务器获取的\n// &quot;2022-8-10 16:00:43&quot;\n// &quot;2022/8/10 16:00:43&quot;\n// &quot;2022/8/10&quot;\n//=&gt;想要转变为的格式\n// &quot;08月10日 16时00分&quot;\n// &quot;2022年8月10日&quot;\n// ...\nlet time = &quot;2022-8-10 16:00:43&quot;;\nconsole.log(time.formatTime()); //=&gt;2022年08月10日 16时00分43秒\nconsole.log(time.formatTime(&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;)); //=&gt;2022年08月10日\nconsole.log(time.formatTime(&quot;&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;&quot;)); //=&gt;08-10 16:00\ntime = &quot;2022/8/13&quot;;\nconsole.log(time.formatTime()); //=&gt;2022年08月13日 00时00分00秒\nconsole.log(time.formatTime(&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;)); //=&gt;2022年08月13日\nconsole.log(time.formatTime(&quot;&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;&quot;)); //=&gt;08-13 00:00\n</code></pre>\n<p><em><strong>queryURLParams</strong></em></p>\n<pre><code class=\"js\">~ function() &#123;\n    /* \n     *  queryURLParams: 获取URl地址问号和后面的参数信息 (可能也包含HASH值)\n     *  @params   \n     *  @return\n     *      [object]把所有问号参数信息以键值对的方式存储起来并且返回\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function queryURLParams() &#123;\n        let obj = &#123;&#125;;\n        this.replace(/([^?=&amp;#]+)=([^?=&amp;#]+)/g, (...[, $1, $2]) =&gt; obj[$1] = $2);\n        this.replace(/#([^?=&amp;#]+)/g, (...[, $1]) =&gt; obj[&#39;HASH&#39;] = $1);\n        return obj;\n    &#125;\n    \n    /* 扩展到内置类String.prototype上 */\n    [&quot;queryURLParams&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\nlet url = &quot;http://www.zhufengpeixun.cn/?lx=1&amp;from=wx#video&quot;;\nconsole.log(url.queryURLParams()); //=&gt;&#123;lx: &#39;1&#39;, from: &#39;wx&#39;, HASH: &#39;video&#39;&#125;\n</code></pre>\n<p><strong>千分符</strong></p>\n<pre><code class=\"js\">~ function() &#123;\n    /* \n     *  millimeter: 实现大数字的千分符处理\n     *  @params    \n     *  @return\n     *      [string]千分符后的字符串\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function millimeter() &#123;\n        return this.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g, content =&gt; content + &#39;,&#39;);\n    &#125;\n\n    /* 扩展到内置类String.prototype上 */\n    [&quot;millimeter&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\nlet num = &quot;15628954&quot;; //=&gt;&quot;15,628,954&quot; 千分符\nconsole.log(num.millimeter()); //=&gt;&quot;15,628,954&quot;\n\n// 把字符串倒过来\nnum = num.split(&#39;&#39;).reverse().join(&#39;&#39;);\nfor (let i = 2; i &lt; num.length - 1; i += 4) &#123;\n    let prev = num.substring(0, i + 1),\n        next = num.substring(i + 1);\n    num = prev + &quot;,&quot; + next;\n&#125;\nnum = num.split(&#39;&#39;).reverse().join(&#39;&#39;);\nconsole.log(num); //=&gt;&quot;15,628,954&quot;\n</code></pre>\n","categories":["正则表达式"],"tags":["正则表达式"]},{"title":"杂记","url":"/2023/01/01/%E6%9D%82%E8%AE%B0/","content":"<h1 id=\"category标签\"><a href=\"#category标签\" class=\"headerlink\" title=\"category标签\"></a>category标签</h1><p>category标签定义类别，表示一类的主题内容</p>\n<Category title=\"电影\">\n```html\n<video controls src=\"媒体文件\"></video>\n```\n\n</Category>\n\n<h1 id=\"track标签\"><a href=\"#track标签\" class=\"headerlink\" title=\"track标签\"></a>track标签</h1><p>用于在媒体标签中处理文字           <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track\"><code>&lt;track&gt;</code></a></p>\n<h1 id=\"figure标签\"><a href=\"#figure标签\" class=\"headerlink\" title=\"figure标签\"></a>figure标签</h1><p>figure标签（可附标题内容元素，通常内部使用图片和媒体，也有利于SEO）</p>\n<pre><code class=\"html\">&lt;figure&gt;\n  &lt;img\n    src=&quot;/zh-CN/docs/Web/HTML/Element/figure/favicon-192x192.png&quot;\n    alt=&quot;The beautiful MDN logo.&quot; /&gt;\n  &lt;figcaption&gt;MDN Logo&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre>\n<h1 id=\"iframe内联标签\"><a href=\"#iframe内联标签\" class=\"headerlink\" title=\"iframe内联标签\"></a>iframe内联标签</h1><h6 id=\"iframe内联框架标签：\"><a href=\"#iframe内联框架标签：\" class=\"headerlink\" title=\"iframe内联框架标签：\"></a>iframe内联框架标签：</h6><pre><code class=\"html\">  &lt;iframe src=&quot;./student.html&quot; name=&quot;fm&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;当点击`&lt;a href=&quot; &quot; target=&quot;fm&quot;&gt; &lt;/a&gt;` 标签时，只会替换跳转iframe页面，而非整个网页\n</code></pre>\n<p><strong>使用ifram标签访问页面</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        iframe &#123;\n            width: 100%;\n            height: 650px;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;iframe src=&quot;https://www.csdn.net/&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h1 id=\"lt-x3D-符号-gt\"><a href=\"#lt-x3D-符号-gt\" class=\"headerlink\" title=\"&lt;%&#x3D; 符号 %&gt;\"></a>&lt;%&#x3D; 符号 %&gt;</h1><p> <strong>用于html中嵌入js语句</strong></p>\n<h1 id=\"css属性\"><a href=\"#css属性\" class=\"headerlink\" title=\"css属性\"></a>css属性</h1><p>css 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL1JlZmVyZW5jZQ==\">100 多个属性</span> </p>\n<h1 id=\"CSS-基本数据类型\"><a href=\"#CSS-基本数据类型\" class=\"headerlink\" title=\"CSS 基本数据类型\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL0NTU19UeXBlcw==\">CSS 基本数据类型</span></h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL2ZpbHRlcg==\">filter</span>  用于定义滤镜</p>\n<h1 id=\"选择文件夹\"><a href=\"#选择文件夹\" class=\"headerlink\" title=\"选择文件夹\"></a>选择文件夹</h1><p>**<code>showDirectoryPicker()</code>**方法，用于选择文件夹目录</p>\n<p>**<code>showOpenFilePicker()</code>**用于显示一个文件选择器</p>\n<p><code>showSaveFilePicker()</code>用于更改一个文件</p>\n<h1 id=\"JS引擎优化\"><a href=\"#JS引擎优化\" class=\"headerlink\" title=\"JS引擎优化\"></a>JS引擎优化</h1><p>一、<em>小的数字类型(Sim) ,占据四个字节 , 正常num占据八个字节</em></p>\n<p>二、</p>\n<h1 id=\"js8种数据类型\"><a href=\"#js8种数据类型\" class=\"headerlink\" title=\"js8种数据类型\"></a>js<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9QcmltaXRpdmU=\">8种数据类型</span></h1><p><strong>基本：</strong>null、undefined、number、boolean、string、symbol、bigInt、</p>\n<p>**引用数据类型 :  **    Object</p>\n<h1 id=\"for-in循环和for-of循环\"><a href=\"#for-in循环和for-of循环\" class=\"headerlink\" title=\"for  in循环和for  of循环\"></a>for  in循环和for  of循环</h1><p>（1）for  in 通常遍历对象，for  of通常遍历数组</p>\n<p>（2）<code>for  in</code> 会遍历对象的可枚举属性，这个过程是通过原型链实现的 ；<code>for...of</code> 循环遍历可迭代对象的元素，这个过程是通过迭代器实现的。</p>\n<p>（3）实际上，在底层，<code>for...in</code> 循环会遍历对象自身及其原型链上所有可枚举的属性（包括继承自父对象的属性），因此需要使用 <code>hasOwnProperty()</code> 方法来判断属性是否是对象自身的属性。<code>for...of</code> 循环实际上是基于这个迭代器实现的。循环首先获取可迭代对象的迭代器，然后按照迭代器定义的顺序依次遍历每个元素，并将当前元素的值赋给循环变量。</p>\n<h1 id=\"封装的简易随机数\"><a href=\"#封装的简易随机数\" class=\"headerlink\" title=\"封装的简易随机数\"></a>封装的简易随机数</h1><pre><code class=\"js\">        //随机数\n            function rannum (min, max) &#123;\n            return Math.round(Math.random() * (max - min)) + min;\n            &#125;\n</code></pre>\n<h1 id=\"解决获取对象属性时存在的兼容性问题\"><a href=\"#解决获取对象属性时存在的兼容性问题\" class=\"headerlink\" title=\"解决获取对象属性时存在的兼容性问题\"></a>解决获取对象属性时存在的兼容性问题</h1><h6 id=\"获取对象属性问题\"><a href=\"#获取对象属性问题\" class=\"headerlink\" title=\"获取对象属性问题\"></a>获取对象属性问题</h6><ol>\n<li><p>浏览器兼容性：不同浏览器在处理 CSS 属性名称上存在差异。例如，某些浏览器可能将 <code>background-color</code> 属性解析为 <code>backgroundColor</code>，而另一些浏览器则保持原样。这就导致了使用 <code>obj.attr</code> 的方式无法跨浏览器获得准确的样式值。</p>\n</li>\n<li><p>获取计算后样式：直接通过 <code>obj.attr</code> 获取的是元素的内联样式（即<strong>行内样式</strong>），而不是计算后的样式（包括 CSS 样式和继承样式）。如果需要获取元素显示时的实际样式，例如考虑到外部样式表或通过其他选择器影响的样式，需要使用 <code>getComputedStyle</code> 或 <code>currentStyle</code> 方法。</p>\n<p>**例如：如下代码中，dom获取的属性值和页面呈现的值不一致</p>\n<pre><code class=\"html\">&lt;style&gt;\ndiv&#123; width: 100px !important;  &#125;\n&lt;/style&gt;\n&lt;body&gt;&lt;div style=&quot;width:500px;height:10px;background-color:black&quot;&gt;&lt;/div&gt;&lt;/body&gt;\n&lt;script&gt;\nlet div = document.querySelector(&#39;div&#39;)\n    console.log(div.style.width)     // 页面呈现的为100px, dom获取到的是行内样式（500px）\n&lt;/script&gt;\n</code></pre>\n</li>\n</ol>\n<h6 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h6><p>封装函数获取计算后的dom元素属性值（<code>getComputedStyle</code>）,同时注意IE浏览器没有此方法</p>\n<pre><code class=\"js\">function getstyle(obj, attr) &#123;\n    if (window.getComputedStyle) &#123; //标准\n        return getComputedStyle(obj)[attr];\n    &#125; else &#123; //IE\n        return obj.currentStyle[attr];\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"js\">//非 IE 浏览器中，currentStyle 属性是不存在的\nfunction getStyle(obj, attr) &#123;\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle(obj, null)[attr];\n&#125;\n</code></pre>\n<h1 id=\"构造函数创建对象方法\"><a href=\"#构造函数创建对象方法\" class=\"headerlink\" title=\"构造函数创建对象方法\"></a>构造函数创建对象方法</h1><p>静态方法只能通过构造函数调用，实例方法通过对象调用，定义在对象身上，原型方法通过对象调用，定义在对象原型上（节省内存）</p>\n<p>原型方法和实例方法是 JavaScript 中定义在对象上的两种不同类型的方法，它们有以下区别和好处：</p>\n<ol>\n<li>区别：<ul>\n<li>原型方法：定义在对象的原型上，即通过构造函数的 <code>prototype</code> 属性添加的方法。所有通过该构造函数创建的实例对象都共享同一个原型方法。</li>\n<li>实例方法：定义在对象实例上，通过构造函数创建的每个对象实例都具有自己的实例方法。</li>\n</ul>\n</li>\n<li>好处：<ul>\n<li>原型方法的好处：<ul>\n<li>节省内存：所有通过构造函数创建的实例对象共享原型方法，避免为每个实例对象重复创建方法，节省了内存开销。</li>\n<li>动态性：原型方法的修改会立即反映在所有实例对象上。当你在原型上添加、删除或修改方法时，所有实例对象会自动继承这些变化，无需更新每个实例对象。</li>\n</ul>\n</li>\n<li>实例方法的好处：<ul>\n<li>封装性：实例方法可以使用构造函数内部的变量和方法，实现更灵活和封装的对象行为。</li>\n<li>访问实例属性：实例方法可以直接访问实例对象的属性，因为它们是在实例对象中定义的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"js\">// 构造函数\nfunction People(color) &#123;\n    this.color = color;\n    this.seeColor = function() &#123;\n        console.log(&quot;color is &quot;+this.color)\n    &#125;\n&#125;\n// 静态方法\nPeople.say = function() &#123;\n    console.log(&quot;静态方法color is &quot;, this.color)\n&#125;\n// 原型方法\nPeople.prototype.eat = function() &#123;\n    console.log(&quot;原型方法color is &quot;, this.color)\n&#125;\n// 实例\nvar pp = new People();\n\n// 调用静态方法\nPeople.say(); // 静态方法color is  undefined\npp.say(); // 报错信息：Uncaught TypeError: pp.say is not a function\n\n// 调用原型方法\nPeople.eat(); // 报错信息：Uncaught TypeError: People.eat is not a function\npp.eat(); // 原型方法color is  Red\n\n// 调用实例方法\nPeople.seeColor(); // Uncaught TypeError: People.seeColor is not a function\npp.seeColor(); // color is Red\n</code></pre>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9hbGw=\">Promise.all()</span></h3><p>Promise.all（）静态方法接受一个Promose可迭代对象作为输入，并返回一个Promise，当所有输入的Promise都被兑现时，返回的Promise也将被兑现，并返回一个包含所有对闲置的数组，如果输入的任何Promise都被拒绝，则返回的Promise也将被拒绝</p>\n<h1 id=\"生成乱文\"><a href=\"#生成乱文\" class=\"headerlink\" title=\"生成乱文\"></a>生成乱文</h1><p>以下是使用 <code>lorem</code> 快捷键生成乱文的步骤：</p>\n<ol>\n<li>在编辑器中选中或定位到您想要插入乱文的位置。</li>\n<li>键入 <code>lorem</code> 并按下 Tab 键。</li>\n</ol>\n<p>这将会触发代码片段的展开，生成一段默认长度的乱文。</p>\n<p>如果您需要生成特定长度的乱文，可以在 <code>lorem</code> 后面跟随所需的长度，例如 <code>lorem5</code> 会生成 5 个单词的乱文。</p>\n<h1 id=\"NodeList和HTMLCollection\"><a href=\"#NodeList和HTMLCollection\" class=\"headerlink\" title=\"NodeList和HTMLCollection\"></a>NodeList和HTMLCollection</h1><p>他们都是伪数组 ， 用typeof进行检测时，返回function。</p>\n<p>1、NodeList（<code>.querySelectorAll(selector)</code>、<code>.childNodes</code>、<code>.getElementsByName</code> .querySelectorAll等获取）</p>\n<p><code>NodeList</code> 包含文档中匹配选择器所得到的所有节点，包括元素、文本节点、注释节点等；<code>NodeList</code> 是动态的，即当文档中的节点发生变化时，<code>NodeList</code> 中的内容也会实时发生变化。</p>\n<p>2、HTMLCollection（<code>.getElementsByClassName()</code>、<code>.getElementsByTagName( )</code>等）</p>\n<p>而 <code>HTMLCollection</code> 则只包含文档中指定标签名的元素节点；</p>\n<p>而 <code>HTMLCollection</code> 是静态的，在创建后不会随着文档中的节点变化而自动更新。</p>\n<p>两者都可以像数组一样使用索引访问其成员，但 <code>NodeList</code> 对象具有更多的方法（如 <code>forEach</code>、<code>item</code> 等），而 <code>HTMLCollection</code> 相对较少。<code>NodeList</code> 和 <code>HTMLCollection</code> 都可以用于获取文档中的元素集合，并进行相关操作。其中，<code>HTMLCollection</code> 更适用于固定集合的情况，如 <code>document.forms</code>、<code>document.links</code>、<code>document.images</code> 等；而 <code>NodeList</code> 则更适用于动态查询、筛选和遍历节点的情况，</p>\n<h1 id=\"HTML-Element所有的元素\"><a href=\"#HTML-Element所有的元素\" class=\"headerlink\" title=\"HTML Element所有的元素\"></a>HTML Element所有的元素</h1><p>(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9FbGVtZW50\">HTML 元素</span>)</p>\n<h1 id=\"HTML全局属性\"><a href=\"#HTML全局属性\" class=\"headerlink\" title=\"HTML全局属性\"></a>HTML全局属性</h1><h2 id=\"全局属性列表\"><a href=\"#全局属性列表\" class=\"headerlink\" title=\"全局属性列表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcyMlRTUlODUlQTglRTUlQjElODAlRTUlQjElOUUlRTYlODAlQTclRTUlODglOTclRTglQTElQTg=\">全局属性列表</span></h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy9kYXRhLSo=\">data-* 属性</span></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus\"><code>autofocus</code> (en-US)</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/autocapitalize\"><code>autocapitalize</code></a></p>\n<p>等</p>\n<h1 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket\"><code>WebSocket</code></a></h1><p>XML和WebSocket</p>\n<p>XML是一种用于存储和传输数据的标准格式，常用于Web应用程序之间传递数据。XML的好处是灵活、可扩展、易于阅读，并且可以通过各种编程语言解析和操作。使用XML，我们可以定义自己的标记来描述数据，达到数据交换的目的。</p>\n<p>WebSocket是HTML5提供的一种新的网络通信协议。它可以在浏览器和服务器之间建立一个实时的、双向通信的通道，使得数据可以实时地双向传输。WebSocket的好处是实时性好、带宽利用率高、开发成本低，能够有效地解决HTTP协议中存在的单向请求-响应模式不能满足实时性需求的问题。</p>\n<p>在实际开发中，XML和WebSocket可以结合使用。例如，可以使用XML来编写数据格式，然后使用WebSocket将数据传输到客户端或服务器端。这样可以实现双向通信，并且能够按需发送和接收数据，从而提高了系统的实时性和效率。</p>\n<pre><code class=\"js\">// WebSocket构造器创建一个WebSocket对象\n    var socket = new WebSocket(&quot;ws://127.0.0.1:9000&quot;);\n    // 当连接上时,给服务端发送数据\n    socket.addEventListener(&quot;open&quot;, function (e) &#123;\n        socket.send(&quot;Hello Server!&quot;);\n    &#125;);\n    let div = document.querySelector(&#39;div&#39;)\n    // 收到数据时，进行处理\n    socket.addEventListener(&quot;message&quot;, function (event) &#123;\n        var blob = event.data;\n        console.log(event.data);\n        let a = JSON.parse(event.data);\n        console.log(a.list);\n        for (let i = 0; i &lt; a.list.length; i++) &#123;\n            // 遍历得到每一个数组\n            let p = document.createElement(&#39;p&#39;)\n            console.log(a.list[i].name);\n            p.innerText = a.list[i].name\n            div.appendChild(p)\n        &#125;\n    &#125;);\n</code></pre>\n<p>fetch（ES6原生，是基于Promise对象封装的方法）、axios（基于XMLHttpRequest的库）和 XMLHttpRequest都可以用于请求数据</p>\n<h1 id=\"void一元运算符\"><a href=\"#void一元运算符\" class=\"headerlink\" title=\"void一元运算符\"></a>void一元运算符</h1><h3 id=\"在箭头函数中避免泄漏\"><a href=\"#在箭头函数中避免泄漏\" class=\"headerlink\" title=\"在箭头函数中避免泄漏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3ZvaWQjJUU1JTlDJUE4JUU3JUFFJUFEJUU1JUE0JUI0JUU1JTg3JUJEJUU2JTk1JUIwJUU0JUI4JUFEJUU5JTgxJUJGJUU1JTg1JThEJUU2JUIzJTg0JUU2JUJDJThG\">在箭头函数中避免泄漏</span></h3><p>箭头函数标准中，允许在函数体不使用括号来直接返回值。如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用。安全起见，当函数返回值不会被使用到的时候，应该使用 <code>void</code> 运算符，来确保 API 改变时，并不会改变箭头函数的行为。</p>\n<pre><code class=\"js\">button.onclick = () =&gt; void doSomething();\n</code></pre>\n<p>运算js表达式，返回undefined</p>\n<pre><code class=\"html\">&lt;a href=&quot;javascript:void(document.form.submit())&quot;&gt;Click here to submit&lt;/a&gt;\n</code></pre>\n<h1 id=\"in关系运算符\"><a href=\"#in关系运算符\" class=\"headerlink\" title=\"in关系运算符\"></a>in关系运算符</h1><p>使用键，而非值</p>\n<p>一、数组：</p>\n<p>index  in  arr   （使用索引，不能用值，数组中默认index为键，还有length键）</p>\n<p>二、对象：</p>\n<p> “PI” <strong>in</strong> Math**;**（例子），注意不可枚举的属性会返回false，如对象中Prototype</p>\n<p>三、字符串</p>\n<pre><code class=\"js\">  var myString = new String(&quot;coral&quot;);\n        &quot;length&quot; in myString; // returns true\n        var mycar = &#123; make: &quot;Honda&quot;, model: &quot;Accord&quot;, year: 1998 &#125;;\n        &quot;make&quot; in mycar; // returns true\n        &quot;model&quot; in mycar; // returns true\n</code></pre>\n<h1 id=\"draggable属性\"><a href=\"#draggable属性\" class=\"headerlink\" title=\"draggable属性\"></a>draggable属性</h1><p>设置元素可拖拽，相关事件：ondragstart拖拽开始、ondragover拖拽经过、ondragenter拖拽进入和ondrop停止拖拽。事件中(event . )包含dataTransfer.effectAllowed&#x3D;“ copy ”等，表示设置拖拽复制还是移动 move</p>\n<h1 id=\"css变量\"><a href=\"#css变量\" class=\"headerlink\" title=\"css变量\"></a>css变量</h1><pre><code class=\"css\">:root&#123;\n--big-size:20px;\n--color-green:green;\n&#125;\n</code></pre>\n<h1 id=\"分号分隔的重要性\"><a href=\"#分号分隔的重要性\" class=\"headerlink\" title=\"分号分隔的重要性\"></a>分号分隔的重要性</h1><pre><code class=\"js\">// 你不知道的JS------报错\nfunction foo(el) &#123;\n    console.log(el, this.id);\n&#125;\nvar obj = &#123;\n    id: &quot;awesom&quot; \n&#125;;\n// 分号很关键，在特殊用法的时候，不用分号断开会报错\n[1, 2, 3].forEach(foo, obj)\n</code></pre>\n<h1 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h1><h6 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h6><p>普通函数的this的绑定与函数调用方式有关，与函数定义的位置无关，</p>\n<h6 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h6><p> 箭头函数的this与函数定义位置有关，与调用方式无关,（但与上层作用域的调用方式有关，上层this改变时，会跟着改变），其没有自己的this，会找沿用上层的this。</p>\n<h6 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h6><p> 立即执行函数的this一定指向window（因为会立即执行，太早执行了）</p>\n<h6 id=\"定时器函数\"><a href=\"#定时器函数\" class=\"headerlink\" title=\"定时器函数\"></a>定时器函数</h6><p> 定时器里的函数的this一定指向window（因为会被赋为函数地址，延迟后普通调用）</p>\n<h6 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h6><p> 事件处理函数<strong>普通形式</strong>的this指向绑定的DOM元素（ 注意和e.target有所区别 ），箭头函数形式指向绑定的作用域</p>\n<p>一、this的默认绑定（独立函数调用）</p>\n<pre><code class=\"js\">var obj = &#123;\n    name: &#39;jgas&#39;,\n    foo: function () &#123;\n        console.log(this);\n    &#125;\n&#125;\nvar bar = obj.foo\n// -----------                 this默认绑定\n// this的指向与调用方式有关\nobj.foo(); //this指向obj\nbar();  //this指向window\n</code></pre>\n<p>二、this的隐式绑定（对象函数调用，或数组调用）</p>\n<pre><code class=\"js\">// 定义一个对象\nconst person = &#123;\n  name: &#39;Alice&#39;,\n  sayHello: function() &#123;\n    console.log(&#39;Hello, &#39; + this.name);\n  &#125;\n&#125;;\n\n// 调用对象的方法\nperson.sayHello(); // 输出：Hello, Alice\n</code></pre>\n<p>三、this的显示绑定（特殊方法调用）</p>\n<pre><code class=\"js\">函数名.call()  // -----call传参数用 , 分割  this写在第一个形参\n函数名.apply()  //---apply传参用[]数组,   this写在第一个形参\n函数名.bind()   //-------bind ,显示绑定对象中的this,this写在第一个形参\n// 当使用这些函数改变this指向，传入null或者undefined时，自动将this绑定为全局对象\n</code></pre>\n<p>四、通过new关键字绑定（实例调用）</p>\n<p>通过new关键字进行绑定时，会创建一个实例对象的时候将this绑定到实例上。</p>\n<pre><code class=\"js\">function Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n&#125;\n\nconst person1 = new Person(&#39;Alice&#39;, 25);\nconsole.log(person1.name); // 输出：Alice\nconsole.log(person1.age); // 输出：25\n// JS中通过new关键字进性绑定this就是new绑定,new绑定会在生成实例时尽享绑定,指向构造的实例\n</code></pre>\n<p>五、this绑定的优先级：</p>\n<p><em>new关键字绑定 &gt; bind 方法绑定     ;         new &gt; 隐式绑定       ;   显示绑定      &gt;           隐式绑定;                   默认绑定优先级最低</em></p>\n<p>六、箭头函数的this</p>\n<p>箭头函数不会创建自己的执行上下文，而是继承了外部作用域的执行上下文。这意味着箭头函数的 <code>this</code> 值是在定义函数时确定的，而不是在函数调用时确定的。箭头函数的 <code>this</code> 始终指向其定义时所处的上下文，无论它在哪里被调用。</p>\n<pre><code class=\"js\">function Person(name)&#123;\n    this.name = name\n    this.obj = &#123;\n        name:&#39;obj&#39;,\n        foo1:function()&#123;\n            return function()&#123;\n                console.log(this.name)\n            &#125;\n        &#125;,\n        foo2:function()&#123;\n            return ()=&gt;&#123;\nconsole.log(this.name)\n            &#125;\n        &#125;\n    &#125;\n&#125;\nvar person1 = new Person(&#39;person1&#39;)\nvar person2 = new Person(&#39;person2&#39;)\n</code></pre>\n<p>①普通函数，独立调用</p>\n<pre><code class=\"js\">person1.obj.foo1()()  //普通函数独立调用，this指向window\nperson1.obj.foo1.call(person2)()//普通函数独立调用，this指向window\nperson1.obj.foo1().call(person2)//普通函数，通过call进行调用，this指向person2\n</code></pre>\n<p>②箭头函数独立调用</p>\n<pre><code class=\"js\">person1.obj.foo2()()  //箭头函数不绑定this去上一层找，this指向obj\nperson1.obj.foo2.call(person2)()  //call方法绑定作用域，然后调用，里面的箭头函数没this，去外层作用域查找，this指向person2\nperson1.obj.foo2().call(person2)  //obj隐式调用函数，后面call调用箭头函数没有this，因此去外层作用于查找，this指向obj\n</code></pre>\n<h1 id=\"let和const声明的影响\"><a href=\"#let和const声明的影响\" class=\"headerlink\" title=\"let和const声明的影响\"></a>let和const声明的影响</h1><p>let和const声明的变量不会存储到window对象中，而是存储到VariableMap中。</p>\n<p><strong>（引入let和const关键字之后，window和GlobalObject已经不是同一个对象了，let和const声明的变量存在VariableMap中、一个hash map，当使用变量时会在VariableMap中查找）</strong></p>\n<h1 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a>NaN</h1><p>NaN&#x3D;&#x3D;&#x3D;NaN 返回false，因为NaN是一个特殊的Number类型的值（不是对象），存储时为双精度浮点型，每次取出都不一样。（NaN和其他值永不相等！）</p>\n<p>相较于Infinity，Infinity&#x3D;&#x3D;&#x3D;Infinity返回的是true。</p>\n<h1 id=\"函数和对象的原型问题\"><a href=\"#函数和对象的原型问题\" class=\"headerlink\" title=\"函数和对象的原型问题\"></a>函数和对象的原型问题</h1><p>函数可以看成是特殊的对象，函数的原型指向对象，而在JS当中Object是一个构造函数，每个构造函数都是Function的实例，因此，Object是Function的一个实例。</p>\n<pre><code class=\"js\">console.log(typeof Function); //function\nconsole.log(Object.getOwnPropertyDescriptors(Function));//不会报错\nconsole.log(Function instanceof Object);   //true\nconsole.log(Function instanceof Function);   //true\nconsole.log(Object instanceof Object);   //true\nconsole.log(Object instanceof Function);   //true\nconsole.log(Array instanceof Function);  //true\nconsole.log(Number instanceof Function); //true\nconsole.log(BigInt instanceof Function);  //true\n</code></pre>\n<h1 id=\"双等号和三等号\"><a href=\"#双等号和三等号\" class=\"headerlink\" title=\"双等号和三等号\"></a>双等号和三等号</h1><p>双等号和三等号的区别在于，是否会进行隐式转换。而在是否判断地址上没有区别（无论是双等号还是三等号 ， 判断应用数据类型时都会判断地址是否相等），因此两者的区别仅在于判断基本数据类型时是否隐式转换。</p>\n<pre><code class=\"js\">let as = [1, 2]\nlet bs = [1, 2]\nconsole.log(as == bs);   //F\nconsole.log(as === bs);  //F   判断引用类型值时,无论是双等号,还是三等号,都会判断内存地址\nlet cs = 100;\nlet ds = &#39;100&#39;;\nconsole.log(cs == ds);   //T   隐式转换\nconsole.log(cs === ds); //F    判断简单类型值时,都不会判断其地址\n</code></pre>\n<h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h1><h1 id=\"Vue-use和Vue-component\"><a href=\"#Vue-use和Vue-component\" class=\"headerlink\" title=\"Vue.use和Vue.component\"></a>Vue.use和Vue.component</h1><ol>\n<li>Vue.use与vue.component的区别<br><code>Vue.use</code>是用于<strong>注册插件</strong>,这个插件必须是一个对象  。 插件是通过将Vue构造函数上添加方法和属性，来扩展Vue功能。</li>\n<li>而<code>vue.component</code>是<strong>注册组件</strong>.差别就像是Vue.use&#x3D;只能穿戴,vue.component&#x3D;手机.Vue.use比vue.component更强大,一般是由多个组件组成  .  组件是Vue实例的一部分，用于封装可复用的模块。</li>\n<li>vue.use 如何封装<br>Vue.use 可以接收一个对象，对象中内置了一个install函数，install函数的参数为Vue构造函数（可以用Vue.use进行多个组件的批量注册）</li>\n</ol>\n<p>在 Vue.use(obj) 时，会自动调用该 install 函数，并传入 Vue构造器</p>\n<p>用vue.use进行组件注册时候，会首先判断组件的installed属性是否为true,为true说明此组件已经注册过,如果没有注册的话,在use注册的同时,会给组件添加一个属性installed：true</p>\n<p>插件的install方法将接收两个参数，第一个是参数是Vue，第二个参数是配置项options</p>\n<pre><code class=\"js\">//      components文件夹下的 index.js:\nimport PageTools from &#39;@/components/PageTools&#39;\nimport UploadExcel from &#39;@/components/UploadExcel&#39;\nimport UploadImg from &#39;@/components/UploadImg&#39;\nexport default &#123;\n    install(Vue) &#123;\n        Vue.component(PageTools.name, PageTools)\n        Vue.component(UploadExcel.name, UploadExcel)\n        Vue.component(UploadImg.name, UploadImg)\n    &#125;\n&#125;\n//        main.js文件中:\n import MyPlugin from &#39;@/components/index&#39;\n Vue.use(MyPlugin)\n</code></pre>\n<h1 id=\"Vue组件\"><a href=\"#Vue组件\" class=\"headerlink\" title=\"Vue组件\"></a>Vue组件</h1><pre><code class=\"js\">VueComponent是通过Vue.extend()方法创建的组件构造函数的原型。当您使用Vue.extend()创建一个组件时，会返回一个新的组件构造函数，而这个构造函数的原型即为VueComponent\nVueComponent.prototype.__proto__ === Vue.prototype\n</code></pre>\n<p><code>VueComponent</code> 和 <code>Vue.extend</code> 是 Vue.js 中用于创建组件的两个关键概念，它们之间有着紧密的联系。</p>\n<p>在 Vue.js 中，每个组件都是一个 <code>VueComponent</code> 实例。<code>VueComponent</code> 对象代表了一个已经挂载到 DOM 树上的 Vue 组件实例，包括了该组件的状态数据、模板和组件实例方法等信息。通过访问 <code>$options</code> 属性，可以获取该组件的选项对象。</p>\n<p>而 <code>Vue.extend</code> 方法则用于创建一个可以动态生成 <code>VueComponent</code> 实例的组件构造函数，每当需要创建一个新的实例时，就可以调用这个构造函数来创建。</p>\n<p>具体而言，<code>Vue.extend</code> 会接收一个组件选项对象作为参数，并返回一个组件构造函数，我们可以将这个构造函数传递给 <code>Vue.component</code> 方法或者在某个 Vue 实例中局部注册，使得该组件可以在应用程序的任何地方使用。在 Vue 应用程序中，一个 Vue 组件最终都会被转换成一个 <code>VueComponent</code> 实例，而 <code>Vue.extend</code> 方法则是用于创建这些实例所使用的组件构造函数。</p>\n<p>下面是一个简单的示例，展示了如何使用 <code>Vue.extend</code> 方法来创建一个组件构造函数，并使用该构造函数创建多个 <code>VueComponent</code> 实例：</p>\n<pre><code class=\"js\">javascriptCopy Code// 创建一个组件构造函数\nconst MyComponent = Vue.extend(&#123;\n  template: &#39;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#39;,\n  data() &#123;\n    return &#123;\n      message: &#39;Hello, Vue!&#39;\n    &#125;;\n  &#125;\n&#125;);\n// 创建两个组件实例\nnew MyComponent().$mount(&#39;#app1&#39;);\nnew MyComponent().$mount(&#39;#app2&#39;);\n</code></pre>\n<p>在上述示例中，我们使用 <code>Vue.extend</code> 方法创建了一个名为 <code>MyComponent</code> 的组件构造函数，并在选项对象中定义了模板和状态数据。然后，我们通过创建两个 <code>MyComponent</code> 实例并分别将它们挂载到不同的元素上。</p>\n<p>这里需要注意的是，每次调用 <code>MyComponent</code> 构造函数都会生成一个新的 <code>VueComponent</code> 实例。也就是说，虽然这两个实例是基于同一个组件构造函数创建的，但它们之间是相互独立的，彼此不会共享状态数据和实例方法。</p>\n<h1 id=\"native修饰符详解\"><a href=\"#native修饰符详解\" class=\"headerlink\" title=\"native修饰符详解\"></a>native修饰符详解</h1><p>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1WdWUuanMmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=\">Vue.js</span>中，.native修饰符用于在自定义组件上监听原生 DOM 事件。通过使用.native修饰符，可以将原生事件绑定到组件的根元素上，而不是绑定到组件内部的子组件元素上。这使得在组件使用过程中，可以更方便地监听和处理原生事件。如果不使用 <code>native</code> 修饰符，那么在绑定事件时，实际上绑定的是组件的内部事件而不是原生 DOM 的事件。这意味着事件处理函数会被绑定到组件根元素上，而不是直接绑定到原生 DOM 元素上</p>\n<p>总结: 给组件绑定原生事件后, 如果没触发就加 <strong>.native</strong></p>\n<h1 id=\"sync修饰符详解\"><a href=\"#sync修饰符详解\" class=\"headerlink\" title=\"sync修饰符详解\"></a>sync修饰符详解</h1><p>sync修饰符相当于自定义事件的语法糖，用于父子组件数据之间的双向绑定，与v-model类似，（sync修饰符修饰v-bind指令）</p>\n<p>一、   一般数据进行双向绑定要：①v-bind绑定数据，②添加一个自定义事件（父组件上）接受新值改变旧值③子组件中抛出自定义事件，传入改变后的值（this.$emit）</p>\n<p>二、   但是使用sync修饰符进行绑定之后，相当于父组件单项绑定数据的同时添加了一个自定义事件（upload : bindName），子组件不用再抛出事件，绑定的数据会随着父组件数据的改变自动改变</p>\n<p>三、v-model和sync修饰符的原理相同，都是语法糖，相当于v-bind绑定一个value属性，然后v-on添加一个自定义事件</p>\n<h1 id=\"this-set给对象添加响应式数据\"><a href=\"#this-set给对象添加响应式数据\" class=\"headerlink\" title=\"this.$set给对象添加响应式数据\"></a>this.$set给对象添加响应式数据</h1><p><code>this.$set</code> 是 Vue.js 提供的一个实例方法，用于在 Vue 实例中响应式地添加新属性到已有的对象上。它并不是 JavaScript 或者浏览器原生提供的方法，而是 Vue.js 框架提供的一种特殊功能。</p>\n<p>通常情况下，当我们使用 Vue 来创建数据驱动的程序时，如果我们直接给一个对象添加新的属性，这个新属性将不会被 Vue 监听到变化，因为 Vue 无法自动追踪对象属性的添加或删除。这时候就可以使用 <code>this.$set</code> 方法来解决这个问题。</p>\n<p>具体用法如下：</p>\n<pre><code class=\"js\">javascriptCopy Code// 在 Vue 实例的方法中使用 this.$set\nthis.$set(obj, &#39;newProp&#39;, 123)\n</code></pre>\n<p>其中，<code>obj</code> 是已有的对象，<code>newProp</code> 是要添加的新属性名，<code>123</code> 是新属性的初始值。</p>\n<p>通过使用 <code>this.$set</code> 方法，Vue 将能够监听到新属性的变化，从而实现响应式更新。</p>\n<p>需要注意的是，在 Vue 2.x 版本中，通常情况下是不推荐直接给对象添加新属性的，而是应该在初始化时就声明好所有的属性。但是在某些动态场景下，比如处理服务器返回的数据、动态表单等，可能会用到 <code>this.$set</code> 方法来动态添加属性并保持响应式。</p>\n<h1 id=\"Vue3中为v-for循环渲染的列表添加ref\"><a href=\"#Vue3中为v-for循环渲染的列表添加ref\" class=\"headerlink\" title=\"Vue3中为v-for循环渲染的列表添加ref\"></a>Vue3中为v-for循环渲染的列表添加ref</h1><p>只需要v-bind  ref  为一个函数即可，则函数在每次进行列表渲染的时候都会执行一次，函数的参数为当前列表的DOM元素</p>\n<h1 id=\"Vue中组件通信\"><a href=\"#Vue中组件通信\" class=\"headerlink\" title=\"Vue中组件通信\"></a>Vue中组件通信</h1><p>一、父子组件传值和自定义事件</p>\n<p>二、全局事件总线</p>\n<p>三、依赖注入 Provide &#x2F; Inject </p>\n<p>四、Vuex </p>\n<p>五、组件上使用ref</p>\n<p>六、pinia</p>\n<h1 id=\"Vue3新增内置组件\"><a href=\"#Vue3新增内置组件\" class=\"headerlink\" title=\"Vue3新增内置组件\"></a>Vue3新增内置组件</h1><p>一、teleport  传送，通过to属性传送对应内容</p>\n<p>二、suspense异步组件  未定（占位）</p>\n<p>三、fragment片段，比template更加轻量</p>\n<h1 id=\"swc-loader\"><a href=\"#swc-loader\" class=\"headerlink\" title=\"swc-loader\"></a>swc-loader</h1><p>swc-loader是用于pollyfill的打包工具之一，底层采用rust进行编写，大大提升了打包构建的速度</p>\n<h1 id=\"SSE（Server-Send-Event）\"><a href=\"#SSE（Server-Send-Event）\" class=\"headerlink\" title=\"SSE（Server-Send-Event）\"></a>SSE（Server-Send-Event）</h1><p>SSE采用服务端主动发送事件的方式（返回响应头Content-Type:”text&#x2F;event-stream’’），向前端发送信息，前端通过事件的注册（通过EventSource构造函数创建实例，通过事件注册的方式）来接受。采用的是发布订阅的模式。</p>\n<ul>\n<li><p>服务端注册api，res.writeHead中书写Content-Type，通过res.write方法进行写入</p>\n</li>\n<li><p>浏览器端</p>\n<ul>\n<li><p>通过<code>new EventSource(url,options);</code>创建事件源</p>\n</li>\n<li><p>通过实例的readState判断连接状态</p>\n</li>\n<li><p>通过监听实例的onmessage事件来获取服务端响应过来的数据</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"获取网络连接状态\"><a href=\"#获取网络连接状态\" class=\"headerlink\" title=\"获取网络连接状态\"></a>获取网络连接状态</h1><p>一、事件监听（不断执行）</p>\n<pre><code class=\"js\">window.addEventListener(&#39;online&#39;,()=&gt;&#123;\n    console.log(&#39;网络连接成功&#39;);\n&#125;)\nwindow.addEventListener(&#39;offline&#39;,()=&gt;&#123;\n    console.log(&#39;网络连接失败&#39;);\n&#125;)\n</code></pre>\n<p>二、通过navigator（执行一次）</p>\n<pre><code class=\"js\">if (navigator.onLine) &#123;\n  console.log(&#39;在线&#39;);\n&#125; else &#123;\n  console.log(&#39;掉线&#39;);\n&#125;\n</code></pre>\n<p>获取更多详细连接信息（通过navigator.connection）</p>\n<pre><code class=\"js\">//需要兼容性处理\nif (&#39;connection&#39; in navigator) &#123;\n  const networkInfo = navigator.connection;\n  console.log(&#39;当前网络估计下行速度&#39;, networkInfo.downlink);\n  console.log(&#39;当前网络估计速度类型&#39;, networkInfo.effectiveType);\n  console.log(&#39;当前网络估计往返时间&#39;, networkInfo.rtt);\n  console.log(&#39;是否处于数据节省模式&#39;, networkInfo.saveData);\n&#125; else &#123;\n  console.log(&#39;当前浏览器不支持&#39;);\n&#125;\n</code></pre>\n<h1 id=\"—————————-JS函数式编程\"><a href=\"#—————————-JS函数式编程\" class=\"headerlink\" title=\"—————————-JS函数式编程\"></a>—————————-JS函数式编程</h1><p>在JavaScript中，函数式编程（Functional Programming）是一种以函数为基本构建块的编程范式。它强调将计算视为数学函数的执行，并避免了状态和可变数据。函数式编程在JavaScript中具有以下特点：</p>\n<ol>\n<li>函数是一等公民：在函数式编程中，函数被视为一等公民，可以像其他值（如数字、字符串）一样被传递、赋值和返回。这意味着函数可以作为参数传递给其他函数，也可以从函数中返回另一个函数。</li>\n<li>纯函数（Pure Function）：纯函数是指没有副作用的函数，它的输出完全由输入决定，不会改变外部状态或产生其他可见效果。纯函数对于相同的输入始终返回相同的结果，且不会修改原始数据。在函数式编程中，鼓励使用纯函数来处理数据，因为它们易于测试、理解和推理。</li>\n<li>不可变性（Immutability）：函数式编程鼓励使用不可变数据，即数据在创建后不能被修改。当需要对数据进行操作时，函数式编程通常会创建新的数据副本而不是直接修改原始数据。这样可以避免出现意外的副作用和数据竞争，并使代码更加可靠和可维护。</li>\n<li>高阶函数（Higher-Order Function）：高阶函数是指能够接受一个或多个函数作为参数，或者返回一个函数作为结果的函数。JavaScript中的函数可以作为值进行传递和操作，因此非常适合编写高阶函数。高阶函数可以接收其他函数作为参数，也可以返回新的函数，从而实现函数的组合和抽象。</li>\n<li>函数组合（Function Composition）：函数式编程鼓励使用函数组合来创建复杂功能。函数组合是指将一个函数的输出作为另一个函数的输入，并生成一个新的函数。通过将多个小功能的函数组合在一起，可以形成更复杂的功能，提高代码的可读性和可维护性。</li>\n</ol>\n<p>函数式编程的目标是编写简洁、模块化且可复用的代码。通过使用函数式编程范式，可以实现代码的易于测试、可扩展、并行处理以及更好的可维护性。在JavaScript中，函数式编程通常与其他编程范式（如面向对象编程）结合使用，以充分发挥JavaScript的灵活性和表达力。</p>\n<h1 id=\"prototype和、-proto\"><a href=\"#prototype和、-proto\" class=\"headerlink\" title=\"prototype和、_ _proto _ _\"></a>prototype和、_ _proto _ _</h1><p>构造函数的prototype是实例的原型对象（_ _ <em>proto</em> _ _）</p>\n<ol>\n<li><p><code>prototype</code> 属性： <code>prototype</code> 是函数对象特有的属性，它指向一个对象，该对象被用作构造函数创建的实例的原型。当使用 <code>new</code> 关键字创建一个对象时，该对象的 <code>__proto__</code> 属性会指向构造函数的 <code>prototype</code> 属性。通过修改构造函数的 <code>prototype</code> 属性，可以为通过该构造函数创建的实例添加共享的方法和属性。</p>\n<p>示例：</p>\n<pre><code class=\"js\">javascriptCopy Codefunction Person(name) &#123;\n  this.name = name;\n&#125;\n\nPerson.prototype.sayHello = function() &#123;\n  console.log(&#39;Hello, &#39; + this.name);\n&#125;;\n\nconst person1 = new Person(&#39;Alice&#39;);\nperson1.sayHello(); // 输出：Hello, Alice\n</code></pre>\n</li>\n<li><p><code>__proto__</code> 属性： <code>__proto__</code> 是每个对象（包括函数对象）都具有的属性，它指向该对象的原型。通过 <code>__proto__</code> 属性，可以访问和操作对象的原型链。当访问一个对象的属性时，如果对象本身没有该属性，JavaScript 引擎会沿着对象的原型链向上查找，直到找到该属性或到达原型链的顶端（即 <code>null</code>）。</p>\n<p>示例：</p>\n<pre><code class=\"js\">javascriptCopy Codeconst obj = &#123; a: 1 &#125;;\nconsole.log(obj.__proto__); // 输出：Object &#123;&#125;\n\nconst arr = [1, 2, 3];\nconsole.log(arr.__proto__); // 输出：Array []\n\nfunction Person(name) &#123;\n  this.name = name;\n&#125;\n\nconst person1 = new Person(&#39;Alice&#39;);\nconsole.log(person1.__proto__); // 输出：Person &#123;&#125;\n</code></pre>\n<p>需要注意的是，<code>__proto__</code> 属性在现代 JavaScript 中已经被标准化为内部属性 <code>[[Prototype]]</code>，推荐使用 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 方法来访问和设置对象的原型。</p>\n</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><code>prototype</code> 属性是函数对象特有的属性，用于指定构造函数创建的实例的原型。</li>\n<li><code>__proto__</code> 属性是每个对象都具有的属性，用于指向该对象的原型。它可以访问和操作对象的原型链。</li>\n</ul>\n<h1 id=\"hasOwnProperty和in\"><a href=\"#hasOwnProperty和in\" class=\"headerlink\" title=\"hasOwnProperty和in\"></a>hasOwnProperty和in</h1><p>OBJ . hasOwnProperty检查对象中是否有属性（只返回在自己身上的，不包括原型）</p>\n<p>属性  in  OBJ 检查对象中是否有属性，只能检查对象是否可以调用该属性</p>\n<h1 id=\"ES6剩余参数\"><a href=\"#ES6剩余参数\" class=\"headerlink\" title=\"ES6剩余参数\"></a>ES6剩余参数</h1><pre><code class=\"js\">//形参中使用数组，然后展开\nfunction a(...nums)&#123;\n//传参数组\n    console.log(nums)  //数组\n&#125;\nsum(&#39;sd&#39;,&#39;s&#39;,&#39;a&#39;,&#39;b&#39;)\n</code></pre>\n<h1 id=\"模拟call方法定义过程\"><a href=\"#模拟call方法定义过程\" class=\"headerlink\" title=\"模拟call方法定义过程\"></a>模拟call方法定义过程</h1><p>（用JS代码模拟，实际是C++代码）</p>\n<pre><code class=\"js\">Function.prototype.hycall = function(thisArg,...args)&#123;\n    var fn = this\n    thisArg = thisArg?Object(thisArg):window\n    thisArg.fn=fn\n    var result = thisArg.fn(...args)\n    delete thisArg.fn\n    return result\n&#125;\nfunction foo()&#123;\nconsole.log(&quot;foo函数执行&quot;,this)\n&#125;\nfunction sum(sum1,sum2)&#123;\n    console.log(&#39;sum函数执行&#39;,this,sum1,sum2)\n    return num1+num2\n&#125;\nfoo.call(undefined)  //系统调用call方法\nvar result = sum.call(&#123;&#125;,20,30) //系统调用call方法\nfoo.hycall(undefined)\nvar result = sum.hycall(&#39;abc&#39;,20,30)\nconsole.log(&#39;hycall的调用：&#39;,result)\n</code></pre>\n<h1 id=\"模拟apply方法定义过程\"><a href=\"#模拟apply方法定义过程\" class=\"headerlink\" title=\"模拟apply方法定义过程\"></a>模拟apply方法定义过程</h1><pre><code class=\"js\">Function.prototype.hyapply = function (thisArg, argArray) &#123;\n    // 获取到要执行的函数,this因为是隐式调用，指向当前的函数\n    var fn = this\n    // 处理绑定的thisArg,(边界判断了0)\n    thisArg = (thisArg!==null &amp;&amp; thisArg!==undefined) ? Object(thisArg) : window\n    // 执行函数\n    thisArg.fn = fn\n    var result\n    // 没有传参数数组时\n    // if (!argArray) &#123;\n    //     result = thisArg.fn()\n    // &#125; else &#123;\n    //     result = thisArg.fn(...argArray)\n    // &#125;  或者\n    // argArray = argArray ? argArray:[]   或者\n    argArray = argArray || []\n    // 形参处理\n    result = thisArg.fn(...argArray)\n    delete thisArg.fn\n    return result\n&#125;\nfunction sum(num1, num2) &#123;\n    console.log(&quot;sum被调用&quot;, this, num1, num2);\n    return num1 + num2\n&#125;\n\n// 自己实现的调用\nvar result = sum.hyapply(&quot;abc&quot;, [20, 30])\nconsole.log(result);\n</code></pre>\n<h1 id=\"关键字arguments-函数中\"><a href=\"#关键字arguments-函数中\" class=\"headerlink\" title=\"关键字arguments(函数中)\"></a>关键字arguments(函数中)</h1><p>一、<strong>类数组对象</strong>，默认绑定函数执行时传入的参数</p>\n<p>二、可以使用length或者索引，但是不能使用数组内置的一些方法（类数组对象）</p>\n<pre><code class=\"js\">function ad() &#123;\n    console.log(arguments);\n    console.log(arguments.length);\n    console.log(arguments[0]);\n&#125;\nad(1, 4, 2, 1, 22)\nad(&#39;sd&#39;, &#39;sdj&#39;)\nad(&#39;d&#39;)\n</code></pre>\n<p>三、如何让arguments类数组对象可以使用数组的内置方法？</p>\n<pre><code class=\"js\">//一、 遍历类数组对象\nfunction foo(num1, num2) &#123;\n    var newArr = []\n    for (var i = 0; i &lt; arguments.length; i++) &#123;\n        newArr.push[arguments[i] * 10]\n    &#125;\n    console.log(newArr);\n&#125;\nfoo(10, 20, 30, 40, 50)\n\n// 二、数组原型上使用方法，加到arguments上（argument类数组，可遍历迭代，因此可以使用）\nvar newArr2 = Array.prototype.slice.call(arguments)\nconsole.log(newArr2);\n// 或 三：\nvar newArr3 = [].slice.call(arguments)\nconsole.log(newArr3);\n// 或   四、将类数组对象转成数组类型\nvar newArr4 = Array.from(arguments)\n// 或  五、转成数组类型\nvar newArr5 = [...arguments]\n</code></pre>\n<p>四、<strong>箭头函数没有<code>arguments</code>对象 ，函数执行时会去上层作用域寻找</strong></p>\n<p>五、<strong>注意浏览器中全局对象中没有<code>arguments</code> ， 但是node环境全局中有<code>arguments</code>，里面存放的是模块</strong></p>\n<h1 id=\"剩余参数…args\"><a href=\"#剩余参数…args\" class=\"headerlink\" title=\"剩余参数…args\"></a>剩余参数…args</h1><p>…args不是关键字！！，只能使用在函数定义时，最后一个形参</p>\n<p><code>...arg</code> 和 <code>arguments</code> 都可以用于处理函数中的参数。但是，它们之间有一些重要的区别和不同：</p>\n<ol>\n<li><strong>变量类型不同</strong>：<code>...arg</code> 表示一个数组，而 <code>arguments</code> 表示一个类似数组的对象。</li>\n<li><strong>使用限制不同</strong>：<code>...arg</code> 只能用在函数定义时的最后一个参数上，而 <code>arguments</code> 可以在任何地方使用。</li>\n<li><strong>可迭代性不同</strong>：由于 <code>...arg</code> 生成的是一个真正的数组，因此可以使用数组的所有方法，如 <code>forEach()</code>、<code>map()</code>、<code>reduce()</code> 等。而 <code>arguments</code> 并非真正的数组，因此不能使用数组方法，需要通过数组转换才能使用。</li>\n</ol>\n<h1 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h1><p>一、定义：①、相同的输入，产生相同的输出，输出只和函数内部执行有关。即输出不会因为外部变量或状态改变受影响</p>\n<p>②、无副作用，不会改变外部变量的值或状态（副作用是产生bug的温床）</p>\n<p>二、举例：数组中<code>slice</code>方法是纯函数，<code>splice</code>方法是非纯函数</p>\n<h1 id=\"函数的柯里化\"><a href=\"#函数的柯里化\" class=\"headerlink\" title=\"函数的柯里化\"></a>函数的柯里化</h1><p>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUE3JTkxJUU1JUFEJUE2\">计算机科学</span>中，<strong>柯里化</strong>（英语：Currying），又译为<strong>卡瑞化</strong>或<strong>加里化</strong>，是把接受多个<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJTgzJUU2JTk1JUI4XyglRTclQTglOEIlRTUlQkMlOEYlRTglQTglQUQlRTglQTglODgp\">参数</span>的<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg3JUJEJUU2JTk1JUIw\">函数</span>变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。例如：</p>\n<pre><code class=\"js\">const add = (x,y) =&gt; x+y; //柯里化转化为；\nconst add2 = (x) =&gt; y =&gt; x+y;\nadd2(4)(4)\n\n//又或者：\n\nfunction foo(m,n,x,y)&#123;\nreturn m+n+x+y &#125;\nfoo(10,20,30,40)\n//柯里化的过程\nfunction bar(m)&#123;\n    return function(n)&#123;\n        return function(x)&#123;\n            return function(y)&#123;\n                m+n+x+y\n&#125;&#125;&#125;&#125;\nbar(10)(20)(30)(40)\n//简化柯里化代码\nvar sum3 = x =&gt; y =&gt; z =&gt; x+y+z\n</code></pre>\n<p>柯里化的作用和好处：使得一个函数处理问题尽可能的<strong>单一、简单</strong>，而不是一大推处理过程交给一个函数来处理，并且可以<strong>复用和定制化</strong><br>柯里化的本质：将某个操作中已完成的结果保留，知道其余部分后续也完成后可以一并提供的机制，通过在一个函数中返回另一个函数实现</p>\n<pre><code class=\"js\">var log = date =&gt; type =&gt; message =&gt; &#123;\n    console.log(`[$&#123;date.getHours()&#125;:$&#123;date.getMinutes()&#125;][$&#123;type&#125;]:[$&#123;message&#125;]`);\n&#125;\nvar nowLog = log(new Date())\nnowLog(&#39;DEBUG&#39;)(&#39;查找到轮播图的bug&#39;)\nnowLog(&#39;FETURE&#39;)(&#39;新增了添加功能&#39;)\nvar nowAndDebugLog = log(new Date())(&quot;DEBUG&quot;)\nnowAndDebugLog(&quot;找到bug&quot;)\nvar nowAndFutureLog = log(new Date())(&quot;FETURE&quot;)\nnowAndFutureLog(&quot;添加功能&quot;)\n</code></pre>\n<p><strong>柯里化的本质：</strong></p>\n<p>函数柯里化就是将多参函数转变为单参函数的过程，柯里化将函数转变为高阶的返回新函数的函数，目的是将原先传入的多个参数利用函数作用域储存起来，以供后续直接使用。</p>\n<h1 id=\"————————-面向对象编程\"><a href=\"#————————-面向对象编程\" class=\"headerlink\" title=\"————————-面向对象编程\"></a>————————-面向对象编程</h1><h1 id=\"浏览器事件循环\"><a href=\"#浏览器事件循环\" class=\"headerlink\" title=\"浏览器事件循环\"></a>浏览器事件循环</h1><p>①setTimeout、Http、DOM、等并不在浏览器内核（如V8引擎中）</p>\n<p> ②调用函数时，进入函数就将函数放进执行栈，离开函数就将函数弹出执行栈</p>\n<p>③在栈中表现很慢的东西叫做阻塞（http请求，多重for循环，加载资源等），执行栈中的内容是一个个执行的，因为js是一门单线程的语言，那么当执行阻塞时，为了不影响到页面的流畅 ，浏览器会开启其余的线程（交互线程、文件线程、网络线程、计时线程、等）进行辅助处理 </p>\n<h1 id=\"webAPI\"><a href=\"#webAPI\" class=\"headerlink\" title=\"webAPI\"></a>webAPI</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9MZWFybi9KYXZhU2NyaXB0L0NsaWVudC1zaWRlX3dlYl9BUElzL0ludHJvZHVjdGlvbg==\">Web API 简介 - 学习 Web 开发 | MDN (mozilla.org)</span></p>\n<p>分为：一、浏览器API  二、第三方API</p>\n<h1 id=\"navigator-sendBeacon\"><a href=\"#navigator-sendBeacon\" class=\"headerlink\" title=\"navigator.sendBeacon\"></a>navigator.sendBeacon</h1><pre><code class=\"js\">//性能中继器，使用不同指标来衡量和分析应用程序的性能\n//当页面上任何指标值完成计算时，将传递计算出的结果并触发这个函数\n//可以使用它将结果记录到控制台或者发送到特定端点\nfunction sendTo(metric)&#123;\n    const content = JSON.stringify(metric);\n    if(navigator.sendBeacon)&#123;\n        navigator.sendBeacon(&#39;http://test&#39;,content); //navigator.sendBeacon的作用是\n    &#125;else&#123;\n        fetch(&#39;http://test.com&#39;,&#123;\n        content,\n        method:&#39;POST&#39;,\n        keepAlive:true //fetch中的keepAlice保证了即使页面刷新或者关闭，发出的请求仍然存在并进行，而不是进行到一半的请求突然停止\n    &#125;).then(()=&gt;&#123;\n    console.log(&#39;发送成功&#39;);\n    &#125;).catch((e)=&gt;&#123;\n        console.error(e);\n    &#125;)\n    &#125;\n&#125;\nreportWebVitals(sendTo); //每一次得到计算结果都会执行一次\n</code></pre>\n<h3 id=\"对比-Ajax-fetch\"><a href=\"#对比-Ajax-fetch\" class=\"headerlink\" title=\"对比 Ajax fetch\"></a>对比 Ajax fetch</h3><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li>不受页面卸载过程的影响，确保数据可靠发送。</li>\n<li>异步执行，不阻塞页面关闭或跳转。</li>\n<li>能够发送跨域请求。</li>\n</ol>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ol>\n<li>fetch 和 ajax 都可以发送任意请求 而 sendBeacon 只能发送POST</li>\n<li>fetch 和 ajax 可以传输任意字节数据 而 sendBeacon 只能传送少量数据（64KB 以内）</li>\n<li>fetch 和 ajax 可以定义任意请求头 而  sendBeacon 无法自定义请求头</li>\n<li>sendBeacon 只能传输 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>ArrayBufferView</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\"><code>Blob</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\"><code>DOMString</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\"><code>FormData</code></a> 或 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams\"><code>URLSearchParams</code></a> 类型的数据</li>\n<li><code>如果处于危险的网络环境，或者开启了广告屏蔽插件 此请求将无效</code></li>\n</ol>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ol>\n<li>发送心跳包：可以使用 <code>navigator.sendBeacon</code> 发送心跳包，以保持与服务器的长连接，避免因为长时间没有网络请求而导致连接被关闭。</li>\n<li>埋点：可以使用 <code>navigator.sendBeacon</code> 在页面关闭或卸载时记录用户在线时间，pv uv，以及错误日志上报 按钮点击次数。</li>\n<li>发送用户反馈：可以使用 <code>navigator.sendBeacon</code> 发送用户反馈信息，如用户意见、bug 报告等，以便进行产品优化和改进</li>\n</ol>\n<h1 id=\"Promise实现\"><a href=\"#Promise实现\" class=\"headerlink\" title=\"Promise实现\"></a>Promise实现</h1><pre><code class=\"js\">const PENDING = &#39;PENDING&#39;;\nconst FULFILLED = &#39;FULFILLED&#39;;\nconst REJECTED = &#39;REJECTED&#39;;\n\nconst resolvemyPromise = (myPromise2, x, resolve, reject) =&gt; &#123;\n  if (myPromise2 === x) &#123;\n    return reject(new TypeError(&#39;Chaining cycle detected for myPromise #&lt;myPromise&gt;&#39;))\n  &#125;\n  let called;\n  if ((typeof x === &#39;object&#39; &amp;&amp; x != null) || typeof x === &#39;function&#39;) &#123; \n    try &#123;\n      let then = x.then;\n      if (typeof then === &#39;function&#39;) &#123; \n        then.call(x, y =&gt; &#123; \n          if (called) return;\n          called = true;\n          resolvemyPromise(myPromise2, y, resolve, reject); \n        &#125;, r =&gt; &#123;\n          if (called) return;\n          called = true;\n          reject(r);\n        &#125;);\n      &#125; else &#123;\n        resolve(x);\n      &#125;\n    &#125; catch (e) &#123;\n      if (called) return;\n      called = true;\n      reject(e)\n    &#125;\n  &#125; else &#123;\n    resolve(x)\n  &#125;\n&#125;\n\nclass myPromise &#123;\n  constructor(executor) &#123;\n    this.status = PENDING; //状态\n    this.value = undefined; //值\n    this.reason = undefined; //原因\n    this.onResolvedCallbacks = []; //成功回调数组\n    this.onRejectedCallbacks= []; //失败回调数组\n    let resolve = (value) =&gt; &#123;\n      if(value instanceof myPromise)&#123;\n        return value.then(resolve,reject)\n      &#125;\n      if(this.status ===  PENDING) &#123;\n        this.status = FULFILLED;\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn=&gt;fn());\n      &#125;\n    &#125; \n    let reject = (reason) =&gt; &#123;\n      if(this.status ===  PENDING) &#123;\n        this.status = REJECTED;\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn=&gt;fn());\n      &#125;\n    &#125;\n    try &#123;\n      executor(resolve,reject)\n    &#125; catch (error) &#123;\n      reject(error)\n    &#125;\n  &#125;\n  then(onFulfilled, onRejected) &#123;\n    onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : v =&gt; v;\n    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : err =&gt; &#123; throw err &#125;;\n    let myPromise2 = new myPromise((resolve, reject) =&gt; &#123;\n      if (this.status === FULFILLED) &#123;\n        setTimeout(() =&gt; &#123;\n          try &#123;\n            let x = onFulfilled(this.value);\n            resolvemyPromise(myPromise2, x, resolve, reject);\n          &#125; catch (e) &#123;\n            reject(e)\n          &#125;\n        &#125;, 0);\n      &#125;\n      if (this.status === REJECTED) &#123;\n        setTimeout(() =&gt; &#123;\n          try &#123;\n            let x = onRejected(this.reason);\n            resolvemyPromise(myPromise2, x, resolve, reject);\n          &#125; catch (e) &#123;\n            reject(e)\n          &#125;\n        &#125;, 0);\n      &#125;\n      if (this.status === PENDING) &#123;\n        this.onResolvedCallbacks.push(() =&gt; &#123;\n          setTimeout(() =&gt; &#123;\n            try &#123;\n              let x = onFulfilled(this.value);\n              resolvemyPromise(myPromise2, x, resolve, reject);\n            &#125; catch (e) &#123;\n              reject(e)\n            &#125;\n          &#125;, 0);\n        &#125;);\n\n        this.onRejectedCallbacks.push(()=&gt; &#123;\n          setTimeout(() =&gt; &#123;\n            try &#123;\n              let x = onRejected(this.reason);\n              resolvemyPromise(myPromise2, x, resolve, reject)\n            &#125; catch (e) &#123;\n              reject(e)\n            &#125;\n          &#125;, 0);\n        &#125;);\n      &#125;\n    &#125;);\n    return myPromise2;\n  &#125;\n\n  catch(errCallback) &#123;\n    return this.then(null,errCallback)\n  &#125;\n\n  finally(callback) &#123;\n    return this.then((value)=&gt;&#123;\n      return myPromise.resolve(callback()).then(()=&gt;value)\n    &#125;,(reason)=&gt;&#123;\n      return myPromise.resolve(callback()).then(()=&gt;&#123;throw reason&#125;)\n    &#125;)  \n  &#125;\n\n  static resolve(data)&#123;\n    return new myPromise((resolve,reject)=&gt;&#123;\n      resolve(data);\n    &#125;)\n  &#125;\n\n  static reject(reason)&#123;\n    return new myPromise((resolve,reject)=&gt;&#123;\n      reject(reason);\n    &#125;)\n  &#125; \n\n  static all(values) &#123;\n    if (!Array.isArray(values)) &#123;\n      const type = typeof values;\n      return new TypeError(`TypeError: $&#123;type&#125; $&#123;values&#125; is not iterable`)\n    &#125;\n\n    return new myPromise((resolve, reject) =&gt; &#123;\n      let resultArr = [];\n      let orderIndex = 0;\n      const processResultByKey = (value, index) =&gt; &#123;\n        resultArr[index] = value;\n        if (++orderIndex === values.length) &#123;\n            resolve(resultArr)\n        &#125;\n      &#125;\n      for (let i = 0; i &lt; values.length; i++) &#123;\n        let value = values[i];\n        if (value &amp;&amp; typeof value.then === &#39;function&#39;) &#123;\n          value.then((value) =&gt; &#123;\n            processResultByKey(value, i);\n          &#125;, reject);\n        &#125; else &#123;\n          processResultByKey(value, i);\n        &#125;\n      &#125;\n    &#125;);\n  &#125;\n  static race(myPromises) &#123;\n    return new myPromise((resolve, reject) =&gt; &#123;\n      for (let i = 0; i &lt; myPromises.length; i++) &#123;\n        let val = myPromises[i];\n        if (val &amp;&amp; typeof val.then === &#39;function&#39;) &#123;\n          val.then(resolve, reject);\n        &#125; else &#123;\n          resolve(val)\n        &#125;\n      &#125;\n    &#125;);\n  &#125;\n&#125;\nmyPromise.defer = myPromise.deferred = function () &#123;\n  let dtd = &#123;&#125;\n  dtd.myPromise = new myPromise((resolve, reject) =&gt; &#123;\n    dtd.resolve = resolve;\n    dtd.reject = reject;\n  &#125;)\n  return dtd;\n&#125;\nexport default MyPromise\n</code></pre>\n<h1 id=\"深拷贝新增\"><a href=\"#深拷贝新增\" class=\"headerlink\" title=\"深拷贝新增\"></a>深拷贝新增</h1><p>window.structuredClone方法，用于直接实现深拷贝。</p>\n<h1 id=\"React-StrictMode\"><a href=\"#React-StrictMode\" class=\"headerlink\" title=\"React.StrictMode\"></a>React.StrictMode</h1><p>React的严格模式默认会渲染两次react组件（提前进行一个预渲染），第一次渲染用于收集工作（如计算和副作用），第二次渲染实际上显示在屏幕上。这种双重渲染有助于React检测组件中可能的副作用。以便于开发者能发现和修复性能问题。例如，如果一个函数组件在渲染时执行了不必要的计算或者副作用，这可能会在两次渲染中表现出来。通过比较两次渲染的结果，React可以检测出组件中是否有副作用。如果两次渲染的结果不一致，那么可能表明组件在渲染过程中产生了副作用。</p>\n","categories":["杂记"],"tags":["杂记","技巧"]},{"title":"浮点数存储","url":"/2023/07/02/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/","content":"<p>思考：</p>\n<p>为什么0.1+0.2 !&#x3D; 0.3？</p>\n<p>为什么1.005.toFixed(2)&#x3D;1.00而不是1.01</p>\n<p>双精度存储<br>首先在开始之前需要了解一下JavaScript的number类型在计算机中是如何存储的，这也是一切问题的基础。JavaScript的数字都是number类型的，不管是整数还是浮点数都以IEEE754双精度的格式存储在计算机中，什么是双精度呢？就是以64个bit位来存储</p>\n<p>分别是1个符号位+11个指数位+52个尾数位</p>\n<p>举个例子，如果是5.5这个数字的话，则计算过程是这样的：</p>\n<p>5.5 转二进制 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 101.1 科学计数法 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 1.011*2^2<br>存入计算机：<br>符号位：0<br>指数位：2 加1023 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 1025 转二进制 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 10000000001<br>尾数位：1.011 隐去小数点左边的1 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 011</p>\n<p>为什么0.1+0.2 !&#x3D; 0.3？<br>答：0.1 转二进制 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 0.0001100110011001100…(1100循环)<br>转科学计数法 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 1.100110011…(1100循环) *2^-4<br>数据是无限循环的，但是可供使用的尾数位却是有限的，只有52位可以使用，所以在第53位会被舍去并且进位</p>\n<p>计算结果转换为十进制数字就是0.30000000000000004</p>\n<p>所以就是因为，0.1和0.2在计算机中的二进制存储会让它们本身损失掉一定的精度，而它们在计算机中的二进制存储转换成十进制时已经不是真正的0.1和0.2了，相加的结果也就自然不是0.3了。</p>\n<p>问题来了，既然0.1在计算机中的存储已经有了舍入误差，那为什么num&#x3D;0.1能得到0.1呢？</p>\n<p>可以在控制台使用toPrecision看一下0.1在不同精度下的返回</p>\n<p>可以看出来其实0.1是截断了一部分精度后得到的结果，那么这个问题就可以转化为：双精度浮点数是按什么规则来截断的呢？<br>答：如果一个 IEEE 754 的双精度浮点数被转成至少含17位有效数字的十进制数字字符串，当这个字符串转回双精度浮点数时，必须要跟原来的数相同；换句话说，如果一个双精度的浮点数转为十进制的数字时，只要它转回来的双精度浮点数不变，精度取最短的那个就行。</p>\n<p>拿0.1来举例子，0.1和0.10000000000000001转成双精度浮点数的存储是一样的，所以取最短的0.1就行了。</p>\n<p>为什么1.005.toFixed(2)&#x3D;1.00而不是1.01<br>因为在第一个问题中已经说了，一个十进制数字转为双精度浮点数然后再取出来时，跟原十进制数字可能会有误差，试一下1.005取20个精度：</p>\n<p>1.005.toPrecision(20) &#x2F;&#x2F;返回1.0049999999999998934<br>很明显1.005只是一个被截断后的数字，它的双精度浮点数代表的20位精度的数字是1.0049999999999998934，所以进行保留2位的四舍五入时，2位后的数字会被全部舍去。</p>\n","categories":["计算机组成原理"],"tags":["浮点数","存储"]},{"title":"浏览器执行原理","url":"/2023/10/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/","content":"<h1 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h1><p>浏览器的进程模型</p>\n<h4 id=\"何为进程？\"><a href=\"#何为进程？\" class=\"headerlink\" title=\"何为进程？\"></a>何为进程？</h4><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p>\n<p><img data-src=\"/images/image-20220809205743532\" alt=\"image\"><br>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p>\n<h4 id=\"何为线程？\"><a href=\"#何为线程？\" class=\"headerlink\" title=\"何为线程？\"></a>何为线程？</h4><p>有了进程后，就可以运行程序的代码了。</p>\n<p>运行代码的「人」称之为「线程」。</p>\n<p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p>\n<p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>\n<p><img data-src=\"/images/image-20220809210859457\" alt=\"image\"></p>\n<p>浏览器有哪些进程和线程？<br>浏览器是一个多进程多线程的应用程序</p>\n<p>浏览器内部工作极其复杂。</p>\n<p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>\n<p><img data-src=\"/images/image-20220809213152371\" alt=\"image\"></p>\n<p>可以在浏览器的任务管理器中查看当前的所有进程</p>\n<p>其中，最主要的进程有：</p>\n<h1 id=\"浏览器进程\"><a href=\"#浏览器进程\" class=\"headerlink\" title=\"浏览器进程\"></a>浏览器进程</h1><p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p>\n<h4 id=\"网络进程\"><a href=\"#网络进程\" class=\"headerlink\" title=\"网络进程\"></a>网络进程</h4><p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p>\n<h4 id=\"渲染进程\"><a href=\"#渲染进程\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h4><p>渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。</p>\n<p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p>\n<p>将来该默认模式可能会有所改变，有兴趣的同学可参见chrome官方说明文档</p>\n<p>渲染主线程是如何工作的？<br>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>\n<p>解析 HTML<br>解析 CSS<br>计算样式<br>布局<br>处理图层<br>每秒把页面画 60 次<br>执行全局 JS 代码<br>执行事件处理函数<br>执行计时器的回调函数<br>……<br>思考题：为什么渲染进程不适用多个线程来处理这些事情？</p>\n<p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p>\n<p>比如：</p>\n<p>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？<br>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？<br>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？<br>……<br>渲染主线程想出了一个绝妙的主意来处理这个问题：排队</p>\n<p><img data-src=\"/images/image-20220809223027806\" alt=\"image\"></p>\n<p>在最开始的时候，渲染主线程会进入一个无限循环<br>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。<br>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务<br>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p>\n<p>整个过程，被称之为事件循环（消息循环）</p>\n<p>若干解释</p>\n<h4 id=\"何为异步？\"><a href=\"#何为异步？\" class=\"headerlink\" title=\"何为异步？\"></a>何为异步？</h4><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p>\n<p>计时完成后需要执行的任务 —— setTimeout、setInterval<br>网络通信完成后需要执行的任务 – XHR、Fetch<br>用户操作后需要执行的任务 – addEventListener<br>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p>\n<p><img data-src=\"/images/image-20220810104344296\" alt=\"image\"></p>\n<p>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</p>\n<p>因此，浏览器选择异步来解决这个问题</p>\n<p><img data-src=\"/images/image-20220810104858857\" alt=\"image\"></p>\n<p>使用异步的方式，渲染主线程永不阻塞</p>\n<p>面试题：如何理解 JS 的异步？</p>\n<p>参考答案：</p>\n<p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p>\n<p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p>\n<p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p>\n<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p>\n<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>\n<p>JS为何会阻碍渲染？<br>先看代码</p>\n<pre><code class=\"js\">  var h1 = document.querySelector(&#39;h1&#39;);\n  var btn = document.querySelector(&#39;button&#39;);  \n  // 死循环指定的时间\n  function delay(duration) &#123;\n    var start = Date.now();\n    while (Date.now() - start &lt; duration) &#123;&#125;\n  &#125;\n  btn.onclick = function () &#123;\n    h1.textContent = &#39;hello world！&#39;;\n    delay(3000);\n  &#125;;\n</code></pre>\n<p>点击按钮后，会发生什么呢？</p>\n<p>&lt;见具体演示&gt;</p>\n<p>任务有优先级吗？<br>任务没有优先级，在消息队列中先进先出</p>\n<p>但消息队列是有优先级的</p>\n<p>根据 W3C 的最新解释:</p>\n<p>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。<br>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BlcmZvcm0tYS1taWNyb3Rhc2stY2hlY2twb2ludA==\">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</span><br>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p>\n<p>在目前 chrome 的实现中，至少包含了下面的队列：</p>\n<p>延时队列：用于存放计时器到达后的回调任务，优先级「中」<br>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」<br>微队列：用户存放需要最快执行的任务，优先级「最高」<br>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p>\n<p>例如：</p>\n<p>&#x2F;&#x2F; 立即把一个函数添加到微队列<br>Promise.resolve().then(函数)<br>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p>\n<h1 id=\"面试题：\"><a href=\"#面试题：\" class=\"headerlink\" title=\"面试题：\"></a>面试题：</h1><h4 id=\"阐述一下-JS-的事件循环\"><a href=\"#阐述一下-JS-的事件循环\" class=\"headerlink\" title=\"阐述一下 JS 的事件循环\"></a>阐述一下 JS 的事件循环</h4><p>参考答案：</p>\n<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>\n<p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>\n<p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>\n<p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p>\n<h4 id=\"JS-中的计时器能做到精确计时吗？为什么？\"><a href=\"#JS-中的计时器能做到精确计时吗？为什么？\" class=\"headerlink\" title=\"JS 中的计时器能做到精确计时吗？为什么？\"></a>JS 中的计时器能做到精确计时吗？为什么？</h4><p>参考答案：</p>\n<p>不行，因为：</p>\n<p>计算机硬件没有原子钟，无法做到精确计时<br>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差<br>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差<br>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</p>\n","categories":["浏览器"],"tags":["浏览器","原理"]},{"title":"深拷贝","url":"/2024/04/30/%E6%B7%B1%E6%8B%B7%E8%B4%9D/","content":"<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>我们知道在javascript中有八种数据类型：其中number，string，undefined，null，boolean，symbol和bigint为基本数据类型，而object为复杂数据类型</p>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><ul>\n<li>对于基本数据类型，其值直接存储于栈中。</li>\n<li>对于复杂数据类型，其值存储于堆中，而栈中只存储堆中的地址。这样做的好处有：<ul>\n<li>节省内存空间：存储在堆中的对象可以通过栈内的引用被访问和操作，意味着对象可以在不同的上下文中被共享和引用，从而节省内存。</li>\n<li>垃圾回收：堆内存中的对象不再被引用时，垃圾回收机制就会自动进行回收，从而避免了内存泄漏和资源浪费。</li>\n<li>动态分配内存：堆内存允许对象动态的增长和缩小，因此可以根据需要灵活地修改对象的结构和内容，使得js对象可以轻松地扩展以适应不同的应用需求。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"深拷贝-1\"><a href=\"#深拷贝-1\" class=\"headerlink\" title=\"深拷贝\"></a><strong>深拷贝</strong></h2><p>而深拷贝和浅拷贝就是对于复杂数据类型object来说的，当拷贝了对象的一层（即堆的引用）时，就称之为浅拷贝，当拷贝了对象的两层（堆中创建新的对象）时，就称之为深拷贝。</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><ol>\n<li><p><code>JSON.parse(JSON.stringify(obj))</code>，第一种方法是使用JSON方法，但是这个方法有一些限制：JSON序列化时函数会被转为null，正则表达式会被转为空对象。</p>\n</li>\n<li><p>递归实现：</p>\n<pre><code class=\"js\">\n\n```js\nfunction deepCopy(obj, parent = null) &#123;\n    // 创建一个新对象\n    let result = &#123;&#125;;\n    let keys = Object.keys(obj),\n        key = null,\n        temp = null,\n        _parent = parent;\n    // 该字段有父级则需要追溯该字段的父级\n    while (_parent) &#123;\n        // 如果该字段引用了它的父级则为循环引用\n        if (_parent.originalParent === obj) &#123;\n            // 循环引用直接返回同级的新对象\n            return _parent.currentParent;\n        &#125;\n        _parent = _parent.parent;\n    &#125;\n    for (let i = 0; i &lt; keys.length; i++) &#123;\n        key = keys[i];\n        temp = obj[key];\n        // 如果字段的值也是一个对象\n        if (temp &amp;&amp; typeof temp === &#39;object&#39;) &#123;\n            // 递归执行深拷贝 将同级的待拷贝对象与新对象传递给 parent 方便追溯循环引用\n            result[key] = DeepCopy(temp, &#123;\n                originalParent: obj,\n                currentParent: result,\n                parent: parent\n            &#125;);\n\n        &#125; else &#123;\n            result[key] = temp;\n        &#125;\n    &#125;\n    return result;\n&#125;\n```\n</code></pre>\n</li>\n<li><p>MessageChannel实现深克隆：由于浏览器不能将一个函数正确的复制到另一个线程中，所以不能支持函数的深克隆。</p>\n<pre><code class=\"js\">function deepCopy(obj) &#123;\n  return new Promise((resolve) =&gt; &#123;\n    const &#123;port1, port2&#125; = new MessageChannel();\n    port2.onmessage = ev =&gt; resolve(ev.data);\n    port1.postMessage(obj);\n  &#125;);\n&#125;\n\ndeepCopy(obj).then((copy) =&gt; &#123;// 异步的\n    let copyObj = copy;\n    console.log(copyObj, obj)\n    console.log(copyObj == obj)\n&#125;);\n</code></pre>\n</li>\n<li><p>H5新增structuredClone<br>结构化克隆解决了该JSON.stringify()技术的许多（尽管不是全部）缺点。结构化克隆可以处理循环依赖，支持许多内置数据类型，并且更健壮且速度更快。<br>但是，它仍然有一些限制：</p>\n</li>\n</ol>\n<p>原型：如果你使用structuredClone()类实例，你将获得一个普通对象作为返回值，因为结构化克隆会丢弃对象的原型链。<br>函数：如果你的对象包含函数，它们将被悄悄丢弃。<br>不可克隆：有些值不是结构化可克隆的，尤其是Error、 DOM 节点 和 Function。尝试这样做将引发 DataCloneError 异常。<br>属性描述符：setter和getter(以及类似元数据的功能)不会被复制。例如，如果使用属性描述符将对象标记为只读，则复制后的对象中是可读写(默认配置)。<br>RegExp：RegExp对象的lastIndex字段不会保留。</p>\n<h1 id=\"浅拷贝实现方案\"><a href=\"#浅拷贝实现方案\" class=\"headerlink\" title=\"浅拷贝实现方案\"></a>浅拷贝实现方案</h1><ol>\n<li><code>Object.assign(&#123;&#125;,obj)</code>，第二方法是使用Object.assign()</li>\n<li><code>const obj1 = &#123;...obj2&#125;</code>，使用扩展运算符</li>\n</ol>\n","categories":["面试题"],"tags":["深拷贝,面试题"]},{"title":"渲染模式","url":"/2023/05/17/%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjMzNjk5NjgwNDkwNzk5MTYyLw==\">推荐一篇掘金大佬的文章，写的很详细</span></p>\n","categories":["渲染模式"],"tags":["渲染模式"]},{"title":"网络安全","url":"/2024/05/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","content":"<h1 id=\"前端网络安全\"><a href=\"#前端网络安全\" class=\"headerlink\" title=\"前端网络安全\"></a>前端网络安全</h1><h2 id=\"1-XSS-跨站脚本攻击\"><a href=\"#1-XSS-跨站脚本攻击\" class=\"headerlink\" title=\"#1. XSS 跨站脚本攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzEteHNzLSVFOCVCNyVBOCVFNyVBQiU5OSVFOCU4NCU5QSVFNiU5QyVBQyVFNiU5NCVCQiVFNSU4NyVCQg==\">#</span>1. XSS 跨站脚本攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>XSS 是常见的 Web 攻击技术之一.所谓的跨站脚本攻击指得是:恶意攻击者往 Web 页面里注入恶意 Script 代码，用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取 cookie 信息、会话劫持等各种攻击。</p>\n</blockquote>\n<p><strong>危害</strong></p>\n<p>1、<strong>盗取各类用户帐号</strong>，如机器登录帐号、用户网银帐号、各类管理员帐号</p>\n<p>2、<strong>控制企业数据</strong>，包括读取、篡改、添加、删除企业敏感数据的能力</p>\n<p>3、<strong>盗窃企业重要的具有商业价值的资料</strong></p>\n<p>4、<strong>非法转账</strong></p>\n<p>5、<strong>强制发送电子邮件</strong></p>\n<p>6、<strong>网站挂马</strong></p>\n<p>7、<strong>控制受害者机器向其它网站发起攻击</strong></p>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>过滤用户的输入信息，禁止用户在输入的过程中输入 “&lt;”, “&gt;”, “引号”, “$”, “_”</li>\n<li>核心的用户身份标示或 token 保存在 Cookie 中,Cookie 中一定要加 “HTTPOnly” 在结尾，保证只有在 html 操作时才能将 cookie 中的内容发送出去，在 JS 中无法获得用户的 Cookie 信息</li>\n</ul>\n<h2 id=\"2-CSRF-网络攻击\"><a href=\"#2-CSRF-网络攻击\" class=\"headerlink\" title=\"#2. CSRF 网络攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzItY3NyZi0lRTclQkQlOTElRTclQkIlOUMlRTYlOTQlQkIlRTUlODclQkI=\">#</span>2. CSRF 网络攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为 “One Click Attack” 或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 XSS 更具危险性。</p>\n</blockquote>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>减少在 cookie 中存储客户核心内容比如用户的 token、ID、access_token 等</li>\n<li>GET 请求不对数据进行修改</li>\n<li>不让第三方网站访问到 Cookie</li>\n<li>阻止第三方网站请求接口</li>\n<li>请求时附带验证信息，比如验证码或者 Token</li>\n</ul>\n<h2 id=\"3-DDOS-攻击\"><a href=\"#3-DDOS-攻击\" class=\"headerlink\" title=\"#3. DDOS 攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzMtZGRvcy0lRTYlOTQlQkIlRTUlODclQkI=\">#</span>3. DDOS 攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>DDOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。</p>\n</blockquote>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。</li>\n</ul>\n<p><strong>后端如何处理</strong></p>\n<ul>\n<li>HTTP 请求的拦截，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。</li>\n<li>带宽扩容，或者使用 CDN</li>\n</ul>\n","categories":["网络安全"],"tags":["网络安全"]},{"title":"计组知识点","url":"/2024/01/02/%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E3%80%81CPU%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"一、缓存\"><a href=\"#一、缓存\" class=\"headerlink\" title=\"一、缓存\"></a>一、缓存</h1><h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><blockquote>\n<blockquote>\n<h6 id=\"凡是为于速度相差较大的两种硬件之间-用于协调两者数据传输速度差异的结构-均可称之为Cache-电脑高速缓冲存储器\"><a href=\"#凡是为于速度相差较大的两种硬件之间-用于协调两者数据传输速度差异的结构-均可称之为Cache-电脑高速缓冲存储器\" class=\"headerlink\" title=\"凡是为于速度相差较大的两种硬件之间,用于协调两者数据传输速度差异的结构,均可称之为Cache (电脑高速缓冲存储器)\"></a><strong>凡是为于速度相差较大的两种硬件之间,用于协调两者数据传输速度差异的结构,均可称之为<code>Cache</code></strong> (电脑高速缓冲存储器)</h6></blockquote>\n<ul>\n<li>缓存的存在是为了解决 CPU 和内存之间存取速度的差异的</li>\n<li>内存中被 CPU 访问最频繁的数据和指令会被复制到 CPU 的缓存中（这其中的“频繁”是由专门的算法来定义的</li>\n<li>这样 CPU 就不用去很慢的内存中读取需要的数据和指令了</li>\n</ul>\n</blockquote>\n<h2 id=\"2、被扩充概念\"><a href=\"#2、被扩充概念\" class=\"headerlink\" title=\"2、被扩充概念\"></a>2、被扩充概念</h2><blockquote>\n<h6 id=\"如今缓存的概念已被扩充\"><a href=\"#如今缓存的概念已被扩充\" class=\"headerlink\" title=\"如今缓存的概念已被扩充\"></a>如今缓存的概念已被扩充</h6><ul>\n<li><strong>CPU</strong> 与 <strong>主内存</strong> 之间 (就我们常说的缓存)</li>\n<li><strong>内存</strong> 与 <strong>硬盘</strong> 之间 (磁盘缓存)</li>\n<li><strong>硬盘</strong> 与 <strong>网络</strong>之间 (称为<strong>Internet</strong> 临时文件夹或网络内容缓存等)</li>\n</ul>\n</blockquote>\n<h2 id=\"3、缓存的作用\"><a href=\"#3、缓存的作用\" class=\"headerlink\" title=\"3、缓存的作用\"></a>3、缓存的作用</h2><blockquote>\n<h6 id=\"用于协调两者数据传输速度差异的结构\"><a href=\"#用于协调两者数据传输速度差异的结构\" class=\"headerlink\" title=\"用于协调两者数据传输速度差异的结构\"></a>用于协调两者数据传输速度差异的结构</h6><p>实例:</p>\n<ul>\n<li>缓存 是 CPU 的一部分</li>\n<li>缓存 是硬盘控制器上的一块内存芯片</li>\n<li>硬盘上的缓存: 当硬盘存取零碎数据时需要不断地在硬盘与内存之间交换数据</li>\n</ul>\n</blockquote>\n<h1 id=\"二、内存\"><a href=\"#二、内存\" class=\"headerlink\" title=\"二、内存\"></a>二、内存</h1><h2 id=\"1、什么是内存\"><a href=\"#1、什么是内存\" class=\"headerlink\" title=\"1、什么是内存?\"></a>1、什么是内存?</h2><blockquote>\n<p><strong>在计算机的组成结构中,有一个很重要的部分,就是存储器,那么他的具体概念是什么呢?</strong> </p>\n<ol>\n<li>存储器是用来存储程序和数据的部件,对于计算机来说,有了存储器才有记忆功能,才能保证正常工作</li>\n<li>存储器的种类很多,按照其用途可以分为 <code>主存储器</code> 和 <code>辅助存储器</code></li>\n</ol>\n<ul>\n<li>主存储器又称为 <strong><code>内存储器</code></strong>(<strong>就是我们常说的内存</strong>) </li>\n<li>辅助存储器又成为 <strong><code>外存储器</code></strong> (<strong>简称外存</strong>)</li>\n<li>所以实际上有很多人容易弄混淆这个概念,以为存储器就是内存</li>\n</ul>\n</blockquote>\n<h2 id=\"2、内存与外存\"><a href=\"#2、内存与外存\" class=\"headerlink\" title=\"2、内存与外存\"></a>2、内存与外存</h2><h3 id=\"Ⅰ-外存-ROM\"><a href=\"#Ⅰ-外存-ROM\" class=\"headerlink\" title=\"Ⅰ - 外存 (ROM)\"></a>Ⅰ - 外存 (ROM)</h3><blockquote>\n<blockquote>\n<p><strong>外存通常是磁性介质或光盘: 如硬盘、软盘、磁带、CD等</strong></p>\n</blockquote>\n<ul>\n<li>能长期保存信息,且<strong>不依赖于电</strong>来保存信息,即断电不会失去保存的信息</li>\n<li>由于是机械部件带动,速度与CPU相比就显得慢得多</li>\n<li>**<code>ROM</code>**（Read Only Memory） 只读内存，应用于硬盘存储</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-内存-RAM\"><a href=\"#Ⅱ-内存-RAM\" class=\"headerlink\" title=\"Ⅱ - 内存 (RAM)\"></a>Ⅱ - 内存 (RAM)</h3><blockquote>\n<blockquote>\n<p><strong>物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路</strong></p>\n</blockquote>\n<ul>\n<li>指的是主板上的存储不见,是CPU直接与之沟通并用其存储数据的不见</li>\n<li>存放当前 正在使用的(<strong>即执行中</strong>) 的数据和程序</li>\n<li><strong>它的物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路</strong></li>\n<li>内存只用于暂时存放程序和数据,一旦关闭电源或者发生断电,其中的程序和数据就会丢失</li>\n<li>随机存储器  **<code>RAM</code>**（Random Access Memory）俗称内存</li>\n</ul>\n</blockquote>\n<h2 id=\"3、内存分类\"><a href=\"#3、内存分类\" class=\"headerlink\" title=\"3、内存分类\"></a>3、内存分类</h2><blockquote>\n<p>内存分为 <strong>静态RAM</strong> 和 <strong>动态RAM</strong></p>\n<p><img data-src=\"/images/image-20211011121001215.png\" alt=\"/images/image-20211011121001215\"> </p>\n<p><strong>静态RAM</strong> 速度比 <strong>动态RAM</strong> 快很多</p>\n<ol>\n<li>速度比较：静态RAM &gt; 动态RAM &gt; ROM；缓存 &gt; 内存 &gt; 外存。</li>\n</ol>\n</blockquote>\n<h3 id=\"Ⅰ-静态RAM\"><a href=\"#Ⅰ-静态RAM\" class=\"headerlink\" title=\"Ⅰ - 静态RAM\"></a>Ⅰ - 静态RAM</h3><blockquote>\n<blockquote>\n<p><strong>静态RAM，指SRAM：只要有供电，它保存的数据就不会丢失，且为高速存储器，如CPU中的高速缓存（cache）</strong></p>\n</blockquote>\n<p>缓存通常使用的是静态RAM, 不过由于静态RAM集成度低,因此便延申出一级缓存和二级缓存</p>\n<ul>\n<li>一级缓存为 静态RAM</li>\n<li>二级缓存为告诉动态RAM（比静态RAM慢，但比常规动态RAM要快）</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-动态RAM\"><a href=\"#Ⅱ-动态RAM\" class=\"headerlink\" title=\"Ⅱ - 动态RAM\"></a>Ⅱ - 动态RAM</h3><blockquote>\n<blockquote>\n<p><strong>动态RAM，指DRAM：有供电，还要根据它要求的刷新时间参数，才能保持存储的数据不丢失，如电脑中的内存条</strong></p>\n</blockquote>\n<p>现在使用的内存一般都是<strong>动态RAM</strong> </p>\n<ul>\n<li>因为静态RAM集成度相对较低:存储相同数据量,静态RAM的提及是动态RAM的6倍之多,且价格高</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅲ-动态RAM-与-静态RAM-的区别\"><a href=\"#Ⅲ-动态RAM-与-静态RAM-的区别\" class=\"headerlink\" title=\"Ⅲ  -  动态RAM 与 静态RAM 的区别\"></a>Ⅲ  -  动态RAM 与 静态RAM 的区别</h3><blockquote>\n<ul>\n<li>动态RAM 会周期地刷新,而 静态RAM 不会进行刷新</li>\n<li>动态RAM 是靠MOSS电路中的栅极电容来记忆信息的; 静态RAM 是靠双稳态触发器来记忆信息的</li>\n<li>由于电容上的电荷会泄露,需要定时给予补充. 所以 动态RAM 需要设置刷新电路,而静态不用</li>\n</ul>\n<h6 id=\"应用上的区别\"><a href=\"#应用上的区别\" class=\"headerlink\" title=\"应用上的区别\"></a>应用上的区别</h6><ul>\n<li>动态RAM 比 静态RAM 集成度高、功耗低,从而成本也低,适用于做大容量储存器,所以<strong>主内存通常采用动态RAM</strong></li>\n<li>另外:内存还应用于显卡、声卡及CMOS等设备中,用于充当设备缓存或保存固定的程序及数据</li>\n<li><strong>高速缓冲存储器(Cache)则使用静态RAM</strong></li>\n</ul>\n</blockquote>\n<h2 id=\"4、内存是如何工作的\"><a href=\"#4、内存是如何工作的\" class=\"headerlink\" title=\"4、内存是如何工作的?\"></a>4、内存是如何工作的?</h2><blockquote>\n<blockquote>\n<p><strong>既然内存是用来存放当前 正在使用的(即执行中) 的数据和程序,那么你可能会问:它是怎么工作的呢?</strong></p>\n</blockquote>\n<p>我们平常所提到的计算机内存指的是 <strong>动态内存(即DRAM)</strong> ,动态内存中所谓的 ‘<strong>动态</strong>‘ 指的是当我们将数据写入DRAM后,经过一段时间数据就会丢失,因此我们需要一个额外的电路进行内存刷新操作</p>\n<h6 id=\"具体工作过程是这样的\"><a href=\"#具体工作过程是这样的\" class=\"headerlink\" title=\"具体工作过程是这样的:\"></a>具体工作过程是这样的:</h6><ul>\n<li>一个DRAM的存储单元存储的是0还是1取决于电容是否电荷. <code>有电荷代表1、无电荷代表0</code></li>\n<li>但时间一长,代表 1 的电容会放电,代表 0 的电荷会吸收电荷 (<strong>这就是数据丢失的原因</strong>)</li>\n<li>刷新操作定期对电容进行检查,若电量大于满点亮的 <strong>1&#x2F;2</strong> 则认为其代表 <strong>1</strong>, 并把电容充满</li>\n<li>定期刷新操作时,若电量小于 <strong>1&#x2F;2</strong> 则认为其代表 <strong>0</strong>, 并把电容放电,籍此来保持数据的连续性</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"三、CPU\"><a href=\"#三、CPU\" class=\"headerlink\" title=\"三、CPU\"></a>三、CPU</h1><h2 id=\"1、CPU的简单工作原理图\"><a href=\"#1、CPU的简单工作原理图\" class=\"headerlink\" title=\"1、CPU的简单工作原理图\"></a>1、CPU的简单工作原理图</h2><blockquote>\n<p><img data-src=\"/images/image-20211009180308915.png\" alt=\"/images/image-20211009180308915\"></p>\n<p><strong>CPU 一般由控制单元、逻辑运算单元和存储单元(寄存器)组成（注意忽略了中断系统）</strong> </p>\n<p>CPU负责执行指令，是所有计算机硬件中速度最快的。一般用<strong>时钟周期</strong>（时钟频率）来衡量CPU的性能。</p>\n</blockquote>\n<h3 id=\"Ⅰ-控制单元\"><a href=\"#Ⅰ-控制单元\" class=\"headerlink\" title=\"Ⅰ - 控制单元\"></a>Ⅰ - 控制单元</h3><blockquote>\n<ul>\n<li>在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzkyMDQy\">节拍脉冲</span> 的作用下,将 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTglOEIlRTUlQkElOEYlRTglQUUlQTElRTYlOTUlQjAlRTUlOTklQTgvMzIxOTUzNg==\">程序计数器</span> (Program Counter – PC)指向的 <strong>主存或多级高速缓存</strong> 中的 <code>指令地址</code> 送到地址总线</li>\n<li>接着获取 <strong>指令地址</strong> 所对应的指令并放入<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlODclRTQlQkIlQTQlRTUlQUYlODQlRTUlQUQlOTglRTUlOTklQTgvMzIxOTQ4Mw==\">指令寄存器</span> (Instruction Register – IR) 中</li>\n<li>然后通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlODclRTQlQkIlQTQlRTglQUYlOTElRTclQTAlODElRTUlOTklQTgvMzI5NTI2MQ==\">指令译码器</span> (Instruction Decoder – ID)分析指令需要进行的操作</li>\n<li>最后通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTYlOEUlQTclRTUlODglQjYlRTUlOTklQTgvMTkyMTcyNQ==\">操作控制器</span>(Operation Controller – OC)向其他设备发出 微操作控制信号</li>\n</ul>\n<p>也许你对上述过程中提到的名词感到陌生,下面将会列举出来</p>\n</blockquote>\n<h4 id=\"①-节拍脉冲是什么\"><a href=\"#①-节拍脉冲是什么\" class=\"headerlink\" title=\"① 节拍脉冲是什么?\"></a>① 节拍脉冲是什么?</h4><blockquote>\n<p>时钟周期是由CPU时钟定义的定长时刻距离，是CPU作业的最小时刻单位，也称<code>节拍脉冲</code>或T周期。通常为节拍脉冲或T周期，既主频的倒数，它是处理操作的最基本的单位</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzkyMDQy\">原文地址</span></p>\n</blockquote>\n<h4 id=\"②-程序计数器\"><a href=\"#②-程序计数器\" class=\"headerlink\" title=\"②  程序计数器\"></a>②  程序计数器</h4><blockquote>\n<blockquote>\n<h6 id=\"程序计数器是用于存放下一条指令所在单元的地址的地方。\"><a href=\"#程序计数器是用于存放下一条指令所在单元的地址的地方。\" class=\"headerlink\" title=\"程序计数器是用于存放下一条指令所在单元的地址的地方。\"></a>程序计数器是用于存放下一条指令所在单元的地址的地方。</h6></blockquote>\n<p>当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlODclRTQlQkIlQTQlRTUlQUYlODQlRTUlQUQlOTglRTUlOTklQTgvMzIxOTQ4Mw==\">指令寄存器</span>中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTglOEIlRTUlQkElOEYlRTglQUUlQTElRTYlOTUlQjAlRTUlOTklQTgvMzIxOTUzNg==\">原文地址</span></p>\n</blockquote>\n<h4 id=\"③-指令寄存器\"><a href=\"#③-指令寄存器\" class=\"headerlink\" title=\"③  指令寄存器\"></a>③  指令寄存器</h4><blockquote>\n<p>根据指令在存贮器中的地址（由指令地址计数器给出），把指令从存贮器中取出来之后，需要有一个专门用于存放指令的地方，以便对指令进行分析和执行。这个专门存放现行指令的部件就叫做指令寄存器。指令寄存器的位数应满足指令长度的要求 [2] 。</p>\n<p>指令寄存器与CPU的8根数据总线相连接。当<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTglOEIlRTUlQkElOEYlRTglQUUlQTElRTYlOTUlQjAlRTUlOTklQTgvMzIxOTUzNg==\">程序计数器</span>访问存储器地址时，存储在该地址单元内的信息经8位数据总线送出，并储存在指令存器中</p>\n</blockquote>\n<h5 id=\"a-属性描述\"><a href=\"#a-属性描述\" class=\"headerlink\" title=\"a) 属性描述\"></a>a) 属性描述</h5><blockquote>\n<p>BSDL语言中有一个重要的描述，即指令寄存器（Instruclion Register），它是由一些强制的、可选的和用户自定义的指令集合而成。</p>\n<p>关于这个指令寄存器的属性描述，必须包含5个要素：</p>\n<blockquote>\n<ul>\n<li>指令寄存器的长度、</li>\n<li>各种指令的名称、</li>\n<li>对应的操作码、</li>\n<li>指令寄存器的捕获操作码</li>\n<li>哪些指令是内部的</li>\n</ul>\n</blockquote>\n</blockquote>\n<h5 id=\"b-取指过程\"><a href=\"#b-取指过程\" class=\"headerlink\" title=\"b) 取指过程\"></a>b) 取指过程</h5><blockquote>\n<p>取指令阶段完成的任务是将现行指令从主存中取出来并送至指令寄存器中,具体操作如下</p>\n<ol>\n<li>将 <strong>程序计数器</strong>(PC) 中的内容送至存储器<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUMlQjAlRTUlOUQlODAlRTUlQUYlODQlRTUlQUQlOTglRTUlOTklQTgvMzIxOTYxOQ==\">地址寄存器</span>（MAR),并送地址总线</li>\n<li>由控制单元(CU) 经控制总线(CB)向存储器发 <strong>读命令</strong></li>\n<li>从主存中取出的指令通过数据总线(DB), 送到存储器<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTUlQUYlODQlRTUlQUQlOTglRTUlOTklQTgvMTk0NDIzMQ==\">数据寄存器</span>（MDR）</li>\n<li>将MDR的内容送至指令寄存器（R）中</li>\n<li>将PC的内容递增，为取下一条指令做好准备</li>\n</ol>\n<p>以上这些操作对任何一条指令来说都是必须要执行的操作，所以称为公共操作</p>\n</blockquote>\n<h4 id=\"④-指令译码器\"><a href=\"#④-指令译码器\" class=\"headerlink\" title=\"④ 指令译码器\"></a>④ 指令译码器</h4><blockquote>\n<p>指令译码器(Instruction Decoder,ID)是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlQTclRTUlODglQjYlRTUlOTklQTgvMjIwNjEyNg==\">控制器</span>中的主要部件之一。</p>\n<ul>\n<li>计算机能且只能执行“指令”。指令由<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTclQTAlODEvMzIyMDQxOA==\">操作码</span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUMlQjAlRTUlOUQlODAlRTclQTAlODEvMzIyMDQ1NA==\">地址码</span>组成。</li>\n<li>操作码表示要执行的操作性质，即执行什么操作，或做什么；地址码是操作码执行时的操作对象的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUMlQjAlRTUlOUQlODAvODA0MjA=\">地址</span>。</li>\n<li>计算机执行一条指定的指令时，必须首先分析这条指令的操作码是什么，以决定操作的性质和方法，然后才能控制计算机其他各部件协同完成指令表达的功能。</li>\n<li>这个分析工作由 <strong>指令译码器</strong> 来完成。</li>\n<li>指令执行通过 控制部件 进行 指令译码，标量指令由标量<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQTQlODQlRTclOTAlODYlRTYlOUMlQkE=\">处理机</span>执行向量指令各Cache控制器监听总线所有操作，并对操作做相应处理（修改或作废），如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NRVNJJUU1JThEJThGJUU4JUFFJUFFLzIyNzQyMzMx\">MESI协议</span>。</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlODclRTQlQkIlQTQlRTglQUYlOTElRTclQTAlODElRTUlOTklQTgvMzI5NTI2MQ==\">原文地址</span></p>\n</blockquote>\n<h4 id=\"⑤-操作控制器\"><a href=\"#⑤-操作控制器\" class=\"headerlink\" title=\"⑤ 操作控制器\"></a>⑤ 操作控制器</h4><blockquote>\n<p>操作控制器的功能就是根据指令<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTclQTAlODE=\">操作码</span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTclQjYlRTUlQkElOEYlRTQlQkYlQTElRTUlOEYlQjc=\">时序信号</span>，产生各种操作<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlQTclRTUlODglQjYlRTQlQkYlQTElRTUlOEYlQjc=\">控制信号</span>，以</p>\n<p>便正确地建立<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTklODAlOUElRTglQjclQUY=\">数据通路</span>，从而完成取指令和执行指令的控制。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTYlOEUlQTclRTUlODglQjYlRTUlOTklQTgvMTkyMTcyNQ==\">原文地址</span></p>\n</blockquote>\n<h5 id=\"a-指令执行过程\"><a href=\"#a-指令执行过程\" class=\"headerlink\" title=\"a) 指令执行过程\"></a>a) 指令执行过程</h5><blockquote>\n<p>1、取指令：根据指令地址（由PC提供），从<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUQlOTglRTUlODIlQTglRTUlOTklQTg=\">存储器</span>中取出所要执行的指令。</p>\n<p>2、分析指令：</p>\n<p>（1）<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQUYlOTElRTclQTAlODE=\">译码</span>分析。确定指令应完成的操作，产生相应操作的控制电位。去参与形成该指令功能所需要的全部控制命令（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkUlQUUlRTYlOTMlOEQlRTQlQkQlOUMvODE5MDI2OQ==\">微操作</span>控制信号）。</p>\n<p>（2）根据<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUYlQkIlRTUlOUQlODAlRTYlOTYlQjklRTUlQkMlOEY=\">寻址方式</span>的分析和指令功能要求，形成<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTYlOTUlQjA=\">操作数</span>的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOUMlODklRTYlOTUlODglRTUlOUMlQjAlRTUlOUQlODA=\">有效地址</span>，并按此地址取出操作数（运算型指令）或形成转移地址（转移类指令），以实现程序转移。</p>\n<p>3、执行指令：根据指令分析所产生的操作<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlQTclRTUlODglQjYlRTQlQkYlQTElRTUlOEYlQjc=\">控制信号</span>和形成的有效地址，按一定算法形成指令控制序列，控制有关部件完成指令规定的功能。</p>\n</blockquote>\n<h5 id=\"b-控制方式\"><a href=\"#b-控制方式\" class=\"headerlink\" title=\"b) 控制方式\"></a>b) 控制方式</h5><blockquote>\n<p>操作控制器常用的控制方式有<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEMlRTYlQUQlQTUlRTYlOEUlQTclRTUlODglQjYvOTY0OTg5Nw==\">同步控制</span>、异步控制、联合控制。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEMlRTYlQUQlQTUlRTYlOEUlQTclRTUlODglQjYlRTYlOTYlQjklRTUlQkMlOEY=\">同步控制方式</span>：任何指令的运行或指令中各个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkUlQUUlRTYlOTMlOEQlRTQlQkQlOUMvODE5MDI2OQ==\">微操作</span>的执行，均由确定的，具有统一基准时标的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTclQjYlRTUlQkElOEYlRTQlQkYlQTElRTUlOEYlQjc=\">时序信号</span>所控制。即所有的操作均由统一的时钟控制，在标准时间内完成。（在同步控制下，每个时序信号的结束就意味着安排完成的工作已经完成，随即开始执行后续的微操作或自动转向下条指令的运行。）</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkMlODIlRTYlQUQlQTUlRTYlOEUlQTclRTUlODglQjYlRTYlOTYlQjklRTUlQkMlOEY=\">异步控制方式</span>：没有统一的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEMlRTYlQUQlQTUlRTQlQkYlQTElRTUlOEYlQjcvODU1NTQwMg==\">同步信号</span>，采用问答方式进行时序协调，将前一操作的回答作为下一操作的启动信号。</p>\n<p>联合控制方式：将同步控制和异步控制相结合。其通常设计思想为：在功能部件内部采用同步方式或以同步方式为主的控制方式；在功能部件间采用异步方式。</p>\n</blockquote>\n<h3 id=\"Ⅱ-运算单元\"><a href=\"#Ⅱ-运算单元\" class=\"headerlink\" title=\"Ⅱ - 运算单元\"></a>Ⅱ - 运算单元</h3><blockquote>\n<p>如果 <strong>控制单元</strong> 发出的控制信号存在<strong>算数运算</strong>(加减乘除、增1、减1、取反等) 或者 <strong>逻辑运算</strong>(与、或、非、异或),那么<strong>需要通过运算单元获取存储单元的计算数据</strong>进行处理</p>\n</blockquote>\n<h3 id=\"Ⅲ-储存单元\"><a href=\"#Ⅲ-储存单元\" class=\"headerlink\" title=\"Ⅲ - 储存单元\"></a>Ⅲ - 储存单元</h3><blockquote>\n<p>包括片内 <strong>缓存</strong> 和 <strong>寄存器组</strong> ,是CPU中临时存放数据的地方</p>\n<ul>\n<li>CPU直接访问主存数据大概需要花费数百个机器周期</li>\n<li>而访问 <strong>缓存</strong> 和 <strong>寄存器组</strong> 只需要若干个或者几十个机器周期</li>\n<li>因此会使用 <strong>缓存</strong> 和 <strong>寄存器组</strong> 来存储和获取临时数据(即将被运算或者运算之后的数据),从而提升运行效率</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅳ-指令周期\"><a href=\"#Ⅳ-指令周期\" class=\"headerlink\" title=\"Ⅳ - 指令周期\"></a>Ⅳ - 指令周期</h3><blockquote>\n<p>计算机系统执行程序指令时需要花费时间,其中取出一条指令并执行这条指令的时间叫做 <strong>指令周期</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"2、为什么需要缓存\"><a href=\"#2、为什么需要缓存\" class=\"headerlink\" title=\"2、为什么需要缓存\"></a>2、为什么需要缓存</h2><blockquote>\n<blockquote>\n<p><strong><code>CPU</code></strong> 负责运算，<code>内存</code> 负责暂时存储运算所涉及的东西，<code>高速缓存是CPU内部集成的小容量高速内存</code></p>\n<p><strong>高速缓存</strong>和内存的区别是，缓存容量极小，但是与<strong>CPU</strong>关系密切，所以传输速度比内存快得多</p>\n</blockquote>\n<ul>\n<li>缓存只是内存中少部分数据的复制品,所以CPU到缓存中寻找数据时也会出现找不到的情况(因为这些数据没用从内存复制到缓存中去)</li>\n<li>在这种缓存中找不到的情况下, CPU 还是会到内存中去找数据,这样系统的速度就会慢下来,不过<strong>CPU会把这些数据复制到缓存中去</strong>,以便下一次不用再到内存中去取,以此提高系统运行效率</li>\n<li>不过随着时间的变化,被访问得最频繁得数据不是一成不变的,也许昨天访问的不频繁的数据今天就非常频繁地进行了访问;</li>\n<li>所以说缓存中的数据经常要按照一定的算法来更换,这样才能保证缓存中的数据是被访问的最频繁的</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"3、CPU的作用\"><a href=\"#3、CPU的作用\" class=\"headerlink\" title=\"3、CPU的作用\"></a>3、CPU的作用</h2><h3 id=\"Ⅰ-缩短延迟\"><a href=\"#Ⅰ-缩短延迟\" class=\"headerlink\" title=\"Ⅰ - 缩短延迟\"></a>Ⅰ - 缩短延迟</h3><blockquote>\n<p>访问缓存的时间应该尽可能缩短,可以通过多种的方式缩短这个时间:</p>\n<ul>\n<li>比如能够通过减少缓存的大小、关联性来降低缓存的延迟; </li>\n<li>或者方法预测、增加宽带等</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-提高命中率\"><a href=\"#Ⅱ-提高命中率\" class=\"headerlink\" title=\"Ⅱ - 提高命中率\"></a>Ⅱ - 提高命中率</h3><blockquote>\n<p>所谓命中率是在高速缓存中找到内存引用的速率,我们希望能够首先通过缓存中获得信息以得到速度的优势;</p>\n<p>所以缓存需要最大限度地实现这一目标</p>\n<p>对于单个高速缓存来说:大小、关联性和块大小决定命中率</p>\n</blockquote>\n<h3 id=\"Ⅲ-降低更低级别内存下的开销\"><a href=\"#Ⅲ-降低更低级别内存下的开销\" class=\"headerlink\" title=\"Ⅲ - 降低更低级别内存下的开销\"></a>Ⅲ - 降低更低级别内存下的开销</h3><blockquote>\n<p>高速缓存是内存层次结构的一部分,其性能会影响其他性能,处理其他内存花费的时间越长意味着系统性能越低</p>\n<p>也就是说尽可能地让处理在缓存中完成</p>\n</blockquote>\n<h3 id=\"Ⅳ-减少错失惩罚\"><a href=\"#Ⅳ-减少错失惩罚\" class=\"headerlink\" title=\"Ⅳ - 减少错失惩罚\"></a>Ⅳ - 减少错失惩罚</h3><blockquote>\n<p>缓存中不能命中是无法避免的事情,但是我们可以减少处理未命中所需地时间以获得更好的处理器性能,通过提升命中率与不同的优化能有效降低错失惩罚</p>\n<p>高速缓存是CPU中十分重要的部分,占据了大量的资源开销和成本,如果咱看过CPU架构图的话就会发现缓存占据了至少50%的面积,绝对至关重要</p>\n</blockquote>\n<hr>\n<h2 id=\"4、时钟周期与指令周期\"><a href=\"#4、时钟周期与指令周期\" class=\"headerlink\" title=\"4、时钟周期与指令周期\"></a>4、时钟周期与指令周期</h2><blockquote>\n<p><strong><code>CPU时钟周期</code></strong> 是操作的最小时间单位,值是主频的倒数,现代计算机的主频可以达到几GHZ.</p>\n<p>**<code>指令周期</code>**是取出并执行一个指令的时间单位,一个指令需要多个 CPU 操作来执行,一般来说一个指令周期至少包含2个CPU时钟周期(取指 + 执行)</p>\n<p>同一个硬件架构下不同CPU的时钟周期越高,相同时间内能够执行的指令越多,性能就越好; 但在不同硬件架构下只比较CPU主频大小意义不大，处理器结构不同，指令集就不同，相同意义的指令所需的CPU时钟周期也就不同</p>\n<p>除了计算机架构不同外，在比较计算机整体性能的时候还需要考虑很多因素，例如<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg5JThEJUU3JUFCJUFGJUU2JTgwJUJCJUU3JUJBJUJG\">前端总线</span>（”front side bus”，FSB），<strong>内存的时钟周期</strong>，CPU<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPSVFOSU4MCU5QSVFNyU5NCVBOCVFNSVBRiU4NCVFNSVBRCU5OCVFNSU5OSVBOCZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=\">通用寄存器</span>的数据宽度和机器的一级、二级<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJDJTkzJUU1JUFEJTk4\">缓存</span>等。</p>\n</blockquote>\n<hr>\n<h2 id=\"5、存储单元-寄存器\"><a href=\"#5、存储单元-寄存器\" class=\"headerlink\" title=\"5、存储单元(寄存器)\"></a>5、存储单元(寄存器)</h2><blockquote>\n<p>寄存器是CPU的内部组成单元,是CPU运算时取 <strong>指令</strong> 和 <strong>数据</strong> 的地方,速度很快.</p>\n<blockquote>\n<ul>\n<li>可以理解成对于 CPU 来说, <strong>对寄存器进行 读&#x2F;写 是不需要时间的</strong></li>\n<li>或者说如果只是操作寄存器 (比如类似mov BX,AX之类的操作),那么一秒钟执行的指令个数理论上等于主频,因为寄存器是CPU的一部分</li>\n</ul>\n</blockquote>\n<h6 id=\"寄存器可以用来暂存指令、数据和地址-在CPU中分为\"><a href=\"#寄存器可以用来暂存指令、数据和地址-在CPU中分为\" class=\"headerlink\" title=\"寄存器可以用来暂存指令、数据和地址. 在CPU中分为\"></a>寄存器可以用来暂存指令、数据和地址. 在CPU中分为</h6><ul>\n<li><strong>通用寄存器</strong>: 如指令寄存器<code>IR</code>; </li>\n<li><strong>特殊功能寄存器</strong> : 如程序计数器<code>PC 、sp</code>等</li>\n</ul>\n<p><img data-src=\"/images/image-20211012102032541.png\" alt=\"/images/image-20211012102032541\"> </p>\n</blockquote>\n<hr>\n<h1 id=\"四、CPU的多级缓存-高速缓存\"><a href=\"#四、CPU的多级缓存-高速缓存\" class=\"headerlink\" title=\"四、CPU的多级缓存(高速缓存)\"></a>四、CPU的多级缓存(高速缓存)</h1><blockquote>\n<blockquote>\n<h6 id=\"高速缓存（cache）通常分为L1-L2-L3三级，速度递减，容量递增，是为了弥补CPU与内存之间运算速度的差异而设置的硬件\"><a href=\"#高速缓存（cache）通常分为L1-L2-L3三级，速度递减，容量递增，是为了弥补CPU与内存之间运算速度的差异而设置的硬件\" class=\"headerlink\" title=\"高速缓存（cache）通常分为L1,L2,L3三级，速度递减，容量递增，是为了弥补CPU与内存之间运算速度的差异而设置的硬件\"></a>高速缓存（cache）通常分为L1,L2,L3三级，速度递减，容量递增，是为了弥补CPU与内存之间运算速度的差异而设置的硬件</h6></blockquote>\n<p><img data-src=\"/images/image-20211012100054332.png\" alt=\"/images/image-20211012100054332\"></p>\n<p>上图为最简单的高速缓存的配置, 数据的读取和储存都将经过高速缓存, CPU 核心与高速缓存有一条特殊的快速通道: 主存和高速缓存都连在系统总线上,这条总线还用于其他组件的通信</p>\n<p>高速缓存出现不久,系统变得越来越复杂,高速缓存与主存之间的速度差异越来越大,直到加入了另一级缓存: 新加入的这级缓存比第一缓存更大而且更慢,同时经济上不合适,所以有了二级缓存、三级缓存</p>\n</blockquote>\n<h2 id=\"1、多级缓存出现的意义\"><a href=\"#1、多级缓存出现的意义\" class=\"headerlink\" title=\"1、多级缓存出现的意义\"></a>1、多级缓存出现的意义</h2><h3 id=\"Ⅰ-为什么需要CPU-Cache\"><a href=\"#Ⅰ-为什么需要CPU-Cache\" class=\"headerlink\" title=\"Ⅰ - 为什么需要CPU Cache\"></a>Ⅰ - 为什么需要CPU Cache</h3><blockquote>\n<blockquote>\n<p><strong>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以Cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu -&gt; cache -&gt; memort）</strong></p>\n</blockquote>\n<p>当 <strong>CPU</strong> 处理数据时, 它会先到 <strong>Cache</strong> 中去寻找,如果数据因之前的操作已经读取而被暂存其中的话就不必再从主内存中读取数据</p>\n<ul>\n<li>由于 CPU 的运行速度一般比主内存的读取速度快.主存 <strong>时钟周期</strong>(访问主存储器所需要时间) 为数个 CPU 时钟周期</li>\n<li>因此如果要访问主内存的话,就必须等待数个CPU周期从而造成浪费</li>\n<li><strong>L1缓存</strong> 的速度可以在 2-4 个CPU时钟频率内完成,速度很快</li>\n</ul>\n<p>Linux下可以通过 <code>lscpu</code> 命令来查看 CPU 的信息,其中就包括 Cache 层次</p>\n</blockquote>\n<h3 id=\"Ⅱ-CPU-Cache-有什么意义\"><a href=\"#Ⅱ-CPU-Cache-有什么意义\" class=\"headerlink\" title=\"Ⅱ - CPU Cache 有什么意义\"></a>Ⅱ - CPU Cache 有什么意义</h3><blockquote>\n<ul>\n<li>时间局限性: 如果某个数据被访问,那么在不久的将来他很可能被再次访问</li>\n<li>空间局限性: 如果某个数据被访问,那么与他相邻的数据很快也可能被访问</li>\n</ul>\n</blockquote>\n<h2 id=\"2、原理\"><a href=\"#2、原理\" class=\"headerlink\" title=\"2、原理\"></a>2、原理</h2><blockquote>\n<blockquote>\n<p>提供 ‘<strong>缓存</strong>‘ 的目的是为了让数据访问的速度适应 CPU 的处理速度,多级Cache技术，利用使用一个大的二级Cache来处理一级Cache的缺失，从而降低缺失代价</p>\n</blockquote>\n<p>通常它不像系统主存那样使用 <strong><code>DRAM(动态)</code></strong> 技术,而是使用 <strong>昂贵但比较快速</strong> 的 <strong><code>SRAM(静态)</code></strong> 技术,其原理是:</p>\n<ul>\n<li>内存中 ‘<strong>程序执行与数据访问的局域性行为</strong>‘, 即一定程序执行时间和空间内,被访问的代码集中于一部分</li>\n<li>为了充分发挥缓存的作用,不仅依靠 ‘<strong>暂存刚刚访问过的数据</strong>‘, 还要使用硬件实现的指令 <strong>预测 与 数据预取技术</strong> –&gt; 尽可能把将要使用的数据预先从内存中取到缓存里</li>\n</ul>\n</blockquote>\n<h2 id=\"3、数据结构\"><a href=\"#3、数据结构\" class=\"headerlink\" title=\"3、数据结构\"></a>3、数据结构</h2><blockquote>\n<p>高速缓存的数据结构类似于 <strong><code>拉链式的散列表</code></strong> ,<strong>Key</strong>是内存地址,<strong>值</strong>是内存数据的副本或是即将写入内存的数据</p>\n<p><img data-src=\"/images/image-20211012101834104.png\" alt=\"/images/image-20211012101834104\"> </p>\n<p>其中 <strong>Tag</strong> 可以理解为数据的内存地址, <strong>Data Block</strong> 是内存数据, <strong>Flag</strong> 用于标识数据状态</p>\n</blockquote>\n<h2 id=\"4、CPU的多级缓存\"><a href=\"#4、CPU的多级缓存\" class=\"headerlink\" title=\"4、CPU的多级缓存\"></a>4、CPU的多级缓存</h2><blockquote>\n<p>CPU的核心数量、高频高低都会影响性能，但如果让CPU更聪明、更有效率的执行计算任务，那么缓存的作用就至关重要了</p>\n</blockquote>\n<h3 id=\"Ⅱ-一级缓存-L1-Cache\"><a href=\"#Ⅱ-一级缓存-L1-Cache\" class=\"headerlink\" title=\"Ⅱ - 一级缓存 (L1 Cache)\"></a>Ⅱ - 一级缓存 (L1 Cache)</h3><blockquote>\n<blockquote>\n<h6 id=\"CPU一级缓存-就是指-CPU-的第一层级的高速缓存-主要担当的工作是-缓存指令-和-缓存数据\"><a href=\"#CPU一级缓存-就是指-CPU-的第一层级的高速缓存-主要担当的工作是-缓存指令-和-缓存数据\" class=\"headerlink\" title=\"CPU一级缓存,就是指 CPU 的第一层级的高速缓存, 主要担当的工作是 缓存指令 和 缓存数据 .\"></a><strong>CPU一级缓存</strong>,就是指 CPU 的第一层级的高速缓存, 主要担当的工作是 <strong>缓存指令</strong> 和 <strong>缓存数据</strong> .</h6></blockquote>\n<ul>\n<li>一级缓存的容量与结构对于CPU性能的影响十分巨大,但是由于它的结构相对复杂且还有成本问题</li>\n<li>一般来说, <strong><code>CPU 的一级缓存比较小</code></strong>, 通常 CPU 的一级缓存也就能做到 <strong>256KB</strong> 左右的水平</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-二级缓存-L2-Cache\"><a href=\"#Ⅱ-二级缓存-L2-Cache\" class=\"headerlink\" title=\"Ⅱ - 二级缓存 (L2 Cache)\"></a>Ⅱ - 二级缓存 (L2 Cache)</h3><blockquote>\n<blockquote>\n<h6 id=\"CPU-二级缓存-就是指-CPU-的第二层级的高速缓存\"><a href=\"#CPU-二级缓存-就是指-CPU-的第二层级的高速缓存\" class=\"headerlink\" title=\"CPU 二级缓存, 就是指 CPU 的第二层级的高速缓存\"></a>CPU 二级缓存, 就是指 CPU 的第二层级的高速缓存</h6></blockquote>\n<ul>\n<li>二级缓存的容量会直接影响到 CPU 的性能,所以二级缓存的容量越大越好</li>\n<li>例如intel的第八代i7-8700处理器，共有六个核心数量，而每个核心都拥有256KB的二级缓存，属于各核心独享，这样二级缓存总数就达到了1.5MB。</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅲ-三级缓存-L3-Cache\"><a href=\"#Ⅲ-三级缓存-L3-Cache\" class=\"headerlink\" title=\"Ⅲ - 三级缓存 (L3 Cache)\"></a>Ⅲ - 三级缓存 (L3 Cache)</h3><blockquote>\n<p>CPU 三级缓存, 就是指 CPU 的第三层级的高速缓存, 起作用就是进一步降低内存的延迟, 同时提升海量数据计算时的性能</p>\n<blockquote>\n<h6 id=\"和一级、二级缓存不同的是-三级缓存时核心共享的-能够将容量做很大\"><a href=\"#和一级、二级缓存不同的是-三级缓存时核心共享的-能够将容量做很大\" class=\"headerlink\" title=\"和一级、二级缓存不同的是,三级缓存时核心共享的,能够将容量做很大\"></a>和一级、二级缓存不同的是,三级缓存时核心共享的,能够将容量做很大</h6></blockquote>\n</blockquote>\n<h3 id=\"Ⅳ-缓存一致性-MESI\"><a href=\"#Ⅳ-缓存一致性-MESI\" class=\"headerlink\" title=\"Ⅳ - 缓存一致性(MESI)\"></a>Ⅳ - 缓存一致性(MESI)</h3><blockquote>\n<p>CPU种每个 <code>缓存行</code> 使用 <strong>四种</strong> 状态进行标记</p>\n</blockquote>\n<h4 id=\"①-M-Modified-修改\"><a href=\"#①-M-Modified-修改\" class=\"headerlink\" title=\"① M: Modified 修改\"></a>① M: Modified 修改</h4><blockquote>\n<p>指的时该 <strong>缓存行</strong> 只被缓存在该 CPU 种,并且是<code>被修改过</code>的, <strong>因此他与主存的数据是不一致的</strong>,</p>\n<p>该缓存行中的数据需要在未来某个时间点(<strong>允许其他CPU读取主存相应的内容之前</strong>) 写回主存,然后<code>状态变成E (独享)</code></p>\n</blockquote>\n<h4 id=\"②-Exclusive-独享\"><a href=\"#②-Exclusive-独享\" class=\"headerlink\" title=\"② Exclusive 独享\"></a>② Exclusive 独享</h4><blockquote>\n<p>缓存行 只被缓存在该 CPU 的缓存中,是<code>未被修改过</code>的,<strong>与主存的数据是一致的</strong>. </p>\n<p>可以在任何时刻当有其他CPU读取该内存时,状态变成 <code>S(共享)</code></p>\n<p>当CPU修改缓存行的内容时, 状态变成 <code>M(修改)</code></p>\n</blockquote>\n<h4 id=\"③-Share-共享\"><a href=\"#③-Share-共享\" class=\"headerlink\" title=\"③ Share 共享\"></a>③ Share 共享</h4><blockquote>\n<p>意味着该 缓存行 <code>可能被多个 CPU 进行缓存</code>,并且<strong>该缓存中的数据与主存数据是一致的</strong></p>\n<p>当有一个 CPU 修改 <strong>该缓存行</strong> 时,其他 CPU 是可以被作废的,变成 <code>I(无效的)</code></p>\n</blockquote>\n<h4 id=\"④-Invalid-无效的\"><a href=\"#④-Invalid-无效的\" class=\"headerlink\" title=\"④ Invalid 无效的\"></a>④ Invalid 无效的</h4><blockquote>\n<p>代表这个缓存是无效的，可能是有其他CPU修改了该缓存行</p>\n</blockquote>\n<h4 id=\"⑤对应的四个操作\"><a href=\"#⑤对应的四个操作\" class=\"headerlink\" title=\"⑤对应的四个操作\"></a>⑤对应的四个操作</h4><blockquote>\n<p>local read：读本地缓存<br>local write：写本地缓存<br>remote read：将内存中的数据读取过来<br>remote write：将数据写回主存</p>\n</blockquote>\n<h5 id=\"a-详细说明\"><a href=\"#a-详细说明\" class=\"headerlink\" title=\"a) 详细说明\"></a>a) 详细说明</h5><blockquote>\n<blockquote>\n<p><strong>在一个典型的多核系统中，每一个核都会有自己的缓存来共享总线，每一个CPU会发出读写（I&#x2F;O）请求，而缓存的目的是为了减少CPU读写共享主存的次数；</strong></p>\n</blockquote>\n<ol>\n<li>一个缓存除了在无效（Invalid）状态，都可以满足CPU的读请求，一个无效（Invalid）的缓存行必须从主存中读取（变成Share或者Exclusive状态）来满足该CPU的读请求</li>\n<li>一个 <code>写请求</code> 只有在该缓存行是 <strong><code>修改</code></strong> 或者 <strong><code>独享</code></strong> 状态时才能被执行</li>\n</ol>\n<ul>\n<li>如果缓存行处于 <strong><code>共享</code></strong> 状态，必须<strong>先将其他缓存中的 该缓存行</strong> 变成 <code>无效</code> 状态</li>\n<li><strong>也即是不允许不同CPU同时修改同一缓存行，即使修改该缓存行中的不同数据也不允许</strong></li>\n<li>该操作经常作用广播的方式来完成，例如：Request For Ownership（RFO）</li>\n</ul>\n<ol start=\"3\">\n<li>缓存可以随时将一个 <strong>非修改</strong> 状态的缓存行作废，或者变成 <strong><code>无效</code></strong> 状态，而一个**<code>修改</code>** 状态的缓存行必须先被写回主存</li>\n<li>一个处于 <strong>共享</strong> 状态的 缓存行  也<code>必须监听</code> 其他缓存中<strong>使该 缓存行 <code>无效</code> 或者 <code>独享</code> 该缓存行的请求</strong>，并将该 缓存行 变成 <strong><code>无效</code></strong></li>\n<li>一个处于 <strong>独享</strong> 状态的 缓存行 也<code>必须监听</code>其他缓存中 <strong>读主存中该缓存行的操作</strong>，一旦有这种操作，该缓存行需要变成<code>共享</code>状态</li>\n<li>对于 <code>修改</code> 和 <code>独享</code> 状态而言总是精确的，他们在该缓存行的真正状态是一致的。</li>\n</ol>\n<ul>\n<li>而 <code>共享</code> 状态可能是非一致的</li>\n<li>如果一个缓存将处于 <code>共享</code> 状态的缓存行作废了，而另一个缓存实际上可能已经独享了 该缓存行，但是该缓存却不会将该 缓存行 升迁为 <code>独享</code> 状态</li>\n<li>这是因为<strong>其他缓存不会广播他们作废掉该缓存行的通知</strong>，同样由于缓存并没有保存该缓存行的 copy 的数量，因此也没有办法确定自己是否已经独享（Share了该缓存行）</li>\n</ul>\n<p>从上面的意义看来独享（Exclusive）状态时一种投机性的优化：如果一个CPU想修改一个处于共享（Share）状态的缓存航，总线事务需要将所有缓存行的copy变成Invalid状态，而修改独享（Exclusive）状态的缓存不需要使用总线事务</p>\n</blockquote>\n","categories":["计算机组成原理"],"tags":["计算机组成原理","缓存","内存","CPU"]},{"title":"JS类型转换","url":"/2023/12/02/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","content":"<h1 id=\"JS隐式类型转换\"><a href=\"#JS隐式类型转换\" class=\"headerlink\" title=\"JS隐式类型转换\"></a>JS隐式类型转换</h1><p>一、原始类型 -&gt; 数字：</p>\n<p><img data-src=\"/images/1.png\"></p>\n<p>二、所有转boolean</p>\n<p><img data-src=\"/images/2.png\"></p>\n<p>三、原始类型</p>\n<p><img data-src=\"/images/3.png\"></p>\n<p>四、对象转原始类型</p>\n<p><img data-src=\"/images/4.png\" alt=\"四、对象转原始类型\"></p>\n<h2 id=\"具体转换规则为：\"><a href=\"#具体转换规则为：\" class=\"headerlink\" title=\"具体转换规则为：\"></a>具体转换规则为：</h2><ul>\n<li><p>如果该值已经是原始数据类型（string、number、boolean），则直接返回该值。</p>\n</li>\n<li><p>如果其中一项是字符串，那另一项值就会转换成对应的字符串类型。</p>\n</li>\n<li><p>如果该值是对象（Object），则调用该对象的 valueOf() 方法，如果返回的结果是原始数据类型，则直接返回该值。</p>\n</li>\n<li><p>如果<code>valueOf()</code>方法的返回结果不是原始数据类型，则调用该对象的 toString() 方法，如果返回的结果是原始数据类型，则直接返回该值。</p>\n</li>\n<li><p>如果<code>toString()</code>方法的返回结果不是原始数据类型，则抛出 TypeError 异常。</p>\n</li>\n</ul>\n<p><img data-src=\"/images/Snipaste_2024-05-28_22-08-50.png\" alt=\"images\"></p>\n","categories":["JS"],"tags":["JS类型转换"]},{"title":"脚手架开发","url":"/2024/04/12/%E8%84%9A%E6%89%8B%E6%9E%B6/","content":"<h1 id=\"需求分析\"><a class=\"anchor\" href=\"#需求分析\">#</a> 需求分析</h1>\n<p><strong>为什么需要优化研发流程？</strong></p>\n<ul>\n<li>项目量级增加：几干行代码 -&gt; 几万行代码</li>\n<li>项目数量扩大：几个项目 -&gt; 几干个项目</li>\n<li>项目复杂度高：Wb 项目 -&gt;H5/PC/ 小程序 / 后端 / 脚手架</li>\n<li>团队人数增长：几个人 -&gt; 几百人</li>\n<li>传统的项目研发流程已经无法满足业务需求</li>\n</ul>\n<h1 id=\"git开发流程\"><a class=\"anchor\" href=\"#git开发流程\">#</a> git 开发流程</h1>\n<p>单人 git 项目开发流程</p>\n<p><img data-src=\"/images/Snipaste_2024-05-27_13-57-14.png\" alt=\"images\" /></p>\n<p>多人 git 项目开发流程</p>\n<p><img data-src=\"/images/Snipaste_2024-05-27_14-05-13.png\" alt=\"images\" /></p>\n<h1 id=\"浏览器获取资源步骤\"><a class=\"anchor\" href=\"#浏览器获取资源步骤\">#</a> 浏览器获取资源步骤</h1>\n<p><img data-src=\"/images/Snipaste_2024-05-27_14-34-47.png\" alt=\"images\" /></p>\n<p><strong>项目创建流程思考</strong></p>\n<p>当团队较大时，让每一个团队成员开发创建项目体验趋于一致就非常重要。</p>\n<p><strong>项目创建流程</strong></p>\n<ul>\n<li>项目代码</li>\n<li>抽象出项目模板</li>\n<li>存储到数据库</li>\n<li>脚手架读取数据库</li>\n<li>根据脚手架创建新的项目</li>\n</ul>\n<p><strong>提升前端研发效率的手段</strong></p>\n<ul>\n<li>物料和模板</li>\n<li>低代码搭建</li>\n<li>等等</li>\n</ul>\n<p>从使用角度理解什么是脚手架？</p>\n<h1 id=\"脚手架简介\"><a class=\"anchor\" href=\"#脚手架简介\">#</a> 脚手架简介</h1>\n<p>脚手架本质是一个操作系统的客户端，它通过命令行执行，比如：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vue create vue-test-app</pre></td></tr></table></figure><p>上面这条命令由 3 个部分组成：</p>\n<ul>\n<li>主命令：vue</li>\n<li>command:create</li>\n<li>command 的 param:vue-test-app</li>\n</ul>\n<p>它表示创建一个 vue 项目，项目的名称为 vue-test-app, 以上是最一个较为简单的脚手架命令，但实际场易<br />\n往更加复杂，比如：<br />\n当前目录已经有文件了，我们需要覆盖当前目录下的文件，强制进行安装 ue 项目，此时我们就可以输入：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vue create vue-test-app <span class=\"token parameter variable\">--force</span></pre></td></tr></table></figure><p>这里的 - force 叫做 option, 用来辅助脚手架确认在特定场景下用户的选择（可以理解为配置）。还有一种场景<br />\n通过 vue create<br />\n 创建项目时，会自动执行 npm install 帮用户安装依赖，如果我们希望使用淘宝源来安装，<br />\n可以输入命令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vue create vue-test-app <span class=\"token parameter variable\">--force</span> <span class=\"token parameter variable\">-r</span> https://registry.npm.taobao.org</pre></td></tr></table></figure><p>这里的 - x 也叫做 option, 它与 --force 不同的是它使用 -，并且使用简写，这里的 - x 也可以替换成 --registry, 有的同学可能要问，为什么老师知道这个命令，其实我们输入下面的命令就可以看到 vue create 支持的所有 options:<br />\nvue create  --help</p>\n<p>-r  https:/registry.npm.taobao.org 后面的 https://registry.npm.taobao.org 成为 option 的 param, 其实任 - force 可以理解为：-force true,f 简写为：--force 或 - f</p>\n<h1 id=\"脚手架原理\"><a class=\"anchor\" href=\"#脚手架原理\">#</a> 脚手架原理</h1>\n<p><strong>脚手架的执行原理如下：</strong></p>\n<ul>\n<li>在终端输入 vue create vue-test-app</li>\n<li>终端解析出 vue 命令</li>\n<li>终端在环境变量中找到 ue 命令</li>\n<li>终端根据 vue 命令链接到实际文件 vue.js</li>\n<li>终端利用 node 执行 `ue.js</li>\n<li>vue.js 解析 command/options</li>\n<li>vue.js 执行 command</li>\n<li>执行完毕，退出执行</li>\n</ul>\n<p><strong>从应用的角度看如何开发一个脚手架</strong></p>\n<p>这里以 vue-cli 为例：</p>\n<ul>\n<li>开发 npm 项目，该项目中应包含一个 bin/vue.js 文件，并将这个项目发布到 npm</li>\n<li>将 npm 项目安装到 node 的 lib/node_modules</li>\n<li>在 node 的 bin 目录下配置 vue 软链接指向 lib/node modules/Qvue/cli/bin/vue.js</li>\n<li>这样我们在执行 vue 命令的时候就可以找到 vue.js 进行执行</li>\n</ul>\n<p><strong>还有很多疑问需要解答</strong></p>\n<ul>\n<li>\n<p>为什么全局安装 vue/cli 后会添加的命令为 vue?  （npm install -g @vue/cli）</p>\n</li>\n<li>\n<p>答：vue/cli 项目的 package.json 中的 bin 字段配置的名称为 vue。</p>\n</li>\n<li>\n<p>全局安装 vue/c1i 时发生了什么？</p>\n</li>\n<li>\n<p>答：全局 node_modules 中下载项目文件，并根据项目 package.json 中的 bin 字段配置可执行文件软链接。</p>\n</li>\n<li>\n<p>为什么 vue 指向一个 js 文件，我们却可以直接通过 vue 命令直接去执行它？</p>\n</li>\n<li>\n<p>答：js 文件配置了蛇棒（操作系统的接口），例如：</p>\n</li>\n<li>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token hashbang comment\">#!/usr/bin/env node</span></pre></td></tr></table></figure><p>通常使用环境变量中找 node 命令，因为每个电脑上的 node 文件位置不同，但是环境变量中都会有 node 软连接。</p>\n</li>\n</ul>\n<h1 id=\"脚手架的开发流程\"><a class=\"anchor\" href=\"#脚手架的开发流程\">#</a> 脚手架的开发流程</h1>\n<p><strong>脚手架开发流程详解</strong></p>\n<p>开发流程</p>\n<ul>\n<li>创建 npm 项目</li>\n<li>创建脚手架入口文件，最上方添加 #!/usr/bin/env node</li>\n<li>配置 package.json, 添加 bin 属性</li>\n<li>编写脚手架代码</li>\n<li>将脚手架发布到 npm</li>\n</ul>\n<p><strong>使用流程</strong></p>\n<ul>\n<li>\n<p>安装脚手架</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-g</span> your-own-cli</pre></td></tr></table></figure></li>\n<li>\n<p>使用脚手架</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>your-own-cli-binName</pre></td></tr></table></figure></li>\n</ul>\n<p><strong>脚手架开发难点解析</strong></p>\n<ul>\n<li>\n<p>分包：将复杂的系统拆分成若干个模块</p>\n</li>\n<li>\n<p>命令注册：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>- vue create</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>- vue <span class=\"token function\">add</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>- vue invoke</pre></td></tr></table></figure></li>\n<li>\n<p>参数解析：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vue <span class=\"token builtin class-name\">command</span> <span class=\"token punctuation\">[</span>options <span class=\"token operator\">&lt;</span>params<span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n<li>\n<p>options: 全称：--version、--help。简写为：-v   -h</p>\n</li>\n<li>\n<p>帮助文档：global help</p>\n</li>\n<li>\n<p>命令行交互</p>\n</li>\n<li>\n<p>日志打印</p>\n</li>\n<li>\n<p>命令行文字变色</p>\n</li>\n<li>\n<p>网络通信</p>\n</li>\n<li>\n<p>文件处理</p>\n</li>\n</ul>\n<h1 id=\"开发细节\"><a class=\"anchor\" href=\"#开发细节\">#</a> 开发细节</h1>\n<p><strong>两种链接本地文件的方式</strong></p>\n<ul>\n<li>\n<p>npm  link 命令会将命令执行的当前文件夹根据 bin 字段软连接到全局的 node_moduls。</p>\n</li>\n<li>\n<p>npm link 包名称 ，这个命令会将全局包添加软连接到当前项目的 node_modules 中。</p>\n</li>\n<li>\n<p>npm unlink 包名称 ，这个命令用于移除全局 node_modules 中指定的软连接。（不过这个命令不好用，建议使用 <code>npm uninstall -g </code> 包名称、或者 <code>npm remove -g </code> 包名称  代替）</p>\n</li>\n<li>\n<p>调试过程中，当本地包相互依赖时，可以使用 File: 路径进行指向。</p>\n<p><strong>两种方式的区别</strong></p>\n</li>\n</ul>\n<p>npm  link 的方式创建的软连接可以实时同步更改的文件，但是项目文件多了就不方便管理、很复杂，File 路径不能实时同步文件修改，需要执行 npm install，但是管理方便。</p>\n<h1 id=\"脚手架发布体系\"><a class=\"anchor\" href=\"#脚手架发布体系\">#</a> 脚手架发布体系</h1>\n<p><strong>利用脚手架统一管理发布阶段</strong></p>\n<p><strong>利用脚手架做发布的优势</strong></p>\n<ul>\n<li>规范：利用统一发布规范，如 commiti 记录、分支名称、代码规范等</li>\n<li>效率：避免大量重复操作，浪费开发时间</li>\n<li>安全：构建和发布全部在云端操作，避免个人发布时带来的安全隐患</li>\n</ul>\n<p><strong>脚手架发布的流程？</strong></p>\n<ul>\n<li>GitF1low 自动化代码提交</li>\n<li>远程代码自动检查</li>\n<li>云端完成构建与发布操作</li>\n</ul>\n<h1 id=\"脚手架发布流程\"><a class=\"anchor\" href=\"#脚手架发布流程\">#</a> 脚手架发布流程</h1>\n<ul>\n<li>检查 package.json 中 name 和 bin 字段，name 字段不能和已存在的线上包名重复，</li>\n<li>检查版本号，是否需要更新</li>\n<li>npm login</li>\n<li>npm publish</li>\n</ul>\n<h1 id=\"npm新特性workspace\"><a class=\"anchor\" href=\"#npm新特性workspace\">#</a> npm 新特性：workspace</h1>\n<p><strong>作用</strong></p>\n<p>本地调试时，需要多次执行 npm  link，node15 版本推出 workspace，workspace 新特性可以帮助我们进行多 package 包管理，可以让多个 npm 包在同一个项目中进行开发和管理：</p>\n<ul>\n<li>将子包中所有的依赖包都提升到根目录进行安装，提升包的安装速度</li>\n<li>初始化 (npm install) 后自动将子包之间的依赖进行关联</li>\n<li>各个子包共享一些流程（eslint、githook、publish flow 等等）</li>\n</ul>\n<h1 id=\"lerna多package管理\"><a class=\"anchor\" href=\"#lerna多package管理\">#</a> Lerna 多 package 管理</h1>\n<h3 id=\"lerna简介\"><a class=\"anchor\" href=\"#lerna简介\">#</a> Lerna 简介</h3>\n<p><strong>原生脚手架开发痛点分析</strong>（Lerna 解决了哪些问题： ）</p>\n<p><strong>痛点一：重复操作</strong></p>\n<ul>\n<li>多 Package 本地 link</li>\n<li>多 Package 依赖安装</li>\n<li>多 Package. 单元测试</li>\n<li>多 Package 代码提交</li>\n<li>多 Package 代码发布</li>\n</ul>\n<p><strong>痛点二：版本一致性</strong></p>\n<ul>\n<li>发布时版本一致性</li>\n<li>发布后相互依赖板本升级</li>\n<li>package 越多，管理复杂度越高</li>\n</ul>\n<p><strong>简介：</strong></p>\n<p>Lerna 是一个优化基于 git+npm 的多 package 项目的管理工具。</p>\n<p><strong>优势：</strong></p>\n<ul>\n<li>大幅减少重复操作</li>\n<li>提升操作的标准化</li>\n</ul>\n<p>Lera 是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。优化的主要目标往往都是以效能为核心。</p>\n<h3 id=\"lerna使用\"><a class=\"anchor\" href=\"#lerna使用\">#</a> Lerna 使用</h3>\n<p><strong>Lerna 开发脚手架流程如下：</strong></p>\n<ul>\n<li>\n<p>npm 上创建 group</p>\n</li>\n<li>\n<p>初始化 npm 项目</p>\n</li>\n<li>\n<p>安装 lerna</p>\n</li>\n<li>\n<p>package.json 中配置 workspaces</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token property\">\"workspaces\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token string\">\"packages/*\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">//workspaces 字段允许指定一个或多个目录作为工作区。一、可以在父级目录的 package.json 中管理他们的依赖，从而较少体积。二、工作区每个包之间直接相互引用，有助于提高开发效率。三、工作区所有包共享版本控制历史。</span></pre></td></tr></table></figure></li>\n<li>\n<p>lerna init 初始化项目（创建了 git）</p>\n</li>\n<li>\n<p>配置 gitignore 排除不需要提交的文件</p>\n</li>\n<li>\n<p>--------------------------- 初始化完成</p>\n</li>\n<li>\n<p>lerna create 创建 package</p>\n</li>\n<li>\n<p>lerna add 安装依赖（最新版废弃），使用 npm install &lt;dependency&gt; --workspace  &lt;workspace &gt; 代替。</p>\n</li>\n<li>\n<p>lerna link 链接依赖（最新版废弃），workspace 自动链接。</p>\n</li>\n<li>\n<p>---------------------------- 项目创建完成</p>\n</li>\n<li>\n<p>lerna exec 执行 shell 脚本</p>\n</li>\n<li>\n<p>lerna run 执行 npm 命令</p>\n</li>\n<li>\n<p>lerna clean 清空依赖</p>\n</li>\n<li>\n<p>lerna bootstrap 重装依赖（最新版废弃），使用 npm install 代替</p>\n</li>\n<li>\n<p>---------------------------- 项目开发完成</p>\n</li>\n<li>\n<p>git push 提交到远程仓库</p>\n</li>\n<li>\n<p>lerna version 升级版本号</p>\n</li>\n<li>\n<p>lerna changed 查看上版本以来全部的变更。</p>\n</li>\n<li>\n<p>git add . 添加到 git 工作区</p>\n</li>\n<li>\n<p>lerna diff 查看 diff</p>\n</li>\n<li>\n<p>lerna publish 进行项目发布</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 默认是私有仓库，需要在 package.json 中进行配置：</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token property\">\"publishConfig\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token property\">\"access\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"public\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n<li>\n<p>---------------------------- 项目发布完成</p>\n</li>\n</ul>\n<p>这里注意 npm 最新版 workspace 特性的推广导致 lerna 许多命令在最新版被废弃。</p>\n<h3 id=\"lerna学习收获\"><a class=\"anchor\" href=\"#lerna学习收获\">#</a> Lerna 学习收获</h3>\n<ul>\n<li>熟悉 Yargs 脚手架开发框架</li>\n<li>熟悉多 Package 管理工具 Lerna 的使用方法和实现原理</li>\n<li>深入理解 Node.js 模块路径解析流程</li>\n</ul>\n<h4 id=\"一-yargs\"><a class=\"anchor\" href=\"#一-yargs\">#</a> <strong>一、yargs</strong></h4>\n<p><strong>脚手架构成</strong></p>\n<ul>\n<li>\n<p>bin:package,json 中配置 bin 属性，npm link 本地安装</p>\n</li>\n<li>\n<p>command: 命令</p>\n</li>\n<li>\n<p>options: 参数 (boolean/string/number)</p>\n</li>\n<li>\n<p>文件顶部增加  #！/usr/bin/env node</p>\n</li>\n</ul>\n<p><strong>脚手架初始化流程</strong></p>\n<ul>\n<li>\n<p>构造函数：Yargs (0</p>\n</li>\n<li>\n<p>常用方法：</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>Yargs.options</p>\n</li>\n<li>\n<p>Yargs.option</p>\n</li>\n<li>\n<p>Yargs.group</p>\n</li>\n<li>\n<p>Yargs.demandCommand</p>\n</li>\n<li>\n<p>Yargs.recommendCommands</p>\n</li>\n<li>\n<p>Yargs.strict</p>\n</li>\n<li>\n<p>Yargs.fail</p>\n</li>\n<li>\n<p>Yargs.alias</p>\n</li>\n<li>\n<p>Yargs.wrap</p>\n</li>\n<li>\n<p>Yargs.epilogue</p>\n</li>\n</ol>\n<ul>\n<li>脚手架参数解析</li>\n</ul>\n<ol>\n<li>hideBin(process.argv)/Yargs.argv</li>\n<li>Yargs.parse(argv,options)</li>\n</ol>\n<ul>\n<li>命令注册方法</li>\n</ul>\n<ol>\n<li>Yargs.command(command,describe,builder,handler)</li>\n<li>Yargs.command({command,describe,builder,handler )</li>\n</ol>\n<h4 id=\"二-lerna实现原理\"><a class=\"anchor\" href=\"#二-lerna实现原理\">#</a> <strong>二、Lerna 实现原理</strong></h4>\n<p>Lerna 是基于 git+npm 的多 package 项目管理工具</p>\n<p><strong>实现原理：</strong></p>\n<ul>\n<li>通过 import-local 优先调用本地 lerna 命令</li>\n<li>通过 Yargs 生成脚手架，先注册全局属性，再注册命令，最后通过 parse 方法解析参数</li>\n<li>lerna 命令注册时需要传入 builder 和 handler 两个方法，builder 方法用于注册命令专属的 options</li>\n<li>handler 用来处理命令的业务逻辑</li>\n<li>lerna 通过配置 npm 本地依赖的方式来进行本地开发，具体写法是在 package.json 的依赖中写入：file:your-local--module-path, 在 lerna publish 时会自动将该路径替换</li>\n</ul>\n<h4 id=\"三-nodejs模块路径解析流程\"><a class=\"anchor\" href=\"#三-nodejs模块路径解析流程\">#</a> 三、Node.js 模块路径解析流程</h4>\n<ul>\n<li>\n<p>Node.js 项目模块路径解析是通过 require.resolve 方法来实现的</p>\n</li>\n<li>\n<p>require,resolve 就是通过 Module.reso1 veFileName 方法实现的</p>\n</li>\n<li>\n<p>require,resolve 实现原理：<strong>Module,resolveFileName 方法核心流程有 3 点：</strong></p>\n<ol>\n<li>\n<p>判断是否为内置模块</p>\n</li>\n<li>\n<p>通过 Module,resolveLookupPaths 方法生成 node_modules 可能存在的路径</p>\n</li>\n<li>\n<p>通过 Module,findPath 查询模块的真实路径</p>\n</li>\n</ol>\n<p><strong>Module,findPath 核心流程有 4 点：</strong></p>\n<ol>\n<li>\n<p>查询缓存（将 request 和 paths 通过 \\xoo 合并成 cacheKey)</p>\n</li>\n<li>\n<p>遍历 paths, 将 path 与 request 组成文件路径 basePath</p>\n</li>\n<li>\n<p>如果 basePath 存在则调用 fs,realPathSync 获取文件真实路径</p>\n</li>\n<li>\n<p>将文件真实路径缓存到 Module.pathCache (key 就是前面生成的 cacheKey)</p>\n</li>\n</ol>\n<p><strong>fs.realPathSync 核心流程有 3 点：</strong></p>\n</li>\n</ul>\n<ol>\n<li>\n<p>查询缓存（缓存的 key 为 p, 即 Module.findPath 中生成的文件路径）】</p>\n</li>\n<li>\n<p>从左往右遍历路径字符串，查询到 / 时，拆分路径，判断该路径是否为软链接，如果是软链接则查询真实链接，并生成新路径 P, 然后继续往后遍历，这里有 1 个细节需要特别注意：</p>\n<p>遍历过程中生成的子路径 base 会缓存在 knownHard 和 cache 中，避免重复查询</p>\n</li>\n<li>\n<p>遍历完成得到模块对应的真实路径，此时会将原始路径 original 作为 key, 真实路径作为 value, 保存到缓存中</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>require.resolve,paths 等价于 Module.resolveLookupPaths，, 该方法用于获取所有 node_modules 可能存在的路径</p>\n</li>\n<li>\n<p>require.resolve,paths 实现原理：<br />\n如果路径为 /（根目录），直接返回【'/node modules'】否则，将路径字符串从后往前遍历，查询到 / 时，拆分路径，在后面加上 node_modules, 并传入一个 paths 数组，直至查询不到 / 后返回 paths 数组</p>\n</li>\n</ul>\n<h1 id=\"yargs\"><a class=\"anchor\" href=\"#yargs\">#</a> yargs</h1>\n<p><strong>yargs 使用简要介绍：</strong></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token hashbang comment\">#! /usr/bin/env node</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 获得 yargs 构造实例</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> yargs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'yargs/yargs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 参数解析函数</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> hideBin <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'yargs/helpers'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">const</span> arg <span class=\"token operator\">=</span> <span class=\"token function\">hideBin</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">const</span> cli <span class=\"token operator\">=</span> <span class=\"token function\">yargs</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 配置命令：</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>cli</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">usage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Usage: $0 [command] &lt;options>'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 使用说明，$0 表示命令</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">demandCommand</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'A command is required,pass --help to see info'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 最少一个次命令</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">strict</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 对于未知的命令行参数进行提示输出。</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">recommendCommands</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 查找提示近似命令</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">alias</span><span class=\"token punctuation\">(</span><span class=\"token string\">'h'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'help'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//options 别名</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">alias</span><span class=\"token punctuation\">(</span><span class=\"token string\">'v'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'version'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span>cli<span class=\"token punctuation\">.</span><span class=\"token function\">terminalWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 命令行输出宽度</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">epilog</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">welcomn use cli-core</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 结语</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">options</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 注册多个 options 选项</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token literal-property property\">debug</span><span class=\"token operator\">:</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>      <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span><span class=\"token string\">\"boolean\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>      <span class=\"token literal-property property\">describe</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bootstrap debug mode\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>      <span class=\"token literal-property property\">alias</span><span class=\"token operator\">:</span> <span class=\"token string\">\"d\"</span> <span class=\"token comment\">// 添加别名</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'registry'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 添加单个选项</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token literal-property property\">hidden</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不对外暴露命令</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span><span class=\"token string\">\"string\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token literal-property property\">describe</span><span class=\"token operator\">:</span><span class=\"token string\">\"define global registry\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token literal-property property\">alias</span><span class=\"token operator\">:</span><span class=\"token string\">'r'</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'debug'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Dev Options'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 对 Options 选项进行分类</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'registry'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Extra Options\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'init [name]'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'init a project'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">yargs</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 注册次命令，制定对应 options</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    yargs</pre></td></tr><tr><td data-num=\"36\"></td><td><pre>      <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token literal-property property\">describe</span><span class=\"token operator\">:</span> <span class=\"token string\">'Name of a project'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token literal-property property\">alias</span><span class=\"token operator\">:</span> <span class=\"token string\">'n'</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">argv</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span>    <span class=\"token comment\">// 第二种注册命令的方法（更加精细）</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token literal-property property\">command</span><span class=\"token operator\">:</span> <span class=\"token string\">'list'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token literal-property property\">aliases</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'ls'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'la'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'ll'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token literal-property property\">describe</span><span class=\"token operator\">:</span> <span class=\"token string\">'List local packages'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token function-variable function\">builder</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">yargs</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>      <span class=\"token comment\">//.... 操作</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">argv</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>  <span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 使用参数</span></pre></td></tr></table></figure><h1 id=\"commander\"><a class=\"anchor\" href=\"#commander\">#</a> commander</h1>\n<p><strong>commander 简单单例模式</strong></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token hashbang comment\">#! /usr/bin/env node</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> commander <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'commander'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> pkg <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../package.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> program <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> commander<span class=\"token punctuation\">;</span> <span class=\"token comment\">//commander 单例，包含已注册好的基础命令</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>program</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">version</span><span class=\"token punctuation\">(</span>pkg<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><strong>commander 强大功能</strong></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token hashbang comment\">#! /usr/bin/env node</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> commander <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'commander'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> pkg <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../package.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> program <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">commander<span class=\"token punctuation\">.</span>Command</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 手动实例化一个 commander 实例</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>program</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>pkg<span class=\"token punctuation\">.</span>bin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">usage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;command> [options]'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 使用说明</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">version</span><span class=\"token punctuation\">(</span>pkg<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 版本</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-d,--debug'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'是否开启调试模式'</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 配置 option 选项：选项，帮助信息，默认值</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-e,--envName &lt;envName>'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'获取变量名称'</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//option 获得传参</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 解析参数</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// 使用 command 注册命令</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">const</span> clone <span class=\"token operator\">=</span> program<span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'clone &lt;source> [destination]'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//&lt; 必选项 >，[可选项]</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>clone</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">description</span><span class=\"token punctuation\">(</span><span class=\"token string\">'clone a repository'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-f,--force'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'是否强制克隆'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">source<span class=\"token punctuation\">,</span>destination<span class=\"token punctuation\">,</span>cmdObj</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'do clone'</span><span class=\"token punctuation\">,</span>source<span class=\"token punctuation\">,</span>destination<span class=\"token punctuation\">,</span>cmdObj<span class=\"token punctuation\">.</span>force<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 使用 addCommand 注册子命令</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">const</span> service <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">commander<span class=\"token punctuation\">.</span>Command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'service'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>service</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'start [port]'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">description</span><span class=\"token punctuation\">(</span><span class=\"token string\">'start service at port'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">port</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'do service start'</span><span class=\"token punctuation\">,</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>service</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stop'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">description</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stop service'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stop service'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">addCommand</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\">// 参数解释和自动匹配功能</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>program</pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">arguments</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;cmd> [options]'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 强制传入命令</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">description</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test command'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 描述</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token literal-property property\">cmd</span><span class=\"token operator\">:</span> <span class=\"token string\">'命令'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token string\">'参数'</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cmd<span class=\"token punctuation\">,</span>options</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 匹配全部命令</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>cmd<span class=\"token punctuation\">,</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token comment\">// 默认命令与命令转向功能</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>program</pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'install [name]'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'install package'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            <span class=\"token literal-property property\">executableFile</span><span class=\"token operator\">:</span> <span class=\"token string\">'imooc-cli'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 将 install [name] 命令转向 imooc-cli</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>            <span class=\"token literal-property property\">isDefault</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// 设置为默认命令</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>            <span class=\"token literal-property property\">hidden</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// 命令不可见</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token punctuation\">.</span><span class=\"token function\">alias</span><span class=\"token punctuation\">(</span><span class=\"token string\">'i'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre></pre></td></tr><tr><td data-num=\"56\"></td><td><pre><span class=\"token comment\">// 高级定制 1：自定义 help 信息</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">helpInformation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'--help'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'my help information'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token comment\">// 高级定制 2：监听 debug</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'option:debug'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>debug<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>        process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">LOG_LEVEL</span> <span class=\"token operator\">=</span> <span class=\"token string\">'verbose'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">LOG_LEVEL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre></pre></td></tr><tr><td data-num=\"72\"></td><td><pre><span class=\"token comment\">// 高级定制 3：监听未知命令（与默认命令冲突）</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'command:*'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'未知命令:'</span><span class=\"token operator\">+</span> obj<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>    <span class=\"token keyword\">const</span> avaliableCommands <span class=\"token operator\">=</span> program<span class=\"token punctuation\">.</span>commands<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cmd</span><span class=\"token operator\">=></span>cmd<span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'可用命令：'</span><span class=\"token operator\">+</span>avaliableCommands<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre></pre></td></tr><tr><td data-num=\"79\"></td><td><pre><span class=\"token comment\">// 最后要进行参数解析！</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre></pre></td></tr><tr><td data-num=\"82\"></td><td><pre><span class=\"token comment\">// 内置属性和方法</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>debug<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>envName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">outputHelp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 内置方法，弹出帮助信息</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span><span class=\"token function\">opts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 内置方法，返回 options 信息</span></pre></td></tr></table></figure><h1 id=\"require加载机制\"><a class=\"anchor\" href=\"#require加载机制\">#</a> require 加载机制</h1>\n<p><strong>require 直接加载.js、.json 和.node 文件，其余文件按照 js 语法进行加载</strong></p>\n<ol>\n<li>加载 js 文件，require 加载的 js 文件需要进行导出</li>\n<li>加载 json 文件，通过 JSON.parse 进行文件解析</li>\n<li>加载 node 文件，通过 process.dlopen 方法加载（node 文件是 C++ 语法）</li>\n<li>其余文件，使用 js 语法加载，此时语法错误的会报错。</li>\n</ol>\n<h1 id=\"node多进程\"><a class=\"anchor\" href=\"#node多进程\">#</a> node 多进程</h1>\n<h3 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h3>\n<p><strong>进程是资源分配的最小单位，线程是 CPU 调度的最小单位</strong></p>\n<p>什么是进程</p>\n<p>进程 (Process) 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单</p>\n<p>位，是操作系统结构的基础。</p>\n<p>进程的概念主要有两点：</p>\n<ul>\n<li>第一，进程是一个实体。每一个进程都有它自己的地址空间。</li>\n<li>第二，进程是一个 “执行中的程序”，存在嵌套关系。</li>\n</ul>\n<p>node 多进程官方文档：</p>\n<p>中文版：<span class=\"exturl\" data-url=\"aHR0cDovL25vZGVpcy5jbi9hcGkvY2hpbGRfcHJvY2VzcyxodG1s\">http://nodeis.cn/api/child_process,html</span></p>\n<p><strong>操作系统会使用时会开辟一个 node 进程，每个 node 文件在运行时都会创建一个 child_process 进行，也就是 node.js 的子进程。</strong></p>\n<h3 id=\"child_precess用法\"><a class=\"anchor\" href=\"#child_precess用法\">#</a> child_precess 用法</h3>\n<p><strong>一、执行可执行文件。</strong></p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> cp <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'child_process'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 默认内置库</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">//exec 方法，可以传执行命令，也可以传文件路径，但不支持给文件传参。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>cp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ls -al|grep node_modules'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">//execFile 方法，传文件路径，并且支持给文件传参数。</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>cp<span class=\"token punctuation\">.</span><span class=\"token function\">execFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ls'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'-al'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">//spawn 方法，传入文件路径，以流式的方式输出，是 exec 和 execFile 的底层原理</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> cp<span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'npm'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>install<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token literal-property property\">cwd</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/User/dmq/Desktop/test'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>child<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stdout'</span><span class=\"token punctuation\">,</span>chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>child<span class=\"token punctuation\">.</span>stderr<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stderr'</span><span class=\"token punctuation\">,</span>chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><strong>exec 和 spawn 使用场景：</strong></p>\n<p>当文件操作过程复杂，并且需要频繁输出日志时，使用 spawn 进行流式操作。</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> cp<span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'npm'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>install<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token literal-property property\">cwd</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/User/dmq/Desktop/test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token literal-property property\">stdio</span><span class=\"token operator\">:</span> <span class=\"token string\">'inherit'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 将输出传给父进程。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 监听错误事件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>child<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span><span class=\"token parameter\">e</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 监听退出事件</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>child<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'exit'</span><span class=\"token punctuation\">,</span><span class=\"token parameter\">e</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'命令执行成功'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>child<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stdout'</span><span class=\"token punctuation\">,</span>chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>child<span class=\"token punctuation\">.</span>stderr<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stderr'</span><span class=\"token punctuation\">,</span>chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>当文件操作过程简单，需要直接输出时，使用 exec 方法</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'npm install'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token literal-property property\">cwd</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/User/dmq/Desktop/test'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>stdout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>stderr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><strong>二、执行指定 JS 文件（不支持回调）</strong></p>\n<p>fork 方法类似于 require 函数，但是区别在于 fork 方法会创建一个 node 子进程执行 JS 文件，使用独立的 v8 引擎去解析代码。</p>\n<p>index.js 文件：</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> cp<span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span><span class=\"token string\">'child.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>child<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello child process!'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    child<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 及时断开连接，防止主进程和子进程长期处于等待状态</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>child<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'main pid:'</span><span class=\"token punctuation\">,</span>process<span class=\"token punctuation\">.</span>pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>child.js 文件：</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'child process pid:'</span><span class=\"token punctuation\">,</span>process<span class=\"token punctuation\">.</span>pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>process<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>process<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello main process'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"child_process源码\"><a class=\"anchor\" href=\"#child_process源码\">#</a> child_process 源码</h3>\n<p>疑问：</p>\n<ul>\n<li>exec、execFile、spanwn 和 fork 区别：\n<ul>\n<li>exec: 原理是调用 /bin/sh-c 执行我们传入的 shell 脚本，底层调用了 execFile</li>\n<li>execFile: 原理是直接执行我们传入的 file 和 args, 底层调用 spawn 创建和执行子进程，并建立了回调，一次性将所有的 stdout 和 stderr 结果返回</li>\n<li>spawn: 原理是调用了 internal/child_.process, 实例化了 ChildProcess 子进程对象，再调用 child.spawn 创建子进程并执行命令，底层是调用了 child._handle.spawn 执行 process_wrap 中的 spwn 方法，执行过程是异步的，执行完毕后通过 PIPE 进行单向数据通信，通信结束后会子进程发起 onexit 回调，同时 Socket 会执行 close 回调</li>\n<li>fork: 原理是通过 spawn 创建子进程和执行命令，通过 setupchannel 创建 IPC 用于子进程和父进程之</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"eggjsmongodb\"><a class=\"anchor\" href=\"#eggjsmongodb\">#</a> egg.js+mongodb</h1>\n<p><strong>1、egg.js</strong></p>\n<p>用于快速生成后端 api 的框架。</p>\n<p><strong>2、npm init egg 命令</strong></p>\n<p>当执行 <code>npm init egg</code>  命令时，npm 会自动找到 create-egg 这个包（其他包同理，找到 create - 包名），进行执行。<strong>当不想将脚手架安装到本地，而是在线上直接使用时，这个机制就显得十分重要。</strong></p>\n<p><strong>3、mongodb 数据库</strong></p>\n<p>非关系型数据库。</p>\n<ul>\n<li>\n<p><strong>云 mongodb</strong></p>\n<ul>\n<li>\n<p>云 mongodb 开通</p>\n</li>\n<li>\n<p>地址：https:/mongodb.console.aliyun.comL, 创建实例并付款即可</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>本地 mongodb</strong></p>\n<ul>\n<li>\n<p>地址：https:/www.runoob.com/mongodb/mongodb-tutorial.html</p>\n</li>\n<li>\n<p>mongodb 使用方法</p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9tb25nb2RiL21vbmdvZGItZGF0YWJhc2VzLWRvY3VtZW50cy1jb2xsZWN0aW9ucy5odG1s\">https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html</span></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>4、egg.js 链接 mongodb 数据库</p>\n<p>utils/mongo.js</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> logger <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'npmlog'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>logger<span class=\"token punctuation\">.</span>level <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">LOG_LEVEL</span> <span class=\"token operator\">?</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">LOG_LEVEL</span> <span class=\"token operator\">:</span> <span class=\"token string\">'info'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>logger<span class=\"token punctuation\">.</span>heading <span class=\"token operator\">=</span> <span class=\"token string\">'pick'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 自定义头部</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>logger<span class=\"token punctuation\">.</span><span class=\"token function\">addLevel</span><span class=\"token punctuation\">(</span><span class=\"token string\">'success'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token literal-property property\">fg</span><span class=\"token operator\">:</span> <span class=\"token string\">'green'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">bold</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 自定义 success 日志</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>logger<span class=\"token punctuation\">.</span><span class=\"token function\">addLevel</span><span class=\"token punctuation\">(</span><span class=\"token string\">'notice'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token literal-property property\">fg</span><span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">bg</span><span class=\"token operator\">:</span> <span class=\"token string\">'black'</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 自定义 notice 日志</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">const</span> MongoClient <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mongodb'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>MongoClient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Mongo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">url<span class=\"token punctuation\">,</span> dbName</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>url <span class=\"token operator\">=</span> url<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dbName <span class=\"token operator\">=</span> dbName<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>      MongoClient<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>          <span class=\"token literal-property property\">useNewUrlParser</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>          <span class=\"token literal-property property\">useUnifiedTopology</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> client</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">const</span> db <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">db</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dbName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span> db<span class=\"token punctuation\">,</span> client <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>  <span class=\"token function\">connectAction</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">docName<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> db<span class=\"token punctuation\">,</span> client <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>      <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token keyword\">const</span> collection <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span><span class=\"token function\">collection</span><span class=\"token punctuation\">(</span>docName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token function\">action</span><span class=\"token punctuation\">(</span>collection<span class=\"token punctuation\">,</span> <span class=\"token parameter\">result</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>          logger<span class=\"token punctuation\">.</span><span class=\"token function\">verbose</span><span class=\"token punctuation\">(</span><span class=\"token string\">'result'</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">err</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>          logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>          <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>  <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">docName</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">connectAction</span><span class=\"token punctuation\">(</span>docName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">collection<span class=\"token punctuation\">,</span> onSuccess<span class=\"token punctuation\">,</span> onError</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>      collection<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token literal-property property\">projection</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token literal-property property\">_id</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> docs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>          <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>          <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>docs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>  <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">docName<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">connectAction</span><span class=\"token punctuation\">(</span>docName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">collection<span class=\"token punctuation\">,</span> onSuccess<span class=\"token punctuation\">,</span> onError</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>      collection<span class=\"token punctuation\">.</span><span class=\"token function\">insertMany</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>          <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>          <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>  <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">docName<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">connectAction</span><span class=\"token punctuation\">(</span>docName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">collection<span class=\"token punctuation\">,</span> onSuccess<span class=\"token punctuation\">,</span> onError</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>      collection<span class=\"token punctuation\">.</span><span class=\"token function\">deleteOne</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>          <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>          <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>  <span class=\"token comment\">//   update(collection, data) &#123;</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>  <span class=\"token comment\">//   &#125;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>  <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">client</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>    client <span class=\"token operator\">&amp;&amp;</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> Mongo<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>db.js</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> mongo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Mongodb</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mongodb://dmq:dmq0216@127.0.0.1:27017/dbName'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'dbName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token function\">mongo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'project'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h1 id=\"inquirer源码\"><a class=\"anchor\" href=\"#inquirer源码\">#</a> inquirer 源码</h1>\n<h2 id=\"学习路径\"><a class=\"anchor\" href=\"#学习路径\">#</a> 学习路径</h2>\n<ul>\n<li>掌握一些库：readline（命令行读取）/events（事件驱动）/stream（输入输出流）/ansi-escapes（命令行文字样式）/rxjs（处理异步事件）</li>\n<li>掌握命令行交互的实现原理，并实现一个可交互的列表</li>\n<li>分析 inquirer 源码掌握其中的关键实现</li>\n</ul>\n<h1 id=\"ejsglob\"><a class=\"anchor\" href=\"#ejsglob\">#</a> ejs+glob</h1>\n<p>ejs 三方库用于 xml 动态模板渲染，glob 三方库用于根据 <code>文件路径进行遍历和匹配文件</code> ，拿到文件的内容。</p>\n<h1 id=\"ejs源码\"><a class=\"anchor\" href=\"#ejs源码\">#</a> ejs 源码</h1>\n<p>省略，详见官网</p>\n<h1 id=\"require源码\"><a class=\"anchor\" href=\"#require源码\">#</a> require 源码</h1>\n<p>省略，详见官网</p>\n<h1 id=\"代码复用实践\"><a class=\"anchor\" href=\"#代码复用实践\">#</a> 代码复用实践</h1>\n<p>** 代码复用目的：** 提高人效，降低开发成本。</p>\n<p><strong>计算公式</strong>为：<strong>节约工时 = 服用代码节约时间  *  代码复用系数  *  复用次数</strong></p>\n<p><strong>背后思考：</strong></p>\n<ul>\n<li>不同开发者、团队之间会产生了大量重复、通用的代码</li>\n<li>这些代码散落在各自团队的项目代码里</li>\n<li>复用的时候大家习惯于直接拷贝这些代码到项目中，因为这样做对个人成本最低（开发者往往更熟悉自己写的代码)，但是这种做法不利于团队之间代码共享，因为每个人开发不同的业务，对不同页面的熟悉程度不一样，而代码复用的宗旨就是要尽可能将团队中的开发着的整体水平拉齐</li>\n<li>所以需要通过工具化的方式降低代码复用的成本</li>\n</ul>\n","categories":["脚手架开发"],"tags":["脚手架开发"]},{"title":"图片上传解决方案","url":"/2023/06/02/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"<p>图片上传：<br>input标签中file（accetp接受类型） 、</p>\n<p>fileList（change事件的e.target.files[0]） 、</p>\n<p>Blob（二进制格式数据）、</p>\n<p>FileReader（将文本文件file转为字符串或者URL）、</p>\n<p>URL scheme 、</p>\n<p>拖拽事件：dragenter、dragover、drop</p>\n","categories":["算法"],"tags":["图片上传","解决方案"]},{"title":"算法与数据结构","url":"/2023/12/02/%E7%AE%97%E6%B3%95/","content":"<h1 id=\"数据结构视频：\"><a href=\"#数据结构视频：\" class=\"headerlink\" title=\"数据结构视频：\"></a>数据结构视频：</h1><h1 id=\"栈：后进先出\"><a href=\"#栈：后进先出\" class=\"headerlink\" title=\"栈：后进先出\"></a>栈：后进先出</h1><p>（JS中可以使用array模拟栈）</p>\n<p>【1】十进制转二进制【2】编辑器检查括号是否有效【3】JS函数调用堆栈（相互调用的函数，最后一个函数先执行完） 、等等</p>\n<p>【练习：20有效的括号】（栈）</p>\n<pre><code class=\"typescript\">function isValid(s: string): boolean &#123;\n    if(s.length % 2 === 1) return false\n    const arr:Array&lt;string&gt;=[]\n    for(let i =0 ;i&lt;s.length;i++)&#123;\n        if(s[i]===&#39;(&#39; || s[i]===&#39;&#123;&#39; || s[i]===&#39;[&#39;)&#123; \n            arr.push(s[i])\n        &#125;else&#123; \n           if((arr[arr.length-1]===&#39;(&#39; &amp;&amp; s[i]===&#39;)&#39;) || (arr[arr.length-1]===&#39;[&#39; &amp;&amp; s[i]===&#39;]&#39;) || (arr[arr.length-1]===&#39;&#123;&#39; &amp;&amp; s[i]===&#39;&#125;&#39;)) &#123;\n            arr.pop()\n           &#125;else&#123;\n            return false\n           &#125;\n        &#125;\n    &#125;\n    return arr.length===0\n&#125;;\n</code></pre>\n<h1 id=\"队列：先进先出\"><a href=\"#队列：先进先出\" class=\"headerlink\" title=\"队列：先进先出\"></a>队列：先进先出</h1><p>（JS中可以使用array模拟队列）</p>\n<p>【1】排队打饭【2】JS异步中的任务队列（JS是单线程的）【3】计算最近请求次数</p>\n<p>【练习：请求最近的请求次数】（队列）</p>\n<pre><code class=\"typescript\">class RecentCounter &#123;\n    stack:number[]=[]\n    ping(t: number): number &#123;\n        this.stack.push(t)\n        while(t - this.stack[0] &gt; 3000)&#123;\n            this.stack.shift()\n        &#125;\n        return this.stack.length\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"链表：非连续存储\"><a href=\"#链表：非连续存储\" class=\"headerlink\" title=\"链表：非连续存储\"></a>链表：非连续存储</h1><p>【1】JS中的原型链（<strong>构造函数实例的__ proto __等于构造函数的prototype</strong> , 是一个链表）</p>\n<p>一、<strong>实例的原型(_ _ proto _ _)就是其构造函数的原型对象(prototype)</strong></p>\n<p>二、<strong>如果A沿着原型链能找到B的prototype,那么A instanceof B 为true</strong></p>\n<p>三、<strong>如果在A对象上没有找到x属性，那么会沿着原型链找x属性</strong></p>\n<p>【面试题】</p>\n<p>一、instanceof的原理，并使用代码实现</p>\n<pre><code class=\"js\">const instanceof1 = (A,B) =&gt; &#123;\n    let p = A\n    while(p)&#123;\n        if(p === B.prototype)&#123;\n            return true\n        &#125;\n        p=p.__proto__\n    &#125;\n    return false\n&#125;\n</code></pre>\n<p>二、代码演示对象属性会沿着原型链进行查找</p>\n<pre><code class=\"js\">let foo = &#123;&#125;,F = function()&#123;&#125;;\nObject.prototype.a = &#39;value a&#39;;\nFunction.prototype.b = &#39;value b&#39;;\nconsole.log(foo); //&#123;&#125;\nconsole.log(foo.a); //value a\nconsole.log(foo.b); //undefined\nconsole.log(F.a); //value a\nconsole.log(F.b); //value b\n</code></pre>\n<p>【原型链图解】</p>\n<pre><code class=\"js\">obj.__proto__------Object.prototype-------null\nfunc.__proto__--------Function.prototype-------Object.prototype----------null\n（其中：func.__proto__.__proto__ === Object.prototype   ； func也是Object的实例（instanceof））\narr.__proto__ -------------Array.prototype---------Object.prototype---------null\n</code></pre>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A8.png\" alt=\"/images/image-20240123164938769\"> </p>\n<p>【练习】（JS中可以使用对象object模拟链表 ，值得注意的是：<strong>链表由于只给一个头节点，所以不知道链表的长度（一般使用while循环遍历）</strong>）</p>\n<p>【练习：237删除链表中的节点】</p>\n<pre><code class=\"typescript\"> function deleteNode(node: ListNode | null): void &#123;\n    //将下一个节点的值赋值给当前节点值（相当于移动）\n    node.val=node.next.val;\n    //跳过下一个节点（跳过的是下一个节点，效果是删除了当前节点）\n    node.next=node.next.next;\n &#125;;\n</code></pre>\n<p>【练习：206反转链表】（双指针）</p>\n<pre><code class=\"typescript\">//双指针法\nfunction reverseList(head: ListNode | null): ListNode | null       &#123;\n        let p1:ListNode | null=head\n        let p2:ListNode | null=null\n        let tmp;\n        while(p1)&#123;\n         tmp = p1.next\n         p1.next=p2\n         p2 = p1\n         p1 = tmp\n        &#125;\n        return p2\n      &#125;;\n</code></pre>\n<pre><code class=\"typescript\">//标志变量法\n    let pre\n     var reverseList= function(head)&#123;\n        // 遍历节点,进行迭代\n        if(head===null) &#123;\n            const a=pre\n            pre =undefined\n            return a || head\n        &#125;\n        const tem = head.next\n        head.next = pre || null\n        pre = head\n        return reverseList(tem)\n     &#125;\n</code></pre>\n<p>【练习：2两数相加】</p>\n<pre><code class=\"js\">var addTwoNumbers = function(l1, l2) &#123;\n    let l3 = new ListNode(0)\n    let p3 = l3;\n    let carry = 0;\n    while(l1 || l2)&#123;\n    const v1 = l1?l1.val:0;\n    const v2 = l2?l2.val:0;\n    const sum = v1 + v2 + carry;\n    carry = Math.floor(sum / 10)  \n    p3.next = new ListNode(sum % 10)\n    if(l1) l1=l1.next;\n    if(l2) l2=l2.next;\n        p3 = p3.next;\n    &#125;\n    if(carry)&#123;\n        p3.next=new ListNode(carry)\n    &#125;\n    return l3.next;\n&#125;;\n</code></pre>\n<p>【练习：83删除排序链表中的重复元素】</p>\n<pre><code class=\"js\">var deleteDuplicates = function(head) &#123;\n    let firstNode = head;\n    while(head &amp;&amp; head.next)&#123;\n        if(head.val == head.next.val)&#123;\n            head.next = head.next.next\n        &#125;else&#123;\n            head = head.next\n        &#125;\n    &#125;\n    return firstNode\n&#125;;\n</code></pre>\n<p>【练习：141环形链表】（快慢指针）</p>\n<p>注意链表由于只给一个头节点，所以不知道链表的长度，此时不能直接拿到最后一个节点，一直在遍历过程中时无法确定是由于链表太长尚未遍历完还是由于是环形链表。</p>\n<pre><code class=\"js\">//快慢指针\nvar hasCycle = function(head) &#123;\n    let p1 = head\n    let p2 = head \n    while(p1 &amp;&amp; p2 &amp;&amp; p2.next)&#123;\n        p1=p1.next\n        p2 = p2.next.next\n        if(p1===p2)&#123;\n            return true\n        &#125;\n    &#125;\n    return false\n&#125;;\n</code></pre>\n<h1 id=\"集合：无序且唯一\"><a href=\"#集合：无序且唯一\" class=\"headerlink\" title=\"集合：无序且唯一\"></a>集合：无序且唯一</h1><p>JS中有set集合，内部有has、add、delete、clear、entries、forEach、kyes、values、intersection（求交集）、difference（求非交集）、union（联合）等方法，可以用于数组去重等。</p>\n<p>【练习：349两个数组的交集】</p>\n<pre><code class=\"js\">var intersection = function(nums1, nums2) &#123;\n    return [...new Set(nums1)].filter(item=&gt;nums2.includes(item))\n&#125;;\n</code></pre>\n<p>【前端中的set集合】</p>\n<p>set集合使用for of遍历（因为set集合中不包含属性），  使用Array.from方法可以将set集合转为array数组，使用new Set([])可以将数组转为set集合。</p>\n<h1 id=\"字典：键值对映射（键不重复）\"><a href=\"#字典：键值对映射（键不重复）\" class=\"headerlink\" title=\"字典：键值对映射（键不重复）\"></a>字典：键值对映射（键不重复）</h1><p>JS中有map集合，内部有set、delete和clear等方法。</p>\n<p>【优化：349两个数组的交集】</p>\n<p>此方法利用了map集合的特点（键不重复，还有数据量很小的情况下：map.get方法的性能相比于arr.includes方法的性能更好）,此方法性能更好，时间复杂度为O(n)或O(m)</p>\n<pre><code class=\"js\">var intersection = function(nums1, nums2) &#123;\n    const res = []\n    const map = new Map()\n    nums1.forEach(item=&gt;&#123;\n        map.set(item,true);\n    &#125;)\n    nums2.forEach(item=&gt;&#123;\n        if(map.get(item))&#123;\n            res.push(item);\n            map.delete(item);\n        &#125;\n    &#125;)\n    return res\n&#125;;\n</code></pre>\n<p>【优化：20有效的括号】</p>\n<pre><code class=\"js\">var isValid = function(s) &#123;\n    if(s.length % 2 ===1) return false\n    const map=new Map()\n    map.set(&#39;(&#39;,&#39;)&#39;)\n    map.set(&#39;&#123;&#39;,&#39;&#125;&#39;)\n    map.set(&#39;[&#39;,&#39;]&#39;)\n    const stack=[];\n    for(let i=0;i&lt;s.length;i++)&#123;\n        const c = s[i];\n       if(map.has(c))&#123;\n           stack.push(c)\n       &#125; else&#123;\n           const t = stack[stack.length-1];\n           if(map.get(t)===c)&#123;\n               stack.pop();\n           &#125;else&#123;\n               return false;\n           &#125;\n       &#125;\n    &#125;\n    return !stack.length\n&#125;;\n</code></pre>\n<p>【练习：1两数之和】</p>\n<pre><code class=\"js\">var twoSum =function (nums,target)&#123;\n    const map =new Map();\n    for (let i =0;i&lt;nums.length;i+=1)&#123;\n        const n= nums[i];\n        const n2 =target -n;\n    if (map.has(n2))&#123;\n        return [map.get(n2),i];\n    &#125;\n    else&#123;\n        map.set(n,i);\n    &#125;\n&#125;\n&#125;\n</code></pre>\n<p>【练习：3无重复字符的最长子串】</p>\n<pre><code class=\"js\">var lengthOfLongestSubstring = function(s) &#123;\n    let l = 0;\n    let num = 0;\n    let map =new Map()\n    for(let r=0;r&lt;s.length;r++)&#123;\n        if(map.has(s[r]) &amp;&amp; map.get(s[r])&gt;=l)&#123;\n            l=map.get(s[r]) + 1;\n        &#125;\n        map.set(s[r],r)\n        num=Math.max(num,r-l+1);\n    &#125;\n    return num\n&#125;;\n</code></pre>\n<p>【练习：76最小覆盖子串】</p>\n<pre><code class=\"js\">var minWindow = function(s, t) &#123;\n    let l=0,r=0,need=new Map();\n    for(let item of t)&#123;\n        need.set(item,need.has(item)?need.get(item)+1:1);\n    &#125;\n    let needType = need.size;//定义需要类型\n    let res = &#39;&#39;;//定义结果字符串\n    while(r&lt;s.length)&#123;\n        const c = s[r] //定义又字符\n        if(need.has(c))&#123;\n            need.set(c,need.get(c) - 1);\n            if(need.get(c)===0) needType -= 1; //如果说当前的数值为0，标识减一\n        &#125;\n        //遍历左边指针，如果needType为0,说明当前包含全部字符，遍历取最小长度\n        while(needType===0)&#123;\n            const newRes = s.substring(l,r+1)\n            if(!res || newRes.length&lt;res.length) res = newRes\n            const c2 = s[l]\n            if(need.has(c2))&#123;\n                need.set(c2,need.get(c2)+1);\n                if(need.get(c2)===1) needType+=1;\n            &#125;\n            l+=1;\n        &#125;\n        r+=1;\n    &#125;\n    return res\n&#125;\n</code></pre>\n<h1 id=\"哈希表-散列的数组\"><a href=\"#哈希表-散列的数组\" class=\"headerlink\" title=\"哈希表:散列的数组\"></a>哈希表:散列的数组</h1><p>哈希表通常基于数组实现，对下标值进行变换（哈希函数），基本可以瞬间查找到想要的元素，但是哈希表中的数据是没有顺序的，所以不能以一种固定的方式来遍历元素。</p>\n<p>【例子：员工信息，用数组存储增删数据较慢，用链表存储查找较慢。】</p>\n<p>1、哈希化：将大数字转化为数组范围内的下标的过程。</p>\n<p>2、哈希函数：通常会将单词转化为大数字，将大数字进行哈希化的函数就是哈希函数，哈希算法得到的也可能会有相同的值（冲突），对此有很多解决方案。</p>\n<p>3、哈希表：对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。</p>\n<pre><code class=\"js\">    //封装哈希表类\n    function HashTable() &#123;\n      //属性\n      this.storage = []\n      this.count = 0//计算已经存储的元素个数\n      //装填因子：loadFactor &gt; 0.75时需要扩容；loadFactor &lt; 0.25时需要减少容量\n      this.limit = 7//初始长度\n\n      //方法\n      //哈希函数\n      HashTable.prototype.hashFunc = function(str, size)&#123;\n      //1.定义hashCode变量\n      let hashCode = 0\n\n      //2.霍纳法则，计算hashCode的值\n      //cats -&gt; Unicode编码\n      for(let i = 0 ;i &lt; str.length; i++)&#123;\n        // str.charCodeAt(i)//获取某个字符对应的unicode编码\n        hashCode = 37 * hashCode + str.charCodeAt(i)\n      &#125;\n\n      //3.取余操作\n      let index = hashCode % size\n      return index\n    &#125;\n\n    //一.插入&amp;修改操作\n    HashTable.prototype.put = function (key, value)&#123;\n      //1.根据key获取对应的index\n      let index = this.hashFunc(key, this.limit)\n\n      //2.根据index取出对应的bucket\n      let bucket = this.storage[index]\n\n      //3.判断该bucket是否为null\n      if (bucket == null) &#123;\n        bucket = []\n        this.storage[index] = bucket\n      &#125;\n\n      //4.判断是否是修改数据\n      for (let i = 0; i &lt; bucket.length; i++) &#123;\n        let tuple = bucket[i];\n        if (tuple[0] == key) &#123;\n          tuple[1] = value\n          return//不用返回值\n        &#125;\n      &#125;\n\n      //5.进行添加操作\n      bucket.push([key, value])\n      this.count += 1\n\n      //6.判断是否需要扩容操作\n      if(this.count &gt; this.limit * 0.75)&#123;\n        let newSize = this.limit * 2\n        let newPrime = this.getPrime(newSize)\n        this.resize(newPrime)\n      &#125;\n    &#125;\n\n    //二.获取操作\n    HashTable.prototype.get = function(key)&#123;\n      //1.根据key获取对应的index\n      let index = this.hashFunc(key, this.limit)\n\n      //2.根据index获取对应的bucket\n      let bucket = this.storage[index]\n\n      //3.判断bucket是否等于null\n      if (bucket == null) &#123;\n        return null\n      &#125;\n\n      //4.有bucket，那么就进行线性查找\n      for (let i = 0; i &lt; bucket.length; i++) &#123;\n        let tuple = bucket[i];\n        if (tuple[0] == key) &#123;//tuple[0]存储key，tuple[1]存储value\n          return tuple[1]\n        &#125;\n      &#125;\n\n      //5.依然没有找到，那么返回null\n      return null\n    &#125;\n\n    //三.删除操作\n    HashTable.prototype.remove = function(key)&#123;\n      //1.根据key获取对应的index\n      let index = this.hashFunc(key, this.limit)\n\n      //2.根据index获取对应的bucket\n      let bucket = this.storage[index]\n\n      //3.判断bucket是否为null\n      if (bucket == null) &#123;\n        return null\n      &#125;\n\n      //4.有bucket,那么就进行线性查找并删除\n      for (let i = 0; i &lt; bucket.length; i++) &#123;\n        let tuple = bucket[i]\n        if (tuple[0] == key) &#123;\n          bucket.splice(i,1)\n          this.count -= 1 \n          return tuple[1]\n\n          //6.缩小容量\n          if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;\n            let newSize = Math.floor(this.limit / 2)\n            let newPrime = this.getPrime(newSize)\n            this.resize(newPrime)\n          &#125;\n        &#125;\n    &#125;\n\n      //5.依然没有找到，返回null\n      return null\n    &#125;\n\n  /*------------------其他方法--------------------*/\n  //判断哈希表是否为null\n  HashTable.prototype.isEmpty = function()&#123;\n    return this.count == 0\n  &#125;\n\n  //获取哈希表中元素的个数\n  HashTable.prototype.size = function()&#123;\n    return this.count\n  &#125;\n\n\n  //哈希表扩容\n  HashTable.prototype.resize = function(newLimit)&#123;\n    //1.保存旧的storage数组内容\n    let oldStorage = this.storage\n\n    //2.重置所有的属性\n    this.storage = []\n    this.count = 0\n    this.limit = newLimit\n\n    //3.遍历oldStorage中所有的bucket\n    for (let i = 0; i &lt; oldStorage.length; i++) &#123;\n      //3.1.取出对应的bucket\n      const bucket = oldStorage[i];\n\n      //3.2.判断bucket是否为null\n      if (bucket == null) &#123;\n        continue\n      &#125;      \n\n      //3.3.bucket中有数据，就取出数据重新插入\n      for (let j = 0; j &lt; bucket.length; j++) &#123;\n        const tuple = bucket[j];\n        this.put(tuple[0], tuple[1])//插入数据的key和value\n      &#125;\n    &#125;\n  &#125;\n\n  //判断传入的num是否质数\n  HashTable.prototype.isPrime = function(num)&#123;\n      if (num &lt;= 1) &#123;\n        return false\n      &#125;\n      //1.获取num的平方根:Math.sqrt(num)\n      //2.循环判断\n      for(var i = 2; i&lt;= Math.sqrt(num); i++ )&#123;\n        if(num % i == 0)&#123;\n          return false;\n        &#125;\n      &#125;\n        return true;\n    &#125;\n\n    //获取质数的方法\n    HashTable.prototype.getPrime = function(num)&#123;\n       //7*2=14,+1=15,+1=16,+1=17(质数)\n      while (!this.isPrime(num)) &#123;\n        num++\n      &#125;\n      return num\n    &#125;\n &#125;\n</code></pre>\n<h1 id=\"哈希算法-任意长度输入转为固定长度输出\"><a href=\"#哈希算法-任意长度输入转为固定长度输出\" class=\"headerlink\" title=\"哈希算法:任意长度输入转为固定长度输出\"></a>哈希算法:任意长度输入转为固定长度输出</h1><p>hash（散列），是将任意长度输入通过散列算法转变成固定长度的输出，该输出就是散列值。这种转换是一种<strong>压缩映射</strong>，映射表达的是一种一一对应的关系。散列值的空间通常空间会小于输出的空间。</p>\n<p>哈希算法：</p>\n<p>1、不可逆：哈希算法不能从结果去推算出输入</p>\n<p>2、计算快</p>\n<p>【例子：md5加密、webpack热更新检测文件是否变化】</p>\n<h1 id=\"树：分层抽象数据模型\"><a href=\"#树：分层抽象数据模型\" class=\"headerlink\" title=\"树：分层抽象数据模型\"></a>树：分层抽象数据模型</h1><p>【前端】DOM树、级联选择、树形控件。</p>\n<p>JS中没有树，但是可以使用Object和Array来模拟构建树。</p>\n<p>【树的常用操作】：深度&#x2F;广度优先遍历、先序（后序遍历）</p>\n<p>【树】</p>\n<pre><code class=\"js\">const tree = &#123;\n    val:&#39;a&#39;,\n    children:[\n        &#123;\n            val:&#39;b&#39;,\n            children:[\n                &#123;\n                    val:&#39;c&#39;,\n                    children:[]\n                &#125;\n            ]\n        &#125;,\n        &#123;\n            val:&#39;d&#39;,\n            children:[\n                &#123;\n                    val:&#39;e&#39;,\n                    children:[]\n                &#125;,&#123;\n                    val:&#39;f&#39;,\n                    children:[]\n                &#125;\n            ]\n        &#125;\n\n    ]\n&#125;\n</code></pre>\n<p>【1】深度优先遍历：</p>\n<p>尽可能深的搜索树的分支。（相当于一本书，一页一页翻着看）</p>\n<pre><code class=\"js\">// 深度优先遍历\nconst dfs = function(root)&#123;\n    console.log(root.val,&#39;还好&#39;);\n    root.children.forEach(dfs);//forEach回调不传参数，默认穿的参数就是item项\n&#125;\n</code></pre>\n<p>【2】广度优先遍历：</p>\n<p>先访问离根节点最近的节点。（相当于一本书，先看章节再看对应页）</p>\n<pre><code class=\"js\">//广度优先遍历\nconst bfs = (root)=&gt;&#123;\n    const q = [root];\n    while(q.length&gt;0)&#123;\n        const n = q.shift();\n        n.children.forEach(item=&gt;&#123;\n            q.push(item);\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"【二叉树】\"><a href=\"#【二叉树】\" class=\"headerlink\" title=\"【二叉树】\"></a>【二叉树】</h2><p>JS中使用Object来模拟二叉树</p>\n<p>【二叉树】</p>\n<pre><code class=\"js\">const bt = &#123;\n    val:1,\n    left:&#123;\n        val:2,\n        left:&#123;&#125;,\n        right:&#123;&#125;\n    &#125;,\n    right:&#123;\n        val:3,\n        left:&#123;\n            val:4,\n            left:&#123;&#125;,\n            right:&#123;&#125;\n        &#125;,\n        right:&#123;\n            val:5,\n            left:&#123;&#125;,\n            right:&#123;&#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>【1】递归版二叉树的先中后序遍历</p>\n<p>（1）先序遍历：（中、左、右  向下递归）</p>\n<pre><code class=\"js\">//先序遍历\nconst preOrder = (root)=&gt;&#123;\n    if(!root) return;\n    console.log(root.val);\n    preOrder(root.left);\n    preOrder(root.right);\n&#125;\n</code></pre>\n<p>（2）中序遍历：（左、中、右  向下递归）</p>\n<pre><code class=\"js\">//中序遍历\nconst centerOrder = (root)=&gt;&#123;\n    if(!root) return;\n    centerOrder(root.left);\n    console.log(root.val);\n    centerOrder(root.right);\n&#125;\n</code></pre>\n<p> （3）后序遍历：（左、右、中  向下递归）</p>\n<pre><code class=\"js\">//后序遍历\nconst postOrder = (root)=&gt;&#123;\n    if(!root) return;\n    postOrder(root.left);\n    postOrder(root.right);\n    console.log(root.val);\n&#125;\n</code></pre>\n<p>【2】函数调用栈版二叉树的先中后序遍历</p>\n<p>此方法原理和函数递归相似，其实就是模拟函数递归调用时，调用栈的执行（通过栈结构）来模拟执行的全过程。</p>\n<p>   <strong>（1）先序遍历（重要）：</strong></p>\n<pre><code class=\"js\">const preOrder = (root)=&gt;&#123;\n    const stack = [root]\n    while(stack.length)&#123;\n    const n = stack.pop()\n    console.log(n.val);\n    if(n.right) stack.push(n.right);\n    if(n.left) stack.push(n.left);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>（2）中序遍历（重要）：</strong></p>\n<pre><code class=\"js\">const centerOrder = (root)=&gt;&#123;\n    const stack = []\n    let p = root\n    while(stack.length || p)&#123;\n        while(p)&#123;\n            stack.push(p)\n            p=p.left\n        &#125;\n        //到此将全部的左节点推入栈中\n        const n = stack.pop();\n        //弹出栈，输出\n        console.log(n.val);\n        //将右子节点赋值为p，当右子节点没有左子节点时，直接输出\n        p = n.right;\n    &#125;\n&#125;;\n</code></pre>\n<p><strong>（3）后序遍历（重要）：</strong></p>\n<pre><code class=\"js\">//函数调用栈进行后序遍历（巧妙借鉴先序遍历（将输出变为存到另一个栈中））\nconst postOrder = (root)=&gt;&#123;\n    const stack = [root]\n    const outputStack = []\n    while(stack.length)&#123;\n        const n = stack.pop()\n        outputStack.push(n)\n        if(n.left) stack.push(n.left)\n        if(n.right) stack.push(n.right)\n    &#125;\n    while(outputStack.length)&#123;\n        const n = outputStack.pop()\n        console.log(n.val);\n    &#125;\n&#125;\n</code></pre>\n<p>【练习：104二叉树的最大深度】</p>\n<pre><code class=\"js\">var maxDepth = function(root) &#123;\n    let res = 0;\n    //定义深度优先遍历\n    const dfs = (root,l)=&gt;&#123;\n        if(!root) return\n        if(!root.left &amp;&amp; !root.right)&#123;\n        res = Math.max(res,l)\n        &#125;\n         dfs(root.left,l+1)\n         dfs(root.right,l+1)\n    &#125;\n    dfs(root,1)\n    return res\n&#125;;\n</code></pre>\n<p>【练习：111二叉树的最小深度】</p>\n<pre><code class=\"js\">var minDepth = function(root)&#123;\n    if(!root) return 0;\n    //使用广度优先遍历，注意使用队列，因为广度优先。\n    let queue = [[root,1]]\n    while(queue.length)&#123;\n        const [n,l] = queue.shift()\n        if(!n.left &amp;&amp; !n.right)&#123;\n            return l\n        &#125;\n       if(n.left) queue.push([n.left,l+1])\n       if(n.right) queue.push([n.right,l+1])\n    &#125;\n&#125;\n</code></pre>\n<p>【练习：102二叉树的层序遍历】</p>\n<p>方法一：</p>\n<pre><code class=\"js\">var levelOrder = function(root) &#123;\n    //使用广度优先遍历算法\n    let queue = [[root,1]]\n    if(!root) return [];\n    let res = []\n    while(queue.length)&#123;\n        const [n,l] = queue.shift()\n        if(res.length&lt;l)&#123;\n            res.push([n.val])\n        &#125;else&#123;\n            res[l-1].push(n.val)\n        &#125;\n        if(n.left) queue.push([n.left,l+1])\n        if(n.right) queue.push([n.right,l+1])\n    &#125;\n    return res\n&#125;;\n</code></pre>\n<p>方法二：（性能更好&#x3D;&#x3D;）</p>\n<pre><code class=\"js\">var levelOrder = function(root) &#123;\n    if(!root) return [];\n    let queue = [root]\n    let res = []\n    while(queue.length)&#123;\n        let n = queue.length\n        const item = []\n        while(n)&#123;\n            const i = queue.shift();\n            item.push(i.val)\n            if(i.left) queue.push(i.left)\n            if(i.right) queue.push(i.right)\n            n--;\n        &#125;\n        res.push(item)\n    &#125;\n    return res;\n&#125;;\n</code></pre>\n<p>【练习：94二叉树的中序遍历】</p>\n<pre><code class=\"js\">//递归版实现\nvar inorderTraversal = function(root) &#123;\n    let res = []\n    //定义递归函数，进行执行\n    const rec = (n) =&gt;&#123;\n        if(!n) return;\n        rec(n.left);\n        res.push(n.val);\n        rec(n.right);\n    &#125;;\n    rec(root);\n    return res\n&#125;;\n</code></pre>\n<pre><code class=\"js\">//模拟栈实现\nvar inorderTraversal = function(root) &#123;\n    let stack = [];\n    let res = [];\n    let p = root;\n    while(stack.length || p)&#123;\n    // 中序遍历首先是将全部的左子节点进行添加\n        while(p)&#123;\n            stack.push(p);\n            p = p.left;\n        &#125;\n    //从栈中弹出\n        const n = stack.pop();\n        res.push(n.val);\n    //将右子节点添加进数组，此时为中序顺序添加\n        p = n.right;\n    &#125;\n    return res;\n&#125;;\n</code></pre>\n<p>【练习：112路径总和】</p>\n<pre><code class=\"js\">var hasPathSum = function(root, targetSum) &#123;\n    if(!root) return false;\n    let res = false;\n    //使用深度优先遍历\n    let dfs = (root,sum)=&gt;&#123;\n       if(!root.left &amp;&amp; !root.right &amp;&amp; sum == targetSum) &#123;\n           res=true;\n       &#125;;\n       // 深度优先遍历\n       if(root.left) dfs(root.left,sum+root.left.val);\n       if(root.right) dfs(root.right,sum+root.right.val);\n    &#125;\n    dfs(root,root.val);\n    return res;\n&#125;;\n</code></pre>\n<p>【前端与树—遍历JSON】</p>\n<pre><code class=\"js\">// 前端与树----json的遍历\nconst json = &#123;\n    a:&#123;b:&#123;c:1&#125;&#125;,\n    d:[1,2]\n&#125;\nconst dfs = (n,path)=&gt;&#123;\n    console.log(n,path);\n    Object.keys(n).forEach(item=&gt;&#123;\n        dfs(n[item],path.concat(item))\n    &#125;);\n&#125;;\ndfs(json,[]);\n</code></pre>\n<p>【前端与树—渲染Antd中的树组件】</p>\n<pre><code class=\"tsx\">const json = [\n    &#123;\n        title:&#39;一&#39;,\n        key:&#39;1&#39;,\n        children:[&#123;title:&#39;三&#39;,key:&#39;3&#39;,children:[]&#125;]\n    &#125;,\n    &#123;\n        title:&#39;二&#39;,\n        key:&#39;2&#39;,\n        children:[&#123;title:&#39;四&#39;,key:&#39;4&#39;,children:[]&#125;]\n    &#125;\n]\nclass Demo extends React.Component &#123;\n    dfs = (n)=&gt;&#123;\n        return (\n            &lt;TreeNode title=&#123;n.title&#125; key=&#123;n.key&#125;&gt;\n                &#123;n.children.map(this.dfs)&#125;\n            &lt;/TreeNode&gt;\n        );\n    &#125;;\n    render()&#123;\n        return &lt;Tree&gt;&#123;json.map(this.dfs)&#125;&lt;/Tree&gt;;\n    &#125;\n&#125;;\nReactDOM.render(&lt;Demo /&gt;,mountNode)\n</code></pre>\n<h1 id=\"图：网络结构抽象模型\"><a href=\"#图：网络结构抽象模型\" class=\"headerlink\" title=\"图：网络结构抽象模型\"></a>图：网络结构抽象模型</h1><p>【理解：图相当于可以跨越多个父级和子级和相互指对的树。】</p>\n<p> JS中没有图，但是可以使用Object和Array来构建图。</p>\n<p>【图的表示】</p>\n<p>一、临接矩阵（可连接则为1）</p>\n<p><img data-src=\"/images/%E5%9B%BE.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>二、邻接表（对象键的数组中表示可连接的值）</p>\n<p><img data-src=\"/images/%E5%9B%BE1.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【图的操作】</p>\n<p>【1】深度优先遍历</p>\n<p><img data-src=\"/images/%E5%9B%BE2.png\" alt=\"/images/image-20240123164938769\"></p>\n<pre><code class=\"js\">// 图的深度优先遍历\nconst graph = &#123;\n    0:[1,2],\n    1:[2],\n    2:[0,3],\n    3:[3]\n&#125;\n//定义集合用于存储已经访问过的节点\nconst visited = new Set();\nconst dfs = (n)=&gt;&#123;\n    console.log(n);\n    visited.add(n)\n    graph[n].forEach(item=&gt;&#123;\n       if(!visited.has(item)) dfs(item)\n    &#125;)\n&#125; \ndfs(2)\n</code></pre>\n<p>【2】广度优先遍历</p>\n<p><img data-src=\"/images/%E5%9B%BE3.png\" alt=\"/images/image-20240123164938769\"></p>\n<pre><code class=\"js\">// 图的广度优先遍历\nconst graph = &#123;\n    0:[1,2],\n    1:[2],\n    2:[0,3],\n    3:[3]\n&#125;\n//图的广度优先遍历\nconst bfs = (n)=&gt;&#123;\n    //定义集合存储访问过的变量\n    const visited = new Set([n])\n    //定义队列，取出访问\n    const queue = [n];\n    while(queue.length)&#123;\n        const i = queue.shift();\n        console.log(i);\n        graph[i].forEach(item=&gt;&#123;\n            if(!visited.has(item))&#123;\n                queue.push(item)\n                //推入队列中就会执行，表示已经访问过了\n                visited.add(item)\n            &#125;\n        &#125;)\n    &#125;\n&#125;\nbfs(2)\n</code></pre>\n<p>【练习：65有效的数字】</p>\n<pre><code class=\"js\">var isNumber = function(s) &#123;\n    const graph = &#123;\n        0:&#123;&#39;blank&#39;:0,&#39;sign&#39;:1,&#39;.&#39;:2,&#39;digit&#39;:6&#125;,\n        1:&#123;&#39;digit&#39;:6,&#39;.&#39;:2&#125;,\n        2:&#123;&#39;digit&#39;:3&#125;,\n        3:&#123;&#39;digit&#39;:3,&#39;e&#39;:4&#125;,\n        4:&#123;&#39;digit&#39;:5,&#39;sign&#39;:7&#125;,\n        5:&#123;&#39;digit&#39;:5&#125;,\n        6:&#123;&#39;digit&#39;:6,&#39;.&#39;:3,&#39;e&#39;:4&#125;,\n        7:&#123;&#39;digit&#39;:5&#125;\n    &#125;\n    let state = 0;\n    for(let str of s.trim())&#123;\n        if(str &gt;= 0 &amp;&amp; str &lt;= 9)&#123;\n            str = &#39;digit&#39;;\n        &#125;else if(str === &#39; &#39;)&#123;\n            str = &#39;blank&#39;;\n        &#125;else if(str === &#39;+&#39; || str === &#39;-&#39;)&#123;\n            str = &#39;sign&#39;;\n        &#125;else if(str === &#39;E&#39;)&#123;\n            str=&#39;e&#39;\n        &#125;\n        state = graph[state][str]\n        if(state === undefined) return false;\n    &#125;\n    if(state ==3 || state== 5 || state== 6) return true;\n    return false;\n&#125;;\n</code></pre>\n<p>【练习：417太平洋大西洋水流问题】</p>\n<pre><code class=\"js\">var pacificAtlantic = function(matrix) &#123;\n    if(!matrix || !matrix[0]) return[];\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const flow1 = Array.from(&#123;length:m&#125;,()=&gt;new Array(n).fill(false));\n    const flow2 = Array.from(&#123;length:m&#125;,()=&gt;new Array(n).fill(false));\n    const dfs = (r,c,flow)=&gt;&#123;\n        //在flow中，将当前节点设置为true\n        flow[r][c] = true;\n        //遍历当前项的四周节点\n        [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].forEach(([nr,nc])=&gt;&#123;\n            if(\n                //保证遍历的项在矩阵中,并且遍历项海拔大于当前节点海拔\n                nr&gt;=0 &amp;&amp; nr &lt;m &amp;&amp; nc&gt;=0 &amp;&amp; nc&lt;n &amp;&amp; !flow[nr][nc] &amp;&amp; matrix[nr][nc] &gt;= matrix[r][c]\n            )&#123;\n                dfs(nr,nc,flow);\n            &#125;\n        &#125;);\n    &#125;;\n    // 沿着两个海洋遍历节点，能到达的节点为true（海岸线使用flow1，大西洋使用flow2）\n    for(let r = 0;r&lt;m;r++)&#123;\n        dfs(r,0,flow1);\n        dfs(r,n-1,flow2);\n    &#125;\n    for(let c = 0;c&lt;n;c++)&#123;\n        dfs(0,c,flow1);\n        dfs(m-1,c,flow2);\n    &#125;\n    //收集到能留到两个大洋里的坐标\n    const res = [];\n    for(let r=0;r&lt;m;r++)&#123;\n        for(let c =0;c&lt;n;c++)&#123;\n            if(flow1[r][c] &amp;&amp; flow2[r][c])&#123;\n                res.push([r,c])\n            &#125;\n        &#125;\n    &#125;\n    return res;\n&#125;;\n</code></pre>\n<p>【练习：133克隆图】</p>\n<pre><code class=\"js\">//深度优先遍历方法\nvar cloneGraph = function(node) &#123;\n    if(!node) return;\n    //深优先遍历图，将节点和拷贝的节点存起来\n    const visited = new Map();\n    const dfs = (node)=&gt;&#123;\n        const cloneNode = new Node(node.val);\n        visited.set(node,cloneNode);\n        (node.neighbors || []).forEach(item=&gt;&#123;\n            if(!visited.has(item))&#123;\n                dfs(item)\n            &#125;\n             cloneNode.neighbors.push(visited.get(item));\n        &#125;);\n    &#125;;\n    dfs(node);\n    return visited.get(node);\n&#125;;\n</code></pre>\n<h1 id=\"堆：特殊的完全二叉树\"><a href=\"#堆：特殊的完全二叉树\" class=\"headerlink\" title=\"堆：特殊的完全二叉树\"></a>堆：特殊的完全二叉树</h1><p><img data-src=\"/images/%E5%A0%86.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><img data-src=\"/images/%E5%A0%861.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><img data-src=\"/images/%E5%A0%862.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【JS实现最小堆类】</p>\n<pre><code class=\"js\">// 最小堆类\nclass MinHeap&#123;\n    constructor()&#123;\n        this.heap=[];\n    &#125;\n    // 交换两个节点位置\n    swap(i1,i2)&#123;\n        const temp = this.heap[i1];\n        this.heap[i1]=this.heap[i2]\n        this.heap[i2]=temp;\n    &#125;\n    // 得到父元素索引\n    getParentIndex(i)&#123;\n        return i-1 &gt;&gt; 1\n    &#125;\n    //获取左侧子节点\n    getLeftIndex(i)&#123;\n        return (i*2)+1;\n    &#125;\n    //获取右侧子节点\n    getRightIndex(i)&#123;\n        return (i*2)+2;\n    &#125;\n    //比较大小值确定位置\n    shiftup(index)&#123;\n        if(index==0) return;\n        const parentIndex = this.getParentIndex(index)\n        if(this.heap[parentIndex]&gt;this.heap[index])&#123;\n            this.swap(parentIndex,index);\n            this.shiftup(parentIndex);\n        &#125;\n    &#125;\n    //插入节点，并放置到正确的位置\n    insert(value)&#123;\n        this.heap.push(value);\n        this.shiftup(this.heap.length-1);\n    &#125;\n    //下移操作\n    shiftDown(index)&#123;\n        const leftIndex = this.getLeftIndex(index);\n        const rightIndex = this.getRightIndex(index);\n        if(this.heap[leftIndex]&lt;this.heap[index])&#123;\n            this.swap(leftIndex,index);\n            this.shiftDown(leftIndex);\n        &#125;\n        if(this.heap[rightIndex]&lt;this.heap[index])&#123;\n            this.swap(rightIndex,index);\n            this.shiftDown(rightIndex);\n        &#125;\n    &#125;\n    //删除操作\n    pop()&#123;\n        this.heap[0]=this.heap.pop();\n        this.shiftDown(0);\n    &#125;\n    peek()&#123;\n        return this.heap[0];\n    &#125;\n    size()&#123;\n        return this.heap.length;\n    &#125;\n&#125;\nconst h = new MinHeap();\nh.insert(3)\nh.insert(2)\nh.insert(1)\nh.pop();\n</code></pre>\n<p>【练习：215数组中的第K个最大元素】</p>\n<pre><code class=\"js\">class MinHeap&#123;\n    constructor()&#123;\n        this.heap=[];\n    &#125;\n    // 交换两个节点位置\n    swap(i1,i2)&#123;\n        [this.heap[i1],this.heap[i2]]=[this.heap[i2],this.heap[i1]]\n    &#125;\n    // 得到父元素索引\n    getParentIndex(i)&#123;\n        return i-1 &gt;&gt; 1\n    &#125;\n    //获取左侧子节点\n    getLeftIndex(i)&#123;\n        return (i*2)+1;\n    &#125;\n    //获取右侧子节点\n    getRightIndex(i)&#123;\n        return (i*2)+2;\n    &#125;\n    //比较大小值确定位置\n    shiftup(index)&#123;\n        if(index==0) return;\n        const parentIndex = this.getParentIndex(index)\n        if(this.heap[parentIndex]&gt;this.heap[index])&#123;\n            this.swap(parentIndex,index);\n            this.shiftup(parentIndex);\n        &#125;\n    &#125;\n    //插入节点，并放置到正确的位置\n    insert(value)&#123;\n        this.heap.push(value);\n        this.shiftup(this.heap.length-1);\n    &#125;\n    //下移操作\n    shiftDown(index)&#123;\n        const leftIndex = this.getLeftIndex(index);\n        const rightIndex = this.getRightIndex(index);\n        if(this.heap[leftIndex]&lt;this.heap[index])&#123;\n            this.swap(leftIndex,index);\n            this.shiftDown(leftIndex);\n        &#125;\n        if(this.heap[rightIndex]&lt;this.heap[index])&#123;\n            this.swap(rightIndex,index);\n            this.shiftDown(rightIndex);\n        &#125;\n    &#125;\n    //删除操作\n    pop()&#123;\n        this.heap[0]=this.heap.pop();\n        this.shiftDown(0);\n    &#125;\n    peek()&#123;\n        return this.heap[0];\n    &#125;\n    size()&#123;\n        return this.heap.length;\n    &#125;\n&#125;\n//算法使用创建的最小堆类\nvar findKthLargest = function(nums,k)&#123;\n    const h = new MinHeap();\n    nums.forEach(item=&gt;&#123;\n        h.insert(item);\n        if(h.size()&gt;k)&#123;\n            h.pop();\n        &#125;\n    &#125;);\n    return h.peek();\n&#125;\n</code></pre>\n<p>【练习：347前K个最大元素】</p>\n<pre><code class=\"js\">//方法一：暴力解法（里面有排序算法，时间复杂度较高，至少为：O(n*log(n)) ）\nvar topKFrequent = function(nums, k) &#123;\n    const map = new Map()\n    nums.forEach(item=&gt;&#123;\n        map.has(item)? map.set(item,map.get(item)+1):map.set(item,1)\n    &#125;)\n    return Array.from(map)\n        .sort((a,b)=&gt;b[1]-a[1])\n        .slice(0,k)\n        .map(item=&gt;item[0]);\n&#125;;\n</code></pre>\n<pre><code class=\"js\">//方法二：使用堆\nclass MinHeap&#123;\n    constructor()&#123;\n        this.heap=[];\n    &#125;\n    // 交换两个节点位置\n    swap(i1,i2)&#123;\n        [this.heap[i1],this.heap[i2]]=[this.heap[i2],this.heap[i1]]\n    &#125;\n    // 得到父元素索引\n    getParentIndex(i)&#123;\n        return i-1 &gt;&gt; 1\n    &#125;\n    //获取左侧子节点\n    getLeftIndex(i)&#123;\n        return (i*2)+1;\n    &#125;\n    //获取右侧子节点\n    getRightIndex(i)&#123;\n        return (i*2)+2;\n    &#125;\n    //比较大小值确定位置\n    shiftup(index)&#123;\n        if(index==0) return;\n        const parentIndex = this.getParentIndex(index)\n        if(this.heap[parentIndex].value&gt;this.heap[index].value)&#123;\n            this.swap(parentIndex,index);\n            this.shiftup(parentIndex);\n        &#125;\n    &#125;\n    //插入节点，并放置到正确的位置\n    insert(value)&#123;\n        this.heap.push(value);\n        this.shiftup(this.heap.length-1);\n    &#125;\n    //下移操作\n    shiftDown(index)&#123;\n        const leftIndex = this.getLeftIndex(index);\n        const rightIndex = this.getRightIndex(index);\n        if(this.heap[leftIndex] &amp;&amp; this.heap[leftIndex].value&lt;this.heap[index].value)&#123;\n            this.swap(leftIndex,index);\n            this.shiftDown(leftIndex);\n        &#125;\n        if(this.heap[rightIndex] &amp;&amp; this.heap[rightIndex].value&lt;this.heap[index].value)&#123;\n            this.swap(rightIndex,index);\n            this.shiftDown(rightIndex);\n        &#125;\n    &#125;\n    //删除操作\n    pop()&#123;\n        this.heap[0]=this.heap.pop();\n        this.shiftDown(0);\n    &#125;\n    peek()&#123;\n        return this.heap[0];\n    &#125;\n    size()&#123;\n        return this.heap.length;\n    &#125;\n&#125;\nvar findKthLargest = function(nums,k)&#123;\n    const h = new MinHeap();\n    nums.forEach(item=&gt;&#123;\n        h.insert(item);\n        if(h.size()&gt;k)&#123;\n            h.pop();\n        &#125;\n    &#125;);\n    return h.peek();\n&#125;\nvar topKFrequent = function(nums,k)&#123;\n    const map = new Map();\n    nums.forEach(item=&gt;&#123;\n        map.set(item,map.has(item)?map.get(item)+1:1);\n    &#125;)\n    const h = new MinHeap();\n    map.forEach((value,key)=&gt;&#123;\n        h.insert(&#123;value,key&#125;);\n        if(h.size()&gt;k)&#123;\n            h.pop();\n        &#125;;\n    &#125;);\n    return h.heap.map(item=&gt;item.key);\n&#125;;\n</code></pre>\n<p>【练习：23合并K个排序链表】</p>\n<pre><code class=\"js\">class minHeap&#123;\n    constructor()&#123;\n        this.heap=[];\n    &#125;\n    //移动两个元素的位置\n    swap(i1,i2)&#123;\n        [this.heap[i1],this.heap[i2]]=[this.heap[i2],this.heap[i1]]\n    &#125;\n    //得到父元素下标\n    getParentIndex(i)&#123;\n        return i-1&gt;&gt;1;\n    &#125;\n    //得到左侧子节点下标\n    getLeftIndex(i)&#123;\n        return i*2+1;\n    &#125;\n    //得到右侧子节点下标\n    getRightIndex(i)&#123;\n        return i*2+2;\n    &#125;\n    //根据索引调整元素位置(冒泡将最小元素上移)\n    shiftup(index)&#123;\n        if(index==0) return;\n        const parentIndex = this.getParentIndex(index);\n        if(this.heap[parentIndex]&amp;&amp;this.heap[parentIndex].val&gt;this.heap[index].val)&#123;\n            this.swap(index,parentIndex);\n            this.shiftup(parentIndex);\n        &#125;\n    &#125;\n    //插入\n    insert(value)&#123;\n        this.heap.push(value);\n        this.shiftup(this.heap.length-1);\n    &#125;\n    //删除操作\n    pop()&#123;\n        if(this.size()===1) return this.heap.shift();\n        const top = this.heap[0];\n        this.heap[0]=this.heap.pop();\n        this.shiftDown(0);\n        return top;\n    &#125;\n    //下沉操作\n    shiftDown(index)&#123;\n        const leftIndex = this.getLeftIndex(index)\n        const rightIndex = this.getRightIndex(index)\n        if(this.heap[leftIndex]&amp;&amp;this.heap[leftIndex].val&lt;this.heap[index].val)&#123;\n            this.swap(leftIndex,index)\n            this.shiftDown(leftIndex)\n        &#125;\n        if(this.heap[rightIndex]&amp;&amp;this.heap[rightIndex].val&lt;this.heap[index].val)&#123;\n            this.swap(rightIndex,index)\n            this.shiftDown(rightIndex)\n        &#125;\n    &#125;\n    //选取\n    peek()&#123;\n        return this.heap[0]\n    &#125;\n    size()&#123;\n        return this.heap.length;\n    &#125;\n&#125;\n\nclass ListNode&#123;\n    constructor(value)&#123;\n    this.val = value;\n    this.next = null\n      &#125;\n    &#125;\n    var mergeKLists = function(lists) &#123;\n        const res = new ListNode(0);\n        let p =res;\n        const h = new minHeap();\n        lists.forEach(item=&gt;&#123;\n            if(item) h.insert(item);\n        &#125;);\n        while(h.size())&#123;\n            const n = h.pop();\n            if(p)&#123;\n            p.next = n;\n            p = p.next;\n            &#125;\n            if(n &amp;&amp; n.next) h.insert(n.next);\n        &#125;\n        return res.next;\n    &#125;;\n</code></pre>\n<h1 id=\"排序和搜索\"><a href=\"#排序和搜索\" class=\"headerlink\" title=\"排序和搜索\"></a>排序和搜索</h1><p>【排序算法】</p>\n<p>1、冒泡排序：</p>\n<p>冒泡排序比较所有相邻元素，如果第一个比第二个大，就交换他们，一轮下来可以保证最后一个数是最大的，则执行n-1轮之后可以实现排序，时间复杂度为O(n**2)</p>\n<pre><code class=\"js\">//冒泡排序\nArray.prototype.bubbleSort=function()&#123;\n        for(let i =0;i&lt;this.length-1;i++)&#123;\n            for(let j =0;j&lt;this.length-1-i;j++)&#123;\n                if(this[j]&gt;this[j+1])&#123;\n                    [this[j],this[j+1]]=[this[j+1],this[j]]\n                &#125;\n            &#125;\n        &#125;\n        return this\n&#125;\n</code></pre>\n<p>2、选择排序：</p>\n<p>选择排序找到数组中的最小值，选中它并将其放置在第一位，接着找到第二小的值，选中它并将其放置在第二位，以此类推执行n-1轮，时间复杂度为O(n**2)</p>\n<pre><code class=\"js\">//选择排序\nArray.prototype.selectionSort=function()&#123;\n    for(let i =0;i&lt;this.length;i++)&#123;\n        for(let j =i+1;j&lt;this.length;j++)&#123;\n            if(this[j]&lt;this[i])&#123;\n                [this[j],this[i]]=[this[i],this[j]]\n            &#125;\n        &#125;\n    &#125;\n    return this\n&#125;\n</code></pre>\n<p>3、插入排序：</p>\n<p> 插入排序会从第二个数开始往前比，比他大就往后排，以此类推进行到最后一个数。时间复杂度为： O(n**2)</p>\n<pre><code class=\"js\">//插入排序\nArray.prototype.insertSort=function()&#123;\n   for(let i=1;i&lt;this.length;i++)&#123;\n    const temp = this[i];\n    let j=i;\n    while(j&gt;0)&#123;\n        if(this[j-1]&gt;temp)&#123;\n            this[j]=this[j-1];\n        &#125;else&#123;\n            break;\n        &#125;\n        j-=1;\n    &#125;\n    this[j]=temp;\n   &#125;\n&#125;\n</code></pre>\n<p>4、归并排序（火狐浏览器sort）</p>\n<p>归：将数组分为两半，再递归的对子数组进行分操作，直到分成一个个单独的数。</p>\n<p>并：将两个数合并成一个有序数组，再对有序数组进行合并，直到全部子数合并成一个完整数组。</p>\n<p>时间复杂度为：O(nlogn)</p>\n<pre><code class=\"js\">Array.prototype.mergeSort = function()&#123;\n    const rec = (arr)=&gt;&#123;\n        if(arr.length===1) return arr;\n        const mid = arr.length &gt;&gt; 1;\n        const left = arr.slice(0,mid);\n        const right = arr.slice(mid,arr.length)\n        const orderLeft=rec(left);\n        const orderRight=rec(right);\n        const res = [];\n        while(orderLeft.length || orderRight.length)&#123;\n            if(orderLeft.length &amp;&amp; orderRight.length)&#123;\n                res.push(orderLeft[0]&lt;orderRight[0]?orderLeft.shift():orderRight.shift())\n            &#125;else if(orderLeft.length)&#123;\n                res.push(orderLeft.shift())\n            &#125;else if(orderRight.length)&#123;\n                res.push(orderRight.shift())\n            &#125;\n        &#125;\n        return res;\n    &#125;;\n    const res = rec(this);\n    res.forEach((item,index)=&gt;&#123;this[index]=item;&#125;);\n    return this;\n&#125;\nlet ate = [2,3,1,-1,4,6,8,5,-3,-2];\nconsole.log(ate.mergeSort());\n</code></pre>\n<p>5、快速排序（Chrome浏览器之前的sort）</p>\n<p><strong>首先分区</strong>：从数组中任意选择一个基准，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面。</p>\n<p><strong>然后递归</strong>：递归地对基准前后的子数组进行分区。</p>\n<p>时间复杂度：O(nlogn)</p>\n<pre><code class=\"js\">Array.prototype.quickSort = function()&#123;\n    const rec = (arr)=&gt;&#123;\n        if(arr.length&lt;=1)&#123;return arr;&#125;\n        const left = [];\n        const right = [];\n        const mid = arr[0];\n        for(let i=1;i&lt;arr.length;i++)&#123;\n            if(arr[i]&lt;mid)&#123;\n                left.push(arr[i]);\n            &#125;else&#123;\n                right.push(arr[i]);\n            &#125;\n        &#125;\n        return [...rec(left),mid,...rec(right)]\n    &#125;\n    const res = rec(this)\n    res.forEach((item,index)=&gt;&#123;\n        this[index]=item;\n    &#125;)\n    return this;\n&#125;\nconst a2 = [-2,-4,0,3,5]\nconsole.log(\na2.quickSort()\n);\n</code></pre>\n<p>【搜索算法】</p>\n<p>1、顺序搜索</p>\n<p>首先遍历数组，找到跟目标值相等的元素就返回下标，遍历结束后如果没有找到搜索的目标值，就返回-1</p>\n<p>时间复杂度为O(n)</p>\n<pre><code class=\"js\">Array.prototype.sequentialSearch = function(num)&#123;\n    for(let i=0;i&lt;this.length;i++)&#123;\n        if(this[i]===num)&#123;\n            return i;\n        &#125;\n    &#125;\n    return -1;\n&#125;\nconst a = [-2,-4,0,3,5]\nconsole.log(a.sequentialSearch(5));\n</code></pre>\n<p>2、二分搜索（前提是数组有序）</p>\n<p>从数组的中间元素开始，如果中间元素正好是目标值，则索引结束，如果目标值大于或者等于中间元素，则在大于或小于中间元素的那一半数组中搜索。</p>\n<p>时间复杂度为O(logn)</p>\n<pre><code class=\"js\">Array.prototype.bannerySearch = function(num)&#123;\n    let head = 0;\n    let tail = this.length-1;\n    while(head&lt;=tail)&#123;\n        const mid = head+tail &gt;&gt; 1;\n        const item = this[mid];\n        if(num&lt;item)&#123;\n            tail=mid-1;\n        &#125;else if(num&gt;item)&#123;\n            head=mid+1;\n        &#125;else&#123;\n            return mid;\n        &#125;\n    &#125;\n    return -1;\n&#125;\nconst a = [-2,0,3,4,9,11]\nconsole.log(a.bannerySearch(11));\n</code></pre>\n<p>【练习：21合并两个有序链表】</p>\n<p>时间复杂度为：O(m+n)</p>\n<pre><code class=\"js\">var mergeTwoLists = function(list1, list2) &#123;\n    let list = new ListNode(0);\n    const firstNode = list;\n    let p1 = list1;\n    let p2 = list2;\n    while(p1 &amp;&amp; p2)&#123;\n        if(p1.val&gt;p2.val)&#123;\n            list.next=p2;\n            p2=p2.next\n        &#125;else&#123;\n            list.next=p1;\n            p1=p1.next\n        &#125;\n        list=list.next;\n    &#125;\n    if(p1)&#123;list.next=p1&#125;\n    if(p2)&#123;list.next=p2&#125;\n    return firstNode.next;\n&#125;;\n</code></pre>\n<p>【练习：374猜数字大小】</p>\n<pre><code class=\"js\">var guessNumber = function(n) &#123;\n    let head = 1;\n    let tail = n;\n    while(head&lt;tail)&#123;\n       const mid = head+(tail-head&gt;&gt;1);\n        if(guess(mid)&lt;=0)&#123;\n            tail=mid;\n        &#125;else&#123;\n            head=mid+1;\n        &#125;\n    &#125;\n    return head;\n&#125;;\n</code></pre>\n<p>【练习：69x的平方】</p>\n<pre><code class=\"js\">var mySqrt = function(x) &#123;\n    let left =1,right=x;\n    while(left&lt;=right)&#123;\n        let mid = left+(right-left&gt;&gt;1);\n        if(mid*mid&lt;=x)&#123;\n            if((mid+1)*(mid+1)&gt;x)&#123;\n                return mid;\n            &#125;\n            left=mid+1;\n        &#125;else&#123;\n            right=mid-1;\n        &#125;\n    &#125;\n    return 0;\n&#125;;\n</code></pre>\n<h1 id=\"算法设计思想\"><a href=\"#算法设计思想\" class=\"headerlink\" title=\"算法设计思想\"></a>算法设计思想</h1><h3 id=\"分而治之\"><a href=\"#分而治之\" class=\"headerlink\" title=\"分而治之\"></a>分而治之</h3><p>分而治之是算法设计中的一种方法（思想），</p>\n<p>分而治之将一个问题分为多个和原问题相似的<strong>相互独立的子问题</strong>，递归解决小问题，再将结果合并已解决原来的问题。应用场景有：归并排序、快速排序和二分搜索。</p>\n<p>【练习：374猜数字大小】</p>\n<p> 时间复杂度为：O(logn),空间复杂度为：O(logn)空间复杂度不如直接使用循环。</p>\n<pre><code class=\"js\">var guessNumber = function(n) &#123;\n    const rec = (head,tail)=&gt;&#123;\n        const mid = head+(tail-head&gt;&gt;1);\n        const res = guess(mid);\n        if(res===0)&#123;\n            return mid;\n        &#125;else if(res===1)&#123;\n            return rec(mid+1,tail)\n        &#125;else&#123;\n            return rec(head,mid-1)\n        &#125;\n    &#125;\n    return rec(1,n)\n&#125;;\n</code></pre>\n<p>【练习：226翻转二叉树】</p>\n<pre><code class=\"js\">var invertTree = function(root) &#123;\n    if(!root) return null;\n    return &#123;\n        val:root.val,\n        left:invertTree(root.right),\n        right:invertTree(root.left)\n    &#125;\n&#125;;\n</code></pre>\n<p>【练习：100相同的树】</p>\n<p>时间复杂度为：O(n) , 空间复杂度为：O(n)</p>\n<pre><code class=\"js\">var isSameTree = function(p, q) &#123;\n    if(!p &amp;&amp; !q) return true;\n    if(p &amp;&amp; q &amp;&amp; p.val===q.val &amp;&amp; isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right))&#123;\n       return true;\n   &#125;\n&#125;;\n</code></pre>\n<p>【练习：101对称二叉树】</p>\n<pre><code class=\"js\">var isSymmetric = function(root) &#123;\n    if(!root) return true;\n    const isMirror = (l,r)=&gt;&#123;\n        if(!l &amp;&amp; !r) return true;\n        if(l &amp;&amp; r &amp;&amp; l.val===r.val &amp;&amp; isMirror(l.left,r.right) &amp;&amp; isMirror(l.right,r.left))&#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n    return isMirror(root.left,root.right)\n&#125;;\n</code></pre>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>动态规划是算法设计中的一种方法，</p>\n<p>动态规划将一个问题分解为<strong>相互重叠的子问题</strong>，通过反复求解子问题来解决原来的问题。</p>\n<p>关键：找出<strong>状态转移方程</strong>。</p>\n<p>【练习：70爬楼梯】</p>\n<pre><code class=\"js\">var climbStairs = function(n) &#123;\n    if(n&lt;2) return 1;\n    let dp0 = 1;\n    let dp1 = 1;\n    for(let i = 2;i&lt;=n;i++)&#123;\n        const temp = dp0;\n        dp0=dp1;\n        dp1+=temp;\n    &#125;\n    return dp1;\n&#125;;\n</code></pre>\n<p>【练习：198打家劫舍】</p>\n<pre><code class=\"js\">var rob = function(nums) &#123;\n    if(nums.length===0) return 0;\n    if(nums.length===1) return nums[0];\n    let dp0 = 0,dp1=nums[0];\n    for(let i=2;i&lt;=nums.length;i++)&#123;\n       const dp2=Math.max(dp0+nums[i-1],dp1);\n        dp0=dp1;\n        dp1=dp2;\n    &#125;\n    return dp1;\n&#125;;\n</code></pre>\n<h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3><p>贪心算法是算法设计中的一种方法（思想），期盼通过每个阶段的<strong>局部最优</strong>选择，从而达到全局的最优，但是并不一定是最优的解法。</p>\n<p>【练习：455分饼干】</p>\n<pre><code class=\"js\">var findContentChildren = function(g, s) &#123;\n    const sortFn = function(a,b)&#123;\n        return a-b\n    &#125;\n    g=g.sort(sortFn);\n    s=s.sort(sortFn);\n    let i =0;\n    s.forEach(item=&gt;&#123;\n        if(item&gt;=g[i])&#123;\n            i++;\n        &#125;\n    &#125;)\n    return i;\n&#125;;\n</code></pre>\n<p>【练习：122买卖股票的最佳时机】</p>\n<pre><code class=\"js\">var maxProfit = function(prices) &#123;\n    let profit = 0;\n    for(let i=1;i&lt;prices.length;i++)&#123;\n        if(prices[i]&gt;prices[i-1])&#123;\n            profit+=prices[i]-prices[i-1]\n        &#125;\n    &#125;\n    return profit;\n&#125;;\n</code></pre>\n<h3 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h3><p>回溯算法是算法设计中的一种方法（思想），</p>\n<p>回溯算法是一种渐进式寻找并构建问题解决方式的策略。</p>\n<p>回溯算法会先从一个可能的动作开始解决问题，如果不行就回溯并选择另一个动作，直到将问题解决。</p>\n<p>【练习：46全排列】</p>\n<p>时间复杂度：O(n!) ;空间复杂度：O(n)</p>\n<pre><code class=\"js\">var permute = function(nums) &#123;\n    const res = [];\n    const backtrack = (arr)=&gt;&#123;\n        if(arr.length===nums.length)&#123;\n            res.push(arr);\n            return;\n        &#125;\n        nums.forEach(item=&gt;&#123;\n            if(arr.includes(item)) return;\n            backtrack(arr.concat(item))\n        &#125;)\n    &#125;\n    backtrack([]);\n    return res;\n&#125;;\n</code></pre>\n<p>【练习：78子集】（难点）</p>\n<p>时间复杂度：O(2**n)  , 空间复杂度：O(n)</p>\n<pre><code class=\"js\">var subsets = function(nums) &#123;\n    const res = [];\n    const backtrack = (path,l,start)=&gt;&#123;\n        if(path.length===l)&#123;\n            res.push(path);\n            return;\n        &#125;\n        for(let i=start;i&lt;nums.length;i++)&#123;\n            backtrack(path.concat(nums[i]),l,i+1)\n        &#125;\n    &#125;\n    for(let i =0;i&lt;=nums.length;i++)&#123;\n       backtrack([],i,0)\n    &#125;\n    return res;\n&#125;;\n</code></pre>\n<h1 id=\"代码思想录\"><a href=\"#代码思想录\" class=\"headerlink\" title=\"代码思想录\"></a>代码思想录</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDQuJUU0JUJBJThDJUU1JTg4JTg2JUU2JTlGJUE1JUU2JTg5JUJFLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG\">代码思想录</span></p>\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>时间复杂度不是在计算执行时间因为执行时间是没有标准的，这个和我们的硬件设备和机器环境有关系。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法 的时间复杂度。</p>\n<p>找到<strong>某条基本语句与问题规模N之间的数学表达式</strong>，就是算出了该算法的时间复杂度。</p>\n<p>另外有些算法的时间复杂度存在最好、平均和最坏情况：</p>\n<p>最坏情况：任意输入规模的最大运行次数(上界)</p>\n<p>平均情况：任意输入规模的期望运行次数</p>\n<p>最好情况：任意输入规模的最小运行次数(下界)</p>\n<p>一般情况关注的是算法的最坏运行情况，所以以<strong>最坏情况的时间复杂度为准</strong>。</p>\n<p>使用<strong>大O的渐进表示法</strong>进行估算。</p>\n<p>o(1):</p>\n<pre><code class=\"typescript\">let i = 0;i+=1;\n</code></pre>\n<p>0(n):</p>\n<pre><code class=\"typescript\">for(let i =0;i&lt;n;i++)&#123;console.log(i);&#125;\n</code></pre>\n<p>o(n^2):</p>\n<p><strong>双重for循环</strong></p>\n<p>o(logN)：</p>\n<pre><code class=\"typescript\">let i = 1;\nwhile(i&lt;n)&#123;\nconsole.log(i)\ni *= 2;\n&#125;\n</code></pre>\n<p><img data-src=\"/images/%E7%AE%97%E6%B3%953.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>相比而言现在算法不那么关注空间复杂度，因为现在的设备的存储空间都比较大。</p>\n<p>空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度 ，也就是额外占取的空间的大小。在进行计算时需要注意空间是可以重复利用的，不进行累积。例如：for循环中定义的变量i每一次创建时使用的都是同一块空间。</p>\n<p>【变量空间可以重复利用】</p>\n<p><img data-src=\"/images/%E7%AE%97%E6%B3%951.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【函数的调用需要建立栈】</p>\n<p><img data-src=\"/images/%E7%AE%97%E6%B3%952.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>使用<strong>大O的渐进表示法</strong>进行估算。</p>\n<h2 id=\"数组算法：\"><a href=\"#数组算法：\" class=\"headerlink\" title=\"数组算法：\"></a>数组算法：</h2><h4 id=\"理论\"><a href=\"#理论\" class=\"headerlink\" title=\"理论\"></a>理论</h4><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>\n<ul>\n<li><strong>数组下标都是从0开始的。</strong></li>\n<li><strong>数组内存空间的地址是连续的</strong></li>\n</ul>\n<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>\n<p>java中的二位数组不是一直连续的，而是n条连续的地址空间组成。</p>\n<h4 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h4><p>【前提】传入的数组是有序数组，数组中无重复元素</p>\n<p>【要点】区间定义  循环不变量</p>\n<p>然后while循环(left&lt;right),定中间的mid变量为：left+((right-left) &gt;&gt; 1)，利用位运算进行除法操作。</p>\n<pre><code class=\"ts\">function search(nums: number[], target: number): number &#123;\n    let mid: number, left: number = 0, right: number = nums.length - 1;\n    while (left &lt;= right) &#123;\n        // 位运算 + 防止大数溢出\n        mid = left + ((right - left) &gt;&gt; 1);\n        if (nums[mid] &gt; target) &#123;\n            right = mid - 1;\n        &#125; else if (nums[mid] &lt; target) &#123;\n            left = mid + 1;\n        &#125; else &#123;\n            return mid;\n        &#125;\n    &#125;\n    return -1;\n&#125;;\n</code></pre>\n<h4 id=\"移除元素\"><a href=\"#移除元素\" class=\"headerlink\" title=\"移除元素\"></a>移除元素</h4><p>【前提】传入数组和val,移除数组中等于val的全部元素，返回移除后数组长度</p>\n<p>【要点】数组的元素在内存空间是连续的，不能单独删除数组的某个元素，只能覆盖</p>\n<p>两次循环（移动数组元素）：</p>\n<pre><code class=\"ts\">function solution(arr:any[],val:any):number&#123;\n    let size:number = arr.length;\n    for(let i =0;i&lt;arr.length;i++)&#123;\n        if(arr[i]==val)&#123;\n            //集体向前进位\n            for(let j=i+1;j&lt;arr.length;j++)&#123;\n                arr[j-1]=arr[j]\n            &#125;\n            i--;\n            size--;\n        &#125;\n    &#125;\n    return size;\n&#125;\n</code></pre>\n<p><strong>快慢指针</strong>（给指定元素重新赋值）：</p>\n<pre><code class=\"ts\">function removeElement(nums: number[], val: number): number &#123;\n    let slowIndex: number = 0, fastIndex: number = 0 //定义快慢指针index\n    while (fastIndex &lt; nums.length) &#123;  //当快指针index小于数组长度时执行循环\n        if (nums[fastIndex] !== val) &#123; //如果快指针对应的元素不等于val元素\n            // 注意后置递增的运算顺序大于赋值运算，相当于确定了nums中的数值，表达式结束之后再自增加一\n            nums[slowIndex++] = nums[fastIndex];  //满指针赋值\n        &#125;\n        fastIndex++;\n    &#125;\n    return slowIndex;\n&#125;;\n</code></pre>\n<p>4  将排序数组平方后再排序（注意负数平方后可能大于正数）</p>\n<p>暴力解法：</p>\n<pre><code class=\"ts\">function sortedSquares(arr:number[]):number[]&#123;\n    return arr.map((item:number)=&gt;item ** 2).sort((a:number,b:number)=&gt;a-b)\n&#125;\nconsole.log(sortedSquares([2,1,4,0,3]));\n</code></pre>\n<p>双指针解法：</p>\n<pre><code class=\"ts\">// 数组本来是存在顺序的,问题在于负数平方之后变为了最大数\n// 此时考虑双指针方法，向两边靠拢\nfunction sortedSquares(arr:number[]):number[]&#123;\n    let right:number = arr.length-1,left:number=0,newArr:number[]=[];\n    while(right&gt;=left)&#123;\n        if(arr[right] ** 2 &gt;= arr[left] ** 2)&#123;\n            newArr.push(arr[right--]**2)\n        &#125;else&#123;\n            newArr.push(arr[left++]**2)\n        &#125;\n    &#125;\n    return newArr\n&#125;\nconsole.log(sortedSquares([-9,-3,0,2,3,6]));\n</code></pre>\n<p>5  长度最小的子数组</p>\n<p>双重for循环遍历</p>\n<pre><code class=\"ts\">function minSubArrayLen(s: number, nums: number[]): number &#123;\n    let result = Infinity; \n    let sum = 0; \n    let subLength = 0; \n    for (let i = 0; i &lt; nums.length; i++) &#123;  //数组遍历一遍\n      sum = 0;\n      for (let j = i; j &lt; nums.length; j++) &#123;  //数组遍历一遍\n        sum += nums[j]; //累加\n        if (sum &gt;= s) &#123; //一旦累加的和大于指定数字\n          subLength = j - i + 1; //数组长度\n          result = result &lt; subLength ? result : subLength; //\n          break; \n        &#125;\n      &#125;\n    &#125;\n    return result == Infinity ? 0 : result;\n  &#125;\n</code></pre>\n<p><strong>滑动窗口法（双指针的一种）</strong></p>\n<p>双指针滑动判断条件，将满足条件的结果进行记录（这种方法执行的也是两次循环，但是省略了中间的部分步骤，剔除了不必要的记录结果的部分）</p>\n<pre><code class=\"ts\">function minSubArrayLen(target: number, nums: number[]): number &#123;\n    // 创建指针\n    let left: number = 0, right: number = 0;\n    // 创建res变量\n    let res: number = nums.length + 1;\n    let sum: number = 0;\n    while (right &lt; nums.length) &#123; //当右指针小于数组的长度时执行循环\n        sum += nums[right]; //sum和累加right对应的元素（移动右指针）\n        if (sum &gt;= target) &#123; //如果累加和大于目标值（移动左指针）\n            while (sum - nums[left] &gt;= target) &#123; //移动到累加和小于目标值\n                sum -= nums[left++]; \n            &#125;\n            res = Math.min(res, right - left + 1); //每一次累加和大于目标值时，进行判断和统计\n        &#125;\n        right++;\n    &#125;\n    return res === nums.length + 1 ? 0 : res;\n&#125;;\nconsole.log(minSubArrayLen(7,[2,3,1,2,4,3]));\n</code></pre>\n<p>6  螺旋矩阵||</p>\n<p>【条件】给定一个正整数n，生成一个包含1到n的平方的所有元素，按照顺时针顺序螺旋排列正方形矩阵。</p>\n<p>【要点】循环不变量原则，坚持每一条边左闭右开原则</p>\n<pre><code class=\"ts\">function generateMatrix(n: number): number[][] &#123;\n    let loopNum: number = Math.floor(n / 2); //定义循环次数\n    const resArr: number[][] = new Array(n).fill(1).map(i =&gt; new Array(n));//定义二元数组\n    let chunkNum: number = n - 1;  //循环长度\n    let startX: number = 0; //开始x\n    let startY: number = 0; //开始y\n    let value: number = 1; //数值\n    let x: number, y: number;\n    while (loopNum--) &#123; //当loopNum的值大于0时执行循环，每一个loopNum自减\n        x = startX;\n        y = startY;\n        while (x &lt; startX + chunkNum) &#123; //当x小于开始x加上循环长度时 向右执行循环\n            resArr[y][x] = value;  //填充\n            x++;\n            value++;\n        &#125;\n        while (y &lt; startY + chunkNum) &#123; //当y小于开始Y加上循环长度时 向下执行循环\n            resArr[y][x] = value;  //累加y的值到指定循环长度次\n            y++;\n            value++;\n        &#125;\n        while (x &gt; startX) &#123;  //当x大于开始的x时，向左执行循环\n            resArr[y][x] = value;\n            x--;\n            value++;\n        &#125;\n        while (y &gt; startY) &#123;  //当y大于开始的y时，向上执行循环\n            resArr[y][x] = value;\n            y--;\n            value++;\n        &#125;\n        startX++;  //每一次让开始x和开始y自增，以达到向内延展的效果\n        startY++;\n        chunkNum -= 2; //每一次循环之后，一行或一列需要的长度少2\n    &#125;\n    //全部循环完毕之后进行判断：如果n是奇数，则中间会有一个空出来，填充\n    if (n % 2 === 1) &#123;  \n        resArr[startX][startY] = value;\n    &#125;\n    return resArr;\n&#125;;\n</code></pre>\n<h2 id=\"链表算法：\"><a href=\"#链表算法：\" class=\"headerlink\" title=\"链表算法：\"></a>链表算法：</h2><h4 id=\"理论-1\"><a href=\"#理论-1\" class=\"headerlink\" title=\"理论\"></a>理论</h4><p>链表理论基础：</p>\n<p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>\n<p>链表的入口节点称为链表的头结点也就是head。</p>\n<p>1 单链表</p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A81.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>2 双链表</p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A82.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>3 循环链表</p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A83.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><strong>4 链表存储方式</strong></p>\n<p><strong>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</strong></p>\n<p><strong>链表是通过指针域的指针链接在内存中各个节点。</strong></p>\n<p><strong>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</strong></p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A84.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【链表和数组的区别：】</p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A85.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><strong>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</strong></p>\n<p><strong>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</strong></p>\n<p><strong>数组取值容易增删难，链表增删简单，取值难</strong></p>\n<p><strong>5 链表的定义：</strong></p>\n<pre><code class=\"ts\">//定义链表\nclass ListNode&#123;\n    public val:number;\n    public next:ListNode | null=null;\n    constructor(value:number,next?:ListNode | null)&#123;\n        this.val = value;\n        this.next = next || null;\n    &#125;\n&#125;\nconst head1 = new ListNode(1)\nconst head2 = new ListNode(2)\nconst head3 = new ListNode(2)\nconst head4 = new ListNode(1)\nhead1.next = head2\nhead2.next = head3\nhead3.next = head4\n</code></pre>\n<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【练习：203移除链表中对应值的元素：】</p>\n<p>（1）原链表上直接删除</p>\n<pre><code class=\"ts\">// 移除链表节点元素,传入ListNode链表，val数值\nfunction removeElements(head: ListNode | null, val: number): ListNode | null &#123;\n    //边界判断，如果当前链表头节点的值为目标值，不能直接移除头节点（设置虚拟头节点可以避免）\n    while (head !== null &amp;&amp; head.val === val) &#123;\n        head = head.next;\n    &#125;\n    if (head === null) return head;  //如果传入的链表是空对象，直接返回\n    let pre: ListNode = head, cur: ListNode | null = head.next; //定义前一个节点，当前节点\n    // 删除非头部节点\n    while (cur) &#123; //当前节点有值时进行循环\n        if (cur.val === val) &#123; //如果当前节点的值为进行判断的值，就将当前的下一项赋值给pre前一个的下一项（跳过当前节点）\n            pre.next = cur.next;\n        &#125; else &#123;  //否则遍历判断下一项\n            //此处不加类型断言时：编译器会认为pre类型为ListNode, pre.next类型为ListNode | null\n            pre = pre.next as ListNode;\n        &#125;\n        cur = cur.next;\n    &#125;\n    return head; //返回头节点\n&#125;;\n</code></pre>\n<p>（2）创建虚拟头节点删除</p>\n<pre><code class=\"ts\">//在原链表上直接删除\nvar removeElements = function(head:ListNode | null, val:number):ListNode | null &#123;\n   //添加虚拟头节点\n   const data = new ListNode(0,head);\n   let pre = data, cur = data.next;\n   while(cur)&#123;\n    if(cur.val===val)&#123;\n        pre.next = cur.next;\n    &#125;else&#123;\n        pre = cur;\n    &#125;\n    cur=cur.next;\n   &#125;\n   return data.next;\n&#125;;\nconsole.log(removeElements(head1,2));\n</code></pre>\n<p>【练习：707设计链表】</p>\n<pre><code class=\"ts\">class ListNode &#123;\n    public val: number;\n    public next: ListNode | null;\n    constructor(val?: number, next?: ListNode | null) &#123;\n        this.val = val === undefined ? 0 : val;\n        this.next = next === undefined ? null : next;\n    &#125;\n&#125;\n\nclass MyLinkedList &#123;\n    // 记录链表长度\n    private size: number;\n    private head: ListNode | null;\n    private tail: ListNode | null;\n    constructor() &#123;\n        this.size = 0;\n        this.head = null;\n        this.tail = null;\n    &#125;\n\n    // 获取链表中第 index个节点的值\n    get(index: number): number &#123;\n        // 索引无效的情况\n        if (index &lt; 0 || index &gt;= this.size) &#123;\n            return -1;\n        &#125;\n        let curNode = this.getNode(index);\n        // 这里在前置条件下，理论上不会出现 null的情况\n        return curNode.val;\n    &#125;\n\n    // 在链表的第一个元素之前添加一个值为 val的节点。插入后，新节点将成为链表的第一个节点。\n    addAtHead(val: number): void &#123;\n        let node: ListNode = new ListNode(val, this.head);\n        this.head = node;\n        if (!this.tail) &#123;\n            this.tail = node;\n        &#125;\n        this.size++;\n    &#125;\n\n    // 将值为 val 的节点追加到链表的最后一个元素。\n    addAtTail(val: number): void &#123;\n        let node: ListNode = new ListNode(val, null);\n        if (this.tail) &#123;\n            this.tail.next = node;\n        &#125; else &#123;\n            // 还没有尾节点，说明一个节点都还没有\n            this.head = node;\n        &#125;\n        this.tail = node;\n        this.size++;\n    &#125;\n\n    // 在链表中的第 index个节点之前添加值为 val的节点。\n    // 如果 index等于链表的长度，则该节点将附加到链表的末尾。如果 index大于链表长度，则不会插入节点。如果 index小于0，则在头部插入节点。\n    addAtIndex(index: number, val: number): void &#123;\n        if (index === this.size) &#123;\n            this.addAtTail(val);\n            return;\n        &#125;\n        if (index &gt; this.size) &#123;\n            return;\n        &#125;\n        // &lt;= 0 的情况都是在头部插入\n        if (index &lt;= 0) &#123;\n            this.addAtHead(val);\n            return;\n        &#125;\n        // 正常情况\n        // 获取插入位置的前一个 node\n        let curNode = this.getNode(index - 1);\n        let node: ListNode = new ListNode(val, curNode.next);\n        curNode.next = node;\n        this.size++;\n    &#125;\n\n    // 如果索引 index有效，则删除链表中的第 index个节点。\n    deleteAtIndex(index: number): void &#123;\n        if (index &lt; 0 || index &gt;= this.size) &#123;\n            return;\n        &#125;\n        // 处理头节点\n        if (index === 0) &#123;\n            this.head = this.head!.next;\n            // 如果链表中只有一个元素，删除头节点后，需要处理尾节点\n            if (index === this.size - 1) &#123;\n                this.tail = null\n            &#125;\n            this.size--;\n            return;\n        &#125;\n        // 索引有效\n        let curNode: ListNode = this.getNode(index - 1);\n        curNode.next = curNode.next!.next;\n        // 处理尾节点\n        if (index === this.size - 1) &#123;\n            this.tail = curNode;\n        &#125;\n        this.size--;\n    &#125;\n\n    // 获取指定 Node节点\n    private getNode(index: number): ListNode &#123;\n        // 这里不存在没办法获取到节点的情况，都已经在前置方法做过判断\n        // 创建虚拟头节点\n        let curNode: ListNode = new ListNode(0, this.head);\n        for (let i = 0; i &lt;= index; i++) &#123;\n            // 理论上不会出现 null\n            curNode = curNode.next!;\n        &#125;\n        return curNode;\n    &#125;\n&#125;\n</code></pre>\n<p>【练习：206反转链表】</p>\n<p>双指针法：</p>\n<pre><code class=\"ts\">     var reverseList= function(head:ListNode | null):ListNode | null&#123;\n         let pre:ListNode | null=null;\n         let curNode:ListNode | null = head;\n         let tempNode:ListNode | null;\n            while(curNode)&#123;\n                tempNode=curNode.next;\n                [curNode.next,pre]=[pre,curNode]\n                curNode=tempNode;\n            &#125;\n            return pre;\n     &#125;\n</code></pre>\n<p>递归法（从前往后翻转）：</p>\n<pre><code class=\"ts\">function reverseList(head:ListNode | null):ListNode | null&#123;\n    function recur(preNode:ListNode | null,curNode:ListNode | null):ListNode | null&#123;\n        if(curNode===null) return preNode;\n        let tempNode:ListNode | null = curNode.next;\n        curNode.next = preNode;\n        preNode = curNode;\n        curNode = tempNode;\n        return recur(preNode,curNode)\n    &#125;\n    return recur(null,head)\n&#125;\n</code></pre>\n<p>【练习：24两两交换链表中的节点】</p>\n<pre><code class=\"js\">var swapPairs = function(head) &#123;\n    // 首先创建一个新的节点\n    const res = new ListNode(0,head);\n    let temp = res;\n    while(temp &amp;&amp; temp.next &amp;&amp; temp.next.next)&#123;\n        const node1 = temp.next;\n        const node2 = temp.next.next;\n        temp.next=node2;\n        node1.next=node2.next;\n        node2.next=node1;\n        temp=node1;\n    &#125;\n    return res.next;\n&#125;;\n</code></pre>\n<p>【练习：19删除链表的倒数第N个节点】</p>\n<p>双指针</p>\n<pre><code class=\"js\">var removeNthFromEnd = function(head, n) &#123;\n    let pre = new ListNode(0,head),tail =head;\n    let res = pre;\n    while(n--)&#123;\n        tail=tail.next\n    &#125;\n    while(tail)&#123;\n        tail=tail.next;\n        pre=pre.next;\n    &#125;\n    pre.next=pre.next.next;\n    return res.next;\n&#125;;\n</code></pre>\n<p>【练习：160相交链表】</p>\n<p>时间复杂度：O(n) 或 O(m)</p>\n<pre><code class=\"js\">function getListLen(list)&#123;\n    let len=0 , head = list;\n    while(head)&#123;\n        len++;\n        head=head.next\n    &#125;\n    return len;\n&#125;\nfunction getIntersectionNode(head1,head2)&#123;\n    let len1 = getListLen(head1),len2 = getListLen(head2),shortList=head1,bigList=head2;\n    if(len2 &lt; len1)&#123;\n        shortList = head2;\n        bigList = head1;\n    &#125;\n    let i = Math.abs(len1 - len2);\n    while(i-- &gt; 0)&#123;\n        bigList=bigList.next;\n    &#125;\n    while(bigList &amp;&amp; bigList !== shortList)&#123;\n        bigList=bigList.next;\n        shortList=shortList.next;\n    &#125;\n        return bigList\n&#125;\n</code></pre>\n<p>【练习：142环形链表】</p>\n<pre><code class=\"js\">var detectCycle = function(head) &#123;\n    if(!head || !head.next) return null;\n    let slow = head.next,fast = head.next.next;\n    //当快慢指针都有值，并且快指针和慢指针不相等时循环\n    while(fast &amp;&amp; fast.next &amp;&amp; fast !== slow)&#123;\n        slow = slow.next;\n        fast = fast.next.next;\n    &#125;\n    //此时判断是由于遍历结束，还是两值相等（有环）\n    if(!fast || !fast.next) return null;\n    slow = head;\n    while(fast !== slow)&#123;\n        slow = slow.next;\n        fast = fast.next;\n    &#125;\n    return slow;\n&#125;;\n</code></pre>\n<h2 id=\"哈希算法：\"><a href=\"#哈希算法：\" class=\"headerlink\" title=\"哈希算法：\"></a>哈希算法：</h2><h4 id=\"理论-2\"><a href=\"#理论-2\" class=\"headerlink\" title=\"理论\"></a>理论</h4><p>1 哈希表</p>\n<p>也称散列表，数组就是一张哈希表，哈希表将元素和数组的下标相对应，这样就可以快速查询到数组中的某个元素。一般哈希表用于快速判断一个元素是否出现在集合里。如果查询数组中是否有某个元素，或者获取该元素，需要遍历整个数组（O(n)），但要是查询哈希表中是否有某个元素，只需要找数组对应下标的元素。</p>\n<p>其中关键在于将元素和数组下标对应起来，这就是哈希函数:</p>\n<p>2 哈希函数</p>\n<p>哈希函数通过算法，将元素和数组下标对应起来，例如当存储元素为a-z的字母时，可以巧妙使用Unicode值：</p>\n<pre><code class=\"js\">const hashArr = [];\nfunction hashFn(str)&#123;\n    const index = str.charCodeAt() - &#39;a&#39;.charCodeAt();\n    hashArr[index] = str;\n&#125;\n</code></pre>\n<p>但是，某情况下无法避免两个元素所计算的下标相同的情况（哈希碰撞）</p>\n<p>3 哈希碰撞</p>\n<p>两个不同元素，通过哈希函数所计算出来的下标相同。</p>\n<p>4 拉链法</p>\n<p>拉链法用于解决哈希碰撞，发生碰撞的时候，将碰撞处以链表形式添加，就是适当选择哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多空间。</p>\n<p>5 线性探测法</p>\n<p>线性探测法当发生哈希碰撞时，根据碰撞位置向下寻找，知道找到空位。</p>\n<h4 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【242】有效的字母异位词</p>\n<pre><code class=\"js\">var isAnagram = function(s, t) &#123;\n    if(s.length !== t.length) return false;\n    const arr = new Array(26).fill(0);\n    const base = &quot;a&quot;.charCodeAt();\n    for(const i of s)&#123;\n        arr[i.charCodeAt() - base]++;\n    &#125;\n    for(const i of t)&#123;\n        if(!arr[i.charCodeAt() - base]) return false;\n        arr[i.charCodeAt() - base]--;\n    &#125;\n    return true;\n&#125;;\n</code></pre>\n<p>【349】两个数组的交集</p>\n<pre><code class=\"js\">var intersection = function(nums1, nums2) &#123;\n    const res = []\n    const map = new Map()\n    nums1.forEach(item=&gt;&#123;\n        map.set(item,true);\n    &#125;)\n    nums2.forEach(item=&gt;&#123;\n        if(map.get(item))&#123;\n            res.push(item);\n            map.delete(item);\n        &#125;\n    &#125;)\n    return res\n&#125;;\n</code></pre>\n<pre><code class=\"js\">var intersection = function(nums1, nums2) &#123;\n  return Array.from(new Set(nums1.filter(item=&gt;nums2.includes(item))));\n&#125;;\n</code></pre>\n<p>【202】快乐数</p>\n<pre><code class=\"js\">var getSum = function (n) &#123;\n    let sum = 0;\n    while (n) &#123;\n        sum += (n % 10) ** 2;\n        n =  Math.floor(n/10);\n    &#125;\n    return sum;\n&#125;\nvar isHappy = function(n) &#123;\n    let set = new Set();   // Set() 里的数是惟一的\n    // 如果在循环中某个值重复出现，说明此时陷入死循环，也就说明这个值不是快乐数\n    while (n !== 1 &amp;&amp; !set.has(n)) &#123;\n        set.add(n);\n        n = getSum(n);\n    &#125;\n    return n === 1;\n&#125;;\n</code></pre>\n<p>【1】两数之和</p>\n<pre><code class=\"js\">var twoSum =function (nums,target)&#123;\n    const map =new Map();\n    for (let i =0;i&lt;nums.length;i+=1)&#123;\n    const n= nums[i];\n    const n2 =target -n;\n    if (map.has(n2))&#123;\n        return [map.get(n2),i];\n    &#125;\n    else&#123;\n         map.set(n,i); \n    &#125;\n &#125;\n&#125;\n</code></pre>\n<p>【454】四数相加 ||</p>\n<pre><code class=\"js\">var fourSumCount = function(nums1, nums2, nums3, nums4) &#123;\n    const towSumMap = new Map();\n    let count = 0;\n    for(const n1 of nums1)&#123;\n        for(const n2 of nums2)&#123;\n            const sum = n1 + n2;\n            //如果map中有sum就get++，如果map中没有sum就set\n            towSumMap.set(sum,(towSumMap.get(sum) || 0) + 1);\n        &#125;\n    &#125;\n    for(const n3 of nums3)&#123;\n        for(const n4 of nums4)&#123;\n            const sum = n3 + n4;\n            count += towSumMap.get(-sum) || 0;\n        &#125;\n    &#125;\n    return count;\n&#125;;\n</code></pre>\n<p>【383】赎金信</p>\n<pre><code class=\"js\">var canConstruct = function(ransomNote, magazine) &#123;\n    if(magazine.length&lt;ransomNote.length) return false;\n    const arr = new Array(26).fill(0);\n    const base = &quot;a&quot;.charCodeAt();\n    for(let i of magazine)&#123;\n        arr[i.charCodeAt()-base]++;\n    &#125;\n    for(let i of ransomNote)&#123;\n        let index = i.charCodeAt()-base;\n        if(arr[index]===0)&#123;\n            return false\n        &#125;\n        arr[index]--;\n    &#125;\n    return true;\n&#125;;\n</code></pre>\n<p>【15】三数之和</p>\n<pre><code class=\"js\">var threeSum = function(nums) &#123;\n    const res = [],len = nums.length;\n    //将数组排序\n    nums.sort((a,b)=&gt;a-b);\n    console.log(nums);\n    //遍历数组\n    for(let i = 0;i&lt;len;i++)&#123;\n        let l = i+1, r = len-1,iNum = nums[i];\n        //判断首元素\n        if(nums[i]&gt;0) return res;\n        if(iNum == nums[i-1]) continue;\n        while(l&lt;r)&#123;\n            let lNum = nums[l],rNum = nums[r],threeSum = iNum+lNum+rNum;\n            console.log(iNum,lNum,rNum);\n            console.log(threeSum);\n            if(threeSum&lt;0) l++;\n            else if(threeSum&gt;0) r--;\n            else&#123;\n                res.push([iNum,lNum,rNum]);\n                //去重\n                while(l&lt;r &amp;&amp; nums[l]==nums[l+1])&#123;\n                    l++;\n                &#125;\n                while(l&lt;r &amp;&amp; nums[r]==nums[r-1])&#123;\n                    r--;\n                &#125;\n                l++;\n                r--;\n            &#125;\n        &#125;\n    &#125;\n    return res\n&#125;;\n</code></pre>\n<p>【18】四数之和   <strong>难点</strong></p>\n<pre><code class=\"js\">var fourSum = function(nums, target) &#123;\n    const len = nums.length;\n    if(len&lt;4) return [];\n    nums.sort((a,b)=&gt;a-b);\n    const res = [];\n    for(let i=0;i&lt;len-3;i++)&#123;\n        //去重\n        if(i&gt;0 &amp;&amp; nums[i] === nums[i-1]) continue;\n        for(let j =i+1;j&lt;len-2;j++)&#123;\n            // 去重\n            if(j&gt;i+1 &amp;&amp; nums[j]===nums[j-1]) continue;\n            let l = j+1,r = len-1;\n            while(l&lt;r)&#123;\n                const sum = nums[i]+nums[j]+nums[l]+nums[r];\n                if(sum&lt;target)&#123; l++;continue &#125;\n                if(sum&gt;target)&#123; r--;continue &#125;\n                res.push([nums[i],nums[j],nums[l],nums[r]]);\n                while(l&lt;r &amp;&amp; nums[l]===nums[++l]);\n                while(l&lt;r &amp;&amp; nums[r]===nums[--r]);\n            &#125;\n        &#125;\n    &#125;\n    return res;\n&#125;;\n</code></pre>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h4 id=\"题目-2\"><a href=\"#题目-2\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【27】移除元素</p>\n<pre><code class=\"js\">let removeElement = (nums,val)=&gt;&#123;\n    let k =0;\n    for(let i of nums)&#123;\n        if(i != val)&#123;\n            nums[k++]=i;\n        &#125;\n    &#125;\n    return k;\n&#125;\n</code></pre>\n<p>【344】反转字符串</p>\n<pre><code class=\"js\">var reverse = function(s) &#123;\n    let l = -1, r = s.length;\n    while(++l &lt; --r) [s[l], s[r]] = [s[r], s[l]];\n    return s;\n&#125;;\n</code></pre>\n<p>【】替换数字</p>\n<pre><code class=\"js\">let replaceNumber = (nums)=&gt;&#123;\n    let str = &#39;&#39;;\n    for(let i of nums)&#123;\n        if(!Object.is(Number(i),NaN))&#123;\n        console.log(i);\n        str += &#39;number&#39;;\n        &#125;else&#123;\n            str += i;\n        &#125;\n    &#125;\n    return str;\n&#125;\n</code></pre>\n<p>【151】翻转字符串里的单词</p>\n<pre><code class=\"js\">/**\n * 删除前后的空格\n */\nfunction removeExtraSpaces(strArr)&#123;\n    let slowIndex = 0,fastIndex = 0;\n    while(fastIndex &lt; strArr.length)&#123;\n        if(strArr[fastIndex] === &#39; &#39; &amp;&amp; (fastIndex === 0 || strArr[fastIndex -1]===&#39; &#39;))&#123;\n            fastIndex++;\n        &#125;else&#123;\n            strArr[slowIndex++] = strArr[fastIndex++];\n        &#125;\n    &#125;\n    // 移除末尾的空格\n    strArr.length = strArr[slowIndex -1] === &#39; &#39; ? slowIndex -1:slowIndex;\n&#125;\n/**\n * 翻转从start到end的字符\n */\nfunction reverse(strArr,start,end)&#123;\n    let left = start;\n    let right = end;\n    while(left &lt; right)&#123;\n        [strArr[left],strArr[right]] = [strArr[right],strArr[left]];\n        left ++;\n        right\n    &#125;\n&#125;\n/**\n * 翻转字符串\n */\nfunction reverseWords(s)&#123;\n    const strArr = Array.from(s);\n    removeExtraSpaces(strArr);\n    reverse(strArr,0,strArr.length - 1);\n    let start = 0;\n    for(let i=0;i&lt;=strArr.length;i++)&#123;\n        if(strArr[i] === &#39; &#39; || i === strArr.length)&#123;\n            reverse(strArr,start,i -1);\n            start = i+i;\n        &#125;\n    &#125;\n    return strArr.join(&#39;&#39;);\n&#125;\n</code></pre>\n<p> 【28】实现strStr()</p>\n<p>自己实现：</p>\n<pre><code class=\"js\">var strStr = function(str1, str2) &#123;\n    if(str2.length === 0) return 0;\n    if(str2.length &gt; str1.length) return -1;\n    let l=0, r =0,len = str1.length,len2;\n    while(l &lt; len)&#123;\n         if(str1[l] === str2[0])&#123;\n            if(str2.length===1) return l;\n            let i=1;\n            for(;i&lt;str2.length;i++)&#123;\n                if(str1[l+i] != str2[i])&#123;\n                    break;\n                &#125;\n            &#125;\n            len2 = i-1;\n         &#125;\n         if(len2===str2.length-1)&#123;\n            return l;\n         &#125;\n         l++;\n    &#125;\n    return -1;\n&#125;;\n</code></pre>\n<p> next数组前缀表统一减一</p>\n<pre><code class=\"js\">var strStr = function (haystack, needle) &#123;\n    if (needle.length === 0)\n        return 0;\n\n    const getNext = (needle) =&gt; &#123;\n        let next = [];\n        let j = -1;\n        next.push(j);\n\n        for (let i = 1; i &lt; needle.length; ++i) &#123;\n            while (j &gt;= 0 &amp;&amp; needle[i] !== needle[j + 1])\n                j = next[j];\n            if (needle[i] === needle[j + 1])\n                j++;\n            next.push(j);\n        &#125;\n\n        return next;\n    &#125;\n\n    let next = getNext(needle);\n    let j = -1;\n    for (let i = 0; i &lt; haystack.length; ++i) &#123;\n        while (j &gt;= 0 &amp;&amp; haystack[i] !== needle[j + 1])\n            j = next[j];\n        if (haystack[i] === needle[j + 1])\n            j++;\n        if (j === needle.length - 1)\n            return (i - needle.length + 1);\n    &#125;\n\n    return -1;\n&#125;;\n</code></pre>\n<p> 【459】重复的子字符串</p>\n<pre><code class=\"js\">var repeatedSubstringPattern = function (s) &#123;\n    let str = s + s;\n    return str.slice(1, str.length - 1).includes(s);\n&#125;;\n</code></pre>\n<p>next数组实现</p>\n<pre><code class=\"js\">var repeatedSubstringPattern = function (s) &#123;\n    if (s.length === 0) return false;\n    const getNext = (s) =&gt; &#123; //得到next数组\n        let next = [];\n        let j = -1;\n        next.push(j); //next数组第一个是-1\n        for (let i = 1; i &lt; s.length; ++i) &#123; //遍历s的长度\n            while (j &gt;= 0 &amp;&amp; s[i] !== s[j + 1]) \n                j = next[j];\n            if (s[i] === s[j + 1])\n                j++;\n            next.push(j);\n        &#125;\n        return next;\n    &#125;\n    let next = getNext(s); //得到next数组\n    if (next[next.length - 1] !== -1 &amp;&amp; s.length % (s.length - (next[next.length - 1] + 1)) === 0)&#123;\n        // next数组最后一个元素不等于-1 并且 字符串的长度取余next数组最后一个元素\n        return true;\n    &#125;\n    return false;\n&#125;;\n</code></pre>\n<h2 id=\"双指针算法\"><a href=\"#双指针算法\" class=\"headerlink\" title=\"双指针算法\"></a>双指针算法</h2><h4 id=\"题目-3\"><a href=\"#题目-3\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【27】移除元素</p>\n<pre><code class=\"js\">var removeElement = function(nums, val) &#123;\n    let i =0 ,len = nums.length-1;\n    while(i&lt;=len)&#123;\n        if(nums[i]===val)&#123;\n            nums[i]=nums[len];\n            len--;\n            i--;\n        &#125;\n        i++;\n    &#125;\n    nums.length = len+1;\n    return len+1;\n&#125;;\n</code></pre>\n<p>【344】反转字符串</p>\n<pre><code class=\"js\">var reverseString = function(s) &#123;\n    let i =0,j=s.length-1;\n    while(i&lt;=j)&#123;\n        [s[i],s[j]] = [s[j],s[i]];\n        j--;\n        i++;\n    &#125;\n    return s;\n&#125;;\n</code></pre>\n<p>【】替换数字</p>\n<pre><code class=\"js\">function reverseNumber(str)&#123;\n    let i = 0,res = &#39;&#39;;\n    while(i&lt;str.length)&#123;\n        if(Object.is(+str[i],NaN))&#123;\n            console.log(str[i]);\n            res+=str[i]\n        &#125;else&#123;\n            console.log(str[i]);\n            res+=&#39;number&#39;;\n        &#125;\n        i++;\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<p>【151】翻转字符串里的单词</p>\n<pre><code class=\"js\">var reverseWords = function(s) &#123;\n    return s.split(/\\s+/).reverse().join(&#39; &#39;).trim();\n&#125;;\n</code></pre>\n<p>【160】链表相交</p>\n<p>链表后长度统一：</p>\n<pre><code class=\"js\">\nfunction getListLen(list)&#123;\n    let len=0 , head = list;\n    while(head)&#123;\n        len++;\n        head=head.next\n    &#125;\n    return len;\n&#125;\nfunction getIntersectionNode(head1,head2)&#123;\n    let len1 = getListLen(head1),len2 = getListLen(head2),shortList=head1,bigList=head2;\n    if(len2 &lt; len1)&#123;\n        shortList = head2;\n        bigList = head1;\n    &#125;\n    let i = Math.abs(len1 - len2);\n    while(i-- &gt; 0)&#123;\n        bigList=bigList.next;\n    &#125;\n    while(bigList &amp;&amp; bigList !== shortList)&#123;\n        bigList=bigList.next;\n        shortList=shortList.next;\n    &#125;\n        return bigList\n&#125;\n</code></pre>\n<h2 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h2><p>队列是先进先出，栈是先进后出。</p>\n<h4 id=\"题目-4\"><a href=\"#题目-4\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【232】用栈实现队列</p>\n<pre><code class=\"js\">//实现链表\nclass listNode &#123;\n    constructor(val,next=null)&#123;\n        this.val = val;\n        this.next = next;\n    &#125;\n&#125;\n//实现栈\nclass Stack&#123;\n    constructor()&#123;\n         this.items = []\n    &#125;\n&#125;\nStack.prototype.push = function(val)&#123;\n    return this.items.push(val);\n&#125;\nStack.prototype.pop = function()&#123;\n    return this.items.pop();\n&#125;\nStack.prototype.peek = function()&#123;\n    return this.items[this.items.length - 1]\n&#125;\nStack.prototype.isEmpty = function()&#123;\n    return this.items.length === 0;\n&#125;\nStack.prototype.size = function()&#123;\n    return this.items.length;\n&#125;\n//用栈实现队列\nclass MyQueue&#123;\n    constructor()&#123;\n        this.stackIn = new Stack();\n        this.stackOut = new Stack();\n    &#125;\n&#125;\n\nMyQueue.prototype.push = function(x) &#123;\n    this.stackIn.push(x);\n&#125;;\n\nMyQueue.prototype.pop = function() &#123;\n    const size = this.stackOut.size();\n    if(size)&#123;\n        return this.stackOut.pop();\n    &#125;\n    while(this.stackIn.size())&#123;\n        this.stackOut.push(this.stackIn.pop());\n    &#125;\n    return this.stackOut.pop();\n&#125;;\n\nMyQueue.prototype.peek = function() &#123;\n    const size = this.stackOut.size();\n    if(size) &#123;\n        return this.stackOut[this.stackOut.size() - 1];\n    &#125;\n    while(this.stackIn.size())&#123;\n        this.stackOut.push(this.stackIn.pop());\n    &#125;\n    return this.stackOut.peek();\n&#125;;\n\nMyQueue.prototype.empty = function() &#123;\n    return !this.stackOut.size() &amp;&amp; !this.stackIn.size()\n&#125;;\n</code></pre>\n<p>【225】用队列实现栈</p>\n<pre><code class=\"js\">//队列模拟栈\nclass Queue &#123;\n    constructor()&#123;\n        this.items = [];\n    &#125;\n&#125;\nQueue.prototype.shift = function()&#123;\n    return this.items.shift();\n&#125;\nQueue.prototype.push = function(val)&#123;\n    return this.items.push(val);\n&#125;\nQueue.prototype.size = function()&#123;\n    return this.items.length;\n&#125;\nQueue.prototype.peek = function()&#123;\n    return this.items[0];\n&#125;\n\nclass Stack&#123;\n    constructor()&#123;\n        this.queueIn = new Queue();\n        this.queueOut = new Queue();\n    &#125;\n&#125;\nStack.prototype.push = function(val)&#123;\n    this.queueIn.push(val);\n&#125;\nStack.prototype.pop = function()&#123;\n    if(!this.queueIn.size())&#123;\n        [this.queueIn,this.queueOut] = [this.queueOut,this.queueIn];\n    &#125;\n    while(this.queueIn.size() &gt; 1)&#123;\n        this.queueOut.push(this.queueIn.shift());\n    &#125;\n    return this.queueIn.shift();\n&#125;\nStack.prototype.top = function()&#123;\n    const x = this.pop();\n    this.queueIn.push(x);\n    return x;\n&#125;\nStack.prototype.empty = function()&#123;\n    return !this.queueIn.size() &amp;&amp; !this.queueOut.size()\n&#125;\n</code></pre>\n<p>【1047】删除字符串中的所有相邻重复项</p>\n<pre><code class=\"js\">const removeDuplicates = (str)=&gt;&#123;\n    //使用栈\n    const resArr = []\n    for(let i of str)&#123;\n        if(resArr[resArr.length - 1] === i)&#123;\n            resArr.pop();\n        &#125;else&#123;\n            resArr.push(i);\n        &#125;\n    &#125;\n    return resArr.join(&#39;&#39;)\n&#125;\n</code></pre>\n<p>【150】逆波兰表达式求值</p>\n<pre><code class=\"js\">/**\n * @param &#123;string[]&#125; tokens\n * @return &#123;number&#125;\n */\nvar evalRPN = function(tokens) &#123;\n    //维持一个栈\n    const stack = [];\n    for(const token of tokens)&#123;\n        if(isNaN(+token))&#123;\n            const n2 = stack.pop();\n            const n1 = stack.pop();\n            switch(token)&#123;\n                case &quot;+&quot;:\n                     stack.push(n1 + n2);\n                     break;\n                case &quot;-&quot;:\n                     stack.push(n1 - n2);\n                     break;\n                case &quot;*&quot;:\n                     stack.push(n1 * n2);\n                     break;\n                case &quot;/&quot;:\n                     stack.push(n1 / n2 | 0);\n                     break;\n            &#125;\n        &#125;else&#123;\n            stack.push(+token);\n        &#125;\n    &#125;\n    return stack[0];\n&#125;;\n</code></pre>\n<p>【239】滑动窗口最大值（难点）</p>\n<p>使用队列：</p>\n<pre><code class=\"js\">var maxSlidingWindow = function (nums, k) &#123;\n    class MonoQueue &#123;\n        queue;\n        constructor() &#123;\n            this.queue = [];\n        &#125;\n        enqueue(value) &#123;\n            let back = this.queue[this.queue.length - 1];\n            while (back !== undefined &amp;&amp; back &lt; value) &#123;\n                this.queue.pop();\n                back = this.queue[this.queue.length - 1];\n            &#125;\n            this.queue.push(value);\n        &#125;\n        dequeue(value) &#123;\n            let front = this.front();\n            if (front === value) &#123;\n                this.queue.shift();\n            &#125;\n        &#125;\n        front() &#123;\n            return this.queue[0];\n        &#125;\n    &#125;\n    let helperQueue = new MonoQueue();\n    let i = 0, j = 0;\n    let resArr = [];\n    while (j &lt; k) &#123;\n        helperQueue.enqueue(nums[j++]);\n    &#125;\n    resArr.push(helperQueue.front());\n    while (j &lt; nums.length) &#123;\n        helperQueue.enqueue(nums[j]);\n        helperQueue.dequeue(nums[i]);\n        resArr.push(helperQueue.front());\n        i++, j++;\n    &#125;\n    return resArr;\n&#125;;\n</code></pre>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>1、满二叉树</p>\n<p>如果一棵二叉树只有度为0的结点和度为2的结点，并且<strong>度为0的结点在同一层上</strong>，则这颗二叉树就为满二叉树。</p>\n<p>2、完全二叉树</p>\n<p>在完全二叉树中，除了最底层节点可能没填满之外，其余每层结点数都达到最大值，并且最下面一层的结点都集中在该层最左边的若干位置。</p>\n<p>3、二叉搜索树</p>\n<p>二叉搜索树是一个有序树（左&lt;中&lt;右的排序向下递归）：</p>\n<ul>\n<li>若左子树不空，则左子树所有结点均小于它的根节点的值</li>\n<li>若右子树不空，则右子树上所有结点的值均大于它的根节点的值</li>\n<li>它的左右子树也分别为二叉搜索树</li>\n</ul>\n<p>4、平衡二叉树（左子树右子树高度差不超过1的方式向下递归）</p>\n<p>平衡二叉树是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。</p>\n<p>5、红黑树</p>\n<p>当二叉搜索树插入序列是有序的时候会出现退化的情况，变成链表（查询速度变慢），这时使用平衡树，在插入的时候调整这棵树，让它的节点尽可能地均匀分布，变为平衡二叉搜索树。</p>\n<p>红黑树其实就是平衡树的一种，它的复杂定义和规则都是为了保证树的平衡性。红黑树是一种更为宽松的二叉平衡搜索树，相对于二叉平衡搜索树，它的平衡条件更加宽松，可以容忍一定程度的不平衡。</p>\n<p>保证树的平衡的意义：因为树的查找性能取决于树的高度，让树尽可能平衡就是为了降低树的高度。</p>\n<p>6、B树</p>\n<p>B树是一种<strong>多路搜索树</strong>，它的每个节点可以拥有多于两个孩子节点。M路的B树最多能拥有M个孩子节点。路数越多，树的高度越低。不限制路数，B树就退化成一个有序数组了。</p>\n<p><strong>B树常用于文件系统的索引</strong>，文件系统和数据库的索引都是存在硬盘上的，如果数据量大的话，不一定能一次性加载到内存中（运行时内存）。这时就需要使用<strong>B树多路存储</strong>的威力，可以每次加载B树的一个节点，然后一步步往下找。</p>\n<p>在内存中，红黑树确实比B树效率更高，但是当涉及到磁盘操作时，B树就更优了。</p>\n<p>7、B+树</p>\n<p>B+树是在B树的基础上进行改造的，它的数据都在叶子节点，同时叶子节点之间还加了指针形成链表。</p>\n<p><strong>B+树在数据库索引中用的比较多</strong>，数据库中 Select 数据，不一定只选一条，很多时候会选多条。如果是多条的话，B 树需要做局部的中序遍历，可能要跨层访问。而 B+ 树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p>\n<h4 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h4><ul>\n<li><p>用数组存储：如果父节点数组下标是i，则它的左孩子就是  i * 2 + 1 , 右孩子就是  i * 2 + 2 </p>\n</li>\n<li><p>用链表存储：用左右指针进行存储</p>\n<pre><code class=\"ts\">class TreeNode &#123;\n    public val: number;\n    public left: TreeNode | null\n    public right: TreeNode | null\n    constructor(val: number,left?: TreeNode,right?: TreeNode)&#123;\n        this.val = val === undefined ? 0 : val;\n        this.left = left === undefined ? null : left;\n        this.right = left === undefined ? null : right;\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><p>二叉树的遍历方式有：（中间节点的顺序就是所谓的遍历方式）</p>\n<ul>\n<li>前序遍历：中 左 右</li>\n<li>中序遍历：左 中 右</li>\n<li>后序遍历： 左 右 中</li>\n</ul>\n<p><strong>二叉树的递归遍历：</strong></p>\n<pre><code class=\"ts\">// 前序遍历\nfunction preorderTracersal(node:TreeNode | null): number[]&#123;\n    function traverse(node:TreeNode | null,res: number[]):void &#123;\n        if(node === null) return ;\n        res.push(node.val);\n        traverse(node.left,res);\n        traverse(node.right,res);//中序遍历和后序遍历除了此处顺序不同之外，其余都相同\n    &#125;\n    const res: number[] = [];\n    traverse(node,res);\n    return res;\n&#125;\n</code></pre>\n<p><strong>二叉树的迭代遍历（需要维持一个栈）：</strong></p>\n<pre><code class=\"ts\">// 前序遍历（迭代法）\nfunction preorderTraversal(root: TreeNode | null): number[] &#123;\n    if (root === null) return [];\n    let res: number[] = [];\n    let helperStack: TreeNode[] = [];\n    let curNode: TreeNode = root;\n    helperStack.push(curNode);\n    while (helperStack.length &gt; 0) &#123;\n        curNode = helperStack.pop()!;\n        res.push(curNode.val);\n        if (curNode.right !== null) helperStack.push(curNode.right);\n        if (curNode.left !== null) helperStack.push(curNode.left);\n    &#125;\n    return res;\n&#125;;\n\n// 中序遍历（迭代法）\nfunction inorderTraversal(root: TreeNode | null): number[] &#123;\n    let helperStack: TreeNode[] = [];\n    let res: number[] = [];\n    if (root === null) return res;\n    let curNode: TreeNode | null = root;\n    while (curNode !== null || helperStack.length &gt; 0) &#123;\n        if (curNode !== null) &#123;\n            helperStack.push(curNode);\n            curNode = curNode.left;\n        &#125; else &#123;\n            curNode = helperStack.pop()!;\n            res.push(curNode.val);\n            curNode = curNode.right;\n        &#125;\n    &#125;\n    return res;\n&#125;;\n\n// 后序遍历（迭代法）\nfunction postorderTraversal(root: TreeNode | null): number[] &#123;\n    let helperStack: TreeNode[] = [];\n    let res: number[] = [];\n    let curNode: TreeNode;\n    if (root === null) return res;\n    helperStack.push(root);\n    while (helperStack.length &gt; 0) &#123;\n        curNode = helperStack.pop()!;\n        res.push(curNode.val);\n        if (curNode.left !== null) helperStack.push(curNode.left);\n        if (curNode.right !== null) helperStack.push(curNode.right);\n    &#125;\n    return res.reverse();\n&#125;;\n</code></pre>\n<h1 id=\"最长递增子序列\"><a href=\"#最长递增子序列\" class=\"headerlink\" title=\"最长递增子序列:\"></a>最长递增子序列:</h1><p>在计算机科学中，最长递增子序列问题（英语：longest increasing subsequence problem）的目标是找到一个给定序列的子序列，其中子序列的元素按升序排序，并且子序列尽可能长。该子序列不一定是连续的或唯一的。最长递增连续性是在与数学相关的各种学科的背景下研究的，包括算法论，随机矩阵理论，表示论和物理学。 [<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlI2NpdGVfbm90ZS0x\">1]</span> [<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlI2NpdGVfbm90ZS1yb21pay0y\">2]</span> 最长递增子序列问题在时间上是可解的<img data-src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/497720dca0f6c8c6268f7a1332b993e597136e8b\" alt=\"{\\displaystyle O(n\\log n),}\"> 其中n表示输入序列的长度</p>\n<p>技术blog，云服务器域名。</p>\n","categories":["算法"],"tags":["算法","数据结构"]},{"title":"设计模式","url":"/2024/03/02/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p>\n<ul>\n<li><p>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</p>\n</li>\n<li><p>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</p>\n</li>\n<li><p>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</p>\n</li>\n</ul>\n<p>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思</p>\n<p>每个代理模式的代码都必须自己手动完成一遍。</p>\n<h2 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p>\n<p>工厂模式分为简单工厂模式，工厂模式，抽象工厂模式</p>\n<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<strong>本质就是使用工厂方法代替new操作。</strong></p>\n<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><pre><code class=\"java\">public class FoodFactory &#123;\n    public static Food makeFood(String name) &#123;\n        if (name.equals(&quot;兰州拉面&quot;)) &#123;\n            Food noodle = new LanZhouNoodle();\n            System.out.println(&quot;兰州拉面&quot;+noodle+&quot;出锅啦&quot;);\n            return noodle;\n        &#125; else if (name.equals(&quot;黄焖鸡&quot;)) &#123;\n            Food chicken = new HuangMenChicken();\n            System.out.println(&quot;黄焖鸡&quot;+ chicken +&quot;出锅啦&quot;);\n            return chicken;\n        &#125; else &#123;\n            System.out.println(&quot;不知道你做的什么哦~&quot;);\n            return null;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</p>\n<pre><code class=\"java\">public class Cook &#123;\n    public static void main(String[] args) &#123;\n        Food food = FoodFactory.makeFood(&quot;黄焖鸡&quot;);\n        FoodFactory.makeFood(&quot;jaja&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>简单地说，<strong>简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</strong></p>\n<blockquote>\n<p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p>\n</blockquote>\n<p>在此例中可以看出，Cook 类在使用 FoodFactory 时就不需要 new 任何一个对象，这就是简单工厂模式的好处，封装了 new 的部分，做到的代码易用性。</p>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p>\n<pre><code class=\"java\">public interface FoodFactory &#123;\n    Food makeFood(String name);\n&#125;\npublic class ChineseFoodFactory implements FoodFactory &#123;\n\n    @Override\n    public Food makeFood(String name) &#123;\n        if (name.equals(&quot;A&quot;)) &#123;\n            return new ChineseFoodA();\n        &#125; else if (name.equals(&quot;B&quot;)) &#123;\n            return new ChineseFoodB();\n        &#125; else &#123;\n            return null;\n        &#125;\n    &#125;\n&#125;\npublic class AmericanFoodFactory implements FoodFactory &#123;\n\n    @Override\n    public Food makeFood(String name) &#123;\n        if (name.equals(&quot;A&quot;)) &#123;\n            return new AmericanFoodA();\n        &#125; else if (name.equals(&quot;B&quot;)) &#123;\n            return new AmericanFoodB();\n        &#125; else &#123;\n            return null;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p>\n<p>客户端调用：</p>\n<pre><code class=\"java\">public class APP &#123;\n    public static void main(String[] args) &#123;\n        // 先选择一个具体的工厂\n        FoodFactory factory = new ChineseFoodFactory();\n        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象\n        Food food = factory.makeFood(&quot;A&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>虽然都是调用 makeFood(“A”) 制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p>\n<p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>\n<p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p>\n<h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。 一个经典的例子是造一台电脑 。</p>\n<p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p>\n<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p>\n<p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。</p>\n<p><img data-src=\"/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/3-1Q1141559151S.gif\" alt=\"3-1Q1141559151S\"></p>\n<p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>\n<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>\n<p>使用抽象工厂模式一般要满足以下条件。</p>\n<ul>\n<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>\n<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>\n</ul>\n<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>\n<ul>\n<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>\n<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>\n</ul>\n<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p>\n<p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li>类构造器私有</li>\n<li>持有自己类型的属性</li>\n<li>对外提供获取实例的静态方法</li>\n</ul>\n<p><strong>饿汉式写法</strong></p>\n<pre><code class=\"java\">public class Singleton &#123;  \n   private static Singleton instance = new Singleton();  \n   private Singleton ()&#123;&#125;  \n   public static Singleton getInstance() &#123;  \n   return instance;  \n   &#125;  \n&#125;\n</code></pre>\n<p>弊端：因为类加载的时候就会创建对象，所以有的时候还不需要使用对象，就会创建对象，造成内存的浪费；</p>\n<p><strong>饱汉模式最容易出错：</strong></p>\n<pre><code class=\"java\">public class Singleton &#123;\n    // 首先，也是先堵死 new Singleton() 这条路\n    private Singleton() &#123;&#125;\n    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的\n    private static volatile Singleton instance = null;\n\n    public static Singleton getInstance() &#123;\n        if (instance == null) &#123;\n            // 加锁\n            synchronized (Singleton.class) &#123;\n                // 这一次判断也是必须的，不然会有并发问题\n                if (instance == null) &#123;\n                    instance = new Singleton();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;\n</code></pre>\n<blockquote>\n<p>双重检查，指的是两次检查 instance 是否为 null。</p>\n<p>volatile 在这里是需要的，希望能引起读者的关注。</p>\n<p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p>\n</blockquote>\n<p>嵌套类最经典，以后大家就用它吧：</p>\n<pre><code class=\"java\">public class Singleton &#123;\n\n    private Singleton() &#123;&#125;\n    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性\n    private static class Holder &#123;\n        private static Singleton instance = new Singleton();\n    &#125;\n    public static Singleton getInstance() &#123;\n        return Holder.instance;\n    &#125;\n&#125;\n</code></pre>\n<blockquote>\n<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p>\n</blockquote>\n<p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>\n<p><strong>TODO:</strong></p>\n<p>建造者模式</p>\n<p>原型模式</p>\n<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p>\n<p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p>\n<p>理解<strong>代理</strong>这个词，这个模式其实就简单了。 下面上代码理解。 代理接口：</p>\n<pre><code class=\"java\">//要有一个代理接口让实现类和代理实现类来实现。\npublic interface FoodService &#123;\n    Food makeChicken();\n&#125;\n</code></pre>\n<p>被代理的实现类：</p>\n<pre><code class=\"java\">public class FoodServiceImpl implements FoodService &#123;\n    @Override\n    public Food makeChicken() &#123;\n        Food f = new Chicken();\n        f.setChicken(&quot;1kg&quot;);\n        f.setSpicy(&quot;1g&quot;);\n        f.setSalt(&quot;3g&quot;);\n        System.out.println(&quot;鸡肉加好佐料了&quot;);\n        return f;\n    &#125;\n&#125;\n</code></pre>\n<p>被代理实现类就只需要做自己该做的事情就好了，不需要管别的。</p>\n<p>代理实现类：</p>\n<pre><code class=\"java\">public class FoodServiceProxy implements FoodService &#123;\n    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入\n    private FoodService foodService = new FoodServiceImpl();\n    \n    @Override\n    public Food makeChicken() &#123;\n        System.out.println(&quot;开始制作鸡肉&quot;);\n        \n        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，\n        // 代理只是在核心代码前后做些“无足轻重”的事情\n        Food food = foodService.makeChicken();\n        \n        System.out.println(&quot;鸡肉制作完成啦，加点胡椒粉&quot;);\n        food.addCondiment(&quot;pepper&quot;);\n        System.out.println(&quot;上锅咯&quot;);\n        return food;\n    &#125;\n&#125;\n</code></pre>\n<p>客户端调用，注意，我们要用代理来实例化接口：</p>\n<pre><code class=\"java\">// 这里用代理类来实例化\nFoodService foodService = new FoodServiceProxy();\nfoodService.makeChicken();\n</code></pre>\n<p>所谓代理模式，<strong>就是对被代理方法包装或者叫增强， 在面向切面编程（AOP）中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</strong></p>\n<p>待续。。。</p>\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><h3 id=\"模板模式\"><a href=\"#模板模式\" class=\"headerlink\" title=\"模板模式\"></a>模板模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p>\n<p><strong>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现</strong></p>\n<p>模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p>\n<p>好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好</p>\n<p>缺点： 每一个不同的实现都需要一个子类来实现，导致类个数增加，使系统更加庞大</p>\n<p><strong>模板模式的关键点：</strong></p>\n<p>　　　　1、使用抽象类定义模板类，并在其中定义所有的基本方法、模板方法，钩子方法，不限数量，以实现功能逻辑为主。其中基本方法使用final修饰，其中要调用基本方法和钩子方法，基本方法和钩子方法可以使用protected修饰，表明可被子类修改。</p>\n<p>　　　　2、定义实现抽象类的子类，重写其中的模板方法，甚至钩子方法，完善具体的逻辑。</p>\n<p>　　使用场景：</p>\n<p>　　　　1、在多个子类中拥有相同的方法，而且逻辑相同时，可以将这些方法抽出来放到一个模板抽象类中。</p>\n<p>　　　　2、程序主框架相同，细节不同的情况下，也可以使用模板方法。</p>\n<h4 id=\"架构方法介绍\"><a href=\"#架构方法介绍\" class=\"headerlink\" title=\"架构方法介绍\"></a>架构方法介绍</h4><p>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。其主要分为两大类：模版方法和基本方法，而基本方法又分为：抽象方法（Abstract Method），具体方法（Concrete Method），钩子方法（Hook Method）。</p>\n<p>四种方法的基本定义（前提：在抽象类中定义）：</p>\n<p>（1）抽象方法：由抽象类声明，由具体子类实现，并以abstract关键字进行标识。</p>\n<p>（2）具体方法：由抽象类声明并且实现，子类并不实现或者做覆盖操作。其实质就是普遍适用的方法，不需要子类来实现。</p>\n<p>（3）钩子方法：由抽象类声明并且实现，子类也可以选择加以扩展。通常抽象类会给出一个空的钩子方法，也就是没有实现的扩展。<strong>它和具体方法在代码上没有区别，不过是一种意识的区别</strong>；而它和抽象方法有时候也是没有区别的，就是在子类都需要将其实现的时候。而不同的是抽象方法必须实现，而钩子方法可以不实现。也就是说钩子方法为你在实现某一个抽象类的时候提供了可选项，<strong>相当于预先提供了一个默认配置。</strong></p>\n<p>（4）模板方法：定义了一个方法，其中定义了整个逻辑的基本骨架。</p>\n<pre><code class=\"js\">public abstract class AbstractTemplate &#123;\n    // 这就是模板方法\n    public void templateMethod() &#123;\n        init();\n        apply(); // 这个是重点\n        end(); // 可以作为钩子方法\n    &#125;\n    //这是具体方法\n    protected void init() &#123;\n        System.out.println(&quot;init 抽象层已经实现，子类也可以选择覆写&quot;);\n    &#125;\n\n    // 这是抽象方法，留给子类实现\n    protected abstract void apply();\n    //这是钩子方法，可定义一个默认操作，或者为空\n    protected void end() &#123;\n    &#125;\n&#125;\n</code></pre>\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"自动化测试","url":"/2024/03/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","content":"<h1 id=\"5-3-自动化测试\"><a href=\"#5-3-自动化测试\" class=\"headerlink\" title=\"5-3 自动化测试\"></a>5-3 自动化测试</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>在前端界，浏览器兼容性是让工程师们头疼的问题，对于经验丰富的人来说，很清楚浏览器有哪些坑，但是对于大部分程序员，最可怕的是代码明明在这个浏览器运行得很好，但是到了另一个浏览器中就不能正常运行了。对于这部分的程序员，保障代码能正常运行的方法便是能尽早发现问题，然后将其解决。</p>\n<p><strong>前端项目如何做测试？</strong></p>\n<ul>\n<li>测试同学：功能测试，性能测试，测试用例</li>\n<li>前端同学：单元测试，常用于组件库、AP等(Jest、Mocha),上线项目如何做测试？</li>\n</ul>\n<p><strong>上线项目如何进行测试</strong></p>\n<ul>\n<li>利用前端监控，进行监控项目稳定性和性能，并上报前端日志</li>\n<li>稳定性：如ljserror、白屏检测等</li>\n<li>性能：如秒开率、首屏渲染时长、接请求时长等</li>\n<li>前端日志：如console.log、API请求记录等</li>\n</ul>\n<p><strong>为什么需要自动化测试？</strong></p>\n<p>项目经过不断的开发，最终肯定会趋于稳定，在<strong>适当的时机下</strong>引入自动化测试能及早发现问题，<strong>保证产品的质量</strong>。</p>\n<p>测试作为完整的开发流程中最后的一环，是保证产品质量重要的一环。而前端测试一般在产品开发流程中属于偏后的环节，在整个开发架构中属于较高层次，前端测试更加偏向于GUI的特性，因此前端的测试难度很大。</p>\n<p>测试的目的：</p>\n<ul>\n<li>有利于写出高质量的代码，尽早发现问题</li>\n<li>有利于代码的扩展</li>\n<li>有利于代码的维护</li>\n</ul>\n<p><strong>本课程的学习路径：</strong></p>\n<ul>\n<li>学习基础的概念，清晰测试不同的应用场景</li>\n<li>学习不同的前端测试工具，了解如何进行选择</li>\n<li>在项目中进行实践</li>\n</ul>\n<p><strong>本课程的主要内容：</strong></p>\n<ul>\n<li>介绍测试框架的分类</li>\n<li>单元测试工具介绍：Mocha，Jest，AVA，Karma</li>\n<li>E2E测试工具介绍：Nightmare</li>\n</ul>\n<p><strong>本课程的学习准备：</strong></p>\n<ul>\n<li>IDE vscode，node  LTS</li>\n<li>包管理工具：yarn, cnpm</li>\n</ul>\n<h2 id=\"前端自动化测试\"><a href=\"#前端自动化测试\" class=\"headerlink\" title=\"前端自动化测试\"></a>前端自动化测试</h2><p>测试是一个庞大的主题，包括各种分类的测试，诸如黑盒测试&#x2F;白盒测试、单元测试&#x2F;集成测试&#x2F;端到端测试等。通常程序员在测试自己的代码的时候用得最多的便是单元测试，但是因为测试也是需要代价，很多人是不喜欢写测试的，甚至是一点都不写。</p>\n<p>那么是什么原因让大家不愿意写呢？</p>\n<ol>\n<li>不熟悉</li>\n<li>浪费时间</li>\n<li>知识不成体系</li>\n<li>团队氛围</li>\n<li>缺少实践</li>\n</ol>\n<p>我们要从基础的东西学起，打消对测试的恐惧。</p>\n<h3 id=\"测试的分类\"><a href=\"#测试的分类\" class=\"headerlink\" title=\"测试的分类\"></a>测试的分类</h3><p>在多浏览器的自动化测试，我们多半是进行端到端的测试工作，一小部分是大粒度的单元测试。端到端测试测试模拟用户的行为。在 Web 应用程序中，他们会启动服务器，打开浏览器，模拟用户的行为进行点击、输入、提交等动作，断言浏览器中发生了特定的事情或者是得到了期待的结果，从而让我们相信功能可以正常的运行。</p>\n<p>而单元测试根据代码单元的公共 API 运行它们。这些测试需要创建一个类的实例，使用特定的输入调用它的方法，断言被调用的方法达到了预期的效果。在下文中我们会看到这两种测试的实践，当然有时候区分度并不大，可能无法明显地区分哪些是端对端测试哪些是单元测试，有时候他们是混合起来的，不过只要记住我们的目标是保证功能可以正常运行救足够了。</p>\n<p>按照软件工程自底而上的概念，前端测试一般分为单元测试（Unit Testing ）、集成测试（Integration Testing）和端到端测试（E2E Testing）。从下面的图可以看出，从底向上测试的复杂度将不断提高，另一方面测试的收益反而不断降低的。</p>\n<p><img data-src=\"/assets/16415de723a8d411.png\" alt=\"img\"></p>\n<blockquote>\n<p>关于软件测试分类，可见<a href=\"#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB\">软件测试的分类</a></p>\n</blockquote>\n<h3 id=\"测试工具对比\"><a href=\"#测试工具对比\" class=\"headerlink\" title=\"测试工具对比\"></a>测试工具对比</h3><p>在进行项目实践前，很重要的一项工作是选择合适的技术栈。好比在前端开发时应该选择 React，Vue 还是 Angular 作为框架一样，前端的测试工作也需要选择一套技术栈。很多时候大家在制定技术栈时容易走偏，在选择技术框架时不是选择最合适的框架，而是选择最热门的框架。当然一定程度上热门的框架能反应其受欢迎程度，可能是因为其出众的优点，如较高的开发效率、高效的渲染特性或者是活跃的社区。在前端开发中，很容易有这样的感受，就是只要半个月没有关注业界的最新动态，就感觉恍若隔世，新的解决方案层出不穷，让人喘不过气。</p>\n<p>经过几年的前端洗礼之后，就已经过了慌乱的年纪，再也不会盲目地追寻新技术，而转向关注技术背后解决的痛点，原理等。</p>\n<p><img data-src=\"/assets/v2-af09ebe8167f63a49ea49287fe04526f_hd-20190706122102737.jpg\" alt=\"img\"></p>\n<h4 id=\"如何选择测试框架\"><a href=\"#如何选择测试框架\" class=\"headerlink\" title=\"如何选择测试框架\"></a>如何选择测试框架</h4><p>测试框架基本上都做了一件事儿：</p>\n<ul>\n<li>描述你要测试的东西</li>\n<li>对其进行测试</li>\n<li>判断是否符合预期</li>\n</ul>\n<p>选择框架会考虑下面的点：</p>\n<ul>\n<li><p>测试框架是否有简明的语法与文档。</p>\n<p>Mocha、Jasmine、Jest、AVA、Karma、Nightmare</p>\n</li>\n<li><p>断言(Assertions)：用于判断结果是否符合预期。有些框架需要单独的断言库。</p>\n<p>Should.js、chai、expect.js等等，断言库提供了很多语义化的方法来对值做各种各样的判断。当然也可以不用断言库，Node.js中也可以直接使用原生assert库。</p>\n</li>\n<li><p>适合 TDD &#x2F; BDD：是否适合 测试驱动型 &#x2F; 行为驱动型 的测试风格。</p>\n<blockquote>\n<p>BDD(Bebavior Driven Developement，行为驱动测试)和TDD(Testing Driven Developement，测试驱动开发)</p>\n</blockquote>\n<p>BDD和TDD均有各自的适用场景，BDD一般更偏向于系统功能和业务逻辑的自动化测试设计，而TDD在快速开发并测试功能模块的过程中则更加高效，以快速完成开发为目的。下面我们看下BDD和TDD具体的特点：</p>\n<p>BDD的特点：</p>\n<ul>\n<li>从业务逻辑的角度定义具体的输入与预期输出，以及可衡量的目标；</li>\n<li>尽可能覆盖所有的测试用例情况；</li>\n<li>描述一系列可执行的行为，根据业务的分析来定义预期输出。例如，expect, should, assert；</li>\n<li>设定关键的测试通过节点输出提示，便于测试人员理解；</li>\n<li>最大程度的交付出符合用户期望的产品，避免输出不一致带来的问题。</li>\n</ul>\n<p>TDD的特点：</p>\n<ul>\n<li>需求分析，快速编写对应的输入输出测试脚本；</li>\n<li><strong>仅在自动测试失败时才编写新代码</strong>。</li>\n<li>重构去除不必要的依赖关系，然后重复测试，最终让程序符合所有要求。</li>\n</ul>\n</li>\n<li><p>异步测试：有些框架对异步测试支持良好。</p>\n</li>\n<li><p>使用的语言：大部分 js 测试框架使用 js。</p>\n</li>\n<li><p>用于特定目的：每个框架可能会擅长处理不同的问题。</p>\n<p>是要测试单个功能、单个组件、还是集成化测试？</p>\n<p>是要测试GUI逻辑、交互？</p>\n<p>是要测试非功能性指标？兼容性？</p>\n</li>\n<li><p>社区是否活跃。</p>\n</li>\n</ul>\n<h4 id=\"测试工具的类型\"><a href=\"#测试工具的类型\" class=\"headerlink\" title=\"测试工具的类型\"></a>测试工具的类型</h4><p>测试工具可分为以下功能。有些只为我们提供了一种功能，有些功能为我们提供了一种组合。</p>\n<p>为了实现最灵活的集合功能，通常使用多种工具的组合。</p>\n<ul>\n<li><p>提供UI界面或者CLI工具：（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLw==\">Karma</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>）</p>\n<p><strong>CLI工具</strong>会给出一系列测试，以及运行这些测试所需的各种配置和脚手架（运行什么浏览器，使用什么babel插件，如何格式化输出等）</p>\n</li>\n<li><p>提供测试框架（形成文件目录）：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2NoYWpzLm9yZy8=\">Mocha</span>, <span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N1Y3VtYmVyL2N1Y3VtYmVyLWpz\">Cucumber</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>)</p>\n</li>\n<li><p>提供断言：（<span class=\"exturl\" data-url=\"aHR0cDovL2NoYWlqcy5jb20v\">Chai</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cDovL3VuZXhwZWN0ZWQuanMub3JnLw==\">Unexpected</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>）</p>\n<p><strong>断言函数</strong>检查测试返回的结果是否符合预期</p>\n</li>\n<li><p>生成，展示测试结果（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2NoYWpzLm9yZy8=\">Mocha</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLw==\">Karma</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>）</p>\n</li>\n<li><p>快照测试（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YQ==\">Ava</span>）</p>\n<p>快照测试(snapshot testing)，测试 UI 或数据结构是否和之前完全一致，通常 UI 测试不在单元测试中</p>\n</li>\n<li><p>提供仿真（<span class=\"exturl\" data-url=\"aHR0cDovL3Npbm9uanMub3JnLw==\">Sinon</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2FpcmJuYi5pby9lbnp5bWUvZG9jcy9hcGkv\">enzyme</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZXN0ZG91YmxlLmNvbS8=\">testdouble</span>）</p>\n<p>仿真(mocks, spies, and stubs)：获取方法的调用信息，模拟方法，模块，甚至服务器</p>\n</li>\n<li><p>生成测试覆盖率报告 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nb3R3YXJsb3N0LmdpdGh1Yi5pby9pc3RhbmJ1bC8=\">Istanbul</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>, <span class=\"exturl\" data-url=\"aHR0cDovL2JsYW5rZXRqcy5vcmcv\">Blanket</span>)</p>\n</li>\n<li><p>提供类浏览器环境(<span class=\"exturl\" data-url=\"aHR0cDovL25pZ2h0d2F0Y2hqcy5vcmcv\">Nightwatch</span>, <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5uaWdodG1hcmVqcy5vcmcv\">Nightmare</span>, <span class=\"exturl\" data-url=\"aHR0cDovL3BoYW50b21qcy5vcmcv\">Phantom</span><strong>,</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9wdXBwZXRlZXI=\">Puppeteer</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>)</p>\n</li>\n<li><p>可视化回归工具(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcHBsaXRvb2xzLmNvbS8=\">Applitools</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZXJjeS5pby8=\">Percy</span>, <span class=\"exturl\" data-url=\"aHR0cDovL2JiYy1uZXdzLmdpdGh1Yi5pby93cmFpdGgv\">Wraith</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlYmRyaXZlcmlvLWJvbmV5YXJkL3dlYmRyaXZlcmNzcw==\">WebdriverCSS</span>)</p>\n</li>\n</ul>\n<h4 id=\"单元测试类工具\"><a href=\"#单元测试类工具\" class=\"headerlink\" title=\"单元测试类工具\"></a>单元测试类工具</h4><p>npm trends: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtdHJlbmRzLmNvbS9tb2NoYS12cy1qZXN0LXZzLWF2YS12cy1qYXNtaW5lLWNvcmU=\">点击链接</span></p>\n<p><img data-src=\"/assets/image-20190706101634263.png\" alt=\"/images/image-20190706101634263\"></p>\n<p><strong>Karma</strong></p>\n<p>Karma是一个Runner（即运行环境），具体详细的介绍见 <a href=\"#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83&%E5%B8%AE%E6%89%8BKarma\">后面的章节Karma</a></p>\n<blockquote>\n<p>A test runner is the library or tool that picks up an assembly (or a source code directory) that contains unit tests, and a bunch of settings, and then executes them and writes the test results to the console or log files.<br>there are many runners for different languages. See Nunit and MSTest for C#, or Junit for Java.</p>\n</blockquote>\n<p>karma 设计目标主要有下面四点：</p>\n<blockquote>\n<p>高效<br>扩展性<br>运行在真实设备<br>无缝的使用流程</p>\n</blockquote>\n<p>karma 是一个典型的 C&#x2F;S 程序，包含 client 和 server ，通讯方式基于 Http ，通常情况下，客户端和服务端基本都运行在开发者本地机器上。</p>\n<p>一个服务端实例对应一个项目，假如想同时运行多个项目，得同时开启多个服务端实例。</p>\n<p>Karma 的<strong>优点</strong>是能通过插件和配置的方式集成大部分的主流的测试框架和前端库，能方便的一次在多浏览器环境执行测试用例，并集成了测试覆盖率生成功能，生成页面形式覆盖率报告并能导出不同形式的覆盖率报告数据。</p>\n<p>它的<strong>缺点</strong>是，对测试页面环境的搭建和资源文件的加载不是常见的形式，最开始搭建环境时会有很多跟预期不一致的情况，配置不直观。</p>\n<p><strong>Jasmine</strong></p>\n<p>Jasmine 带有 assertions(断言)，spies (用来模拟函数的执行环境)和 mocks (mock 工具)，Jasmine 初始化设置简单，同时，如果你需要一些单元功能的时候你仍然可以加一些库进来。</p>\n<p><strong>Mocha</strong></p>\n<p>Mocha 是一个灵活的库，提供给开发者的只有一个基础测试结构。然后，其它功能性的功能如 assertions， spies和mocks，这些功能<strong>需要引用添加其它库</strong>&#x2F;插件来完成。</p>\n<p><strong>Jest</strong></p>\n<p>被 Facebook 和各种 React 应用推荐和使用，Jest 得到了很好的支持。Jest 也被发现是一个非常快速的测试库在平行测试报告中。</p>\n<p>对于小型项目来说你可能在开始的时候不用过多担心，而性能的提高，对于希望全天持续部署的大型应用 app 来说是非常之好的。</p>\n<p>而开发人员主要是用 Jest 去测试 React 应用，Jest 可以很容易地集成到其它应用程序中充许你使用更独特的特性在其它地方</p>\n<p>快照测试是一个非常好用的工具，去确保你的应用 UI 不会有超出预期的错误，在产品发布替换的期间发生。虽然大部分功能，专门设计都是使用在 React 上。</p>\n<p>Jest 有着很广阔的 API 。</p>\n<p><strong>AVA</strong></p>\n<p>AVA 它的优势是 JavaScript 的异步特性和并发运行测试.</p>\n<p>利用了 JavaScript 的异步特性优势，优化了在部署的时间等待</p>\n<p>保留了简单的 API 为你提供你所需要的功能。</p>\n<p>如果搭配 mocking 来使用它会显得更加友好，但是必须安装一个单独的库。</p>\n<h4 id=\"E2E测试类工具\"><a href=\"#E2E测试类工具\" class=\"headerlink\" title=\"E2E测试类工具\"></a>E2E测试类工具</h4><p>npm trends: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtdHJlbmRzLmNvbS9jeXByZXNzLXZzLW5pZ2h0bWFyZS12cy1uaWdodHdhdGNoLXZzLXRlc3RjYWZlLXZzLXdlYmRyaXZlcmlv\">点击链接</span></p>\n<p><img data-src=\"/assets/image-20190706100636750.png\" alt=\"/images/image-20190706100636750\"></p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>测试有很多好处，但不代表一上来就要写出100%场景覆盖的测试用例。</p>\n<p><strong>最佳的实践：基于投入产出比来做测试</strong></p>\n<p>由于维护测试用例也是一大笔开销（毕竟没有多少测试会专门帮前端写业务测试用例，而前端使用的流程自动化工具更是没有测试参与了）。</p>\n<p>对于像基础组件、基础模型之类的不常变更且复用较多的部分，可以考虑去写测试用例来保证质量。个</p>\n<p>先写少量的测试用例覆盖到80%+的场景，保证覆盖主要使用流程。</p>\n<p>一些极端场景出现的bug可以在迭代中形成测试用例沉淀，场景覆盖也将逐渐趋近100%。</p>\n<p>但对于迭代较快的业务逻辑以及生存时间不长的活动页面之类的就别花时间写测试用例了，维护测试用例的时间大了去了，成本太高。</p>\n<p>大型项目，可以使用Jest快速形成配置并且开始单元测试。</p>\n<p>需要测试快照，则可以选择Jest或者Ava。</p>\n<p>对于配置性要求高，对测试框架性能有要求的可以选择mocha。</p>\n<p>对模拟还原浏览器业务操作有很大的需求的，可以选择nightmare</p>\n<p>配合CI工具完成自动化测试、测试覆盖率、测试结果推送。</p>\n<h2 id=\"喜欢简单，选择Mocha\"><a href=\"#喜欢简单，选择Mocha\" class=\"headerlink\" title=\"喜欢简单，选择Mocha\"></a>喜欢简单，选择Mocha</h2><p><a href=\"https://mochajs.org/\"><code>Mocha</code></a>（发音”摩卡”）诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。所谓”测试框架”，就是运行测试的工具。通过它，可以为JavaScript应用添加测试，从而保证代码的质量。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>全局安装Mocha</p>\n<pre><code class=\"bash\">npm install -g mocha\n</code></pre>\n<p>项目中也安装Mocha</p>\n<pre><code class=\"bash\">npm install --save-dev mocha\n</code></pre>\n<p>在package.json中加入下面脚本：</p>\n<pre><code class=\"bash\">&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;mocha&quot;\n&#125;\n</code></pre>\n<p>Chai 是一个针对 Node.js 和浏览器的行为驱动测试和测试驱动测试的<strong>断言库</strong>，可与任何 JavaScript 测试框架集成。它是Mocha的好帮手~~</p>\n<pre><code class=\"bash\">npm install --save-dev chai\n</code></pre>\n<p>在package.json中加入下面脚本：</p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;mocha&quot;\n&#125;\n</code></pre>\n<h3 id=\"关于断言\"><a href=\"#关于断言\" class=\"headerlink\" title=\"关于断言\"></a>关于断言</h3><p><code>expect</code>断言的优点是很接近自然语言，下面是一些例子。</p>\n<pre><code class=\"js\">// 相等或不相等\nexpect(4 + 5).to.be.equal(9);\nexpect(4 + 5).to.be.not.equal(10);\nexpect(foo).to.be.deep.equal(&#123; bar: &#39;baz&#39; &#125;);\n\n// 布尔值为true\nexpect(&#39;everthing&#39;).to.be.ok;\nexpect(false).to.not.be.ok;\n\n// typeof\nexpect(&#39;test&#39;).to.be.a(&#39;string&#39;);\nexpect(&#123; foo: &#39;bar&#39; &#125;).to.be.an(&#39;object&#39;);\nexpect(foo).to.be.an.instanceof(Foo);\n\n// include\nexpect([1,2,3]).to.include(2);\nexpect(&#39;foobar&#39;).to.contain(&#39;foo&#39;);\nexpect(&#123; foo: &#39;bar&#39;, hello: &#39;universe&#39; &#125;).to.include.keys(&#39;foo&#39;);\n\n// empty\nexpect([]).to.be.empty;\nexpect(&#39;&#39;).to.be.empty;\nexpect(&#123;&#125;).to.be.empty;\n\n// match\nexpect(&#39;foobar&#39;).to.match(/^foo/);\n</code></pre>\n<p>两种使用方式：</p>\n<pre><code class=\"js\">// commonjs\nconst expect = require(&#39;chai&#39;).expect\n\n// es6\nimport &#123; expect &#125; from &#39;chai&#39;\n</code></pre>\n<h3 id=\"测试案例\"><a href=\"#测试案例\" class=\"headerlink\" title=\"测试案例\"></a>测试案例</h3><p>其中index.js为我们的被测试代码：</p>\n<pre><code class=\"js\">/**\n * 加法函数\n * @param &#123;第一个数&#125; a \n * @param &#123;第二个数&#125; b \n */\nfunction addNum(a,b)&#123;\n    return a+b;\n&#125;\nmodule.exports=addNum;\n</code></pre>\n<p>新建测试脚本<code>test/demo.js</code></p>\n<pre><code class=\"js\">const expect = require(&#39;chai&#39;).expect;\nconst addNum = require(&#39;../src/index&#39;)\n\ndescribe(&#39;测试index.js&#39;, function() &#123;\n  describe(&#39;测试addNum函数&#39;, function() &#123;\n    it(&#39;两数相加结果为两个数字的和&#39;, function() &#123;\n      expect(addNum(1,2)).to.be.equal(3);\n      // 以上语法为chai的expect语法，它还有should语法和asset语法。\n    &#125;);\n  &#125;);\n&#125;);\n\n\n// 等价的意思\nvar addNum=require(&#39;../src/index&#39;)\n\ndescribe(&#39;测试index.js&#39;, function() &#123;\n  describe(&#39;测试addNum函数&#39;, function() &#123;\n    it(&#39;两数相加结果为两个数字的和&#39;, function() &#123;\n       if(addNum(1,2)!==3)&#123;\n         throw new Error(&quot;两数相加结果不为两个数字的和&quot;)；\n       &#125;\n    &#125;);\n  &#125;);\n&#125;);\n</code></pre>\n<h3 id=\"Mocha测试命令\"><a href=\"#Mocha测试命令\" class=\"headerlink\" title=\"Mocha测试命令\"></a>Mocha测试命令</h3><p>如果想测试单一的测试js，可以用：</p>\n<pre><code class=\"bash\">mocha test/index.test.js\n</code></pre>\n<p>或者多个js</p>\n<pre><code class=\"bash\">mocha test/index.test.js test/add.test.js\n</code></pre>\n<p>当然也可以用通配符测试某个文件夹下所有的js和jsx：</p>\n<pre><code class=\"bash\"># node 通配符\nmocha &#39;test/some/*.@(js|jsx)&#39;\n\n# shell 通配符\nmocha test/unit/*.js\n\nmocha spec/&#123;my,awesome&#125;.js\n</code></pre>\n<h3 id=\"ES6语法支持\"><a href=\"#ES6语法支持\" class=\"headerlink\" title=\"ES6语法支持\"></a>ES6语法支持</h3><p>在上面我们用的并非是ES6的语法，那么让我们把其中的代码都改为ES6的语法。<br> 其中index.js为：</p>\n<pre><code class=\"js\">/**\n * 加法函数\n * @param &#123;第一个数&#125; a \n * @param &#123;第二个数&#125; b \n */\nfunction addNum(a, b) &#123;\n  return a + b\n&#125;\n\nexport &#123;\n  addNum\n&#125; \n</code></pre>\n<p>而index.test.js为：</p>\n<pre><code class=\"js\">import &#123; expect &#125; from &#39;chai&#39;\nimport &#123; addNum &#125; from &#39;../src/index&#39;\n\ndescribe(&#39;测试index.js&#39;, function () &#123;\n  describe(&#39;测试addNum函数&#39;, function () &#123;\n    it(&#39;两个参数相加结果为两个数字的和&#39;, function () &#123;\n      expect(addNum(1, 2)).to.be.equal(3);\n    &#125;)\n    it(&#39;两个参数相加结果不为和以外的数&#39;, function () &#123;\n      expect(addNum(1, 2)).to.be.not.equal(4);\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<p>此时直接运行mocha肯定是不行的，我们现需要安装一下babel：</p>\n<pre><code class=\"bash\">npm install --save-dev @babel/cli @babel/core @babel/node @babel/register @babel/preset-env chai mocha nodemon\n</code></pre>\n<p>然后，在项目目录下面，新建一个.babelrc文件：</p>\n<pre><code class=\"json\">&#123;\n  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]\n&#125;\n</code></pre>\n<p>接着讲package.json中的脚本改为：</p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;mocha --require @babel/register&quot;\n&#125;,\n</code></pre>\n<p>命令变得更加简单了</p>\n<h3 id=\"更多用法\"><a href=\"#更多用法\" class=\"headerlink\" title=\"更多用法\"></a>更多用法</h3><h4 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h4><pre><code class=\"bash\">  --timeout, -t, --timeouts  Specify test timeout threshold (in milliseconds)\n                                                        [number] [default: 2000]\n</code></pre>\n<p>官方默认的超时是2000毫秒，即2s。</p>\n<p>有三种方式来修改超时：</p>\n<p><code>--no-timeout</code>参数或者<code>debug</code>模式中，全局禁用了超时；</p>\n<p><code>--timeout</code>后面接时间（毫秒），全局修改了本次执行测试用例的超时时间；</p>\n<p>在测试用例里面，使用<code>this.timeout</code>方法：</p>\n<pre><code class=\"js\">it(&#39;should take less than 500ms&#39;, function(done) &#123;\n  this.timeout(500);\n  setTimeout(done, 300);\n&#125;);\n</code></pre>\n<p>在<a href=\"#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%EF%BC%89\">钩子方法</a>里面使用：</p>\n<pre><code class=\"js\">describe(&#39;a suite of tests&#39;, function() &#123;\n  beforeEach(function(done) &#123;\n    this.timeout(3000); // A very long environment setup.\n    setTimeout(done, 2500);\n  &#125;);\n&#125;);\n</code></pre>\n<blockquote>\n<p>同样，可以使用&#96;&#96;this.timeout(0)<code> </code>去禁用超时。</p>\n</blockquote>\n<h4 id=\"钩子方法（生命周期函数）\"><a href=\"#钩子方法（生命周期函数）\" class=\"headerlink\" title=\"钩子方法（生命周期函数）\"></a>钩子方法（生命周期函数）</h4><p>Mocha在describe块之中，提供测试用例的四个钩子：before()、after()、beforeEach()和afterEach()。它们会在指定时间执行。</p>\n<pre><code class=\"js\">describe(&#39;测试index.js&#39;,()=&gt; &#123;\n  before(()=&gt;console.info(&quot;在本区块的所有测试用例之前执行&quot;))\n\n  after(()=&gt;console.info(&quot;在本区块的所有测试用例之后执行&quot;))\n\n  beforeEach(()=&gt;console.info(&quot;在本区块的每个测试用例之前执行&quot;))\n\n  afterEach(()=&gt;console.info(&quot;在本区块的每个测试用例之后执行&quot;))\n\n  describe(&#39;测试addNum函数&#39;, ()=&gt; &#123;\n    it(&#39;两数相加结果为两个数字的和&#39;, ()=&gt; &#123;\n      assert.equal(addNum(1,2),3)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<h4 id=\"异步测试\"><a href=\"#异步测试\" class=\"headerlink\" title=\"异步测试\"></a>异步测试</h4><p>Mocha本身是支持异步测试的。只需要为<code>describe</code>回调函数添加一个<code>done</code>参数， 成功时调用<code>done()</code>，失败时调用<code>done(err)</code>。例如：</p>\n<pre><code class=\"js\">var expect = require(&#39;chai&#39;).expect;\ndescribe(&#39;db&#39;, function() &#123;\n    it(&#39;#get&#39;, function(done) &#123;\n        db.get(&#39;foo&#39;, function(err, foo)&#123;\n            if(err) done(err);        \n            expect(foo).to.equal(&#39;bar&#39;);\n            done();\n        &#125;);\n    &#125;);\n&#125;);\n</code></pre>\n<ul>\n<li>如果未调用<code>done</code>函数，Mocha会一直等待直到超时。</li>\n<li>如果未添加<code>done</code>参数，Mocha会直接返回成功，不会捕获到异步的断言失败。例如：</li>\n</ul>\n<pre><code class=\"js\">it(&#39;#get&#39;, function()&#123;\n    setTimeout(function()&#123;\n        expect(1).to.equal(2);\n    &#125;, 100);\n&#125;);\n</code></pre>\n<p>运行上述测试<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2NoYWpzLm9yZy8=\">Mocha</span>总会提示Passing。</p>\n<blockquote>\n<p>Mocha怎么知道是否要等待异步断言呢？因为JavaScript中的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24=\">Function</span>有一个<code>length</code>属性， 通过它可以获得该函数的形参个数。Mocha通过传入回调的<code>length</code>来判断是否需要等待。</p>\n</blockquote>\n<p>或者，<code>done()</code>您可以返回<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZQ==\">Promise</span>，而不是使用回调。如果您正在测试的API返回promises而不是回调，可以这样进行使用：</p>\n<pre><code class=\"js\">beforeEach(function() &#123;\n  return db.clear().then(function() &#123;\n    return db.save([tobi, loki, jane]);\n  &#125;);\n&#125;);\n\ndescribe(&#39;#find()&#39;, function() &#123;\n  it(&#39;respond with matching records&#39;, function() &#123;\n    return db.find(&#123;type: &#39;User&#39;&#125;).should.eventually.have.length(3);\n  &#125;);\n&#125;);\n</code></pre>\n<p>同样，可以使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9hc3luY19mdW5jdGlvbg==\">async &#x2F; await</span>，您还可以编写如下的异步测试：</p>\n<pre><code class=\"js\">beforeEach(async function() &#123;\n  await db.clear();\n  await db.save([tobi, loki, jane]);\n&#125;);\n\ndescribe(&#39;#find()&#39;, function() &#123;\n  it(&#39;responds with matching records&#39;, async function() &#123;\n    const users = await db.find(&#123;type: &#39;User&#39;&#125;);\n    users.should.have.length(3);\n  &#125;);\n&#125;);\n</code></pre>\n<blockquote>\n<p>需要Babel支持~~~</p>\n</blockquote>\n<h3 id=\"示例项目\"><a href=\"#示例项目\" class=\"headerlink\" title=\"示例项目\"></a>示例项目</h3><h4 id=\"创建项目-amp-安装依赖\"><a href=\"#创建项目-amp-安装依赖\" class=\"headerlink\" title=\"创建项目&amp;安装依赖\"></a>创建项目&amp;安装依赖</h4><pre><code class=\"bash\">// 初始化一个nodejs项目\nnpm init -y\n\n// 安装依赖\nnpm install --save-dev @babel/cli @babel/core @babel/node @babel/register @babel/preset-env chai mocha nodemon\n</code></pre>\n<p>形成package.json</p>\n<pre><code class=\"json\">&#123;\n  &quot;name&quot;: &quot;projects&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@babel/cli&quot;: &quot;^7.5.0&quot;,\n    &quot;@babel/core&quot;: &quot;^7.5.0&quot;,\n    &quot;@babel/node&quot;: &quot;^7.5.0&quot;,\n    &quot;@babel/preset-env&quot;: &quot;^7.5.0&quot;,\n    &quot;@babel/register&quot;: &quot;^7.4.4&quot;,\n    &quot;chai&quot;: &quot;^4.2.0&quot;,\n    &quot;mocha&quot;: &quot;^6.1.4&quot;,\n    &quot;nodemon&quot;: &quot;^1.19.1&quot;\n  &#125;\n&#125;\n</code></pre>\n<h4 id=\"测试过程\"><a href=\"#测试过程\" class=\"headerlink\" title=\"测试过程\"></a>测试过程</h4><p>新建一个待测试的方法<code>./src/index.js</code></p>\n<pre><code class=\"js\">const sayHello = () =&gt; &quot;Hello world!!!&quot;\n\nconsole.log(sayHello())\n\n// ES6语法\nexport default sayHello\n</code></pre>\n<p>测试脚本<code>./test/index.spec.js</code></p>\n<pre><code class=\"js\">import &#123; expect &#125; from &quot;chai&quot;\nimport sayHello from &quot;../src/index&quot;\n\ndescribe(&quot;index test&quot;, () =&gt; &#123;\n  describe(&quot;sayHello function&quot;, () =&gt; &#123;\n    it(&quot;should say Hello guys!&quot;, () =&gt; &#123;\n\n      const str = sayHello();\n      expect(str).to.equal(&quot;Hello guys!&quot;)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<p><code>package.json</code>中的脚本：</p>\n<pre><code class=\"json\">  &quot;scripts&quot;: &#123;\n    // &quot;start&quot;: &quot;nodemon ./src/index.js&quot;,  // 针对ES5语法\n    &quot;start:babel&quot;: &quot;nodemon --exec babel-node ./src/index.js&quot;,\n    &quot;test:watch&quot;: &quot;mocha --require @babel/register --watch&quot;,\n    &quot;test&quot;: &quot;mocha --require @babel/register&quot;,\n    &quot;build&quot;: &quot;babel src --out-dir ./dist --source-maps&quot;,\n    &quot;serve&quot;: &quot;node ./dist/index.js&quot;,\n    &quot;debug&quot;: &quot;node --inspect-brk ./dist/index.js&quot;\n  &#125;,\n</code></pre>\n<p>开始测试：<code>npm run test</code></p>\n<p>报错了，因为期望的值与实际值不一致。</p>\n<pre><code class=\"bash\">Hello world!!!\n\n\n  index test\n    sayHello function\n      1) should say Hello guys!\n\n\n  0 passing (9ms)\n  1 failing\n\n  1) index test\n       sayHello function\n         should say Hello guys!:\n\n      AssertionError: expected &#39;Hello world!!!&#39; to equal &#39;Hello guys!&#39;\n      + expected - actual\n\n      -Hello world!!!\n      +Hello guys!\n      \n      at Context.equal (test/index.spec.js:9:22)\n</code></pre>\n<p>修改测试脚本，或者修改index.js文件：</p>\n<p>修改<code>./test/index.spec.js</code></p>\n<pre><code class=\"js\">import &#123; expect &#125; from &quot;chai&quot;\nimport sayHello from &quot;../src/index&quot;\n\ndescribe(&quot;index test&quot;, () =&gt; &#123;\n  describe(&quot;sayHello function&quot;, () =&gt; &#123;\n    it(&quot;should say Hello world!!!&quot;, () =&gt; &#123;\n\n      const str = sayHello();\n      expect(str).to.equal(&quot;Hello world!!!&quot;)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<p>再次测试：</p>\n<pre><code class=\"bash\">&gt; mocha --require @babel/register\n\nHello world!!!\n\n\n  index test\n    sayHello function\n      ✓ should say Hello world!!!\n\n\n  1 passing (6ms)\n</code></pre>\n<p>使用<code>mochawesome</code>展示你的测试结果：</p>\n<pre><code class=\"bash\">npm install --save-dev mochawesome\n</code></pre>\n<p>然后在<code>package.json</code>的<code>scripts</code>中添加如下内容，</p>\n<pre><code class=\"json\">&#123;\n    &quot;report&quot;: &quot;mocha --require @babel/register --reporter mochawesome&quot;,\n&#125;\n</code></pre>\n<p>使用方式：</p>\n<pre><code class=\"bash\">npm run report\n</code></pre>\n<p>形成出来的报告在浏览器中打开：</p>\n<p><img data-src=\"/assets/image-20190707212821248.png\" alt=\"/images/image-20190707212821248\"></p>\n<p>在Vscode中可以安装Live Server这个插件快速打开：</p>\n<p><img data-src=\"/assets/image-20190707212923919.png\" alt=\"/images/image-20190707212923919\"></p>\n<h2 id=\"开箱即用Jest\"><a href=\"#开箱即用Jest\" class=\"headerlink\" title=\"开箱即用Jest\"></a>开箱即用Jest</h2><p>Jest是由Facebook发布的开源的、基于<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>的JavaScript单元测试框架。Jest源于Facebook的构想，用于快速、可靠地测试Web聊天应用。它吸引了公司内部的兴趣，Facebook的一名软件工程师Jeff Morrison半年前又重拾这个项目，改善它的性能，并将其开源。Jest的目标是减少开始测试一个项目所要花费的时间和认知负荷，因此它提供了大部分你需要的现成工具：快速的命令行接口、Mock工具集以及它的自动模块Mock系统。此外，如果你在寻找隔离工具例如Mock库，大部分其它工具将让你在测试中（甚至经常在你的主代码中）写一些不尽如人意的样板代码，以使其生效。Jest与Jasmine框架的区别是在后者之上增加了一些层。最值得注意的是，运行测试时，Jest会自动模拟依赖。Jest自动为每个依赖的模块生成Mock，并默认提供这些Mock，这样就可以很容易地隔离模块的依赖。</p>\n<p>Jest支持Babel，我们将很轻松的使用ES6的高级语法</p>\n<p>Jest支持webpack，非常方便的使用它来管理我们的项目</p>\n<p>Jest支持TypeScript，书写测试用例更加严谨</p>\n<ol>\n<li><p>简化API</p>\n<p>Jest既简单又强大，内置支持以下功能：</p>\n<ul>\n<li>灵活的配置：比如，可以用文件名通配符来检测测试文件。</li>\n<li>测试的事前步骤(Setup)和事后步骤(Teardown)，同时也包括测试范围。</li>\n<li>匹配表达式(Matchers)：能使用期望<code>expect</code>句法来验证不同的内容。</li>\n<li>测试异步代码：支持承诺(promise)数据类型和异步等待<code>async</code> &#x2F; <code>await</code>功能。</li>\n<li>模拟函数：可以修改或监查某个函数的行为。</li>\n<li>手动模拟：测试代码时可以忽略模块的依存关系。</li>\n<li>虚拟计时：帮助控制时间推移。</li>\n</ul>\n</li>\n<li><p>性能与隔离</p>\n<p>Jest文档里写道：</p>\n<p>Jest能运用所有的工作部分，并列运行测试，使性能最大化。终端上的信息经过缓冲，最后与测试结果一起打印出来。沙盒中生成的测试文件，以及自动全局状态在每个测试里都会得到重置，这样就不会出现两个测试冲突的情况。</p>\n<p>Mocha用一个进程运行所有的测试，和它比较起来，Jest则完全不同。要在测试之间模拟出隔离效果，我们必须要引入几个测试辅助函数来妥善管理清除工作。这种做法虽然不怎么理想，但99%的情况都可以用，因为测试是按顺序进行的。</p>\n</li>\n<li><p>沉浸式监控模式</p>\n<p>快速互动式监控模式可以监控到哪些测试文件有过改动，只运行与改动过的文件相关的测试，并且由于优化作用，能迅速放出监控信号。设置起来非常简单，而且还有一些别的选项，可以用文件名或测试名来过滤测试。我们用Mocha时也有监控模式，不过没有那么强大，要运行某个特定的测试文件夹或文件，就不得不自己创造解决方法，而这些功能Jest本身就已经提供了，不用花力气。</p>\n</li>\n<li><p>代码覆盖率&amp;测试报告</p>\n<p>Jest内置有代码覆盖率报告功能，设置起来易如反掌。可以在整个项目范围里收集代码覆盖率信息，包括未经受测试的文件。</p>\n<p>要使完善Circle CI整合，只需要一个自定义报告功能。有了Jest，用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWxsZWVhbGxlbi9qZXN0LWp1bml0LXJlcG9ydGVy\">jest-junit-reporter</span>就可以做到，其用法和Mocha几乎相同。</p>\n</li>\n<li><p>快照功能</p>\n<p>快照测试的目的不是要替换现有的单元测试，而是要使之更有价值，让测试更轻松。在某些情况下，某些功能比如React组件功能，有了快照测试意味着无需再做单元测试，但同样这两者不是非此即彼。</p>\n</li>\n</ol>\n<h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>新建文件夹然后通过npm 命令安装：</p>\n<pre><code class=\"bash\">npm install --save-dev jest\n</code></pre>\n<p>或者通过yarn来安装：</p>\n<pre><code class=\"bash\">yarn add --dev jest\n</code></pre>\n<p>然后就可以开始测试了</p>\n<p>也可用<code>npm install -g jest</code>进行全局安装；并在 package.json 中指定 test 脚本：</p>\n<pre><code class=\"json\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;jest&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>Jest 的测试脚本名形如<code>.test.js</code>，不论 Jest 是全局运行还是通过<code>npm test</code>运行，它都会执行当前目录下所有的<code>*.test.js</code> 或 <code>*.spec.js</code> 文件、完成测试。</p>\n<p>ES6语法支持：</p>\n<ol>\n<li>安装依赖</li>\n</ol>\n<pre><code class=\"bash\">yarn add --dev babel-jest @babel/core @babel/preset-env\n</code></pre>\n<ol start=\"2\">\n<li>配置<code>.babelrc</code></li>\n</ol>\n<pre><code class=\"json\">&#123;\n  &quot;presets&quot;: [\n    [\n      &quot;@babel/preset-env&quot;,\n      &#123;\n        &quot;targets&quot;: &#123;\n          &quot;node&quot;: &quot;current&quot;\n        &#125;\n      &#125;\n    ]\n  ]\n&#125;\n</code></pre>\n<p>接下来就可以使用ES6的语法了~~~</p>\n<p>更多高阶的ES6&#x2F;7&#x2F;8…语法，可以参见：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWJlbGpzLmlvLw==\">babel官网</span></p>\n<p>关于Typescript的支持，可以参见 ：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9nZXR0aW5nLXN0YXJ0ZWQjdXNpbmctdHlwZXNjcmlwdA==\">Using Typescript</span></p>\n<h3 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h3><p>关于test suite与test case：</p>\n<p><img data-src=\"/assets/w80140jb42.jpg\" alt=\"img\"></p>\n<p>describe属于 test suite 的描述，而每个 test 或者 it 则描述了每个 test case。</p>\n<p>例如：<code>math.js</code></p>\n<pre><code class=\"js\">export const add = (a, b) =&gt; a + b;\n\nexport const multiple = (a, b) =&gt; a * b;\n</code></pre>\n<p>测试脚本：<code>math.test.js</code></p>\n<pre><code class=\"js\">const math = require(&#39;./src/math&#39;)\n\ndescribe(&quot;math&quot;, () =&gt; &#123;\n  let a\n  let b\n\n  beforeEach(function () &#123;\n    a = 2;\n    b = 3;\n  &#125;);\n\n  test(&quot;#should return result as a+b&quot;, () =&gt; &#123;\n    // test code\n    const result = math.add(a, b)\n    expect(result).toEqual(5)\n  &#125;);\n\n  it(&quot;#should return result as a*b&quot;, () =&gt; &#123;\n    //test code\n    const result = math.multiple(a, b)\n    expect(result).toEqual(6)\n  &#125;);\n&#125;);\n</code></pre>\n<p> test suite 可以进行嵌套：</p>\n<pre><code class=\"js\">describe(&quot;foo&quot;, () =&gt; &#123;\n  describe(&quot;bar&quot;, () =&gt; &#123;\n    it(&quot;foo bar&quot;, () =&gt; &#123;\n      //test code\n    &#125;);\n  &#125;);\n&#125;);\n</code></pre>\n<p>test case 也可以脱离 test suite 独立运行：</p>\n<pre><code class=\"js\">// hello.js\nmodule.exports = () =&gt; &#39;Hello world&#39;\n\n// hello.test.js\nlet hello = require(&#39;hello.js&#39;)\n\ntest(&#39;should get &quot;Hello world&quot;&#39;, () =&gt; &#123;\n    expect(hello()).toBe(&#39;Hello world&#39;) // 测试成功\n// expect(hello()).toBe(&#39;Hello&#39;) // 测试失败\n&#125;)\n</code></pre>\n<h3 id=\"Mock与Spy\"><a href=\"#Mock与Spy\" class=\"headerlink\" title=\"Mock与Spy\"></a>Mock与Spy</h3><p><strong>mock</strong>测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。</p>\n<p>Mock 是单元测试中经常使用的一种技术。单元测试，顾名思义测试的重点是某个具体单元。但是在实际代码中，代码与代码之间，模块与模块之间总是会存在着相互引用。这个时候，剥离出这种单元的依赖，让测试更加独立，使用到的技术就是 Mock。</p>\n<p><strong>为什么要使用Mock函数？</strong></p>\n<p>在项目中，一个模块的方法内常常会去调用另外一个模块的方法。在单元测试中，我们可能并不需要关心内部调用的方法的执行过程和结果，只想知道它是否被正确调用即可，甚至会指定该函数的返回值。此时，使用Mock函数是十分有必要。</p>\n<p>Mock函数提供的以下三种特性，在我们写测试代码时十分有用：</p>\n<ul>\n<li>捕获函数调用情况</li>\n<li>设置函数返回值</li>\n<li>改变函数的内部实现</li>\n</ul>\n<p><img data-src=\"/assets/8u3cp5kz2s.png\" alt=\"img\"></p>\n<p>举个例子：</p>\n<pre><code class=\"js\">// math.js\nexport const getFooResult = () =&gt; &#123;\n  // foo logic here\n&#125;;\nexport const getBarResult = () =&gt; &#123;\n  // bar logic here\n&#125;;\n\n// caculate.js\nimport &#123; getFooResult, getBarResult &#125; from &quot;./math&quot;;\n\nexport const getFooBarResult = () =&gt; getFooResult() + getBarResult();\n</code></pre>\n<p>此时，getFooResult() 和 getBarResult() 就是 getFooBarResult 这个函数的依赖。如果我们关注的点是 getFooBarResult 这个函数，我们就应该把 getFooResult 和 getBarResult Mock 掉，剥离这种依赖。下面是一个使用 Jest 进行 Mock 的例子。</p>\n<p><code>jest.fn()</code>是\b创建Mock函数最简单的方式，如果没有定义函数内部的实现，<code>jest.fn()</code>会返回<code>undefined</code>作为返回值。</p>\n<pre><code class=\"javascript\">test(&#39;测试jest.fn()调用&#39;, () =&gt; &#123;\n  let mockFn = jest.fn();\n  let result = mockFn(1, 2, 3);\n\n  // 断言mockFn的执行后返回undefined\n  expect(result).toBeUndefined();\n  // 断言mockFn被调用\n  expect(mockFn).toBeCalled();\n  // 断言mockFn被调用了一次\n  expect(mockFn).toBeCalledTimes(1);\n  // 断言mockFn传入的参数为1, 2, 3\n  expect(mockFn).toHaveBeenCalledWith(1, 2, 3);\n&#125;)\n</code></pre>\n<p><strong>情景一：设置函数 的返回值</strong></p>\n<pre><code class=\"js\">// calculate.test.js\nimport &#123; getFooBarResult &#125; from &quot;./calculate&quot;;\nimport * as fooBar from &#39;./math&#39;;\n\ntest(&#39;getResult should return result getFooResult() + getBarResult()&#39;, () =&gt; &#123;\n  // mock add方法和multiple方法\n  fooBar.getFooBarResult = jest.fn(() =&gt; 10);\n  fooBar.getBarResult = jest.fn(() =&gt; 5);\n\n  const result = getFooBarResult();\n\n  expect(result).toEqual(15);\n&#125;);\n</code></pre>\n<p>Mock其实就是一种Spies，在Jest中使用spies来“spy”(窥探)一个函数的行为。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9tb2NrLWZ1bmN0aW9uLWFwaS5odG1sI2NvbnRlbnQ=\">Jest文档</span>对于spies的解释:</p>\n<blockquote>\n<p>Mock函数也称为“spies”，因为它们让你窥探一些由其他代码间接调用的函数的行为，而不仅仅是测试输出。你可以通过使用 <code>jest.fn()</code> 创建一个mock函数。</p>\n</blockquote>\n<p>简单来说，一个spy是另一个内置的能够记录对其调用细节的函数：调用它的次数，使用什么参数。</p>\n<pre><code class=\"js\">// calculate.test.js\nimport &#123; getFooBarResult &#125; from &quot;./calculate&quot;;\nimport * as fooBar from &#39;./math&#39;;\n\ntest(&#39;getResult should return result getFooResult() + getBarResult()&#39;, () =&gt; &#123;\n  // mock add方法和multiple方法\n  fooBar.getFooResult = jest.fn(() =&gt; 10);\n  fooBar.getBarResult = jest.fn(() =&gt; 5);\n\n  const result = getFooBarResult();\n\n  // 监控getFooResult和getBarResult的调用情况.\n  expect(fooBar.getFooResult).toHaveBeenCalled();\n  expect(fooBar.getBarResult).toHaveBeenCalled();\n&#125;);\n</code></pre>\n<p><strong>情景二：捕获函数调用情况</strong></p>\n<pre><code class=\"js\">// bot method\nconst bot = &#123;\n  sayHello: name =&gt; &#123;\n    console.log(`Hello $&#123;name&#125;!`);\n  &#125;\n&#125;;\n\n// test.js\ndescribe(&quot;bot&quot;, () =&gt; &#123;\n  it(&quot;should say hello&quot;, () =&gt; &#123;\n    const spy = jest.spyOn(bot, &quot;sayHello&quot;);\n\n    bot.sayHello(&quot;Michael&quot;);\n\n    expect(spy).toHaveBeenCalledWith(&quot;Michael&quot;);\n\n    spy.mockRestore();\n  &#125;);\n&#125;);\n</code></pre>\n<p>我们通过 <code>jest.spyOn</code> 创建了一个监听 <code>bot</code> 对象的 <code>sayHello</code> 方法的 spy。它就像间谍一样监听了所有对 <code>bot#sayHello</code> 方法的调用。由于创建 spy 时，Jest 实际上修改了 <code>bot</code> 对象的 <code>sayHello</code> 属性，所以在断言完成后，我们还要通过 <code>mockRestore</code> 来恢复 <code>bot</code> 对象原本的 <code>sayHello</code>方法。</p>\n<p>Jest的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9qZXN0LW9iamVjdCNqZXN0c3B5b25vYmplY3QtbWV0aG9kbmFtZQ==\">spyOn介绍</span></p>\n<p><strong>情景三：修改函数的内容实现</strong></p>\n<pre><code class=\"js\">const bot = &#123;\n  sayHello: name =&gt; &#123;\n    console.log(`Hello $&#123;name&#125;!`);\n  &#125;\n&#125;;\n\ndescribe(&quot;bot&quot;, () =&gt; &#123;\n  it(&quot;should say hello&quot;, () =&gt; &#123;\n    const spy = jest.spyOn(bot, &quot;sayHello&quot;).mockImplementation(name =&gt; &#123;\n      console.log(`Hello mix $&#123;name&#125;`)\n    &#125;);\n\n    bot.sayHello(&quot;Michael&quot;);\n\n    expect(spy).toHaveBeenCalledWith(&quot;Michael&quot;);\n\n    spy.mockRestore();\n  &#125;);\n&#125;);\n</code></pre>\n<p>使用spyOn方法，还可以去修改Math.random这样的函数</p>\n<pre><code class=\"js\">jest.spyOn(Math, &quot;random&quot;).mockImplementation(() =&gt; 0.9);\n</code></pre>\n<p>举个例子：</p>\n<pre><code class=\"js\">// getNum.js\nconst arr = [1,2,3,4,5,6];\n\nconst getNum = index =&gt; &#123;\n  if (index) &#123;\n    return arr[index % 6];\n  &#125; else &#123;\n    return arr[Math.floor(Math.random() * 6)];\n  &#125;\n&#125;;\n\n// num.test.js\nimport &#123; getNum &#125; from &#39;../src/getNum&#39;\n\ndescribe(&quot;getNum&quot;, () =&gt; &#123;\n  it(&quot;should select numbber based on index if provided&quot;, () =&gt; &#123;\n    expect(getNum(1)).toBe(2);\n  &#125;);\n\n  it(&quot;should select a random number based on Math.random if skuId not available&quot;, () =&gt; &#123;\n    const spy = jest.spyOn(Math, &quot;random&quot;).mockImplementation(() =&gt; 0.9);\n\n    expect(getNum()).toBe(6);\n    expect(spy).toHaveBeenCalled();\n\n    spy.mockRestore();\n  &#125;);\n&#125;);\n</code></pre>\n<h3 id=\"CLI命令\"><a href=\"#CLI命令\" class=\"headerlink\" title=\"CLI命令\"></a>CLI命令</h3><pre><code>➜ npx jest --help\nUsage: jest [--config=&lt;pathToConfigFile&gt;] [TestPathPattern]\n\n选项：\n  --help, -h                    显示帮助信息                              [布尔]\n  --version, -v                 Print the version and exit                [布尔]\n  --config, -c                  The path to a jest config file specifying how to\n                                find and execute tests. If no rootDir is set in\n                                the config, the directory containing the config\n                                file is assumed to be the rootDir for the\n                                project.This can also be a JSON encoded value\n                                which Jest will use as configuration.   [字符串]\n  --coverage                    Indicates that test coverage information should\n                                be collected and reported in the output.  [布尔] \n  --timers                      Setting this value to fake allows the use of\n                                fake timers for functions such as setTimeout.\n                                                                        [字符串]\n  --verbose                     Display individual test results with the test\n                                suite hierarchy.                          [布尔]\n  --watch                       Watch files for changes and rerun tests related\n                                to changed files. If you want to re-run all\n                                tests when a file has changed, use the\n                                `--watchAll` option.                      [布尔]\n  --watchAll                    Watch files for changes and rerun all tests. If\n                                you want to re-run only the tests related to the\n                                changed files, use the `--watch` option.  [布尔]\n...\n</code></pre>\n<p>常见使用：</p>\n<p><code>--verbose</code>显示详细的测试信息，包括测试suite和case：</p>\n<pre><code class=\"bash\">➜ npx jest --verbose\n PASS  test/mock.test.js\n  bot\n    ✓ should say hello (7ms)\n\n  console.log test/mock.test.js:10\n    Hello mix Michael\n\n PASS  test/domain.test.js\n  getImageDomain\n    ✓ should select domain based on skuId if provided (1ms)\n    ✓ should select a random domain based on Math.random if skuId not available (1ms)\n\n  console.log test/sayhello.test.js:3\n    Hello Michael!\n\n PASS  test/sayhello.test.js\n  bot\n    ✓ should say hello (6ms)\n\n PASS  test/num.test.js\n  getNum\n    ✓ should select numbber based on index if provided (1ms)\n    ✓ should select a random number based on Math.random if skuId not available\n\n PASS  test/math.test.js\n  math\n    ✓ #should return result as a+b (1ms)\n    ✓ #should return result as a*b (4ms)\n\nTest Suites: 5 passed, 5 total\nTests:       8 passed, 8 total\nSnapshots:   0 total\nTime:        1.075s\nRan all test suites.\n</code></pre>\n<p><code>--watch</code>和<code>--watchAll</code>用来监听测试文件的变化 </p>\n<pre><code class=\"bash\">Ran all test suites.\n\nWatch Usage\n › Press f to run only failed tests.\n › Press o to only run tests related to changed files.\n › Press p to filter by a filename regex pattern.\n › Press t to filter by a test name regex pattern.\n › Press q to quit watch mode.\n › Press Enter to trigger a test run.\n</code></pre>\n<p><code>--coverage</code>用来形成测试覆盖率报告</p>\n<pre><code class=\"bash\">-----------|----------|----------|----------|----------|-------------------|\nFile       |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\n-----------|----------|----------|----------|----------|-------------------|\nAll files  |      100 |      100 |      100 |      100 |                   |\n getNum.js |      100 |      100 |      100 |      100 |                   |\n math.js   |      100 |      100 |      100 |      100 |                   |\n-----------|----------|----------|----------|----------|-------------------|\n\nTest Suites: 5 passed, 5 total\nTests:       8 passed, 8 total\nSnapshots:   0 total\nTime:        1.497s\n</code></pre>\n<h3 id=\"Jest在React、Vue项目中的应用\"><a href=\"#Jest在React、Vue项目中的应用\" class=\"headerlink\" title=\"Jest在React、Vue项目中的应用\"></a>Jest在React、Vue项目中的应用</h3><p>在<code>create-react-app</code>中的应用：</p>\n<p>安装对应的依赖：</p>\n<pre><code>npm install react-test-renderer enzyme enzyme-adapter-react-16 \n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9lbnp5bWU=\">Enzyme</span>是一个非常棒的React组件测试测试库。</p>\n<blockquote>\n<p>Enzyme is a JavaScript Testing utility for React that makes it easier to test your React Components’ output. You can also manipulate, traverse, and in some ways simulate runtime given the output.</p>\n<p>Enzyme’s API is meant to be intuitive and flexible by mimicking jQuery’s API for DOM manipulation and traversal</p>\n</blockquote>\n<p>需要注意的两点是：</p>\n<ul>\n<li>需要配置Adapter，不同的React的Adapter不同</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Enzyme Adapter Package</th>\n<th>React semver compatibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>enzyme-adapter-react-16</code></td>\n<td><code>^16.4.0-0</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-16.3</code></td>\n<td><code>~16.3.0-0</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-16.2</code></td>\n<td><code>~16.2</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-16.1</code></td>\n<td>&#96;~16.0.0-0</td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-15</code></td>\n<td><code>^15.5.0</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-15.4</code></td>\n<td><code>15.0.0-0 - 15.4.x</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-14</code></td>\n<td><code>^0.14.0</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-13</code></td>\n<td><code>^0.13.0</code></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>需要初始化配置<code>setUpTests.js</code></p>\n<p>官方文档在Package.json中设置jest配置，已经过时，Jest框架最新会默认加载文件<code>src/setUpTests.js</code></p>\n</li>\n<li><pre><code class=\"react\">import &#123; configure &#125; from &#39;enzyme&#39;;\nimport Adapter from &#39;enzyme-adapter-react-16&#39;\n\nconfigure(&#123; adapter: new Adapter() &#125;)\n</code></pre>\n</li>\n</ul>\n<p>在vue工程化项目中：</p>\n<pre><code class=\"json\">&quot;devDependencies&quot;: &#123;\n  &quot;@vue/cli-plugin-unit-jest&quot;: &quot;^3.9.0&quot;,\n  &quot;@vue/test-utils&quot;: &quot;1.0.0-beta.29&quot;,\n  &quot;babel-core&quot;: &quot;7.0.0-bridge.0&quot;,\n  &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,\n  &quot;babel-jest&quot;: &quot;^23.6.0&quot;,\n  &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,\n&#125;,\n</code></pre>\n<p>添加如上依赖，</p>\n<p>配置scripts:</p>\n<pre><code class=\"js\">&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;vue-cli-service test:unit&quot;\n&#125;,\n</code></pre>\n<p>配置<code>jest.config.js</code></p>\n<pre><code class=\"js\">module.exports = &#123;\n  // 处理vue结尾的文件\n  moduleFileExtensions: [\n    &#39;js&#39;,\n    &#39;jsx&#39;,\n    &#39;json&#39;,\n    &#39;vue&#39;\n  ],\n  // es6转义\n  transform: &#123;\n    &#39;^.+\\\\.vue$&#39;: &#39;vue-jest&#39;,\n    &#39;.+\\\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$&#39;: &#39;jest-transform-stub&#39;,\n    &#39;^.+\\\\.jsx?$&#39;: &#39;babel-jest&#39;\n  &#125;,\n  transformIgnorePatterns: [\n    &#39;/node_modules/&#39;\n  ],\n  // cli配置了webpack别名\n  moduleNameMapper: &#123;\n    &#39;^@/(.*)$&#39;: &#39;&lt;rootDir&gt;/src/$1&#39;\n  &#125;,\n  snapshotSerializers: [\n    &#39;jest-serializer-vue&#39;\n  ],\n  testMatch: [\n    &#39;**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)&#39;\n  ],\n  testURL: &#39;http://localhost/&#39;,\n  watchPlugins: [\n    &#39;jest-watch-typeahead/filename&#39;,\n    &#39;jest-watch-typeahead/testname&#39;\n  ]\n&#125;\n</code></pre>\n<p>写一个测试用例：</p>\n<pre><code>\n</code></pre>\n<h2 id=\"简约之美AVA\"><a href=\"#简约之美AVA\" class=\"headerlink\" title=\"简约之美AVA\"></a>简约之美AVA</h2><p>简单的说ava是mocha的替代品：</p>\n<ul>\n<li>es6语法支持更好，对aysnc&#x2F;await有支持</li>\n<li>执行效率更高，使用io并发，就必须保证测试的原子性</li>\n<li>语义上更简单，集众家之长</li>\n</ul>\n<p>虽然 JavaScript 是单线程，但在 Node.js 里由于其异步的特性使得 IO 可以并行。AVA 利用这个优点让你的测试可以并发执行，这对于 IO 繁重的测试特别有用。另外，测试文件可以在不同的进程里并行运行，让每一个测试文件可以获得更好的性能和独立的环境。</p>\n<h3 id=\"AVA特点\"><a href=\"#AVA特点\" class=\"headerlink\" title=\"AVA特点\"></a>AVA特点</h3><ul>\n<li><p>轻量和高效</p>\n</li>\n<li><p>简单的测试语法</p>\n</li>\n<li><p>并发运行测试</p>\n</li>\n<li><p>强制编写<strong>原子测试</strong></p>\n<p>一旦开始，就一直运行到结束，中间不会切换到另一个测试</p>\n</li>\n<li><p>没有隐藏的全局变量</p>\n</li>\n<li><p>为每个测试文件隔离环境</p>\n</li>\n<li><p><strong>用 ES2015 编写测试</strong></p>\n</li>\n<li><p>支持 Promise</p>\n</li>\n<li><p>支持 Generator</p>\n</li>\n<li><p>支持 Async</p>\n</li>\n<li><p>支持 Observable</p>\n</li>\n<li><p>强化断言信息</p>\n</li>\n<li><p>可选的 TAP 输出显示</p>\n<p><img data-src=\"/assets/tap-reporter.png\" alt=\"img\"></p>\n</li>\n<li><p>简明的堆栈跟踪</p>\n</li>\n</ul>\n<h3 id=\"安装-amp-开始\"><a href=\"#安装-amp-开始\" class=\"headerlink\" title=\"安装&amp;开始\"></a>安装&amp;开始</h3><p>情景一：</p>\n<pre><code class=\"bash\">// 创建一个ava项目\nnpm init ava\n</code></pre>\n<p>形成package.json</p>\n<pre><code class=\"json\">&#123;\n    &quot;name&quot;: &quot;awesome-package&quot;, \n    &quot;scripts&quot;: &#123;\n        &quot;test&quot;: &quot;ava&quot;\n    &#125;,\n    &quot;devDependencies&quot;: &#123;\n        &quot;ava&quot;: &quot;^1.0.0&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>情景二：（推荐）</p>\n<pre><code class=\"bash\">npm init -y\n\n// npm &amp; cnpm\nnpm install -D ava\n\n// yarn \nyarn add ava -D\n</code></pre>\n<p>测试ava正常安装：</p>\n<pre><code class=\"bash\">➜ npx ava --version\n2.2.0\n</code></pre>\n<h3 id=\"第一个ava测试例子\"><a href=\"#第一个ava测试例子\" class=\"headerlink\" title=\"第一个ava测试例子\"></a>第一个ava测试例子</h3><p>流程：</p>\n<ol>\n<li>引用ava的测试API</li>\n<li>执行测试</li>\n<li>使用断言</li>\n</ol>\n<p>创建<code>test.js</code>文件</p>\n<pre><code class=\"js\">import test from &#39;ava&#39;;\n\nconst testfn = (a, b) =&gt; a + b\n\ntest(&#39;hello ava&#39;, t =&gt; &#123;\n  t.pass();\n&#125;);\n\ntest(&#39;my first test&#39;, async t =&gt; &#123;\n  const str = &#39;hello ava!!!!&#39;\n  t.is(str, &#39;hello ava!!!!&#39;)\n&#125;);\n\ntest(&#39;add method&#39;, async t =&gt; &#123;\n  const result = testfn(3, 4)\n  t.is(result, 7)\n&#125;);\n</code></pre>\n<p>ava自动搜索如下文件结尾的文件：</p>\n<ul>\n<li><code>**/test.js</code></li>\n<li><code>**/test-*.js</code></li>\n<li><code>**/*.spec.js</code></li>\n<li><code>**/*.test.js</code></li>\n<li><code>**/test/**/*.js</code></li>\n<li><code>**/tests/**/*.js</code></li>\n<li><code>**/__tests__/**/*.js</code></li>\n</ul>\n<p>ava中的断言：</p>\n<pre><code class=\"json\">.pass([message])\n.fail([message])\n.assert(value, [message])\n.truthy(value, [message])\n.falsy(value, [message])\n.true(value, [message])\n.false(value, [message])\n.is(value, expected, [message])\n.not(value, expected, [message])\n.deepEqual(value, expected, [message])\n.notDeepEqual(value, expected, [message])\n.deepEqual()。\n.throws(fn, [expected, [message]])\n.throwsAsync(thrower, [expected, [message]])\n.notThrows(fn, [message])\n.notThrowsAsync(nonThrower, [message])\n.regex(contents, regex, [message])\n.notRegex(contents, regex, [message])\n.snapshot(expected, [message])\n.snapshot(expected, [options], [message])\n</code></pre>\n<h3 id=\"CLI命令-1\"><a href=\"#CLI命令-1\" class=\"headerlink\" title=\"CLI命令\"></a>CLI命令</h3><p>使用<code>--help</code>命令去查看ava支持的cli参数 </p>\n<pre><code class=\"bash\">➜ npx ava --help\n\n  Testing can be a drag. AVA helps you get it done.\n\n  Usage\n    ava [&lt;file&gt; ...]\n\n  Options\n    --watch, -w             Re-run tests when tests and source files change\n    --match, -m             Only run tests with matching title (Can be repeated)\n    --update-snapshots, -u  Update snapshots\n    --fail-fast             Stop after first test failure\n    --timeout, -T           Set global timeout (milliseconds or human-readable, e.g. 10s, 2m)\n    --serial, -s            Run tests serially\n    --concurrency, -c       Max number of test files running at the same time (Default: CPU cores)\n    --verbose, -v           Enable verbose output\n    --tap, -t               Generate TAP output\n    --color                 Force color output\n    --no-color              Disable color output\n    --reset-cache           Reset AVA&#39;s compilation cache and exit\n    --config                JavaScript file for AVA to read its config from, instead of using package.json\n                            or ava.config.js files\n\n  Examples\n    ava\n    ava test.js test2.js\n    ava test-*.js\n    ava test\n\n  The above relies on your shell expanding the glob patterns.\n  Without arguments, AVA uses the following patterns:\n    **/test.js **/test-*.js **/*.spec.js **/*.test.js **/test/**/*.js **/tests/**/*.js **/__tests__/**/*.js\n</code></pre>\n<h4 id=\"文件匹配\"><a href=\"#文件匹配\" class=\"headerlink\" title=\"文件匹配\"></a>文件匹配</h4><p>使用<code>match</code>指令，匹配对应需要测试的文件：</p>\n<p>匹配标题以<code>foo</code>：结尾</p>\n<pre><code>npx ava --match =&#39;* foo&#39;\n</code></pre>\n<p>匹配标题以<code>foo</code>：</p>\n<pre><code>npx ava --match =&#39;foo *&#39;\n</code></pre>\n<p>匹配标题包含<code>foo</code>：</p>\n<pre><code>npx ava --match =&#39;* foo *&#39;\n</code></pre>\n<p>匹配是完全相同 <code>foo</code>：</p>\n<pre><code>npx ava --match =&#39;foo&#39;\n</code></pre>\n<p>匹配标题不包含<code>foo</code>：</p>\n<pre><code>npx ava --match =&#39;！* foo *&#39;\n</code></pre>\n<p>匹配以下<code>foo</code>结尾的标题<code>bar</code>：</p>\n<pre><code>npx ava --match =&#39;foo * bar&#39;\n</code></pre>\n<p>匹配<code>foo</code>以<code>bar</code>：开头或结尾的标题：</p>\n<pre><code>npx ava --match =&#39;foo *&#39; -  match =&#39;* bar&#39;\n</code></pre>\n<h4 id=\"关于reporter\"><a href=\"#关于reporter\" class=\"headerlink\" title=\"关于reporter\"></a>关于reporter</h4><p>默认情况下，AVA使用最小的报告：</p>\n<p><a href=\"https://github.com/avajs/ava/blob/master/media/mini-reporter.gif\"><img data-src=\"/assets/mini-reporter.gif\" alt=\"img\"></a></p>\n<p>使用该<code>--verbose</code>标志启用详细的报告者。除非启用TAP报告，否则始终在CI环境中使用此选项。</p>\n<p><a href=\"https://github.com/avajs/ava/blob/master/media/verbose-reporter.png\"><img data-src=\"/assets/verbose-reporter.png\" alt=\"img\"></a></p>\n<p><strong>TAP报告（推荐）</strong></p>\n<p>AVA支持TAP格式，因此与任何TAP报告器兼容。使用该<code>--tap</code>标志启用TAP输出。</p>\n<pre><code class=\"bash\">$ npx ava --tap | npx tap-nyan\n</code></pre>\n<p><a href=\"https://github.com/avajs/ava/blob/master/media/tap-reporter.png\"><img data-src=\"/assets/tap-reporter-20190709154342692.png\" alt=\"img\"></a></p>\n<p>这里有一些格式：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RhcC1kb3Q=\">tap-dot</span> - Dotted output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RhcC1zcGVj\">tap-spec</span> - Mocha-like spec reporter.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NhbHZpbm1ldGNhbGYvdGFwLW55YW4=\">tap-nyan</span> - Nyan cat.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2d1bW1lc3Nvbi90YXAtbWlu\">tap-min</span> - Minimal output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25hbXVvbC90YXAtZGlmZmxldA==\">tap-difflet</span> - Minimal output with diffing.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F4cm9zcy90YXAtZGlmZg==\">tap-diff</span> - Human-friendly output with diffing.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2pvZXliYWtlci90YXAtc2ltcGxl\">tap-simple</span> - Simple output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2ZhdWNldA==\">faucet</span> - Human-readable summarizer.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy90YXAtbW9jaGEtcmVwb3J0ZXI=\">tap-mocha-reporter</span> - Use any of the <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy90YXAtbW9jaGEtcmVwb3J0ZXIvdHJlZS9tYXN0ZXIvbGliL3JlcG9ydGVycw==\">Mocha reporters</span>.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3pvdWJpbi90YXAtc3VtbWFyeQ==\">tap-summary</span> - Summarized output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NsdXgvdGFwLXBlc3NpbWlzdA==\">tap-pessimist</span> - Only shows failed tests.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Rvb2xuZXNzL3RhcC1wcmV0dGlmeQ==\">tap-prettify</span> - Nice readable output with diffing.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL3RhcC1jb2xvcml6ZQ==\">tap-colorize</span> - Colorize the output while preserving machine-readability.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbmdydWJlci90YXAtYmFpbA==\">tap-bail</span> - Bail out when the first test fails.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F4cm9zcy90YXAtbm90aWZ5\">tap-notify</span> - Notifier for macOS, Linux and Windows.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2d1bW1lc3Nvbi90YXAtanNvbg==\">tap-json</span> - JSON output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3lvdmFzeDIvYXZhLXRhcC1qc29u\">ava-tap-json</span> - JSON output with AVA compatibility.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FnaGFzc2VtaS90YXAteHVuaXQ=\">tap-xunit</span> - xUnit output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Ntb2NrbGUvdGFwLXRlYW1jaXR5\">tap-teamcity</span> - Output for TeamCity.</li>\n</ul>\n<h4 id=\"快照功能\"><a href=\"#快照功能\" class=\"headerlink\" title=\"快照功能\"></a>快照功能</h4><p>ava自动进行项目测试快照，如果文件放置在<code>test</code>或者<code>tests</code>目录，则快照会放置在<code>snapshots</code>目录。如果测试放置在<code>__test__</code>目录，则快照放置在<code>__snapshots__</code>目录</p>\n<pre><code class=\"bash\">ava --update-snapshots\n</code></pre>\n<p>可以指定一个固定位置，以便在AVA的<code>package.json</code>配置中存储快照文件：</p>\n<p><strong>package.json：</strong></p>\n<pre><code class=\"json\">&#123;\n     &quot;ava&quot;：&#123;\n         &quot;snapshotDir&quot;：&quot;自定义目录&quot;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"设置超时\"><a href=\"#设置超时\" class=\"headerlink\" title=\"设置超时\"></a>设置超时</h4><p>AVA中的超时行为与其他测试框架中的行为不同。AVA在每次测试后重置计时器，如果在指定的超时内没有收到新的测试结果，则强制测试退出。这可用于处理停滞的测试。</p>\n<p><em>没有默认超时。</em></p>\n<p>您可以配置使用超时<code>--timeout</code> 命令行选项，或配置文件中设置。它们可以以人类可读的方式设置：</p>\n<pre><code class=\"bash\"># 10秒\nnpx ava --timeout = 10s \n\n# 2分钟\nnpx ava --timeout = 2m \n\n# 100毫秒\nnpx ava --timeout = 100\n</code></pre>\n<p>还可以为每个测试单独设置超时。每次进行断言时都会重置这些超时。</p>\n<pre><code class=\"js\">test(&#39;foo&#39;, t =&gt; &#123;\n    t.timeout(100); // 100 milliseconds\n    // Write your assertions here\n&#125;);\n</code></pre>\n<h3 id=\"其他ava设置相关\"><a href=\"#其他ava设置相关\" class=\"headerlink\" title=\"其他ava设置相关\"></a>其他ava设置相关</h3><h4 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h4><p>如果使用了ESLint，请添加<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2VzbGludC1wbHVnaW4tYXZh\">eslint-plugin-ava</span></p>\n<pre><code class=\"json\">&#123;\n    plugins: [\n        &quot;ava&quot;\n    ]\n&#125;\n</code></pre>\n<h4 id=\"异步相关\"><a href=\"#异步相关\" class=\"headerlink\" title=\"异步相关\"></a>异步相关</h4><p>如果异步操作使用promises，则应返回promise：</p>\n<pre><code class=\"js\">test(&#39;fetches foo&#39;, t =&gt; &#123;\n    return fetch().then(data =&gt; &#123;\n        t.is(data, &#39;foo&#39;);\n    &#125;);\n&#125;);\n</code></pre>\n<p>更好的是，使用<code>async</code>&#x2F; <code>await</code>：</p>\n<pre><code class=\"js\">test(&#39;fetches foo&#39;, async t =&gt; &#123;\n    const data = await fetch();\n    t.is(data, &#39;foo&#39;);\n&#125;);\n</code></pre>\n<h2 id=\"测试环境-amp-帮手Karma\"><a href=\"#测试环境-amp-帮手Karma\" class=\"headerlink\" title=\"测试环境&amp;帮手Karma\"></a>测试环境&amp;帮手Karma</h2><p>Karma 是一个基于 Node.js 的 JavaScript 测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流 Web 浏览器，也可以集成到 CI（Continuous integration）工具，还可以和其他代码编辑器一起使用。</p>\n<p>Karma 会监控配置文件中所指定的每一个文件，每当文件发生改变，它都会向测试服务器发送信号，来通知所有的浏览器再次运行测试代码。此时，浏览器会重新加载源文件，并执行测试代码。其结果会传递回服务器，并以某种形式显示给开发者。</p>\n<p>访问浏览器执行结果，可通过以下的方式</p>\n<ul>\n<li>手工方式 - 通过浏览器</li>\n<li>自动方式 - 让 karma 来启动对应的浏览器</li>\n</ul>\n<h3 id=\"工作原理简介\"><a href=\"#工作原理简介\" class=\"headerlink\" title=\"工作原理简介\"></a>工作原理简介</h3><p><code>karma</code> 是一个典型的 <code>C/S</code> 程序，包含 client 和 server ，通讯方式基于 <code>Http</code> ，通常情况下，客户端和服务端基本都运行在开发者本地机器上。</p>\n<p>一个服务端实例对应一个项目，假如想同时运行多个项目，得同时开启多个服务端实例。</p>\n<p><strong>Server</strong></p>\n<p><code>Server</code> 是框架的主要组成部分之一，它内部保存了所有的程序运行状态，比如 client 连接，当前运行的单测文件，根据这些数据状态，它提供了下面几个功能， 下图是 server 的结构</p>\n<p><img data-src=\"/assets/TB13X9xLXXXXXXoaXXXDUoU9pXX-902-329.png\" alt=\"karma_server\"></p>\n<ul>\n<li>监听文件</li>\n<li>与 client 进行通讯</li>\n<li>向开发者输出测试结果</li>\n<li>提供 client 端所需的资源文件</li>\n</ul>\n<p><strong>Client</strong></p>\n<p>client 是单测最终运行的地方，类似一个 web app ， 跟 server 端通讯利用 <code>socket.io</code>， 执行单测在一个独立的 <code>iframe</code> 中。下面是它的结构图</p>\n<p><img data-src=\"/assets/TB1jTKwLXXXXXX.aXXX0KhCSFXX-619-472.png\" alt=\"karma_impl_client\"></p>\n<p>client 和 server 端通讯采用 <code>socket.io</code></p>\n<ul>\n<li>client 端会发送这些消息</li>\n</ul>\n<p><img data-src=\"/assets/TB1XXuILXXXXXcAXFXX.hdJKpXX-918-179.png\" alt=\"karma_impl_client_message_c\"></p>\n<ul>\n<li>server 端会发送这些消息</li>\n</ul>\n<p><img data-src=\"/assets/TB1PvisLXXXXXcqaXXXEHlCNpXX-896-103.png\" alt=\"karma_impl_client_message_s\"></p>\n<h3 id=\"安装Karma\"><a href=\"#安装Karma\" class=\"headerlink\" title=\"安装Karma\"></a>安装Karma</h3><p>对于Nodejs版本的要求：</p>\n<blockquote>\n<p>Karma currently works on Node.js <strong>6.x</strong>, <strong>8.x</strong>, and <strong>10.x</strong>. See <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLzQuMC9pbnRyby9mYXEuaHRtbA==\">FAQ</span> for more info.</p>\n</blockquote>\n<ol>\n<li><p>全局安装</p>\n<pre><code>$npm install -g karma\n</code></pre>\n<p>安装 Karma 命令会到全局的 <code>node_modules</code> 目录下，我们可以在任何位置直接运行 karma 命令。</p>\n<pre><code>npm install -g karma-cli\n</code></pre>\n<p>此命令用来安装 <code>karma-cli</code>，它会在当前目录下寻找 karma 的可执行文件。这样我们就可以在一个系统内运行多个版本的 Karma。</p>\n</li>\n<li><p>本地安装</p>\n<pre><code>$ npm install karma --save-dev\n</code></pre>\n<p>安装 Karma 命令到当前 <code>node_modules</code> 目录下，此时，如果需要执行 karma 命令，就需要这样 </p>\n<pre><code>./node_modules/.bin/karma\n\nnpx karma --version\n</code></pre>\n</li>\n</ol>\n<h3 id=\"配置Karma\"><a href=\"#配置Karma\" class=\"headerlink\" title=\"配置Karma\"></a>配置Karma</h3><p>karma配置文件可以用JavaScript，CoffeeScript或TypeScript编写，并作为常规Node.js模块加载。</p>\n<p>除非作为参数提供，否则Karma CLI将在以下位置以该顺序(从上至下)查找配置文件</p>\n<ul>\n<li><code>./karma.conf.js</code></li>\n<li><code>./karma.conf.coffee</code></li>\n<li><code>./karma.conf.ts</code></li>\n<li><code>./.config/karma.conf.js</code></li>\n<li><code>./.config/karma.conf.coffee</code></li>\n<li><code>./.config/karma.conf.ts</code></li>\n</ul>\n<p>在配置文件中，配置代码通过设置<code>module.exports</code>指向一个接受一个参数的函数：配置对象。</p>\n<pre><code class=\"javascript\">// karma.conf.js\nmodule.exports = function(config) &#123;\n  config.set(&#123;\n    basePath: &#39;../..&#39;,\n    frameworks: [&#39;jasmine&#39;],\n    //...\n  &#125;);\n&#125;;\n# karma.conf.coffee\nmodule.exports = (config) -&gt;\n  config.set\n    basePath: &#39;../..&#39;\n    frameworks: [&#39;jasmine&#39;]\n    # ...\n// karma.conf.ts\nmodule.exports = (config) =&gt; &#123;\n  config.set(&#123;\n    basePath: &#39;../..&#39;,\n    frameworks: [&#39;jasmine&#39;],\n    //...\n  &#125;);\n&#125;\n</code></pre>\n<blockquote>\n<p>关于typescript的支持，需要使用到<code>ts-node</code>，配置ts-node以使用<code>commonjs</code>模块格</p>\n</blockquote>\n<p>配置文件中的基本的属性介绍：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLzQuMC9jb25maWcvY29uZmlndXJhdGlvbi1maWxlLmh0bWw=\">Overview</span></p>\n<p>使用CLI工具，快速创建配置</p>\n<p>开始配置</p>\n<pre><code class=\"bash\">~/Downloads/Demo is 📦 v1.0.0 via ⬢ v10.16.0 \n➜ npx karma init\n\n# 如果在应用中用到了其它的测试框架，那就需要我们安装它们所对应的插件，并在配置文件中标注它们（详见 karma.conf.js 中的 plugins 项）\nWhich testing framework do you want to use ?\nPress tab to list possible options. Enter to move to the next question.\n&gt; jasmine\n# mocha\n# qunit\n# nodeunit\n# nunit\n\n# Require.js 是异步加载规范（AMD）的实现。常被作为基础代码库，应用在了很多的项目与框架之中，例如 Dojo, AngularJs 等\nDo you want to use Require.js ?\nThis will add Require.js plugin.\nPress tab to list possible options. Enter to move to the next question.\n&gt; no\n# yes\n\n# 选择需要运行测试用例的浏览器。需要注意的就是，必须保证所对应的浏览器插件已经安装成功。\nDo you want to capture any browsers automatically ?\nPress tab to list possible options. Enter empty string to move to the next question.\n&gt; Chrome\n# ChromeHeadless\n# ChromeCanary\n# Firefox\n# Safari\n# PhantomJS\n# Opera\n# IE\n\n# 选择测试用例所在的目录位置。Karma 支持通配符的方式配置文件或目录，例如 *.js, test/**/*.js 等。如果目录或文件使用相对位置，要清楚地是，此时的路径是相对于当前运行 karma 命令时所在的目录。\nWhat is the location of your source and test files ?\nYou can use glob patterns, eg. &quot;js/*.js&quot; or &quot;test/**/*Spec.js&quot;.\nEnter empty string to move to the next question.\n&gt; src/*js\n\n# 目录中不包括的那些文件。\nShould any of the files included by the previous patterns be excluded ?\nYou can use glob patterns, eg. &quot;**/*.swp&quot;.\nEnter empty string to move to the next question.\n\n# 是否需要 Karma 自动监听文件？并且文件一旦被修改，就重新运行测试用例？\nDo you want Karma to watch all the files and run the tests on change ?\nPress tab to list possible options.\n&gt; yes\n</code></pre>\n<p>生成了一个<code>karma.conf.js</code>文件：</p>\n<pre><code class=\"js\">// Karma configuration\n// Generated on Wed Jul 10 2019 22:46:32 GMT+0800 (GMT+08:00)\n\nmodule.exports = function(config) &#123;\n  config.set(&#123;\n\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: &#39;&#39;,\n\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: [&#39;mocha&#39;],\n\n\n    // list of files / patterns to load in the browser\n    files: [\n      &#39;src/*js&#39;\n    ],\n\n\n    // list of files / patterns to exclude\n    exclude: [\n    ],\n\n\n    // preprocess matching files before serving them to the browser\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n    preprocessors: &#123;\n    &#125;,\n\n\n    // test results reporter to use\n    // possible values: &#39;dots&#39;, &#39;progress&#39;\n    // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n    reporters: [&#39;progress&#39;],\n\n\n    // web server port\n    port: 9876,\n\n\n    // enable / disable colors in the output (reporters and logs)\n    colors: true,\n\n\n    // level of logging\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n    logLevel: config.LOG_INFO,\n\n\n    // enable / disable watching file and executing tests whenever any file changes\n    autoWatch: true,\n\n\n    // start these browsers\n    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n    browsers: [&#39;Chrome&#39;],\n\n\n    // Continuous Integration mode\n    // if true, Karma captures browsers, runs the tests and exits\n    singleRun: false,\n\n    // Concurrency level\n    // how many browser should be started simultaneous\n    concurrency: Infinity\n  &#125;)\n&#125;\n</code></pre>\n<h3 id=\"karma示例\"><a href=\"#karma示例\" class=\"headerlink\" title=\"karma示例\"></a>karma示例</h3><p>目标 ：</p>\n<ul>\n<li>babel支持，ES6语法支持</li>\n<li>mocha与chai支持</li>\n<li>karma与chrome、webpack对接</li>\n</ul>\n<p>说明：</p>\n<p>Karma对babel支持的，一个可选项：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2thcm1hLWJhYmVsLXByZXByb2Nlc3Nvcg==\">karma-babel-preprocessor</span>，但是：</p>\n<blockquote>\n<p>babel and karma-babel-preprocessor only convert ES6 modules to CommonJS&#x2F;AMD&#x2F;SystemJS&#x2F;UMD**. If you choose CommonJS, you still need to resolve and concatenate CommonJS modules on your own**. We recommend <strong>karma-browserify + babelify</strong> or <strong>webpack + babel-loader</strong> in such cases.</p>\n</blockquote>\n<p>所以，我们选择了webpack</p>\n<ol>\n<li><p>安装依赖</p>\n<pre><code>npm install @babel/core @babel/preset-env chai mocha webpack webpack-cli babel-loader -D\n</code></pre>\n</li>\n<li><p>安装karma的适配器</p>\n<pre><code>npm install karma-webpack karma-chrome-launcher karma-mocha karma-chai -D\n</code></pre>\n</li>\n<li><p>配置<code>karma.config.js</code></p>\n<pre><code class=\"js\">// Karma configuration\n// Generated on Thu Jul 11 2019 23:23:44 GMT+0800 (GMT+08:00)\n\nmodule.exports = function (config) &#123;\n  config.set(&#123;\n\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: &#39;&#39;,\n\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: [&#39;mocha&#39;],\n\n\n    // list of files / patterns to load in the browser\n    files: [\n      &#39;src/**/*.js&#39;,\n      &#39;test/**/*.js&#39;\n    ],\n\n \n    // ....\n    \n\n    // preprocess matching files before serving them to the browser\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n    preprocessors: &#123;\n      &#39;src/**/*.js&#39;: [&#39;webpack&#39;],\n      &#39;test/**/*.js&#39;: [&#39;webpack&#39;]\n    &#125;,\n\n    webpack: &#123;\n      mode: &quot;none&quot;,\n      node: &#123;\n        fs: &#39;empty&#39;\n      &#125;,\n      module: &#123;\n        rules: [\n          &#123; test: /\\.js?$/, loader: &quot;babel-loader&quot;, options: &#123; presets: [&quot;@babel/env&quot;] &#125;, &#125;\n        ]\n      &#125;\n    &#125;,\n \n    // ....\n    \n    plugins: [\n      &#39;karma-mocha&#39;,\n      &#39;karma-chai&#39;,\n      &#39;karma-chrome-launcher&#39;,\n      &#39;karma-webpack&#39;\n    ]\n  &#125;)\n&#125;\n</code></pre>\n</li>\n<li><p>书写测试用例<code>test.js</code>：</p>\n<pre><code class=\"js\">import &#123; describe &#125; from &quot;mocha&quot;;\nimport &#123; expect &#125; from &#39;chai&#39;\n\ndescribe(&#39;first test&#39;, () =&gt; &#123;\n  it(&#39;hello mocha and karma&#39;, () =&gt; &#123;\n    console.log(&#39;hello mocha&#39;)\n    expect(true).to.be.equal(true)\n  &#125;)\n&#125;)\n</code></pre>\n</li>\n<li><p>开始测试：</p>\n<pre><code class=\"bash\">npx karma start\n</code></pre>\n<p>添加到<code>package.json</code></p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n  &quot;karma&quot;: &quot;karma start&quot;\n&#125;,\n</code></pre>\n<p>然后使用，<code>npm run karma</code></p>\n<pre><code class=\"bash\">➜ npx karma start\nℹ ｢wdm｣: Hash: 9d2c943b68425fd58dd0\nVersion: webpack 4.35.3\nTime: 53ms\nBuilt at: 2019-07-12 5:07:49 PM\nℹ ｢wdm｣: Compiled successfully.\nℹ ｢wdm｣: Compiling...\n⚠ ｢wdm｣: Hash: cca8316f4bd5855fc4de\nVersion: webpack 4.35.3\nTime: 2414ms\nBuilt at: 2019-07-12 5:07:52 PM\n       Asset      Size  Chunks             Chunk Names\nsrc/index.js  3.62 KiB       0  [emitted]  src/index\ntest/test.js  1010 KiB       1  [emitted]  test/test\nEntrypoint src/index = src/index.js\nEntrypoint test/test = test/test.js\n  [0] ./src/index.js 27 bytes &#123;0&#125; [built]\n  [1] ./test/test.js 223 bytes &#123;1&#125; [built]\n  [2] ./node_modules/mocha/browser-entry.js 4.19 KiB &#123;1&#125; [built]\n  [3] ./node_modules/process/browser.js 4.96 KiB &#123;1&#125; [built]\n  [4] (webpack)/buildin/global.js 878 bytes &#123;1&#125; [built]\n  [5] ./node_modules/browser-stdout/index.js 662 bytes &#123;1&#125; [built]\n  [6] ./node_modules/stream-browserify/index.js 3.53 KiB &#123;1&#125; [built]\n [36] ./node_modules/util/util.js 19 KiB &#123;1&#125; [built]\n [38] ./node_modules/mocha/lib/mocha.js 21.8 KiB &#123;1&#125; [built]\n [39] (webpack)/buildin/module.js 552 bytes &#123;1&#125; [built]\n [40] ./node_modules/escape-string-regexp/index.js 230 bytes &#123;1&#125; [built]\n [41] path (ignored) 15 bytes &#123;1&#125; [built]\n [42] ./node_modules/mocha/lib/reporters/index.js 945 bytes &#123;1&#125; [built]\n[105] ./node_modules/chai/index.js 39 bytes &#123;1&#125; [built]\n[106] ./node_modules/chai/lib/chai.js 1.22 KiB &#123;1&#125; [built]\n    + 128 hidden modules\n\nWARNING in ./node_modules/mocha/lib/mocha.js 217:20-37\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 222:24-70\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 266:24-35\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 313:35-48\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 329:23-44\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\nℹ ｢wdm｣: Compiled with warnings.\n12 07 2019 17:07:52.761:WARN [karma]: No captured browser, open http://localhost:9876/\n12 07 2019 17:07:52.770:INFO [karma-server]: Karma v4.1.0 server started at http://0.0.0.0:9876/\n12 07 2019 17:07:52.770:INFO [launcher]: Launching browsers Chrome with concurrency unlimited\n12 07 2019 17:07:52.773:INFO [launcher]: Starting browser Chrome\n12 07 2019 17:07:54.135:INFO [Chrome 75.0.3770 (Mac OS X 10.14.5)]: Connected on socket R9R31QB1GtR_kayNAAAA with id 55412577\nChrome 75.0.3770 (Mac OS X 10.14.5) LOG: &#39;hello karma&#39;\n\nLOG: &#39;hello mocha&#39;\nChrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0 secs / 0.001 secs\n~/Downloads/karma-demo is 📦 v1.0.0 via ⬢ v10.16.0 \n➜ npm run karma\n\n&gt; karma-demo@1.0.0 karma /Users/itheima/Downloads/karma-demo\n&gt; karma start\n\nℹ ｢wdm｣: Hash: 9d2c943b68425fd58dd0\nVersion: webpack 4.35.3\nTime: 48ms\nBuilt at: 2019-07-12 5:24:02 PM\nℹ ｢wdm｣: Compiled successfully.\nℹ ｢wdm｣: Compiling...\n⚠ ｢wdm｣: Hash: cca8316f4bd5855fc4de\nVersion: webpack 4.35.3\nTime: 2307ms\nBuilt at: 2019-07-12 5:24:04 PM\n       Asset      Size  Chunks             Chunk Names\nsrc/index.js  3.62 KiB       0  [emitted]  src/index\ntest/test.js  1010 KiB       1  [emitted]  test/test\nEntrypoint src/index = src/index.js\nEntrypoint test/test = test/test.js\n  [0] ./src/index.js 27 bytes &#123;0&#125; [built]\n  [1] ./test/test.js 223 bytes &#123;1&#125; [built]\n  [2] ./node_modules/mocha/browser-entry.js 4.19 KiB &#123;1&#125; [built]\n  [3] ./node_modules/process/browser.js 4.96 KiB &#123;1&#125; [built]\n  [4] (webpack)/buildin/global.js 878 bytes &#123;1&#125; [built]\n  [5] ./node_modules/browser-stdout/index.js 662 bytes &#123;1&#125; [built]\n  [6] ./node_modules/stream-browserify/index.js 3.53 KiB &#123;1&#125; [built]\n [36] ./node_modules/util/util.js 19 KiB &#123;1&#125; [built]\n [38] ./node_modules/mocha/lib/mocha.js 21.8 KiB &#123;1&#125; [built]\n [39] (webpack)/buildin/module.js 552 bytes &#123;1&#125; [built]\n [40] ./node_modules/escape-string-regexp/index.js 230 bytes &#123;1&#125; [built]\n [41] path (ignored) 15 bytes &#123;1&#125; [built]\n [42] ./node_modules/mocha/lib/reporters/index.js 945 bytes &#123;1&#125; [built]\n[105] ./node_modules/chai/index.js 39 bytes &#123;1&#125; [built]\n[106] ./node_modules/chai/lib/chai.js 1.22 KiB &#123;1&#125; [built]\n    + 128 hidden modules\n\nWARNING in ./node_modules/mocha/lib/mocha.js 217:20-37\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 222:24-70\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 266:24-35\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 313:35-48\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 329:23-44\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\nℹ ｢wdm｣: Compiled with warnings.\n12 07 2019 17:24:04.905:WARN [karma]: No captured browser, open http://localhost:9876/\n12 07 2019 17:24:04.914:INFO [karma-server]: Karma v4.1.0 server started at http://0.0.0.0:9876/\n12 07 2019 17:24:04.914:INFO [launcher]: Launching browsers Chrome with concurrency unlimited\n12 07 2019 17:24:04.922:INFO [launcher]: Starting browser Chrome\n12 07 2019 17:24:06.289:INFO [Chrome 75.0.3770 (Mac OS X 10.14.5)]: Connected on socket EbCCSbQRPbxHbq3OAAAA with id 92342032\nChrome 75.0.3770 (Mac OS X 10.14.5) LOG: &#39;hello karma&#39;\n\nLOG: &#39;hello mocha&#39;\nChrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0 secs / 0.001 secs\nChrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0.006 secs / 0.001 \nsecs)\nTOTAL: 1 SUCCESS\n</code></pre>\n</li>\n</ol>\n<h2 id=\"UI测试利器Nightmare\"><a href=\"#UI测试利器Nightmare\" class=\"headerlink\" title=\"UI测试利器Nightmare\"></a>UI测试利器Nightmare</h2><p>Nightmare是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50LmNvbS8=\">Segment</span>的高级浏览器自动化库。</p>\n<p>目标是公开一些模仿用户操作（例如<code>goto</code>，<code>type</code>和<code>click</code>）的简单方法，使用对每个脚本块感觉同步的API，而不是深层嵌套的回调。它最初设计用于在没有API的站点之间自动执行任务，但最常用于UI测试和爬网。</p>\n<p>它使用<span class=\"exturl\" data-url=\"aHR0cDovL2VsZWN0cm9uLmF0b20uaW8v\">Electron</span>，它与<span class=\"exturl\" data-url=\"aHR0cDovL3BoYW50b21qcy5vcmcv\">PhantomJS</span>类似，但大约<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUvaXNzdWVzLzQ4NCNpc3N1ZWNvbW1lbnQtMTg0NTE5NTkx\">快两倍</span>，更现代。</p>\n<h3 id=\"安装与起步\"><a href=\"#安装与起步\" class=\"headerlink\" title=\"安装与起步\"></a>安装与起步</h3><ol>\n<li><p>安装<code>nightmare</code></p>\n</li>\n<li><pre><code>// 初始化项目\nnpm init -y\n\nnpm install --save-dev nightmare\n</code></pre>\n</li>\n</ol>\n<p>npm install –save-dev mocha</p>\n<pre><code>\n2. 淘宝源加速\n</code></pre>\n<p>   &#x2F;&#x2F; 使用淘宝源加速electron的安装<br>   export ELECTRON_MIRROR&#x3D;”<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ucG0udGFvYmFvLm9yZy9taXJyb3JzL2VsZWN0cm9uLw==\">https://npm.taobao.org/mirrors/electron/</span>“</p>\n<pre><code>\n3. 起步测试：\n\n```js\nconst Nightmare = require(&#39;nightmare&#39;)\nconst assert = require(&#39;assert&#39;)\n\ndescribe(&#39;Load a Page&#39;, function () &#123;\n  // Recommended: 5s locally, 10s to remote server, 30s from airplane ¯\\_(ツ)_/¯\n  this.timeout(&#39;30s&#39;)\n\n  let nightmare = null\n  beforeEach(() =&gt; &#123;\n    nightmare = new Nightmare()\n  &#125;)\n\n  describe(&#39;/ (Home Page)&#39;, () =&gt; &#123;\n    it(&#39;should load without error&#39;, done =&gt; &#123;\n      // your actual testing urls will likely be `http://localhost:port/path`\n      nightmare.goto(&#39;https://www.baidu.com&#39;)\n        .end()\n        .then(function (result) &#123;\n          done()\n        &#125;)\n        .catch(done)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<h3 id=\"nightmare配合mocha测试\"><a href=\"#nightmare配合mocha测试\" class=\"headerlink\" title=\"nightmare配合mocha测试\"></a>nightmare配合mocha测试</h3><p>nightmare可以进行网页的抓取，配合mocha进行页面的测试：</p>\n<p>安装<code>mocha</code></p>\n<pre><code class=\"bash\">npm install --save-dev mocha\n</code></pre>\n<blockquote>\n<p>还可以安装一些断言库，如：<code>chai</code></p>\n</blockquote>\n<p>新建测试：</p>\n<pre><code class=\"js\">const Nightmare = require(&#39;nightmare&#39;)\nconst assert = require(&#39;assert&#39;)\n\ndescribe(&#39;Search nightmare&#39;, () =&gt; &#123;\n  this.timeout(&#39;30s&#39;)\n\n  let nightmare = null\n  \n  beforeEach(() =&gt; &#123;\n    nightmare = new Nightmare()\n  &#125;)\n\n  it(&#39;should load with result nightmare&#39;, done =&gt; &#123;\n    const selector = &#39;em&#39;\n    nightmare.goto(&#39;https://www.baidu.com&#39;)\n      .type(&#39;#kw&#39;, &#39;nightmare&#39;)\n      .click(&#39;#su&#39;)\n      .wait(&#39;em&#39;)\n      .evaluate(selector =&gt; &#123;\n      // now we&#39;re executing inside the browser scope.\n      return document.querySelector(selector).innerText\n    &#125;, selector) // &lt;-- that&#39;s how you pass parameters from Node scope to browser scope\n      .end()\n      .then(function (result) &#123;\n      console.log(result)\n      assert.equal(result, &#39;nightmare&#39;)\n      done()\n    &#125;)\n      .catch(done)\n  &#125;)\n&#125;)\n</code></pre>\n<p>将mocha作为测试脚本添加到您的  <code>package.json</code>：</p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;mocha&quot;\n&#125;\n</code></pre>\n<h3 id=\"API介绍\"><a href=\"#API介绍\" class=\"headerlink\" title=\"API介绍\"></a>API介绍</h3><h4 id=\"nightmare的配置项\"><a href=\"#nightmare的配置项\" class=\"headerlink\" title=\"nightmare的配置项\"></a>nightmare的配置项</h4><pre><code>waitTimeout (default: 30s)\ngotoTimeout (default: 30s)\nloadTimeout (default: infinite)\nexecutionTimeout (default: 30s)\npaths\nswitches\nelectronPath\ndock\nopenDevTools\ntypeInterval (default: 100ms)\npollInterval (default: 250ms)\nmaxAuthRetries (default: 3)\ncertificateSubjectName\n.engineVersions()\n.useragent(useragent)\n.authentication(user, password)\n.authentication(user, password)\n.halt(error, done)\n</code></pre>\n<p>配置链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjbmlnaHRtYXJlb3B0aW9ucw==\">https://github.com/segmentio/nightmare#nightmareoptions</span></p>\n<h4 id=\"页面交互相关\"><a href=\"#页面交互相关\" class=\"headerlink\" title=\"页面交互相关\"></a>页面交互相关</h4><pre><code>.back()\n.forward()\n.refresh()\n.click(selector)\n.mousedown(selector)\n.mouseup(selector)\n.mouseover(selector)\n.mouseout(selector)\n.type(selector[, text])\n.insert(selector[, text])\n.check(selector)\n.uncheck(selector)\n.select(selector, option)\n.scrollTo(top, left)\n.viewport(width, height)\n.inject(type, file)\n.evaluate(fn[, arg1, arg2,...])\n.wait(ms)\n.wait(selector)\n.wait(fn[, arg1, arg2,...])\n.header(header, value)\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjaW50ZXJhY3Qtd2l0aC10aGUtcGFnZQ==\">配置参考链接</span></p>\n<h4 id=\"页面提取\"><a href=\"#页面提取\" class=\"headerlink\" title=\"页面提取\"></a>页面提取</h4><pre><code>.exists(selector)\n.visible(selector)\n.on(event, callback)\n.once(event, callback)\n.removeListener(event, callback)\n.screenshot([path][, clip])\n.html(path, saveType)\n.pdf(path, options)\n.title()\n.url()\n.path()\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjZXh0cmFjdC1mcm9tLXRoZS1wYWdl\">配置参考链接</span></p>\n<h2 id=\"补充学习\"><a href=\"#补充学习\" class=\"headerlink\" title=\"补充学习\"></a>补充学习</h2><h3 id=\"补充资料\"><a href=\"#补充资料\" class=\"headerlink\" title=\"补充资料\"></a>补充资料</h3><h4 id=\"软件测试的分类\"><a href=\"#软件测试的分类\" class=\"headerlink\" title=\"软件测试的分类\"></a>软件测试的分类</h4><p><strong>第一部分：软件测试的分类</strong></p>\n<ul>\n<li><p>按测试执行阶段划分</p>\n<p>单元测试、集成测试、系统测试、验收测试（正式验收测试、Alpha测试、Beta测试）</p>\n</li>\n<li><p>按测试技术划分</p>\n<p>白盒测试、黑盒测试、灰盒测试</p>\n</li>\n<li><p>被测试对象是否运行划分</p>\n<p>动态测试、静态测试（文档检查、代码走查、界面检查）</p>\n</li>\n<li><p>按不同的测试手段划分</p>\n<p>手工测试、自动化测试</p>\n</li>\n<li><p>按测试包含的内容划分</p>\n<p>功能测试、界面测试、安全测试、兼容性测试、易用性测试、性能测试、压力测试、负载测试、恢复测试</p>\n</li>\n<li><p>其他测试</p>\n<p>冒烟测试、回归测试、探索性测试&#x2F;自由测试（测试思维）</p>\n</li>\n</ul>\n<p><strong>第二部分：接下来对软件测试分类进行一个说明</strong></p>\n<p><img data-src=\"/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg\" alt=\"img\"><img data-src=\"/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg\" alt=\"img\"></p>\n<p><img data-src=\"/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-f831b8041976b50aad7c2425aada44e2_hd-1561454378198.jpg\" alt=\"img\"><img data-src=\"/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-f831b8041976b50aad7c2425aada44e2_hd.jpg\" alt=\"img\"></p>\n<p><strong>第三部分：测试工具</strong></p>\n<p>SVN，Git——&gt;版本控制管理工具</p>\n<p>禅道——&gt;Bug管理工具</p>\n<p>Fiddler——&gt;抓包，定位问题你</p>\n<p>postman，jmeter，soapui——&gt;接口测试</p>\n<p>Loadrunner，Jmeter——&gt;性能，压力测试</p>\n<h4 id=\"2019年Javascript测试概览\"><a href=\"#2019年Javascript测试概览\" class=\"headerlink\" title=\"2019年Javascript测试概览\"></a>2019年Javascript测试概览</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpdW0uY29tL3dlbGxkb25lLXNvZnR3YXJlL2FuLW92ZXJ2aWV3LW9mLWphdmFzY3JpcHQtdGVzdGluZy1pbi0yMDE5LTI2NGUxOTUxNGQwYQ==\">https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2019-264e19514d0a</span></p>\n<p>这是一篇非常好的国外的博文，同时也是2018年Javascript测试概览的作者。这里有2018年的译文：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjcwMjQyMQ==\">展望 2018 年 JavaScript Testing</span></p>\n<p>在文中很好介绍到了测试类型，并举了大量的例子，非常全面。</p>\n<h4 id=\"什么是TDD？\"><a href=\"#什么是TDD？\" class=\"headerlink\" title=\"什么是TDD？\"></a>什么是TDD？</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzNlNzM4NzZmYjlhMDQ5ZDM3ZjVkYjE=\">测试驱动开发（TDD）总结——原理篇</span></p>\n<p>TDD （Test Driven Development） 在不同的圈子、不同的角色的认知中可能会有不同的理解，有人可能会理解成 ATDD（Acceptance Test Driven Development），也有人可能会理解成 UTDD（Unit Test Driven Development），为了避免产生歧义，<strong>文章涉及到 TDD 专指 UTDD（Unit Test Driven Development），即 「单元测试驱动开发」</strong>。</p>\n<p>TDD 的目标</p>\n<blockquote>\n<p>Kent Beck 在他的著作《Test-Driven Development》一书中提到：“<strong>代码简洁可用</strong>这句言简意赅的话，正是 TDD 所追求的目标”。</p>\n</blockquote>\n<p><strong>对于如何保证“代码简洁可用”可以使用分而治之的方法，先达到“可用”目标，再追求“简洁”目标。</strong></p>\n<p><strong>可用：</strong> 保证代码通过自动化测试。</p>\n<p><strong>代码简洁：</strong> 在不同阶段人们对简洁的理解程度也不一样，不过遵循的原则差不多，例如 OOD 的 SOLID 原则，Kent Beck 的 Simple Design 原则等。</p>\n<p>虽然有很多因素妨碍我们得到整洁的代码，甚至可用的代码，无需征求太多意见，只需要采用 TDD 的开发方式来驱动出简洁可用的代码。</p>\n<h4 id=\"Karma的前世今生\"><a href=\"#Karma的前世今生\" class=\"headerlink\" title=\"Karma的前世今生\"></a>Karma的前世今生</h4><p>2016年的文章，由淘宝前端团队书写：<span class=\"exturl\" data-url=\"aHR0cDovL3Rhb2Jhb2ZlZC5vcmcvYmxvZy8yMDE2LzAxLzA4L2thcm1hLW9yaWdpbi8=\">http://taobaofed.org/blog/2016/01/08/karma-origin/</span></p>\n<p>通篇介绍了karma的工作原理及实现原理，非常有价值的文章。</p>\n<h3 id=\"ava框架的配置文件\"><a href=\"#ava框架的配置文件\" class=\"headerlink\" title=\"ava框架的配置文件\"></a>ava框架的配置文件</h3><pre><code class=\"json\">&#123;\n    &quot;ava&quot;: &#123;\n        &quot;files&quot;: [\n            &quot;test/**/*&quot;,\n            &quot;!test/exclude-files-in-this-directory&quot;,\n            &quot;!**/exclude-files-with-this-name.*&quot;\n        ],\n        &quot;helpers&quot;: [\n            &quot;**/helpers/**/*&quot;\n        ],\n        &quot;sources&quot;: [\n            &quot;src/**/*&quot;\n        ],\n        &quot;match&quot;: [\n            &quot;*oo&quot;,\n            &quot;!foo&quot;\n        ],\n        &quot;cache&quot;: true,\n        &quot;concurrency&quot;: 5,\n        &quot;failFast&quot;: true,\n        &quot;failWithoutAssertions&quot;: false,\n        &quot;environmentVariables&quot;: &#123;\n            &quot;MY_ENVIRONMENT_VARIABLE&quot;: &quot;some value&quot;\n        &#125;,\n        &quot;tap&quot;: true,\n        &quot;verbose&quot;: true,\n        &quot;compileEnhancements&quot;: false,\n        &quot;require&quot;: [\n            &quot;@babel/register&quot;\n        ],\n        &quot;babel&quot;: &#123;\n            &quot;extensions&quot;: [&quot;js&quot;, &quot;jsx&quot;],\n            &quot;testOptions&quot;: &#123;\n                &quot;babelrc&quot;: false\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li><code>files</code>：用于选择测试文件的glob模式数组。带有下划线前缀的文件将被忽略。默认情况下，仅选择具有<code>js</code>扩展名的文件，即使该模式与其他文件匹配。指定<code>extensions</code>并<code>babel.extensions</code>允许其他文件扩展名</li>\n<li><code>helpers</code>：用于选择帮助文件的glob模式数组。这里匹配的文件永远不会被视为测试。默认情况下，仅选择具有<code>js</code>扩展名的文件，即使该模式与其他文件匹配。指定<code>extensions</code>并<code>babel.extensions</code>允许其他文件扩展名</li>\n<li><code>sources</code>：一组glob模式，用于匹配文件，这些文件在更改时会导致重新运行测试（在监视模式下）。有关详细信息，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzL3JlY2lwZXMvd2F0Y2gtbW9kZS5tZCNzb3VyY2UtZmlsZXMtYW5kLXRlc3QtZmlsZXM=\">请参阅</span></li>\n<li><code>match</code>：通常在<code>package.json</code>配置中没用，但等同于在CLI上指定<code>--match</code></li>\n<li><code>cache</code>：缓存编译的测试和帮助文件<code>node_modules/.cache/ava</code>。如果<code>false</code>，文件缓存在临时目录中</li>\n<li><code>failFast</code>：一旦测试失败，停止运行进一步的测试</li>\n<li><code>failWithoutAssertions</code>：如果设置成<code>false</code>，那么如果没有运行断言，则测试失败</li>\n<li><code>environmentVariables</code>：指定要供测试使用的环境变量。此处定义的环境变量会覆盖其中的环境变量<code>process.env</code></li>\n<li><code>tap</code>：设置成 <code>true</code>，启用TAP报告</li>\n<li><code>verbose</code>：设置成 <code>true</code>，启用详细输出</li>\n<li><code>snapshotDir</code>：指定用于存储快照文件的固定位置。如果快照最终位于错误的位置，请使用此选项</li>\n<li><code>compileEnhancements</code>：设置成 <code>false</code>，禁用了 <a href=\"https://github.com/avajs/ava/blob/master/docs/03-assertions.md#enhanced-assertion-messages\"><code>power-assert</code></a>，否则有助于提供更具描述性的错误消息， 并检测<code>t.throws()</code>断言的不当使用</li>\n<li><code>extensions</code>：未使用AVA的Babel预设进行预编译的测试文件的扩展名。请注意，文件仍然会被编译为启用<code>power-assert</code>和其他功能，因此您可能还需要设置<code>compileEnhancements</code>为<code>false</code>文件是否为有效的JavaScript。设置此<code>&quot;js&quot;</code>值会覆盖默认值，因此请确保在列表中包含该扩展名，只要它不包含在内<code>babel.extensions</code></li>\n<li><code>require</code>：在运行测试之前需要额外的模块。工作进程中需要模块</li>\n<li><code>babel</code>：测试文件特定的Babel选项。有关详细信息，请参阅<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzL3JlY2lwZXMvYmFiZWwubWQjY29uZmlndXJpbmctYmFiZWw=\">Babel配置</span></li>\n<li><code>babel.extensions</code>：将使用AVA的Babel预设进行预编译的测试文件的扩展。设置此选项会覆盖默认<code>&quot;js&quot;</code>值，因此请确保在列表中包含该扩展名。</li>\n<li><code>timeout</code>：AVA中的超时行为与其他测试框架中的行为不同。AVA在每次测试后重置计时器，如果在指定的超时内没有收到新的测试结果，则强制测试退出。这可用于处理停滞的测试。请参阅我们的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzLzA3LXRlc3QtdGltZW91dHMubWQ=\">超时文档</span>以获取更多选</li>\n</ul>\n<p>请注意，在CLI上提供文件会覆盖该<code>files</code>选项。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzAwOTY2NA==\">使用Jest测试JavaScript(Mock篇)</span></li>\n</ul>\n","categories":["自动化测试"],"tags":["自动化测试"]},{"title":"项目质量检测","url":"/2024/01/02/%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B/","content":"<h1 id=\"5-2-项目质量监测\"><a href=\"#5-2-项目质量监测\" class=\"headerlink\" title=\"5-2 项目质量监测\"></a>5-2 项目质量监测</h1><h2 id=\"课程介绍\"><a href=\"#课程介绍\" class=\"headerlink\" title=\"课程介绍\"></a>课程介绍</h2><p>没有规矩不成方圆，所以我们写代码也要有”规矩”，但是我们通常记不住所有的”规矩”，因为人嘛，不可能不犯错。但是，这难不到我们程序员，我们让机器、代码、程序帮我们搞定，让它们来帮我们进行代码质量检查，以便提高的程序的健壮性。</p>\n<p>通常来说，项目的质量决定了：</p>\n<ul>\n<li>软件项目的<strong>命运</strong></li>\n<li>软件项目的<strong>可维护性</strong></li>\n<li>软件项目的<strong>运维成本</strong></li>\n<li>软件项目的<strong>扩展性</strong></li>\n</ul>\n<p><strong>为什么要进行代码质量检查？</strong></p>\n<p>代码检查很重要，原因有三：</p>\n<ol>\n<li><strong>避免低级bug</strong>：一些常见代码问题，如果在编译或运行前不能及时发现，代码中的语法问题会直接导致编译或运行时错误，影响开发效率和代码质量；</li>\n<li><strong>统一代码习惯</strong>：每一个团队或个人都会有一些代码规范或者代码习惯，为了便于后期维护和阅读，我们编写的代码也需要符合一定的格式规范；<ul>\n<li>空格</li>\n<li>统一缩进</li>\n<li>命名规范</li>\n<li>…</li>\n</ul>\n</li>\n<li><strong>保证线上代码质量</strong>：在版本管理中，我们需要在提交或发布之前自动执行一些代码检查工作，确保我们的代码符合最终版本要求。</li>\n</ol>\n<p>如何让一个团队的人产出的代码都在一个基本水平底线之上呢？最初是靠制订规范。要确保规范得以执行只能靠人，所以文字规范成了code review的公共参照标准。<strong>单纯靠人的事最终都容易流于形式，所以需要工具加以保证。</strong>虽说工具并不能完全实现规范中的规则，但至少能够在一定程度上缓解代码不统一的局面。</p>\n<p><strong>本课程的学习路径：</strong></p>\n<ul>\n<li>Why</li>\n<li>What</li>\n<li>How</li>\n</ul>\n<p><strong>本课程的主要内容：</strong></p>\n<p>代码质量监测包括：代码规范（代码编写层面）、功能实现（测试层面）、Code Review（团队协作层面）。</p>\n<p>本课程，代码规范作为展开，以eslint为例子；代码质量中的功能实现，以e2e test为例子。</p>\n<p>关于，功能实现中的单元测试，5-3课程中有具体的框架使用及介绍。</p>\n<ul>\n<li>代码Lint——告别低级代码错误，简单的配置让程序来自动检查</li>\n<li>e2e test——了解什么是黑盒测试，如何进行e2e test，即End to End Test，端到端的测试。</li>\n<li>开源测试平台：Codecov介绍——配合Ci工具，让测试过程自动化，大大提升效率</li>\n</ul>\n<p><img data-src=\"/assets/MacHi-2017-10-15-21-45-04.png\" alt=\"img\"></p>\n<p>这些徽章都是可以点击的，第一个点进去是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmF2aXMtY2kub3JnLyVFRiVCQyU4Q3RyYXZpcy1jaQ==\">https://travis-ci.org/，travis-ci</span> 是一个 CI（Continuous integration，持续集成） 平台，主要提供集群编译、单测、集成测试的环境。<code>.org</code> 的服务对公有仓库免费，<code>.com</code> 面向私人、团队、公司的项目提供商业支持（收费）。使用起来非常简单，使用 Github 帐号登录进去，就能看见开始界面。</p>\n<p>第二个徽章是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlY292LmlvLw==\">codecov.io</span>（单测覆盖率统计平台），接入过程也很简单，也是不同语言选择不同的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmNvZGVjb3YuaW8vZG9jcy9zdXBwb3J0ZWQtbGFuZ3VhZ2Vz\">配置文件</span>，codecov 可以无缝衔接 travis-ci，只需要在原来的配置文件上稍作修改即可，核心就是生成单测的结果文件。\\</p>\n<p><strong>本课程的学习准备：</strong></p>\n<ul>\n<li>IDE vscode，node &gt; 10.15</li>\n<li>包管理工具：yarn, cnpm</li>\n<li>Github账号</li>\n</ul>\n<h2 id=\"代码质量检查\"><a href=\"#代码质量检查\" class=\"headerlink\" title=\"代码质量检查\"></a>代码质量检查</h2><h3 id=\"前端代码中的常见问题-Why-Lint\"><a href=\"#前端代码中的常见问题-Why-Lint\" class=\"headerlink\" title=\"前端代码中的常见问题(Why Lint)\"></a>前端代码中的常见问题(Why Lint)</h3><h4 id=\"书写风格\"><a href=\"#书写风格\" class=\"headerlink\" title=\"书写风格\"></a>书写风格</h4><p>这个问题不用作过多阐述，想必接手过他人代码的同学，多少都有些体会。简单来说，太过随意的代码会让强迫症患者难以容忍，难以阅读理解的代码有时甚至不如推倒重来。</p>\n<pre><code class=\"javascript\">// bad\nvar once\n  , upon\n  , aTime;\n\n// good\nvar once,\n    upon,\n    aTime;\n\n// bad\nvar hero = &#123;\n    firstName: &#39;Bob&#39;\n  , lastName: &#39;Parr&#39;\n  , heroName: &#39;Mr. Incredible&#39;\n  , superPower: &#39;strength&#39;\n&#125;;\n\n// good\nvar hero = &#123;\n  firstName: &#39;Bob&#39;,\n  lastName: &#39;Parr&#39;,\n  heroName: &#39;Mr. Incredible&#39;,\n  superPower: &#39;strength&#39;\n&#125;;\n</code></pre>\n<h4 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h4><p>什么样的代码是低质量或高质量的？好的代码可能会让你如读小说一般被吸引，糟糕的代码会让你看一眼就不想继续、甚至看半天而不知所云。</p>\n<p>有人可能认为初级程序员才会有这种问题，其实不然，一些工作经验两三年的同学写的代码依然如此。对于一些个人自学意识不够积极、没有团队规范性指引的同学，很容易习惯成“学习半年、然后重复三年无长进”的情况。</p>\n<p>Lint会通过源代码去查找：</p>\n<ul>\n<li><p>格式问题</p>\n</li>\n<li><p>不遵守编码标准和惯例</p>\n</li>\n<li><p>精确定位程序中可能存在的逻辑错误</p>\n</li>\n</ul>\n<h4 id=\"高度耦合\"><a href=\"#高度耦合\" class=\"headerlink\" title=\"高度耦合\"></a>高度耦合</h4><p>这种问题其实是非常普遍的。一个函数几百行、一个文件数千行、一个类几十个方法、方法参数定义随意、没有任何注释、方法与变量命名无明确的语义、数据修改与变更穿插在各种方法中等等。 这样的编码方式，你要去理解它的逻辑往往真的很难，一般只能一块块一行行的去做阅读理解（可能还会开启边看边骂娘模式）。</p>\n<p>这主要原因在于开发者个人的基础知识能力、编码经验和意识等的不足。</p>\n<p>其实针对这种情况，常见的开源的编码规范都会有所提及。我的建议是这些同学应该好好温习一下面向对象编程、函数式编程、数据结构、常见设计模式，看一看各种开源的编码规范并尝试去真正的理解它们。当你回顾一个月前的代码时，发现可以改进或重构使得编码逻辑更为简洁清晰，说明你是在成长与进步的。</p>\n<p>经常看到有同学问这类问题：新项目正在选型，Vue.js、React、Angular 三大框架哪个合适？其实团队开发成员对这些都比较有经验，哪种都可以；如果团队成员前端开发经验大都不是太丰富或人员不够稳定，选择 Vue.js 最适合，为什么？因为它更简单简洁，容易上手。Vue.js 通过 prop、data、computed、method、watch 等各种钩子，一定程度上限定了编码方式与风格，使得初级开发者写出来的代码也不会太难看，这也是它越来越受社区推崇的原因之一。</p>\n<h3 id=\"代码质量监测（Def-Lint-Code）\"><a href=\"#代码质量监测（Def-Lint-Code）\" class=\"headerlink\" title=\"代码质量监测（Def: Lint Code）\"></a>代码质量监测（Def: Lint Code）</h3><p>那么，什么是代码质量监测？</p>\n<p>Lint或者Linter是一种分析源代码以标记编程过程中（代码、样式、构建）书写的错误的工具或者过程。</p>\n<blockquote>\n<p><strong>Lint</strong>, or a <strong>linter</strong>, is a tool that analyzes <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU291cmNlX2NvZGU=\">source code</span> to flag programming errors, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29mdHdhcmVfYnVn\">bugs</span>, stylistic errors, and suspicious constructs.[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGludF8oc29mdHdhcmUpI2NpdGVfbm90ZS0x\">1]</span> The term originates from a <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5peA==\">Unix</span> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl91dGlsaXR5X3NvZnR3YXJl\">utility</span> that examined <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ18ocHJvZ3JhbW1pbmdfbGFuZ3VhZ2Up\">C language</span> source code.[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGludF8oc29mdHdhcmUpI2NpdGVfbm90ZS1CZWxsTGFicy0y\">2]</span></p>\n</blockquote>\n<p>代码Lint是动态的监测代码编写的错误，以便我们能写出高质量的代码。</p>\n<blockquote>\n<p>与Prettier或者Format要区别开来，Lint只会告诉你代码中的错误或者不符合规范的地方，而Format是用来对格式进行调整的。</p>\n</blockquote>\n<h3 id=\"如何进行代码质量监测-How-to-Lint\"><a href=\"#如何进行代码质量监测-How-to-Lint\" class=\"headerlink\" title=\"如何进行代码质量监测(How to Lint)\"></a>如何进行代码质量监测(How to Lint)</h3><p>为了统一团队的代码规范，除了一纸规范说明之外，还需要引入工具进行限制。虽说工具并不能完全实现规范中的规则，但至少能够在一定程度上缓解代码不统一的局面。</p>\n<p>相对于后端，前端代码规范的质量检查涉及到HTML, CSS，Javascript ，如今还涉及到SCSS，ES5，JSX,  React，Vue，Angular等。</p>\n<p>常见的代码质量Lint工具：</p>\n<p>HTML &#x2F; tpl:  <span class=\"exturl\" data-url=\"aHR0cDovL2h0bWxoaW50LmNvbS8=\">HTMLHint</span></p>\n<p>CSS &#x2F; SCSS: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHlsZWxpbnQuaW8v\">StyleLint</span></p>\n<p>JS &#x2F; JSX: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lc2xpbnQub3JnLw==\">ESLint</span></p>\n<h3 id=\"3种常见的Js检验工具比较\"><a href=\"#3种常见的Js检验工具比较\" class=\"headerlink\" title=\"3种常见的Js检验工具比较\"></a>3种常见的Js检验工具比较</h3><p>常见三个可以使用的js校验器，但是怎么选择使用哪一个呢？接下来让我们看看这四种流行方案的特点、优点和不足：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qc2xpbnQuY29tLw==\">JSLint</span>、<span class=\"exturl\" data-url=\"aHR0cDovL2pzaGludC5jb20v\">JSHint</span>、<span class=\"exturl\" data-url=\"aHR0cDovL2VzbGludC5vcmcv\">ESLint</span>。</p>\n<p>四种工具用相同的基本方式工作。他们都有一套用户分析、报告js文件错误的规则。他们都可以通过npm安装。他们都可以通过命令行使用、作为IDE插件使用、也可以集成到编辑器中。他们四种均支持使用注释进行配置。</p>\n<h4 id=\"JSLint\"><a href=\"#JSLint\" class=\"headerlink\" title=\"JSLint\"></a>JSLint</h4><p>JSLint是其中最老的工具。在2002年 Douglas Crockford开发了该工具，根据其经验，强制使用js语言中精粹的部分。如果你同意这些精粹，JSLint能成为一个好的工具。</p>\n<p>JSLint的缺点是不能配置和拓展。你根本不能禁掉需要特性，并且很多缺少文档。官方文档非常不友好，例如缺少如何将其集成到编辑的信息。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>参数配置完成，可以直接使用</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>JSLint不存在配置文件，如果想改变参数设置，那就存在问题</li>\n<li>有限的配置选项，许多规则不能禁掉</li>\n<li>不能增加个性化规则</li>\n<li>没有文档记录规则</li>\n<li>很难弄清楚哪个规则引起的错误</li>\n</ul>\n<h4 id=\"JSHint\"><a href=\"#JSHint\" class=\"headerlink\" title=\"JSHint\"></a>JSHint</h4><p>作为一个可配置的JSLint版本，JSHint被开发出来。你可以配置每个规则，将其放到一个配置文件中，这样在大项目中可以容易使用。JSHint对每个规则有好的文档，所以可以准确知道每个规则的作用。将其集成到编辑器也是简单的。</p>\n<p>JSHint的一个小缺点是里面的松散默认配置。也即是你在使其可用之前必须将其启动。和ESLint相比，确定哪个规则用户开启或关闭错误信息，JSHint是更加困难。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>大多是参数可以配置</li>\n<li>支持配置文件，在大项目中容易使用</li>\n<li>已经支持需要类库，像jQuery、QUnit、NodeJS、Mocha等</li>\n<li>支持基本的ES6</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>难于知道哪个规则产生错误</li>\n<li>存在两类选项：强制选项和松散选项。使得配置有些混乱</li>\n<li>不支持自定义规则</li>\n</ul>\n<h4 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h4><p>ESLint是比较新出来的工具。它被设计的容易拓展、拥有大量的自定义规则、容易的通过插件来安装。它给出准确的输出，而且包括规则名，这样可以知道哪个规则造成了错误。</p>\n<p>ESLint文档多少有些混乱。规则容易查找，以及被分为逻辑组，但是配置指南在有些地方容易弄混。然而它可以在一个地方提供链接去编辑集成、插件和样例。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>灵活：任何规则都可以开启闭合，以及有些规则有些额外配置</li>\n<li>很容易拓展和有需要可用插件</li>\n<li>容易理解产出</li>\n<li>包含了在其他检查器中不可用的规则，使得ESLint在错误检查上更有用</li>\n<li>支持ES6，支持JSX的工具</li>\n<li>支持自定义报告</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>需要一些配置</li>\n<li>速度慢</li>\n</ul>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2pzY3MuaW5mby8=\">JSCS</span>已经合并到ESlint</p>\n</blockquote>\n<p>总结一下：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>JSLint</th>\n<th>JSHint</th>\n<th>ESLint</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>初始配置</td>\n<td>有</td>\n<td>有</td>\n<td>可配置</td>\n</tr>\n<tr>\n<td>自定义</td>\n<td>命令行，有限</td>\n<td>可配置</td>\n<td>可配置</td>\n</tr>\n<tr>\n<td>配置文件</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ES6</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>JSX</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>执行效率</td>\n<td>高</td>\n<td>中</td>\n<td>低</td>\n</tr>\n<tr>\n<td>输出友好度</td>\n<td>低</td>\n<td>中</td>\n<td>高</td>\n</tr>\n<tr>\n<td>Stars</td>\n<td>3.3k</td>\n<td>8.2k</td>\n<td>14.2k</td>\n</tr>\n</tbody></table>\n<h2 id=\"Lint工具介绍\"><a href=\"#Lint工具介绍\" class=\"headerlink\" title=\"Lint工具介绍\"></a>Lint工具介绍</h2><p>Lint是一种工具，可以分析源代码，并在出现错误或与团队编码约定不符时通知用户。在某些情况下，它还可以自动修复错误。</p>\n<p>虽然已经为不同语言开发了许多种Lint，但是有些人可能遇到过以下问题。</p>\n<ul>\n<li><p>这是我第一次使用这种语言进行编码，什么被认为是这种语言的一般编码风格？</p>\n</li>\n<li><p>我正在使用Lint的默认设置，但错误验证过程太严格。</p>\n<p>我想更改设置，但是更改设置会更容易忽略某些错误吗？</p>\n</li>\n</ul>\n<p>即使对于单一语言，也提出了各种编码约定。因此，特别是首先，确定哪些编码约定更好地遵循可能是困难的。</p>\n<p>因此，让我们研究一下常用的开源软件上的Lint设置，看看正在使用哪种设置和编码约定。</p>\n<h3 id=\"ESLint-1\"><a href=\"#ESLint-1\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h3><p>ESLint是JavaScript的linting实用程序。</p>\n<p>ESLint不依赖于特定的编码约定，用户也可以自由地启用或禁用各个编码约定。从这个意义上讲，它的一个主要特点是其高度可定制性。</p>\n<p>用户可以通过定义原始<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvcnVsZXMv\">规则来</span>灵活地设置编码标准，这些规则是ESLint中默认可用的编码规则。此外，第三方共享的着名编码约定，例如“Google JavaScript Style Guide”或“Airbnb JavaScript Style Guide”也可以重复使用。</p>\n<p>您甚至可以在遵循这些编码约定的同时启用&#x2F;禁用特定文件的特定规则。</p>\n<p>如果您不知道要开始的设置，可以参考ESLint官方提供的“ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvdXNlci1ndWlkZS9nZXR0aW5nLXN0YXJ0ZWQ=\">入门</span> ”指南，以使用建议的编码约定。</p>\n<p>核心概念：</p>\n<ul>\n<li><p>配置文件：</p>\n<p><code>.eslintrc</code>，<code>.eslintrc.js</code>，<code>.eslintrc.yml</code></p>\n</li>\n<li><p>Rules：</p>\n<ul>\n<li>“off” 或 <code>0</code> - 关闭规则</li>\n<li>“warn” 或 <code>1</code> - 开启规则，使用警告级别的错误：warn (不会导致程序退出)</li>\n<li>“error” 或 <code>2</code> - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)</li>\n</ul>\n<p>看一个例子：</p>\n<pre><code class=\"json\">&#123;\n    &quot;rules&quot;: &#123;\n        &quot;semi&quot;: [&quot;error&quot;, &quot;never&quot;],\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]\n    &#125;\n&#125;\n</code></pre>\n<p>也可以写成：</p>\n<pre><code class=\"json\">&#123;\n    &quot;rules&quot;: &#123;\n        &quot;semi&quot;: [2, &quot;never&quot;],\n        &quot;quotes&quot;: [2, &quot;single&quot;]\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>Extends：</p>\n<p>使用别人提供的包， 如google</p>\n<pre><code class=\"json\">&#123; \n    &quot;extends&quot;：&quot;google&quot;，\n&#125;\n</code></pre>\n<p>通过使用上述说明，用户可以轻松使用Google JavaScript样式指南中的编码约定，而无需从头开始编写设置。</p>\n</li>\n<li><p>Plugins:</p>\n<p>ESLint提供的默认规则涵盖了基本规则，但JavaScript可以使用的范围非常广泛。因此，您可能希望规则不在默认规则中。在这种情况下，可以在ESLint中开发自己的独立规则。为了让第三方开发自己的规则，ESLint允许使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvZGV2ZWxvcGVyLWd1aWRlL3dvcmtpbmctd2l0aC1wbHVnaW5z\">插件</span>。如果你在npm中搜索eslint-plugin- *，你可以找到第三方提供的大量自定义插件。</p>\n<p>如果ESLint的默认规则未提供您要使用的规则，则建议您查找插件。</p>\n<p>与可共享配置类似，它很容易设置。例如，如果要对React代码执行静态分析，可以安装名为<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXNsaW50LXBsdWdpbi1yZWFjdA==\">eslint-plugin-react的插件</span>，并使用以下设置来执行React语法特有的静态分析。</p>\n<pre><code class=\"json\">&#123; \n    &quot;extends&quot;: &quot;google&quot;，\n    &quot;plugins&quot;: [ \n        &quot;react&quot; \n    ]，\n    &quot;rules&quot;&quot;: &#123; \n        &quot;semi&quot;: [&quot;error&quot;, &quot;never&quot;],\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]\n    &#125; \n&#125;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"起步与安装\"><a href=\"#起步与安装\" class=\"headerlink\" title=\"起步与安装\"></a>起步与安装</h4><ol>\n<li><p>在项目中去使用</p>\n<pre><code class=\"json\">// npm init 指令会在项目根目录下生成 package.json 文件。\nnpm init\n\n// --save-dev 会把 eslint 安装到 package.json 文件中的 devDependencies 属性中，意思是只是开发阶段用到这个包，上线时就不需要这个包了。\nnpm install eslint --save-dev\n</code></pre>\n<ul>\n<li>使用<code>npm run</code></li>\n</ul>\n<p>新增<code>package.json</code> 脚本，或者使用 <code>npx</code>命令</p>\n<pre><code class=\"javascript\">&quot;scripts&quot;: &#123;\n    &quot;lint&quot;: &quot;eslint src&quot;,\n    &quot;lint:create&quot;: &quot;eslint --init&quot;\n&#125;\n</code></pre>\n<p>然后使用<code>run</code>命令：</p>\n<pre><code class=\"bash\">npm run lint\n</code></pre>\n<ul>\n<li>直接使用<code>npx</code>命令：</li>\n</ul>\n<pre><code class=\"bash\">npx eslint --init\n\n// 或者\n./node_modules/.bin/eslint --init\n</code></pre>\n</li>\n<li><p>在全局使用</p>\n<pre><code class=\"bash\">npm install -g eslint\n</code></pre>\n</li>\n</ol>\n<h4 id=\"ESLint初始化\"><a href=\"#ESLint初始化\" class=\"headerlink\" title=\"ESLint初始化\"></a>ESLint初始化</h4><p>配置方法使用 <code>eslint --init</code>方法</p>\n<pre><code class=\"bash\">➜ npx eslint --init\n? How would you like to use ESLint? (Use arrow keys)\n  To check syntax only \n❯ To check syntax and find problems \n  To check syntax, find problems, and enforce code style \n  \n? What type of modules does your project use? (Use arrow keys)\n❯ JavaScript modules (import/export) \n  CommonJS (require/exports) \n  None of these \n  \n// 这里可以针对你的开发项目进行配置\n? Which framework does your project use? \n  React \n  Vue.js \n❯ None of these \n\n// 可以配置代码运行的地方，是浏览器还是Node环境？\n? Where does your code run? \n❯◉ Browser\n ◉ Node\n \n// 最张在哪里缓存\n? What format do you want your config file to be in? (Use arrow keys)\n❯ JavaScript \n  YAML \n  JSON \n\n// 成功创建了配置文件\n? What format do you want your config file to be in? JavaScript\nSuccessfully created .eslintrc.js file in /Users/itheima/Downloads/Demo\n</code></pre>\n<p>配置文件<code>.eslintrc.js</code>：</p>\n<blockquote>\n<p>废弃的用法：<code>.eslintrc</code>，eslint使用配置的顺序：<code>.eslintrc.js</code> &gt; <code>.eslintrc.yaml</code> &gt; <code>.eslintrc.yml</code> &gt; <code>.eslintrc.json</code> &gt; <code>.eslintrc</code> &gt; <code>package.json</code></p>\n</blockquote>\n<p><code>.eslintrc.js</code>文件：</p>\n<pre><code class=\"js\">module.exports = &#123;\n    &quot;env&quot;: &#123;\n        &quot;browser&quot;: true,\n        &quot;es6&quot;: true,\n        &quot;node&quot;: true\n    &#125;,\n    &quot;extends&quot;: &quot;eslint:recommended&quot;,\n    &quot;globals&quot;: &#123;\n        &quot;Atomics&quot;: &quot;readonly&quot;,\n        &quot;SharedArrayBuffer&quot;: &quot;readonly&quot;\n    &#125;,\n    &quot;parserOptions&quot;: &#123;\n        &quot;ecmaVersion&quot;: 2018,\n        &quot;sourceType&quot;: &quot;module&quot;\n    &#125;,\n    &quot;rules&quot;: &#123;\n    &#125;\n&#125;;\n</code></pre>\n<p>再来看看，<code>yaml</code>文件配置：</p>\n<pre><code class=\"yaml\">env:\n  browser: true\n  es6: true\n  node: true\nextends: &#39;eslint:recommended&#39;\nglobals:\n  Atomics: readonly\n  SharedArrayBuffer: readonly\nparserOptions:\n  ecmaVersion: 2018\n  sourceType: module\nrules: &#123;&#125;\n</code></pre>\n<p>该文件导出一个对象，对象包含属性 <code>env</code>、<code>extends</code>、<code>parserOptions</code>、<code>plugins</code>、<code>rules</code> 五个属性：</p>\n<ul>\n<li><p><code>env</code>：指定脚本的运行环境。每种环境都有一组特定的预定义全局变量，（如：nodejs，browser，commonjs等）中。</p>\n</li>\n<li><p><code>parserOptions</code>：用于指定想要支持的JavaScript语言选项</p>\n<ul>\n<li><p><code>ecmaVersion</code> - 默认设置为3，5（默认）， 你可以使用 6、7、8 或 9 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）或 2018（同 9）</p>\n</li>\n<li><p><code>sourceType</code> - 设置为 <code>&quot;script&quot;</code> (默认) 或 <code>&quot;module&quot;</code>（如果你的代码是 ECMAScript 模块)。</p>\n</li>\n<li><pre><code>ecmaFeatures\n</code></pre>\n<p>- 这是个对象，表示你想使用的额外的语言特性:</p>\n<ul>\n<li><code>globalReturn</code> - 允许在全局作用域下使用 <code>return</code> 语句</li>\n<li><code>impliedStrict</code> - 启用全局 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RyaWN0X21vZGU=\">strict mode</span> (如果 <code>ecmaVersion</code> 是 5 或更高)</li>\n<li><code>jsx</code> - 启用 <span class=\"exturl\" data-url=\"aHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9qc3gv\">JSX</span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>globals</code>：执行代码时脚步需要访问的额外全局变量。</p>\n</li>\n<li><p><code>rules</code>：开启某些规则，也可以设置规则的等级。</p>\n</li>\n<li><p><code>extends</code>: 对默认规则进行扩展，可以使用<code>Airbnb</code>，或者<code>Standard</code>规则。</p>\n</li>\n</ul>\n<h4 id=\"eslintignore\"><a href=\"#eslintignore\" class=\"headerlink\" title=\".eslintignore\"></a>.eslintignore</h4><p>可以在项目根目录创建，告诉ESLint忽略某些文件或者目录。相当于.gitignore都是纯文本文件。<br>例如</p>\n<pre><code># 注释，忽略文件node_modules**/.jsbuild\n</code></pre>\n<p>常见的eslintignore内容：</p>\n<pre><code>node_modules/*\n**/node_modules/*\ndist/*\n/build/**\n/coverage/**\n/docs/**\n/jsdoc/**\n/templates/**\n/tests/bench/**\n/tests/fixtures/**\n/tests/performance/**\n/tmp/**\n/lib/rules/utils/unicode/is-combining-character.js\ntest.js\n!.eslintrc.js\n</code></pre>\n<h4 id=\"ESLint的使用方法\"><a href=\"#ESLint的使用方法\" class=\"headerlink\" title=\"ESLint的使用方法\"></a>ESLint的使用方法</h4><ul>\n<li><p>本地使用方法：</p>\n<p>如果你想让 ESLint 成为你项目构建系统的一部分，我们建议在本地安装。你可以使用 npm：</p>\n<pre><code class=\"bash\">$ npm install eslint --save-dev\n</code></pre>\n<p>紧接着你应该设置一个配置文件：</p>\n<pre><code class=\"bash\">$ ./node_modules/.bin/eslint --init\n</code></pre>\n<p>之后，你可以在你项目根目录运行 ESLint：</p>\n<pre><code class=\"bash\">$ ./node_modules/.bin/eslint yourfile.js\n</code></pre>\n<p>使用本地安装的 ESLint 时，你使用的任何插件或可分享的配置也都必须在本地安装。</p>\n</li>\n<li><p>全局使用</p>\n<p>如果你想使 ESLint 适用于你所有的项目，我们建议你全局安装 ESLint。你可以使用 npm：</p>\n<pre><code>$ npm install -g eslint\n</code></pre>\n<p>紧接着你应该设置一个配置文件：</p>\n<pre><code>$ eslint --init\n</code></pre>\n<p>之后，你可以在任何文件或目录运行 ESLint：</p>\n<pre><code>$ eslint yourfile.js\n</code></pre>\n</li>\n</ul>\n<h4 id=\"常用ESlint配置\"><a href=\"#常用ESlint配置\" class=\"headerlink\" title=\"常用ESlint配置\"></a>常用ESlint配置</h4><p>ESLint的规范：</p>\n<p>Standard: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0YW5kYXJkL2VzbGludC1jb25maWctc3RhbmRhcmQ=\">https://github.com/standard/eslint-config-standard</span></p>\n<p>具体地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0YW5kYXJkL2VzbGludC1jb25maWctc3RhbmRhcmQvYmxvYi9tYXN0ZXIvZXNsaW50cmMuanNvbg==\">eslintrc.json</span></p>\n<p>Airbnb: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9qYXZhc2NyaXB0\">https://github.com/airbnb/javascript</span></p>\n<ol>\n<li><p>comma逗号</p>\n<pre><code class=\"js\">rules: &#123;\n    &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;never&quot;],\n&#125;\n</code></pre>\n<p>Bad:</p>\n<pre><code class=\"js\">var foo = &#123;\n    a: &#39;123&#39;,\n    b: &#39;321&#39;, // wrong error\n&#125;\n</code></pre>\n<p>Right:</p>\n<pre><code class=\"js\">var foo = &#123;\n    a: &#39;123&#39;,\n    b: &#39;321&#39;\n&#125;\n</code></pre>\n</li>\n<li><p>quotes引号</p>\n</li>\n<li><p>semi分号</p>\n</li>\n<li><p>空行</p>\n</li>\n<li><p>驼峰命名</p>\n</li>\n<li><p>日志输出</p>\n</li>\n<li><p>强等判断</p>\n</li>\n<li><p>冗余的变量</p>\n</li>\n<li><p>空格</p>\n<ul>\n<li>关键字后的空格</li>\n<li>函数名后的空格</li>\n<li>缩进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"在IDE中的配置\"><a href=\"#在IDE中的配置\" class=\"headerlink\" title=\"在IDE中的配置\"></a>在IDE中的配置</h4><ul>\n<li>以下是vscode中插件配置：</li>\n</ul>\n<p><img data-src=\"/./assets/image-20190626120020180.png\" alt=\"/images/image-20190626120020180\"></p>\n<p>配置文件：</p>\n<pre><code class=\"json\">  &quot;eslint.alwaysShowStatus&quot;: true,\n  &quot;eslint.autoFixOnSave&quot;: true,\n  &quot;editor.formatOnSave&quot;: true,\n  &quot;eslint.validate&quot;: [\n    &quot;javascriptreact&quot;,\n    &#123;\n      &quot;language&quot;: &quot;html&quot;,\n      &quot;autoFix&quot;: true\n    &#125;,\n    &#123;\n      &quot;language&quot;: &quot;javascript&quot;,\n      &quot;autoFix&quot;: true\n    &#125;\n  ],\n  &quot;eslint.options&quot;: &#123;\n    &quot;plugins&quot;: [&quot;html&quot;]\n  &#125;,\n</code></pre>\n<p>快速修复配置：</p>\n<p>打开 <code>&quot;editor.formatOnSave&quot;:  true</code>并且要打开<code>eslint.validate</code>如上面的配置，或者在UI界面里面设置。</p>\n<p><img data-src=\"/assets/image-20190627124410671.png\" alt=\"/images/image-20190627124410671\"></p>\n<ul>\n<li>在Webstorm中的配置：</li>\n</ul>\n<p>使用Configure Preferences</p>\n<p><img data-src=\"/assets/image-20190626120415006.png\" alt=\"/images/image-20190626120415006\"></p>\n<p>相比于vscode就智能很多。</p>\n<h4 id=\"实战vue项目配置\"><a href=\"#实战vue项目配置\" class=\"headerlink\" title=\"实战vue项目配置\"></a>实战vue项目配置</h4><p>ESlint配置文件：</p>\n<pre><code class=\"js\">module.exports = &#123;\n  root: true,\n  env: &#123;\n    node: true,\n  &#125;,\n  extends: [\n    &#39;plugin:vue/essential&#39;,\n    &#39;@vue/standard&#39;,\n  ],\n  rules: &#123;\n    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,\n    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,\n    semi: [&#39;error&#39;, &#39;never&#39;],\n  &#125;,\n  parserOptions: &#123;\n    parser: &#39;babel-eslint&#39;,\n  &#125;,\n&#125;\n</code></pre>\n<p>需要安装的VSCode插件：</p>\n<ul>\n<li>vue(高亮语法)</li>\n<li>vetur(格式化，代码规范)</li>\n<li>Vue peek(组件跳转)</li>\n<li>vue beautify(vue格式化)</li>\n<li>Vue VSCode Snippets 和 Vue Snippets(代码提示)</li>\n<li>Prettier(格式化 与 上面的Vetur其实是合作格式化)</li>\n</ul>\n<p>vscode配置格式化：</p>\n<pre><code class=\"json\">&quot;eslint.validate&quot;: [\n  &quot;javascript&quot;,\n  &quot;javascriptreact&quot;,\n  &#123;\n    &quot;language&quot;: &quot;html&quot;,\n    &quot;autoFix&quot;: true\n  &#125;,\n  &#123;\n    &quot;language&quot;: &quot;vue&quot;,\n    &quot;autoFix&quot;: true\n  &#125;\n],\n&quot;vetur.format.defaultFormatter.js&quot;: &quot;prettier-eslint&quot;,\n  // prettier\n&quot;prettier.trailingComma&quot;: &quot;es5&quot;,\n&quot;prettier.semi&quot;: false,\n&quot;prettier.jsxSingleQuote&quot;: true,\n&quot;prettier.singleQuote&quot;: true,\n&quot;prettier.eslintIntegration&quot;: true,\n</code></pre>\n<p>配置emmet:</p>\n<pre><code class=\"json\">  &quot;emmet.syntaxProfiles&quot;: &#123;\n    &quot;vue-html&quot;: &quot;html&quot;,\n    &quot;vue&quot;: &quot;html&quot;\n  &#125;,\n</code></pre>\n<p>在Vue-cli工具中，可以使用<code>npm run lint</code>:</p>\n<pre><code class=\"bash\">// bash输出\n➜ npm run lint\n\n&gt; vue-recipe@0.1.0 lint /Users/itheima/vue-demo\n&gt; vue-cli-service lint\n\n DONE  No lint errors found!\n</code></pre>\n<p>来执行vue cli配置好了的Lint脚本：</p>\n<pre><code class=\"json\">  &quot;scripts&quot;: &#123;\n    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,\n    &quot;build&quot;: &quot;vue-cli-service build&quot;,\n    &quot;lint&quot;: &quot;vue-cli-service lint&quot;\n  &#125;,\n</code></pre>\n<blockquote>\n<p>vscode中插件推荐使用：</p>\n<p>Vue, Vetur, Vue Peek, vue-beautify</p>\n</blockquote>\n<h4 id=\"实战react项目配置\"><a href=\"#实战react项目配置\" class=\"headerlink\" title=\"实战react项目配置\"></a>实战react项目配置</h4><p>使用<code>create-react-app</code>创建react项目：</p>\n<pre><code class=\"bash\">npx create-react-app my-app\n\ncd my-app\n\nnpm start\n</code></pre>\n<blockquote>\n<p>如果<code>npx</code>命令没有，请全局安装<code>create-react-app</code>，使用<code>npm install -g create-react-app</code></p>\n</blockquote>\n<p>然后是安装eslint相关依赖：</p>\n<pre><code class=\"json\">&quot;devDependencies&quot;: &#123;\n  &quot;eslint&quot;: &quot;^5.16.0&quot;,\n  &quot;babel-eslint&quot;: &quot;^10.0.2&quot;,\n  &quot;eslint-plugin-html&quot;: &quot;^6.0.0&quot;,\n  &quot;eslint-plugin-react&quot;: &quot;^7.14.2&quot;\n&#125;\n</code></pre>\n<p>配置eslint，或者使用<code>eslint --init</code>进行初始化：</p>\n<pre><code class=\"js\">module.exports = &#123;\n    &quot;env&quot;: &#123;\n        &quot;browser&quot;: true,\n        &quot;commonjs&quot;: true,\n        &quot;node&quot;: true,\n        &quot;es6&quot;: true\n    &#125;,\n    &quot;extends&quot;: [\n        &quot;eslint:recommended&quot;,\n        &quot;plugin:react/recommended&quot;\n    ],\n    &quot;globals&quot;: &#123;\n        &quot;Atomics&quot;: &quot;readonly&quot;,\n        &quot;SharedArrayBuffer&quot;: &quot;readonly&quot;\n    &#125;,\n    &quot;parserOptions&quot;: &#123;\n        &quot;ecmaFeatures&quot;: &#123;\n            &quot;jsx&quot;: true,\n            &quot;arrowFunctions&quot;: true,\n            &quot;classes&quot;: true,\n            &quot;modules&quot;: true,\n            &quot;defaultParams&quot;: true\n        &#125;,\n        &quot;ecmaVersion&quot;: 2018,\n        &quot;sourceType&quot;: &quot;module&quot;\n    &#125;,\n    &quot;plugins&quot;: [\n        &quot;react&quot;\n    ],\n    &quot;rules&quot;: &#123;\n    &#125;,\n    &quot;settings&quot;: &#123;\n        &quot;react&quot;: &#123;\n            &quot;pragma&quot;: &quot;React&quot;,\n            &quot;version&quot;: &quot;latest&quot;,\n        &#125;,\n    &#125;,\n&#125;;\n</code></pre>\n<p>几点配置需要注意：</p>\n<ul>\n<li>安装插件：<code>eslint-plugin-react</code></li>\n<li>配置<code>extends</code>: <code>&quot;plugin:react/recommended&quot;</code></li>\n<li>配置<code>settings</code></li>\n</ul>\n<p>配置Airbnb：</p>\n<pre><code class=\"bash\">npm --save-dev install eslint-config-airbnb eslint-plugin-import eslint-plugin-jsx-a11y babel-eslint\n</code></pre>\n<p>有三个依赖：</p>\n<ul>\n<li>eslint-config-airbnb</li>\n<li>eslint-plugin-import</li>\n<li>eslint-plugin-jsx-a11y</li>\n<li>Babel-eslint</li>\n</ul>\n<p>修改项目配置：</p>\n<pre><code class=\"js\">module.exports = &#123;\n    &quot;env&quot;: &#123;\n        &quot;browser&quot;: true,\n        &quot;commonjs&quot;: true,\n        &quot;node&quot;: true,\n        &quot;es6&quot;: true\n    &#125;,\n    // 这里有变化 \n    &quot;extends&quot;: [\n        &quot;eslint:recommended&quot;,\n        &quot;plugin:react/recommended&quot;,\n        &quot;plugin:import/errors&quot;,\n        &quot;plugin:jsx-a11y/recommended&quot;,\n        &quot;airbnb&quot;\n    ],\n    &quot;globals&quot;: &#123;\n        &quot;Atomics&quot;: &quot;readonly&quot;,\n        &quot;SharedArrayBuffer&quot;: &quot;readonly&quot;\n    &#125;,\n    &quot;parser&quot;: &quot;babel-eslint&quot;,\n    &quot;parserOptions&quot;: &#123;\n        &quot;ecmaFeatures&quot;: &#123;\n            &quot;jsx&quot;: true,\n            &quot;arrowFunctions&quot;: true,\n            &quot;classes&quot;: true,\n            &quot;modules&quot;: true,\n            &quot;defaultParams&quot;: true\n        &#125;,\n        &quot;ecmaVersion&quot;: 2018,\n        &quot;sourceType&quot;: &quot;module&quot;\n    &#125;,\n    // 这里有变化 \n    &quot;plugins&quot;: [\n        &quot;react&quot;,\n        &quot;jsx-a11y&quot;,\n        &quot;import&quot;\n    ],\n    &quot;rules&quot;: &#123;\n      // 这里可以添加jsx-ally与import相关的自定义rules\n    &#125;,\n    &quot;settings&quot;: &#123;\n        &quot;react&quot;: &#123;\n            &quot;pragma&quot;: &quot;React&quot;,\n            &quot;version&quot;: &quot;latest&quot;,\n        &#125;,\n    &#125;,\n&#125;;\n</code></pre>\n<h3 id=\"StyleLint\"><a href=\"#StyleLint\" class=\"headerlink\" title=\"StyleLint\"></a>StyleLint</h3><p>官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHlsZWxpbnQuaW8v\">https://stylelint.io/</span></p>\n<ul>\n<li><p>安装依赖：</p>\n<pre><code class=\"bash\">npm install -D stylelint-config-recommended stylelint-config-standard\n\n// yarn \nyarn add stylelint-config-recommended stylelint-config-standard -D\n</code></pre>\n</li>\n<li><p>配置忽略</p>\n<pre><code>// .stylelintignore   忽略stylelint检查的文件\n/src/**/*.css\n</code></pre>\n</li>\n<li><p><code>.stylelintrc.js</code>文件配置</p>\n<pre><code class=\"json\">module.exports = &#123;\n  &quot;extends&quot;: [&quot;stylelint-config-recommended&quot;, &quot;stylelint-config-standard&quot;],\n  &quot;rules&quot;: &#123;\n    &quot;indentation&quot;: 2\n  &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>vscode配置</p>\n<p>安装<code>Prettier</code> + <code>stylelint</code>插件，方便格式化代码。</p>\n<p><img data-src=\"/assets/image-20190628004127626.png\" alt=\"/images/image-20190628004127626\"></p>\n<p>配置文件：</p>\n<pre><code>  &quot;[scss]&quot;: &#123;\n    &quot;editor.formatOnSave&quot;: true\n  &#125;,\n  // 打开scss的validate配置\n  &quot;scss.validate&quot;: true,\n</code></pre>\n</li>\n</ul>\n<h3 id=\"HTMLHint\"><a href=\"#HTMLHint\" class=\"headerlink\" title=\"HTMLHint\"></a>HTMLHint</h3><p>官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odG1saGludC5pby8=\">https://htmlhint.io</span></p>\n<p>github: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2h0bWxoaW50L0hUTUxIaW50\">https://github.com/htmlhint/HTMLHint</span></p>\n<ul>\n<li><p>安装依赖：</p>\n<pre><code class=\"bash\">npm install htmlhint --save-dev\n\n// yarn \nyarn add htmlhint -D\n</code></pre>\n</li>\n<li><p>配置忽略</p>\n<pre><code>// .stylelintignore   忽略stylelint检查的文件\n/src/**/*.css\n</code></pre>\n</li>\n<li><p><code>.htmlhintrc</code>文件配置</p>\n<pre><code class=\"json\">/**\n标签名必须小写\n属性名必须小写\n属性值必须放在双引号中\n属性值一定不可为空\n属性值一定不可重复\nDoctype必须是 HTML 文档的第一行\n标签必须成对\n标签必须自封闭\n特殊字符必须\nID 属性必须唯一\nsrc 属性一定不可为空\ntitle 属性必须出现在标签中\nimg 标签必须包含 alt 属性\nDoctype 必须是 HTML5\nID 和 Class 的命名规则必须统一\n不该使用样式标签\n不该使用行内样式\n不该使用行内脚本\n空格和制表符一定不可混合在行前\nID 和 Class 一定不可使用广告关键词\nhref 必须是绝对路径或者相对路径\n属性值一定不可使用不安全字符\nscript 标签不该使用在头部\n*/\n&#123;\n  &quot;tagname-lowercase&quot;: true, \n  &quot;attr-lowercase&quot;: true,\n  &quot;attr-value-double-quotes&quot;: true,\n  &quot;attr-value-not-empty&quot;: false,\n  &quot;attr-no-duplication&quot;: true,\n  &quot;doctype-first&quot;: true,\n  &quot;tag-pair&quot;: true,\n  &quot;empty-tag-not-self-closed&quot;: true,\n  &quot;spec-char-escape&quot;: true,\n  &quot;id-unique&quot;: true,\n  &quot;src-not-empty&quot;: true,\n  &quot;title-require&quot;: true,\n  &quot;alt-require&quot;: true,\n  &quot;doctype-html5&quot;: true,\n  &quot;id-class-value&quot;: &quot;dash&quot;,\n  &quot;style-disabled&quot;: false,\n  &quot;inline-style-disabled&quot;: false,\n  &quot;inline-script-disabled&quot;: false,\n  &quot;space-tab-mixed-disabled&quot;: &quot;space&quot;,\n  &quot;id-class-ad-disabled&quot;: false,\n  &quot;href-abs-or-rel&quot;: false,\n  &quot;attr-unsafe-chars&quot;: true,\n  &quot;head-script-disabled&quot;: true\n&#125;\n</code></pre>\n</li>\n<li><p>vscode配置</p>\n<p>安装<code>Prettier</code>，<code>HTMLHint</code>插件，方便格式化代码。</p>\n<p><img data-src=\"/./assets/image-20190628003752568.png\" alt=\"/images/image-20190628003752568\"></p>\n<p>用户配置文件：</p>\n<pre><code>  &quot;[html]&quot;: &#123;\n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n  &#125;,\n  // 打开scss的validate配置\n  &quot;files.associations&quot;: &#123;\n      &quot;*.ext&quot;: &quot;html&quot;\n  &#125;,\n</code></pre>\n</li>\n</ul>\n<h2 id=\"e2e-test\"><a href=\"#e2e-test\" class=\"headerlink\" title=\"e2e test\"></a>e2e test</h2><p>通常对Web应用程序执行两种类型的测试：<strong>单元测试</strong>和<strong>端到端</strong>（E2E）测试。</p>\n<p><strong>单元测试</strong></p>\n<p>在测试中使用“单元”的想法是将代码分解为易于测试的小部件。通常，单元是单个函数，但也可以是类或甚至是复杂的算法。</p>\n<p>单元测试的一个关键概念是函数的给定输入应始终产生相同的输出。</p>\n<p>例如，如果我们有一个函数添加了两个调用的数字，<code>add</code>我们可以编写一个单元测试来确保我们作为参数提供的特定数字对总是返回我们期望的输出。</p>\n<p><code>add.spec.js</code></p>\n<pre><code class=\"js\">// Function we want to test\nconst add = (x, y) =&gt; x + y;\n\n// Unit test\ntest(&quot;should add two numbers&quot;, () =&gt; &#123;\n  const result = add(2, 3);\n  expect(result).toBe(5);\n&#125;);\n</code></pre>\n<p>任何时候我们运行该测试并且它不等于5，我们可以得出一个错误已经输入我们的代码。</p>\n<p><strong>组件测试</strong></p>\n<p>在大多数Vue.js应用程序中，函数并不真正代表应用程序的原子组成。当然，我们可以对我们的方法进行单元测试，但我们真正关心的是生成的HTML。</p>\n<p>因此，Vue.js app测试中的单元是一个<em>组件</em>而不是一个函数。</p>\n<p>我们如何测试组件？我们以此为例：</p>\n<p><code>displayGreeting.js</code></p>\n<pre><code class=\"js\">export default &#123;\n  template: `&lt;div&gt;Hello, &#123;&#123; name &#125;&#125;&lt;/div&gt;`,\n  props: [&#39;name&#39;]\n&#125;;\n</code></pre>\n<p>如前所述，对于给定输入（在这种情况下，支柱），单元测试必须返回一致的输出（在这种情况下，文本内容）。</p>\n<p>使用像Vue Test Utils这样的库，我们可以在内存中安装Vue组件并创建一个“包装器”对象。然后，我们可以查询包装器以对呈现的HTML进行断言。</p>\n<p><code>displayGreeting.spec.js</code></p>\n<pre><code class=\"js\">import displayGreeting from &quot;./displayGreeting.js&quot;;\n\ntest(&quot;displays message&quot;, () =&gt; &#123;\n  const name = &quot;Michael&quot;;\n  const wrapper = mount(displayGreeting, &#123; propsData: &#123; name &#125; &#125;);\n  expect(wrapper.text()).toBe(`Hello, $&#123;name&#125;`);\n&#125;);\n</code></pre>\n<p>单元测试优点：</p>\n<ul>\n<li>测试运行得很快</li>\n<li>测试是精确的，允许您识别确切的问题</li>\n</ul>\n<p>单元测试缺点：</p>\n<ul>\n<li>为应用程序的每个方面编写测试都非常耗时</li>\n<li>尽管单元测试通过，整个应用程序可能仍然无法正常工作</li>\n</ul>\n<h3 id=\"什么是e2e-test\"><a href=\"#什么是e2e-test\" class=\"headerlink\" title=\"什么是e2e test?\"></a>什么是e2e test?</h3><p>e2e test（End to End test端到端）测试是一种功能测试。与单元测试不同，不会将应用程序分解为更小的部分以进行测试 - 而是测试整个应用程序。</p>\n<p>e2e测试与您的应用程序交互，就像真实用户一样。例如，您可以编写一个E2E测试：</p>\n<ol>\n<li>加载您的网站</li>\n<li>点击“注册”链接</li>\n<li>为注册表单中的输入提供一些有效的详细信息</li>\n<li>单击“注册按钮”。</li>\n</ol>\n<p>如果身份验证令牌已存储在Cookie中并且应用程序重定向到配置文件页面，则应通过此测试。</p>\n<p>E2E测试优点</p>\n<ul>\n<li>可以一次隐式测试很多东西</li>\n<li>e2e测试可确保您拥有一个工作系统</li>\n</ul>\n<p>e2e测试缺点：</p>\n<ul>\n<li>运行缓慢 - 通常需要5或10分钟才能运行一个站点</li>\n<li>测试很脆弱 - 一个无关紧要的变化，如改变组件逻辑，就需要重新设计e2e test了</li>\n<li>测试无法查明失败的原因</li>\n</ul>\n<p>所以，主要的业务流程可能会写E2E，不过规模要小很多，主要目的是：</p>\n<ul>\n<li>便于给PM展示业务流程</li>\n<li>便于修改Bug之后的回归</li>\n</ul>\n<h3 id=\"e2e-test工具介绍\"><a href=\"#e2e-test工具介绍\" class=\"headerlink\" title=\"e2e test工具介绍\"></a>e2e test工具介绍</h3><h4 id=\"Cypress\"><a href=\"#Cypress\" class=\"headerlink\" title=\"Cypress\"></a>Cypress</h4><ol>\n<li><p>安装 &amp; 桌面应用</p>\n<pre><code class=\"bash\">npm install cypress --save-dev\n</code></pre>\n<p>或者直接下载桌面应用：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5jeXByZXNzLmlvL2Rlc2t0b3A=\">https://download.cypress.io/desktop</span></p>\n</li>\n<li><p>使用方式：</p>\n<pre><code>./node_modules/.bin/cypress open\n\n// npx\nnpx cypress open\n\n// yarn \nyarn run cypress open\n</code></pre>\n<p>或者添加 <code>package.json</code>:</p>\n<pre><code class=\"json\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;cypress:open&quot;: &quot;cypress open&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>使用npm命令：<code>npm run cypress:open</code></p>\n</li>\n</ol>\n<h4 id=\"Nightwatch\"><a href=\"#Nightwatch\" class=\"headerlink\" title=\"Nightwatch\"></a>Nightwatch</h4><h4 id=\"TeatCafe\"><a href=\"#TeatCafe\" class=\"headerlink\" title=\"TeatCafe\"></a>TeatCafe</h4><h3 id=\"e2e-test案例\"><a href=\"#e2e-test案例\" class=\"headerlink\" title=\"e2e test案例\"></a>e2e test案例</h3><h2 id=\"Codecov\"><a href=\"#Codecov\" class=\"headerlink\" title=\"Codecov\"></a>Codecov</h2><h3 id=\"Codecov简介\"><a href=\"#Codecov简介\" class=\"headerlink\" title=\"Codecov简介\"></a>Codecov简介</h3><h3 id=\"Codecov使用\"><a href=\"#Codecov使用\" class=\"headerlink\" title=\"Codecov使用\"></a>Codecov使用</h3><h3 id=\"前端项目中的应用\"><a href=\"#前端项目中的应用\" class=\"headerlink\" title=\"前端项目中的应用\"></a>前端项目中的应用</h3><h2 id=\"补充学习\"><a href=\"#补充学习\" class=\"headerlink\" title=\"补充学习\"></a>补充学习</h2><h3 id=\"补充资料\"><a href=\"#补充资料\" class=\"headerlink\" title=\"补充资料\"></a>补充资料</h3><h4 id=\"代码质量管控的四个阶段\"><a href=\"#代码质量管控的四个阶段\" class=\"headerlink\" title=\"代码质量管控的四个阶段\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yOTA4Njk1OQ==\">代码质量管控的四个阶段</span></h4><p><img data-src=\"/assets/v2-2f1a8ca0a919afd7e77859393c9e96f6_hd.png\" alt=\"img\"></p>\n<p>我把代码质量管控通常需要经历的四个阶段，称之为“四个现代化”：</p>\n<ul>\n<li>规范化 - 建立代码规范与Code Review制度</li>\n<li>自动化 - 使用工具自动检查代码质量</li>\n<li>流程化 - 将代码质量检查与代码流动过程绑定</li>\n<li>中心化 - 以团队整体为视角，集中管理代码规范，并实现质量状况透明化</li>\n</ul>\n<h4 id=\"软件测试的分类\"><a href=\"#软件测试的分类\" class=\"headerlink\" title=\"软件测试的分类\"></a>软件测试的分类</h4><p><strong>第一部分：软件测试的分类</strong></p>\n<ul>\n<li><p>按测试执行阶段划分</p>\n<p>单元测试、集成测试、系统测试、验收测试（正式验收测试、Alpha测试、Beta测试）</p>\n</li>\n<li><p>按测试技术划分</p>\n<p>白盒测试、黑盒测试、灰盒测试</p>\n</li>\n<li><p>被测试对象是否运行划分</p>\n<p>动态测试、静态测试（文档检查、代码走查、界面检查）</p>\n</li>\n<li><p>按不同的测试手段划分</p>\n<p>手工测试、自动化测试*</p>\n</li>\n<li><p>按测试包含的内容划分</p>\n<p>功能测试、界面测试、安全测试、兼容性测试、易用性测试、性能测试、压力测试、负载测试、恢复测试</p>\n</li>\n<li><p>其他测试</p>\n<p>冒烟测试、回归测试、探索性测试&#x2F;自由测试（测试思维）</p>\n</li>\n</ul>\n<p><strong>第二部分：接下来对软件测试分类进行一个说明</strong></p>\n<p><img data-src=\"/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg\" alt=\"img\"><img data-src=\"/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg\" alt=\"img\"></p>\n<p><img data-src=\"/assets/v2-f831b8041976b50aad7c2425aada44e2_hd-1561454378198.jpg\" alt=\"img\"><img data-src=\"/assets/v2-f831b8041976b50aad7c2425aada44e2_hd.jpg\" alt=\"img\"></p>\n<p><strong>第三部分：测试工具</strong></p>\n<p>SVN，Git——&gt;版本控制管理工具</p>\n<p>禅道——&gt;Bug管理工具</p>\n<p>Fiddler——&gt;抓包，定位问题你</p>\n<p>postman，jmeter，soapui——&gt;接口测试</p>\n<p>Loadrunner，Jmeter——&gt;性能，压力测试</p>\n<h4 id=\"What-is-“Linting”\"><a href=\"#What-is-“Linting”\" class=\"headerlink\" title=\"What is “Linting”?\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwMzU1OS93aGF0LWlzLWxpbnRpbmc=\">What is “Linting”?</span></h4><h4 id=\"React中的配置资料\"><a href=\"#React中的配置资料\" class=\"headerlink\" title=\"React中的配置资料\"></a>React中的配置资料</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpdW0uY29tL0BzZ3JvZmYwNC9jb25maWd1cmUtZXNsaW50LXByZXR0aWVyLWFuZC1mbG93LWluLXZzLWNvZGUtZm9yLXJlYWN0LWRldmVsb3BtZW50LWM5ZDk1ZGIwNzIxMw==\">Configure ESLint, Prettier, and Flow in VS Code for React Development</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLnNpZGVjaS5jb20vaG93LXRoZS1yZWFjdC1kZXZlbG9wZXItdGVhbS11c2VzLWVzbGludC0yODI4NTY0ODE0ZGE=\">React开发团队如何使用ESLint</span></p>\n<h3 id=\"完整的ESLint文件配置属性的解释\"><a href=\"#完整的ESLint文件配置属性的解释\" class=\"headerlink\" title=\"完整的ESLint文件配置属性的解释\"></a>完整的ESLint文件配置属性的解释</h3><pre><code class=\"json\">/*\n * ESLint的JSON文件是允许JavaScript注释的，但在gist里显示效果不好，所以我把.json文件后缀改为了.js\n */\n\n/*\n * ESLint 配置文件优先级：\n * .eslintrc.js(输出一个配置对象)\n * .eslintrc.yaml\n * .eslintrc.yml\n * .eslintrc.json（ESLint的JSON文件允许JavaScript风格的注释）\n * .eslintrc（可以是JSON也可以是YAML）\n *  package.json（在package.json里创建一个eslintConfig属性，在那里定义你的配置）\n */\n\n/*\n * 你可以通过在项目根目录创建一个.eslintignore文件告诉ESLint去忽略特定的文件和目录\n * .eslintignore文件是一个纯文本文件，其中的每一行都是一个glob模式表明哪些路径应该忽略检测\n */\n\n&#123;\n  //ESLint默认使用Espree作为其解析器\n  //同时babel-eslint也是用得最多的解析器\n  &quot;parser&quot;: &quot;espree&quot;,\n\n  //parser解析代码时的参数\n  &quot;parserOption&quot;: &#123;\n    //指定要使用的ECMAScript版本，默认值5\n    &quot;ecmaVersion&quot;: 5,\n    //设置为script(默认)或module（如果你的代码是ECMAScript模块)\n    &quot;sourceType&quot;: &quot;script&quot;,\n    //这是个对象，表示你想使用的额外的语言特性,所有选项默认都是false\n    &quot;ecmafeatures&quot;: &#123;\n      //允许在全局作用域下使用return语句\n      &quot;globalReturn&quot;: false,\n      //启用全局strict模式（严格模式）\n      &quot;impliedStrict&quot;: false,\n      //启用JSX\n      &quot;jsx&quot;: false,\n      //启用对实验性的objectRest/spreadProperties的支持\n      &quot;experimentalObjectRestSpread&quot;: false\n    &#125;\n  &#125;,\n\n  //指定环境，每个环境都有自己预定义的全局变量，可以同时指定多个环境，不矛盾\n  &quot;env&quot;: &#123;\n    //效果同配置项ecmaVersion一样\n    &quot;es6&quot;: true,\n    &quot;browser&quot;: true,\n    &quot;node&quot;: true,\n    &quot;commonjs&quot;: false,\n    &quot;mocha&quot;: true,\n    &quot;jquery&quot;: true,\n     //如果你想使用来自某个插件的环境时，确保在plugins数组里指定插件名\n     //格式为：插件名/环境名称（插件名不带前缀）\n    &quot;react/node&quot;: true\n  &#125;,\n\n  //指定环境为我们提供了预置的全局变量\n  //对于那些我们自定义的全局变量，可以用globals指定\n  //设置每个变量等于true允许变量被重写，或false不允许被重写\n  &quot;globals&quot;: &#123;\n    &quot;globalVar1&quot;: true,\n    &quot;globalVar2&quot;: false\n  &#125;,\n\n  //ESLint支持使用第三方插件\n  //在使用插件之前，你必须使用npm安装它\n  //全局安装的ESLint只能使用全局安装的插件\n  //本地安装的ESLint不仅可以使用本地安装的插件还可以使用全局安装的插件\n  //plugin与extend的区别：extend提供的是eslint现有规则的一系列预设\n  //而plugin则提供了除预设之外的自定义规则，当你在eslint的规则里找不到合适的的时候\n  //就可以借用插件来实现了\n  &quot;plugins&quot;: [\n    &quot;eslint-plugin-airbnb&quot;,\n    //插件名称可以省略eslint-plugin-前缀\n    &quot;react&quot;\n  ],\n\n  //具体规则配置\n  //off或0--关闭规则\n  //warn或1--开启规则，警告级别(不会导致程序退出)\n  //error或2--开启规则，错误级别(当被触发的时候，程序会退出)\n  &quot;rules&quot;: &#123;\n    &quot;eqeqeq&quot;: &quot;warn&quot;,\n    //你也可以使用对应的数字定义规则严重程度\n    &quot;curly&quot;: 2,\n    //如果某条规则有额外的选项，你可以使用数组字面量指定它们\n    //选项可以是字符串，也可以是对象\n    &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],\n    &quot;one-var&quot;: [&quot;error&quot;, &#123;\n      &quot;var&quot;: &quot;always&quot;,\n      &quot;let&quot;: &quot;never&quot;,\n      &quot;const&quot;: &quot;never&quot;\n    &#125;],\n    //配置插件提供的自定义规则的时候，格式为：不带前缀插件名/规则ID\n    &quot;react/curly&quot;: &quot;error&quot;\n  &#125;,\n\n  //ESLint支持在配置文件添加共享设置\n  //你可以添加settings对象到配置文件，它将提供给每一个将被执行的规则\n  //如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置\n  &quot;settings&quot;: &#123;\n    &quot;sharedData&quot;: &quot;Hello&quot;\n  &#125;,\n\n  //Eslint检测配置文件步骤：\n  //1.在要检测的文件同一目录里寻找.eslintrc.*和package.json\n  //2.紧接着在父级目录里寻找，一直到文件系统的根目录\n  //3.如果在前两步发现有root：true的配置，停止在父级目录中寻找.eslintrc\n  //4.如果以上步骤都没有找到，则回退到用户主目录~/.eslintrc中自定义的默认配置\n  &quot;root&quot;: true,\n\n  //extends属性值可以是一个字符串或字符串数组\n  //数组中每个配置项继承它前面的配置\n  //可选的配置项如下\n  //1.字符串eslint：recommended，该配置项启用一系列核心规则，这些规则报告一些常见问题，即在(规则页面)中打勾的规则\n  //2.一个可以输出配置对象的可共享配置包，如eslint-config-standard\n    //可共享配置包是一个导出配置对象的简单的npm包，包名称以eslint-config-开头，使用前要安装\n    //extends属性值可以省略包名的前缀eslint-config-\n  //3.一个输出配置规则的插件包，如eslint-plugin-react\n    //一些插件也可以输出一个或多个命名的配置\n    //extends属性值为，plugin：包名/配置名称\n  //4.一个指向配置文件的相对路径或绝对路径\n  //5.字符串eslint：all，启用当前安装的ESLint中所有的核心规则\n    //该配置不推荐在产品中使用，因为它随着ESLint版本进行更改。使用的话，请自己承担风险\n  &quot;extends&quot;: [\n    &quot;eslint:recommended&quot;,\n    &quot;standard&quot;,\n    &quot;plugin:react/recommended&quot;,\n    &quot;./node_modules/coding-standard/.eslintrc-es6&quot;,\n    &quot;eslint:all&quot;\n  ]\n&#125;\n</code></pre>\n","categories":["项目质量检测"],"tags":["质量检测"]},{"title":"node.js内置模块","url":"/2024/01/02/node.js%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/","content":"<h1 id=\"05-【nodejs内置模块（上）】\"><a href=\"#05-【nodejs内置模块（上）】\" class=\"headerlink\" title=\"05 【nodejs内置模块（上）】\"></a>05 【nodejs内置模块（上）】</h1><h2 id=\"nodejs-的官方API文档\"><a href=\"#nodejs-的官方API文档\" class=\"headerlink\" title=\"nodejs 的官方API文档\"></a>nodejs 的官方API文档</h2><ul>\n<li>Node.js 的API文档（英文）： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXY4LngvYXBpL2luZGV4Lmh0bWw=\">https://nodejs.org/docs/latest-v8.x/api/index.html</span></li>\n<li>Node.js 的API文档（中文）：<span class=\"exturl\" data-url=\"aHR0cDovL25vZGVqcy5jbi9hcGkv\">http://nodejs.cn/api/</span></li>\n</ul>\n<p>关于 Node.js 的内置模块和常见API，可以看官方文档。</p>\n<p>查阅文档时，稳定指数如下：</p>\n<ul>\n<li>红色：废弃。</li>\n<li>橙色：实验。表示当前版本可用，其他版本不确定。也许不向下兼容，建议不要在生产环境中使用该特性。</li>\n<li>绿色：稳定。与 npm 生态系统的兼容性是最高的优先级。</li>\n</ul>\n<h2 id=\"nodejs-中模块的分类\"><a href=\"#nodejs-中模块的分类\" class=\"headerlink\" title=\"nodejs 中模块的分类\"></a>nodejs 中模块的分类</h2><p>Node.js 应用由模块组成，采用 CommonJS 模块规范。Node.js中的模块分为三种：</p>\n<ul>\n<li>内置模块</li>\n<li>第三方模块</li>\n<li>自定义模块</li>\n</ul>\n<p>下面简单介绍一下。</p>\n<h3 id=\"内置模块\"><a href=\"#内置模块\" class=\"headerlink\" title=\"内置模块\"></a>内置模块</h3><pre><code class=\"js\">const process = require(&#39;process&#39;);\nconst path = require(&#39;path&#39;);\n\nconsole.log(process.version);\nconsole.log(path.resolve(&#39;../&#39;));\n</code></pre>\n<p>require方法用于加载模块。</p>\n<p>常见的内置模块包括：</p>\n<ul>\n<li>FS：文件系统模块</li>\n<li>path：路径模块</li>\n<li>OS：操作系统相关</li>\n<li>net：网络相关</li>\n<li>http</li>\n<li>…</li>\n</ul>\n<p>你可能会有疑问：Node.js 这么牛吗？还能直接和操作系统做交互？</p>\n<p>带着这个疑问，我们不妨简单看看 Node.js 的源码，以 os 模块举例：</p>\n<ul>\n<li>打开os模块的源码：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9vcy5qcyVFRiVCQyU4QyVFNyVCRiVCQiVFNSU4OCVCMCVFNiU5QyU4MCVFNSVCQSU5NSVFOSU4MyVBOCVFRiVCQyU4QyVFNiU4OSVCRSVFNSU4OCVCMA==\">https://github.com/nodejs/node/blob/master/lib/os.js，翻到最底部，找到</span> <code>cpus</code>这个方法</li>\n<li>进而找到 <code>getCPUs()</code></li>\n<li>internalBinding(‘os’)：通过 internalBinding 可以调用系统底层的方法。internalBinding 主要是 JS 虚拟机在做的事情。</li>\n<li><code>internalBinding(&#39;os&#39;)</code> 的实现，在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL3NyYy9ub2RlX29zLmNj\">https://github.com/nodejs/node/blob/master/src/node_os.cc</span> 里，里面都是 C++ 的代码。比如有一个<code>getCPUs</code>方法。</li>\n</ul>\n<p>现在你知道了，JS本身是没有能力获取底层系统资源的，这一切都是 JS虚拟机在和底层做交互，然后通过 JS 的表现形式，暴露给应用层。</p>\n<p>另外，还有很多库，是直接使用C&#x2F;++编写的，通过编译之后，再提供给 JS 应用层调用，或者直接提供给 Node.js层使用。</p>\n<p>**所有的编程语言底层都会回归C&#x2F;C++**，甚至是汇编语言。</p>\n<h3 id=\"require-加载第三方包的机制\"><a href=\"#require-加载第三方包的机制\" class=\"headerlink\" title=\"require 加载第三方包的机制\"></a>require 加载第三方包的机制</h3><pre><code class=\"js\">const express = require(&#39;express&#39;);\n</code></pre>\n<p>require 加载第三方包的机制：</p>\n<p>（1）第三方包安装好后，这个包一般会存放在当前项目的 node_modules 文件夹中。我们找到这个包的 package.json 文件，并且找到里面的main属性对应的入口模块，这个入口模块就是这个包的入口文件。</p>\n<p>（2）如果第三方包中没有找到package.json文件，或者package.json文件中没有main属性，则默认加载第三方包中的index.js文件。</p>\n<p>（3）如果在 node_modules 文件夹中没有找到这个包，或者以上所有情况都没有找到，则会向上一级父级目录下查找node_modules文件夹，查找规则如上一致。</p>\n<p>（4）如果一直找到该模块的磁盘根路径都没有找到，则会报错：can not find module xxx。</p>\n<h3 id=\"自定义模块（module）\"><a href=\"#自定义模块（module）\" class=\"headerlink\" title=\"自定义模块（module）\"></a>自定义模块（module）</h3><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>\n<p>举例：</p>\n<pre><code class=\"js\">var example = require(&#39;./example.js&#39;);\nconsole.log(example.x); // 5\nconsole.log(example.addX(1)); // 6\n</code></pre>\n<h2 id=\"网络服务-http\"><a href=\"#网络服务-http\" class=\"headerlink\" title=\"网络服务 http\"></a>网络服务 http</h2><h3 id=\"http模块概览\"><a href=\"#http模块概览\" class=\"headerlink\" title=\"http模块概览\"></a>http模块概览</h3><p>大多数nodejs开发者都是冲着开发web server的目的选择了nodejs。正如官网所展示的，借助http模块，可以几行代码就搞定一个超迷你的web server。</p>\n<p>在nodejs中，<code>http</code>可以说是最核心的模块，同时也是比较复杂的一个模块。上手很简单，但一旦深入学习，不少初学者就会觉得头疼，不知从何入手。</p>\n<p>本文先从一个简单的例子出发，引出<code>http</code>模块最核心的四个实例。看完本文，应该就能够对http模块有个整体的认识。</p>\n<h3 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h3><p>在下面的例子中，我们创建了1个web服务器、1个http客户端</p>\n<ul>\n<li>服务器server：接收来自客户端的请求，并将客户端请求的地址返回给客户端。</li>\n<li>客户端client：向服务器发起请求，并将服务器返回的内容打印到控制台。</li>\n</ul>\n<p>代码如下所示，只有几行，但包含了不少信息量。下一小节会进行简单介绍。</p>\n<pre><code class=\"js\">var http = require(&#39;http&#39;);\n\n// http server 例子\nvar server = http.createServer(function(serverReq, serverRes)&#123;\n    var url = serverReq.url;\n    serverRes.end( &#39;您访问的地址是：&#39; + url );\n&#125;);\n\nserver.listen(3000);\n\n// http client 例子\nvar client = http.get(&#39;http://127.0.0.1:3000&#39;, function(clientRes)&#123;\n    clientRes.pipe(process.stdout);\n&#125;);\n</code></pre>\n<h3 id=\"例子解释\"><a href=\"#例子解释\" class=\"headerlink\" title=\"例子解释\"></a>例子解释</h3><p>在上面这个简单的例子里，涉及了4个实例。大部分时候，serverReq、serverRes 才是主角。</p>\n<ul>\n<li>server：http.Server实例，用来提供服务，处理客户端的请求。</li>\n<li>client：http.ClientReques实例，用来向服务端发起请求。</li>\n<li>serverReq&#x2F;clientRes：其实都是 http.IncomingMessage实例。serverReq 用来获取客户端请求的相关信息，如request header；而clientRes用来获取服务端返回的相关信息，比如response header。</li>\n<li>serverRes：http.ServerResponse实例</li>\n</ul>\n<h3 id=\"关于http-IncomingMessage、http-ServerResponse\"><a href=\"#关于http-IncomingMessage、http-ServerResponse\" class=\"headerlink\" title=\"关于http.IncomingMessage、http.ServerResponse\"></a>关于http.IncomingMessage、http.ServerResponse</h3><p>先讲下 http.ServerResponse 实例。作用很明确，服务端通过http.ServerResponse 实例，来个请求方发送数据。包括发送响应表头，发送响应主体等。</p>\n<p>接下来是 http.IncomingMessage 实例，由于在 server、client 都出现了，初学者难免有点迷茫。它的作用是</p>\n<p>在server端：获取请求发送方的信息，比如请求方法、路径、传递的数据等。 在client端：获取 server 端发送过来的信息，比如请求方法、路径、传递的数据等。</p>\n<p>http.IncomingMessage实例 有三个属性需要注意：method、statusCode、statusMessage。</p>\n<ul>\n<li>method：只在 server 端的实例有（也就是 serverReq.method）</li>\n<li>statusCode&#x2F;statusMessage：只在 client 端 的实例有（也就是 clientRes.method）</li>\n</ul>\n<h2 id=\"网络服务-http-res\"><a href=\"#网络服务-http-res\" class=\"headerlink\" title=\"网络服务 http res\"></a>网络服务 http res</h2><h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>http模块四剑客之一的<code>res</code>，应该都不陌生了。一个web服务程序，接受到来自客户端的http请求后，向客户端返回正确的响应内容，这就是<code>res</code>的职责。</p>\n<p>返回的内容包括：状态代码&#x2F;状态描述信息、响应头部、响应主体。下文会举几个简单的例子。</p>\n<pre><code class=\"js\">var http = require(&#39;http&#39;);\nvar server = http.createServer(function(req, res)&#123;\n    res.end(&#39;ok&#39;);\n&#125;);\nserver.listen(3000);\n</code></pre>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>在下面的例子中，我们同时设置了 状态代码&#x2F;状态描述信息、响应头部、响应主体，就是这么简单。</p>\n<pre><code class=\"js\">var http = require(&#39;http&#39;);\n\n// 设置状态码、状态描述信息、响应主体\nvar server = http.createServer(function(req, res)&#123;\n    res.writeHead(200, &#39;ok&#39;, &#123;\n        &#39;Content-Type&#39;: &#39;text/plain&#39;\n    &#125;);\n    res.end(&#39;hello&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<h3 id=\"设置状态代码、状态描述信息\"><a href=\"#设置状态代码、状态描述信息\" class=\"headerlink\" title=\"设置状态代码、状态描述信息\"></a>设置状态代码、状态描述信息</h3><p><code>res</code>提供了 res.writeHead()、res.statusCode&#x2F;res.statusMessage 来实现这个目的。</p>\n<p>举例，如果想要设置 200&#x2F;ok ，可以</p>\n<pre><code class=\"js\">res.writeHead(200, &#39;ok&#39;);\n</code></pre>\n<p>也可以</p>\n<pre><code class=\"js\">res.statusCode = 200;\nres.statusMessage = &#39;ok&#39;;\n</code></pre>\n<p>两者差不多，差异点在于</p>\n<ol>\n<li>res.writeHead() 可以提供额外的功能，比如设置响应头部。</li>\n<li>当响应头部发送出去后，res.statusCode&#x2F;res.statusMessage 会被设置成已发送出去的 状态代码&#x2F;状态描述信息。</li>\n</ol>\n<h3 id=\"设置响应头部\"><a href=\"#设置响应头部\" class=\"headerlink\" title=\"设置响应头部\"></a>设置响应头部</h3><p><code>res</code>提供了 res.writeHead()、response.setHeader() 来实现响应头部的设置。</p>\n<p>举例，比如想把 <code>Content-Type</code> 设置为 <code>text-plain</code>，那么可以</p>\n<pre><code class=\"js\">// 方法一\nres.writeHead(200, &#39;ok&#39;, &#123;\n    &#39;Content-Type&#39;: &#39;text-plain&#39;\n&#125;);\n\n// 方法二\nres.setHeader(&#39;Content-Type&#39;, &#39;text-plain&#39;);\n</code></pre>\n<p>两者的差异点在哪里呢？</p>\n<ol>\n<li>res.writeHead() 不单单是设置header。</li>\n<li>已经通过 res.setHeader() 设置了header，当通过 res.writeHead() 设置同名header，res.writeHead() 的设置会覆盖之前的设置。</li>\n</ol>\n<p>关于第2点差异，这里举个例子。下面代码，最终的 <code>Content-Type</code> 为 <code>text/plain</code>。</p>\n<pre><code class=\"js\">var http = require(&#39;http&#39;);\n\nvar server = http.createServer(function(req, res)&#123;\n    res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n    res.writeHead(200, &#39;ok&#39;, &#123;\n        &#39;Content-Type&#39;: &#39;text/plain&#39;\n    &#125;);\n    res.end(&#39;hello&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>而下面的例子，则直接报错。报错信息为 <code>Error: Can&#39;t set headers after they are sent.</code>。</p>\n<pre><code class=\"js\">var http = require(&#39;http&#39;);\n\nvar server = http.createServer(function(req, res)&#123;    \n    res.writeHead(200, &#39;ok&#39;, &#123;\n        &#39;Content-Type&#39;: &#39;text/plain&#39;\n    &#125;);\n    res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n    res.end(&#39;hello&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<h3 id=\"其他响应头部操作\"><a href=\"#其他响应头部操作\" class=\"headerlink\" title=\"其他响应头部操作\"></a>其他响应头部操作</h3><p>增、删、改、查 是配套的。下面分别举例说明下，例子太简单就直接上代码了。</p>\n<pre><code class=\"js\">// 增\nres.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);\n\n// 删\nres.removeHeader(&#39;Content-Type&#39;);\n\n// 改\nres.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);\nres.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);  // 覆盖\n\n// 查\nres.getHeader(&#39;content-type&#39;);\n</code></pre>\n<p>其中略显不同的是 res.getHeader(name)，name 用的是小写，返回值没做特殊处理。</p>\n<pre><code class=\"js\">res.setHeader(&#39;Content-Type&#39;, &#39;TEXT/HTML&#39;);\nconsole.log( res.getHeader(&#39;content-type&#39;) );  // TEXT/HTML\n\nres.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);\nconsole.log( res.getHeader(&#39;content-type&#39;) );  // text/plain\n</code></pre>\n<p>此外，还有不那么常用的：</p>\n<ul>\n<li>res.headersSent：header是否已经发送；</li>\n<li>res.sendDate：默认为true。但为true时，会在response header里自动设置Date首部。</li>\n</ul>\n<h3 id=\"设置响应主体\"><a href=\"#设置响应主体\" class=\"headerlink\" title=\"设置响应主体\"></a>设置响应主体</h3><p>主要用到 res.write() 以及 res.end() 两个方法。</p>\n<p>res.write() API的信息量略大，建议看下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9yZXNwb25zZV93cml0ZV9jaHVua19lbmNvZGluZ19jYWxsYmFjaw==\">官方文档</span>。</p>\n<h4 id=\"response-write-chunk-encoding-callback\"><a href=\"#response-write-chunk-encoding-callback\" class=\"headerlink\" title=\"response.write(chunk[, encoding][, callback])\"></a>response.write(chunk[, encoding][, callback])</h4><ul>\n<li>chunk：响应主体的内容，可以是string，也可以是buffer。当为string时，encoding参数用来指明编码方式。（默认是utf8）</li>\n<li>encoding：编码方式，默认是 utf8。</li>\n<li>callback：当响应体flushed时触发。（TODO 这里想下更好的解释。。。）</li>\n</ul>\n<p>使用上没什么难度，只是有些注意事项：</p>\n<ol>\n<li>如果 res.write() 被调用时， res.writeHead() 还没被调用过，那么，就会把header flush出去。</li>\n<li>res.write() 可以被调用多次。</li>\n<li>当 res.write(chunk) 第一次被调用时，node 会将 header 信息 以及 chunk 发送到客户端。第二次调用 res.write(chunk) ，node 会认为你是要streaming data（WTF，该怎么翻译）。。。</li>\n</ol>\n<blockquote>\n<p>Returns true if the entire data was flushed successfully to the kernel buffer. Returns false if all or part of the data was queued in user memory. ‘drain’ will be emitted when the buffer is free again.</p>\n</blockquote>\n<h4 id=\"response-end-data-encoding-callback\"><a href=\"#response-end-data-encoding-callback\" class=\"headerlink\" title=\"response.end([data][, encoding][, callback])\"></a>response.end([data][, encoding][, callback])</h4><p>掌握了 res.write() 的话，res.end() 就很简单了。res.end() 的用处是告诉nodejs，header、body都给你了，这次响应就到这里吧。</p>\n<p>有点像个语法糖，可以看成下面两个调用的组合。至于callback，当响应传递结束后触发。</p>\n<pre><code class=\"js\">res.write(data, encoding);\nres.end()\n</code></pre>\n<h3 id=\"超时处理\"><a href=\"#超时处理\" class=\"headerlink\" title=\"超时处理\"></a>超时处理</h3><p>接口：response.setTimeout(msecs, callback)</p>\n<p>关于 timeout 事件的说明，同样是言简意赅（WTF），话少信息量大，最好来个demo TODO</p>\n<blockquote>\n<p>If no ‘timeout’ listener is added to the request, the response, or the server, then sockets are destroyed when they time out. If you assign a handler on the request, the response, or the server’s ‘timeout’ events, then it is your responsibility to handle timed out sockets.</p>\n</blockquote>\n<h3 id=\"事件-close-x2F-finish\"><a href=\"#事件-close-x2F-finish\" class=\"headerlink\" title=\"事件 close&#x2F;finish\"></a>事件 close&#x2F;finish</h3><ul>\n<li>close：response.end() 被调用前，连接就断开了。此时会触发这个事件。</li>\n<li>finish：响应header、body都已经发送出去（交给操作系统，排队等候传输），但客户端是否实际收到数据为止。（这个事件后，res 上就不会再有其他事件触发）</li>\n</ul>\n<h3 id=\"其他不常用属性-x2F-方法\"><a href=\"#其他不常用属性-x2F-方法\" class=\"headerlink\" title=\"其他不常用属性&#x2F;方法\"></a>其他不常用属性&#x2F;方法</h3><ul>\n<li>response.finished：一开始是false，响应结束后，设置为true。</li>\n<li>response.sendDate：默认是true。是否自动设置Date头部。（按HTTP协议是必须要的，除非是调试用，不然不要设置为false）</li>\n<li>response.headersSent：只读属性。响应头部是否已发送。</li>\n<li>response.writeContinue()：发送 HTTP&#x2F;1.1 100 Continue 消息给客户端，提示说服务端愿意接受客户端的请求，请继续发送请求正文（body)。（TODO 做个demo啥的是大大的好）</li>\n</ul>\n<h2 id=\"网络服务-http-req\"><a href=\"#网络服务-http-req\" class=\"headerlink\" title=\"网络服务 http req\"></a>网络服务 http req</h2><h3 id=\"概览-1\"><a href=\"#概览-1\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>本文的重点会放在<code>req</code>这个对象上。前面已经提到，它其实是http.IncomingMessage实例，在服务端、客户端作用略微有差异</p>\n<ul>\n<li>服务端处：获取请求方的相关信息，如request header等。</li>\n<li>客户端处：获取响应方返回的相关信息，如statusCode等。</li>\n</ul>\n<p>服务端例子：</p>\n<pre><code class=\"js\">// 下面的 req\nvar http = require(&#39;http&#39;);\nvar server = http.createServer(function(req, res)&#123;\n    console.log(req.headers);\n    res.end(&#39;ok&#39;);\n&#125;);\nserver.listen(3000);\n</code></pre>\n<p>客户端例子</p>\n<pre><code class=\"js\">// 下面的res\nvar http = require(&#39;http&#39;);\nhttp.get(&#39;http://127.0.0.1:3000&#39;, function(res)&#123;\n    console.log(res.statusCode);\n&#125;);\n</code></pre>\n<h3 id=\"属性-x2F-方法-x2F-事件-分类\"><a href=\"#属性-x2F-方法-x2F-事件-分类\" class=\"headerlink\" title=\"属性&#x2F;方法&#x2F;事件 分类\"></a>属性&#x2F;方法&#x2F;事件 分类</h3><p>http.IncomingMessage的属性&#x2F;方法&#x2F;事件 不是特别多，按照是否客户端&#x2F;服务端 特有的，下面进行简单归类。可以看到</p>\n<ul>\n<li>服务端处特有：url</li>\n<li>客户端处特有：statusCode、statusMessage</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"center\">名称</th>\n<th align=\"center\">服务端</th>\n<th align=\"center\">客户端</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">事件</td>\n<td align=\"center\">aborted</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">事件</td>\n<td align=\"center\">close</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">headers</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">rawHeaders</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">statusCode</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">statusMessage</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">httpVersion</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">url</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">socket</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">方法</td>\n<td align=\"center\">.destroy()</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">方法</td>\n<td align=\"center\">.setTimeout()</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n</tbody></table>\n<h3 id=\"服务端的例子\"><a href=\"#服务端的例子\" class=\"headerlink\" title=\"服务端的例子\"></a>服务端的例子</h3><h4 id=\"例子一：获取httpVersion-x2F-method-x2F-url\"><a href=\"#例子一：获取httpVersion-x2F-method-x2F-url\" class=\"headerlink\" title=\"例子一：获取httpVersion&#x2F;method&#x2F;url\"></a>例子一：获取httpVersion&#x2F;method&#x2F;url</h4><p>下面是一个典型的HTTP请求报文，里面最重要的内容包括：HTTP版本、请求方法、请求地址、请求头部。</p>\n<pre><code class=\"http\">GET /hello HTTP/1.1\nHost: 127.0.0.1:3000\nConnection: keep-alive\nCache-Control: no-cache\n</code></pre>\n<p>那么，如何获取上面提到的信息呢？很简单，直接上代码</p>\n<pre><code class=\"js\">// getClientInfo.js\nvar http = require(&#39;http&#39;);\n\nvar server = http.createServer(function(req, res)&#123;\n    console.log( &#39;1、客户端请求url：&#39; + req.url );\n    console.log( &#39;2、http版本：&#39; + req.httpVersion );\n    console.log( &#39;3、http请求方法：&#39; + req.method );\n    console.log( &#39;4、http请求头部&#39; + JSON.stringify(req.headers) );\n\n    res.end(&#39;ok&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>效果如下：</p>\n<pre><code class=\"bash\">1、客户端请求url：/hello\n2、http版本：1.1\n3、http请求方法：GET\n4、http headers：&#123;&quot;host&quot;:&quot;127.0.0.1:3000&quot;,&quot;connection&quot;:&quot;keep-alive&quot;,&quot;cache-control&quot;:&quot;no-cache&quot;,&quot;user-age\n</code></pre>\n<h4 id=\"例子二：获取get请求参数\"><a href=\"#例子二：获取get请求参数\" class=\"headerlink\" title=\"例子二：获取get请求参数\"></a>例子二：获取get请求参数</h4><p>服务端代码如下：</p>\n<pre><code class=\"js\">// getClientGetQuery.js\nvar http = require(&#39;http&#39;);\nvar url = require(&#39;url&#39;);\nvar querystring = require(&#39;querystring&#39;);\n\nvar server = http.createServer(function(req, res)&#123;\n    var urlObj = url.parse(req.url);\n    var query = urlObj.query;\n    var queryObj = querystring.parse(query);\n    \n    console.log( JSON.stringify(queryObj) );\n    \n    res.end(&#39;ok&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>访问地址 <span class=\"exturl\" data-url=\"aHR0cDovLzEyNy4wLjAuMTozMDAwL2hlbGxvP25pY2s9Y2h5aW5ncCZoZWxsbz13b3JsZA==\">http://127.0.0.1:3000/hello?nick=chyingp&amp;hello=world</span></p>\n<p>服务端输出如下</p>\n<pre><code class=\"bash\">&#123;&quot;nick&quot;:&quot;chyingp&quot;,&quot;hello&quot;:&quot;world&quot;&#125;\n</code></pre>\n<h4 id=\"例子三：获取post请求参数\"><a href=\"#例子三：获取post请求参数\" class=\"headerlink\" title=\"例子三：获取post请求参数\"></a>例子三：获取post请求参数</h4><p>服务端代码如下</p>\n<pre><code class=\"js\">// getClientPostBody.js\nvar http = require(&#39;http&#39;);\nvar url = require(&#39;url&#39;);\nvar querystring = require(&#39;querystring&#39;);\n\nvar server = http.createServer(function(req, res)&#123;\n    \n    var body = &#39;&#39;;  \n    req.on(&#39;data&#39;, function(thunk)&#123;\n        body += thunk;\n    &#125;);\n\n    req.on(&#39;end&#39;, function()&#123;\n        console.log( &#39;post body is: &#39; + body );\n        res.end(&#39;ok&#39;);\n    &#125;); \n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>通过curl构造post请求：</p>\n<pre><code class=\"bash\">curl -d &#39;nick=casper&amp;hello=world&#39; http://127.0.0.1:3000\n</code></pre>\n<p>服务端打印如下：</p>\n<pre><code class=\"bash\">post body is: nick=casper&amp;hello=world\n</code></pre>\n<p>备注：post请求中，不同的<code>Content-type</code>，post body有不小差异，感兴趣的同学可以研究下。</p>\n<p>本例中的post请求，HTTP报文大概如下</p>\n<pre><code class=\"http\">POST / HTTP/1.1\nHost: 127.0.0.1:3000\nContent-Type: application/x-www-form-urlencoded\nCache-Control: no-cache\n\nnick=casper&amp;hello=world\n</code></pre>\n<h2 id=\"网络服务-https\"><a href=\"#网络服务-https\" class=\"headerlink\" title=\"网络服务 https\"></a>网络服务 https</h2><h3 id=\"模块概览\"><a href=\"#模块概览\" class=\"headerlink\" title=\"模块概览\"></a>模块概览</h3><p>这个模块的重要性，基本不用强调了。在网络安全问题日益严峻的今天，网站采用HTTPS是个必然的趋势。</p>\n<p>在nodejs中，提供了 https 这个模块来完成 HTTPS 相关功能。从官方文档来看，跟 http 模块用法非常相似。</p>\n<p>本文主要包含两部分：</p>\n<ol>\n<li>通过客户端、服务端的例子，对https模块进行入门讲解。</li>\n<li>如何访问安全证书不受信任的网站。（以 12306 为例子）</li>\n</ol>\n<p>篇幅所限，本文无法对 HTTPS协议 及 相关技术体系 做过多讲解，有问题欢迎留言交流。</p>\n<h3 id=\"客户端例子\"><a href=\"#客户端例子\" class=\"headerlink\" title=\"客户端例子\"></a>客户端例子</h3><p>跟http模块的用法非常像，只不过请求的地址是https协议的而已，代码如下：</p>\n<pre><code class=\"js\">var https = require(&#39;https&#39;);\n\nhttps.get(&#39;https://www.baidu.com&#39;, function(res)&#123;\n    console.log(&#39;status code: &#39; + res.statusCode);\n    console.log(&#39;headers: &#39; + JSON.stringify(res.headers));\n\n    res.on(&#39;data&#39;, function(data)&#123;\n        process.stdout.write(data);\n    &#125;);\n&#125;).on(&#39;error&#39;, function(err)&#123;\n    console.error(err);\n&#125;);\n</code></pre>\n<h3 id=\"服务端例子\"><a href=\"#服务端例子\" class=\"headerlink\" title=\"服务端例子\"></a>服务端例子</h3><p>对外提供HTTPS服务，需要有HTTPS证书。如果你已经有了HTTPS证书，那么可以跳过证书生成的环节。如果没有，可以参考如下步骤</p>\n<h4 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h4><p><strong>1.创建个目录存放证书。</strong></p>\n<pre><code class=\"bash\">mkdir cert\ncd cert\n</code></pre>\n<p><strong>2.生成私钥。</strong></p>\n<pre><code class=\"text\">openssl genrsa -out chyingp-key.pem 2048\n</code></pre>\n<p><strong>3.生成证书签名请求（csr是 Certificate Signing Request的意思）。</strong></p>\n<pre><code class=\"text\">openssl req -new \\\n  -sha256\n  -key chyingp-key.key.pem \\\n  -out chyingp-csr.pem \\\n  -subj &quot;/C=CN/ST=Guandong/L=Shenzhen/O=YH Inc/CN=www.chyingp.com&quot;\n</code></pre>\n<p><strong>4.生成证书。</strong></p>\n<pre><code class=\"text\">openssl x509 \\\n  -req -in chyingp-csr.pem \\\n  -signkey chyingp-key.pem \\\n  -out chyingp-cert.pem\n</code></pre>\n<h4 id=\"HTTPS服务端\"><a href=\"#HTTPS服务端\" class=\"headerlink\" title=\"HTTPS服务端\"></a>HTTPS服务端</h4><p>代码如下：</p>\n<pre><code class=\"js\">var https = require(&#39;https&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar options = &#123;\n    key: fs.readFileSync(&#39;./cert/chyingp-key.pem&#39;), // 私钥\n    cert: fs.readFileSync(&#39;./cert/chyingp-cert.pem&#39;) // 证书\n&#125;;\n\nvar server = https.createServer(options, function(req, res)&#123;\n    res.end(&#39;这是来自HTTPS服务器的返回&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>由于我并没有 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jaHlpbmdwLmNvbS8=\">www.chyingp.com</span> 这个域名，于是先配置本地host</p>\n<pre><code class=\"text\">127.0.0.1 www.chyingp.com\n</code></pre>\n<p>启动服务，并在浏览器里访问 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jaHlpbmdwLmNvbTozMDAwLw==\">http://www.chyingp.com:3000</span>。注意，浏览器会提示你证书不可靠，点击 信任并继续访问 就行了。</p>\n<h2 id=\"URL-接口-代替内置模块url使用\"><a href=\"#URL-接口-代替内置模块url使用\" class=\"headerlink\" title=\"URL 接口(代替内置模块url使用)\"></a>URL 接口(代替内置模块url使用)</h2><blockquote>\n<p>nodejs内置模块<code>url</code>有些方法要被废弃，我们使用<code>URL类</code>代替</p>\n</blockquote>\n<p>浏览器原生提供<code>URL()</code>接口，它是一个构造函数，用来构造、解析和编码 URL。一般情况下，通过<code>window.URL</code>可以拿到这个构造函数。</p>\n<h3 id=\"7-1-对比url模块和URL类\"><a href=\"#7-1-对比url模块和URL类\" class=\"headerlink\" title=\"7.1 对比url模块和URL类\"></a>7.1 对比<code>url模块</code>和URL类</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>url模块</th>\n<th>URL类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>protocol</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>host</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>port</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>hostname</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>search</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>query</td>\n<td><code>✅</code></td>\n<td><code>-</code></td>\n</tr>\n<tr>\n<td>path</td>\n<td><code>✅</code></td>\n<td><code>-</code></td>\n</tr>\n<tr>\n<td>pathname</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>href</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>hash</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>origin</td>\n<td>-</td>\n<td><code>✅</code></td>\n</tr>\n</tbody></table>\n<p>可以看出来，只有三个字段不同，分别是<code>query</code>,<code>path</code>,<code>origin</code></p>\n<pre><code class=\"js\">打印两个对象的输出\n\n// url模块，url.parse(&#39;link&#39;)\n&#123;\n  protocol: &#39;https:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;m.shop.com&#39;,\n  port: null,\n  hostname: &#39;m.shop.com&#39;,\n  hash: &#39;#detail&#39;,\n  search: &#39;?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099&#39;,\n  query: &#39;id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099&#39;,\n  pathname: &#39;/home/share&#39;,\n  path: &#39;/home/share?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099&#39;,\n  href: &#39;https://m.shop.com/home/share?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099#detail&#39;\n&#125;\n// new URL()\n&#123;\n  href: &#39;https://m.shop.com/home/share?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099#detail&#39;,\n  origin: &#39;https://m.shop.com&#39;,\n  protocol: &#39;https:&#39;,\n  username: &#39;&#39;,\n  password: &#39;&#39;,\n  host: &#39;m.shop.com&#39;,\n  hostname: &#39;m.shop.com&#39;,\n  port: &#39;&#39;,\n  pathname: &#39;/home/share&#39;,\n  search: &#39;?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099&#39;,\n  searchParams: URLSearchParams &#123;\n    &#39;id&#39; =&gt; &#39;4433&#39;,\n    &#39;name&#39; =&gt; &#39;李备&#39;,\n    &#39;directCompanyId&#39; =&gt; &#39;&#39;,\n    &#39;mobile&#39; =&gt; &#39;18951431099&#39; &#125;,\n  hash: &#39;#detail&#39;\n&#125;\n</code></pre>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><code>URL()</code>作为构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果参数不是合法的 URL，会报错。</p>\n<pre><code class=\"js\">var url = new URL(&#39;http://www.example.com/index.html&#39;);\nurl.href\n// &quot;http://www.example.com/index.html&quot;\n</code></pre>\n<p>上面示例生成了一个 URL 实例，用来代表指定的网址。</p>\n<p>除了字符串，<code>URL()</code>的参数也可以是另一个 URL 实例。这时，<code>URL()</code>会自动读取该实例的<code>href</code>属性，作为实际参数。</p>\n<p>如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。</p>\n<pre><code class=\"js\">var url1 = new URL(&#39;index.html&#39;, &#39;http://example.com&#39;);\nurl1.href\n// &quot;http://example.com/index.html&quot;\n\nvar url2 = new URL(&#39;page2.html&#39;, &#39;http://example.com/page1.html&#39;);\nurl2.href\n// &quot;http://example.com/page2.html&quot;\n\nvar url3 = new URL(&#39;..&#39;, &#39;http://example.com/a/b.html&#39;)\nurl3.href\n// &quot;http://example.com/&quot;\n</code></pre>\n<p>上面代码中，返回的 URL 实例的路径都是在第二个参数的基础上，切换到第一个参数得到的。最后一个例子里面，第一个参数是<code>..</code>，表示上层路径。</p>\n<h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><p>URL 实例的属性与<code>Location</code>对象的属性基本一致，返回当前 URL 的信息。</p>\n<ul>\n<li>URL.href：返回整个 URL</li>\n<li>URL.protocol：返回协议，以冒号<code>:</code>结尾</li>\n<li>URL.hostname：返回域名</li>\n<li>URL.host：返回域名与端口，包含<code>:</code>号，默认的80和443端口会省略</li>\n<li>URL.port：返回端口</li>\n<li>URL.origin：返回协议、域名和端口</li>\n<li>URL.pathname：返回路径，以斜杠<code>/</code>开头</li>\n<li>URL.search：返回查询字符串，以问号<code>?</code>开头</li>\n<li>URL.searchParams：返回一个<code>URLSearchParams</code>实例，该属性是<code>Location</code>对象没有的</li>\n<li>URL.hash：返回片段识别符，以井号<code>#</code>开头</li>\n<li>URL.password：返回域名前面的密码</li>\n<li>URL.username：返回域名前面的用户名</li>\n</ul>\n<pre><code class=\"js\">var url = new URL(&#39;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&#39;);\n\nurl.href\n// &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;\nurl.protocol\n// &quot;http:&quot;\nurl.hostname\n// &quot;www.example.com&quot;\nurl.host\n// &quot;www.example.com:4097&quot;\nurl.port\n// &quot;4097&quot;\nurl.origin\n// &quot;http://www.example.com:4097&quot;\nurl.pathname\n// &quot;/path/a.html&quot;\nurl.search\n// &quot;?x=111&quot;\nurl.searchParams\n// URLSearchParams &#123;&#125;\nurl.hash\n// &quot;#part1&quot;\nurl.password\n// &quot;passwd&quot;\nurl.username\n// &quot;user&quot;\n</code></pre>\n<p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写，并且会立即生效。</p>\n<pre><code class=\"js\">var url = new URL(&#39;http://example.com/index.html#part1&#39;);\n\nurl.pathname = &#39;index2.html&#39;;\nurl.href // &quot;http://example.com/index2.html#part1&quot;\n\nurl.hash = &#39;#part2&#39;;\nurl.href // &quot;http://example.com/index2.html#part2&quot;\n</code></pre>\n<p>上面代码中，改变 URL 实例的<code>pathname</code>属性和<code>hash</code>属性，都会实时反映在 URL 实例当中。</p>\n<h2 id=\"URLSearchParams-对象-代替内置模块querystring使用\"><a href=\"#URLSearchParams-对象-代替内置模块querystring使用\" class=\"headerlink\" title=\"URLSearchParams 对象(代替内置模块querystring使用)\"></a>URLSearchParams 对象(代替内置模块querystring使用)</h2><blockquote>\n<ol>\n<li><p>nodejs内置模块<code>querystring</code>有些方法要被废弃，我们使用<code>URLSearchParams API </code>构造代替</p>\n</li>\n<li><p>如果你的nodejs版本大于18，可以使用<code>const querystring= require(&#39;node:querystring&#39;)</code><br>&#96;&#96;querystring<code>比</code>URLSearchParams<code>性能更高，但不是 标准化的 API。使用</code>URLSearchParams&#96;当性能不重要或 当需要与浏览器代码兼容时。</p>\n</li>\n<li><p>还可以安装<code>qs</code>模块，使用方式和<code>querystring</code>一样</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><code>URLSearchParams</code>对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。</p>\n<p>它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号<code>?</code>有没有都行，也可以是对应查询字符串的数组或对象。</p>\n<pre><code class=\"js\">// 方法一：传入字符串\nvar params = new URLSearchParams(&#39;?foo=1&amp;bar=2&#39;);\n// 等同于\nvar params = new URLSearchParams(document.location.search);\n\n// 方法二：传入数组\nvar params = new URLSearchParams([[&#39;foo&#39;, 1], [&#39;bar&#39;, 2]]);\n\n// 方法三：传入对象\nvar params = new URLSearchParams(&#123;&#39;foo&#39; : 1 , &#39;bar&#39; : 2&#125;);\n</code></pre>\n<p><code>URLSearchParams</code>会对查询字符串自动编码。</p>\n<pre><code class=\"js\">var params = new URLSearchParams(&#123;&#39;foo&#39;: &#39;你好&#39;&#125;);\nparams.toString() // &quot;foo=%E4%BD%A0%E5%A5%BD&quot;\n</code></pre>\n<p>上面代码中，<code>foo</code>的值是汉字，<code>URLSearchParams</code>对其自动进行 URL 编码。</p>\n<p>浏览器向服务器发送表单数据时，可以直接使用<code>URLSearchParams</code>实例作为表单数据。</p>\n<pre><code class=\"js\">const params = new URLSearchParams(&#123;foo: 1, bar: 2&#125;);\nfetch(&#39;https://example.com/api&#39;, &#123;\n  method: &#39;POST&#39;,\n  body: params\n&#125;).then(...)\n</code></pre>\n<p>上面代码中，<code>fetch</code>命令向服务器发送命令时，可以直接使用<code>URLSearchParams</code>实例。</p>\n<p><code>URLSearchParams</code>可以与<code>URL()</code>接口结合使用。</p>\n<pre><code class=\"js\">var url = new URL(window.location);\nvar foo = url.searchParams.get(&#39;foo&#39;) || &#39;somedefault&#39;;\n</code></pre>\n<p>上面代码中，URL 实例的<code>searchParams</code>属性就是一个<code>URLSearchParams</code>实例，所以可以使用<code>URLSearchParams</code>接口的<code>get</code>方法。</p>\n<p><code>URLSearchParams</code>实例有遍历器接口，可以用<code>for...of</code>循环遍历。</p>\n<pre><code class=\"js\">var params = new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);\n\nfor (var p of params) &#123;\n  console.log(p[0] + &#39;: &#39; + p[1]);\n&#125;\n// foo: 1\n// bar: 2\n</code></pre>\n<p><code>URLSearchParams</code>没有实例属性，只有实例方法。</p>\n<h3 id=\"URLSearchParams-toString\"><a href=\"#URLSearchParams-toString\" class=\"headerlink\" title=\"URLSearchParams.toString()\"></a>URLSearchParams.toString()</h3><p><code>toString</code>方法返回实例的字符串形式。</p>\n<pre><code class=\"js\">var url = new URL(&#39;https://example.com?foo=1&amp;bar=2&#39;);\nvar params = new URLSearchParams(url.search);\n\nparams.toString() // &quot;foo=1&amp;bar=2&#39;\n</code></pre>\n<p>那么需要字符串的场合，会自动调用<code>toString</code>方法。</p>\n<pre><code class=\"js\">var params = new URLSearchParams(&#123;version: 2.0&#125;);\nwindow.location.href = location.pathname + &#39;?&#39; + params;\n</code></pre>\n<p>上面代码中，<code>location.href</code>赋值时，可以直接使用<code>params</code>对象。这时就会自动调用<code>toString</code>方法。</p>\n<h3 id=\"URLSearchParams-has\"><a href=\"#URLSearchParams-has\" class=\"headerlink\" title=\"URLSearchParams.has()\"></a>URLSearchParams.has()</h3><p><code>has()</code>方法返回一个布尔值，表示查询字符串是否包含指定的键名。</p>\n<pre><code class=\"js\">var params = new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);\nparams.has(&#39;bar&#39;) // true\nparams.has(&#39;baz&#39;) // false\n</code></pre>\n<h3 id=\"URLSearchParams-get-，URLSearchParams-getAll\"><a href=\"#URLSearchParams-get-，URLSearchParams-getAll\" class=\"headerlink\" title=\"URLSearchParams.get()，URLSearchParams.getAll()\"></a>URLSearchParams.get()，URLSearchParams.getAll()</h3><p><code>get()</code>方法用来读取查询字符串里面的指定键。它接受键名作为参数。</p>\n<pre><code class=\"js\">var params = new URLSearchParams(&#39;?foo=1&#39;);\nparams.get(&#39;foo&#39;) // &quot;1&quot;\nparams.get(&#39;bar&#39;) // null\n</code></pre>\n<p>两个地方需要注意。第一，它返回的是字符串，如果原始值是数值，需要转一下类型；第二，如果指定的键名不存在，返回值是<code>null</code>。</p>\n<p>如果有多个的同名键，<code>get</code>返回位置最前面的那个键值。</p>\n<pre><code class=\"js\">var params = new URLSearchParams(&#39;?foo=3&amp;foo=2&amp;foo=1&#39;);\nparams.get(&#39;foo&#39;) // &quot;3&quot;\n</code></pre>\n<p>上面代码中，查询字符串有三个<code>foo</code>键，<code>get</code>方法返回最前面的键值<code>3</code>。</p>\n<p><code>getAll()</code>方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。</p>\n<pre><code class=\"js\">var params = new URLSearchParams(&#39;?foo=1&amp;foo=2&#39;);\nparams.getAll(&#39;foo&#39;) // [&quot;1&quot;, &quot;2&quot;]\n</code></pre>\n<p>上面代码中，查询字符串有两个<code>foo</code>键，<code>getAll</code>返回的数组就有两个成员。</p>\n<h3 id=\"URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries\"><a href=\"#URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries\" class=\"headerlink\" title=\"URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()\"></a>URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()</h3><p>这三个方法都返回一个遍历器对象，供<code>for...of</code>循环遍历。它们的区别在于，<code>keys</code>方法返回的是键名的遍历器，<code>values</code>方法返回的是键值的遍历器，<code>entries</code>返回的是键值对的遍历器。</p>\n<pre><code class=\"js\">var params = new URLSearchParams(&#39;a=1&amp;b=2&#39;);\n\nfor(var p of params.keys()) &#123;\n  console.log(p);\n&#125;\n// a\n// b\n\nfor(var p of params.values()) &#123;\n  console.log(p);\n&#125;\n// 1\n// 2\n\nfor(var p of params.entries()) &#123;\n  console.log(p);\n&#125;\n// [&quot;a&quot;, &quot;1&quot;]\n// [&quot;b&quot;, &quot;2&quot;]\n</code></pre>\n<p>如果直接对<code>URLSearchParams</code>进行遍历，其实内部调用的就是<code>entries</code>接口。</p>\n<pre><code class=\"js\">for (var p of params) &#123;&#125;\n// 等同于\nfor (var p of params.entries()) &#123;&#125;\n</code></pre>\n<h2 id=\"qs模块\"><a href=\"#qs模块\" class=\"headerlink\" title=\"qs模块\"></a>qs模块</h2><p>qs是一个npm仓库所管理的包,可通过npm install qs命令进行安装.</p>\n<ol>\n<li>qs.parse()将URL解析成对象的形式</li>\n<li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li>\n</ol>\n<pre><code class=\"javascript\">const qs = require(&#39;qs&#39;);\n\n1.qs.parse()\nconst str = &quot;username=&#39;admin&#39;&amp;password=&#39;123456&#39;&quot;;\nconsole.log(qs.parse(str)); \n// Object &#123; username: &quot;admin&quot;, password: &quot;123456&quot; &#125;\n\n2.qs.stringify()\nconst a = qs.stringify(&#123; username: &#39;admin&#39;, password: &#39;123456&#39; &#125;);\nconsole.log(a); \n// username=admin&amp;password=123456\n</code></pre>\n<pre><code class=\"js\">qs.stringify() 和JSON.stringify()有什么区别?\n\nvar a = &#123;name:&#39;hehe&#39;,age:10&#125;;\nqs.stringify序列化结果如\nname=hehe&amp;age=10\n--------------------\n而JSON.stringify序列化结果如下：\n&quot;&#123;&quot;a&quot;:&quot;hehe&quot;,&quot;age&quot;:10&#125;&quot;\n</code></pre>\n<h1 id=\"06-【nodejs内置模块（中）】\"><a href=\"#06-【nodejs内置模块（中）】\" class=\"headerlink\" title=\"06 【nodejs内置模块（中）】\"></a>06 【nodejs内置模块（中）】</h1><h2 id=\"1-路劲处理模块-path\"><a href=\"#1-路劲处理模块-path\" class=\"headerlink\" title=\"1.路劲处理模块 path\"></a>1.路劲处理模块 path</h2><h3 id=\"1-1-模块概览\"><a href=\"#1-1-模块概览\" class=\"headerlink\" title=\"1.1 模块概览\"></a>1.1 模块概览</h3><p>在nodejs中，path是个使用频率很高，但却让人又爱又恨的模块。部分因为文档说的不够清晰，部分因为接口的平台差异性。</p>\n<p>将path的接口按照用途归类，仔细琢磨琢磨，也就没那么费解了。</p>\n<h3 id=\"1-2-获取路径-x2F-文件名-x2F-扩展名\"><a href=\"#1-2-获取路径-x2F-文件名-x2F-扩展名\" class=\"headerlink\" title=\"1.2 获取路径&#x2F;文件名&#x2F;扩展名\"></a>1.2 获取路径&#x2F;文件名&#x2F;扩展名</h3><ul>\n<li>获取路径：path.dirname(filepath)</li>\n<li>获取文件名：path.basename(filepath)</li>\n<li>获取扩展名：path.extname(filepath)</li>\n</ul>\n<h4 id=\"1-2-1-获取所在路径\"><a href=\"#1-2-1-获取所在路径\" class=\"headerlink\" title=\"1.2.1 获取所在路径\"></a>1.2.1 获取所在路径</h4><p>例子如下：</p>\n<pre><code class=\"javascript\">var path = require(&#39;path&#39;);\nvar filepath = &#39;/tmp/demo/js/test.js&#39;;\n\n// 输出：/tmp/demo/js\nconsole.log( path.dirname(filepath) );\n</code></pre>\n<h4 id=\"1-2-2-获取文件名\"><a href=\"#1-2-2-获取文件名\" class=\"headerlink\" title=\"1.2.2 获取文件名\"></a>1.2.2 获取文件名</h4><p>严格意义上来说，path.basename(filepath) 只是输出路径的最后一部分，并不会判断是否文件名。</p>\n<p>但大部分时候，我们可以用它来作为简易的“获取文件名“的方法。</p>\n<pre><code class=\"javascript\">var path = require(&#39;path&#39;);\n\n// 输出：test.js\nconsole.log( path.basename(&#39;/tmp/demo/js/test.js&#39;) );\n\n// 输出：test\nconsole.log( path.basename(&#39;/tmp/demo/js/test/&#39;) );\n\n// 输出：test\nconsole.log( path.basename(&#39;/tmp/demo/js/test&#39;) );\n</code></pre>\n<p>如果只想获取文件名，单不包括文件扩展呢？可以用上第二个参数。</p>\n<pre><code class=\"javascript\">// 输出：test\nconsole.log( path.basename(&#39;/tmp/demo/js/test.js&#39;, &#39;.js&#39;) );\n</code></pre>\n<h4 id=\"1-2-3-获取文件扩展名\"><a href=\"#1-2-3-获取文件扩展名\" class=\"headerlink\" title=\"1.2.3 获取文件扩展名\"></a>1.2.3 获取文件扩展名</h4><p>简单的例子如下：</p>\n<pre><code class=\"javascript\">var path = require(&#39;path&#39;);\nvar filepath = &#39;/tmp/demo/js/test.js&#39;;\n\n// 输出：.js\nconsole.log( path.extname(filepath) );\n</code></pre>\n<p>更详细的规则是如下：（假设 path.basename(filepath) &#x3D;&#x3D;&#x3D; B ）</p>\n<ul>\n<li>从B的最后一个<code>.</code>开始截取，直到最后一个字符。</li>\n<li>如果B中不存在<code>.</code>，或者B的第一个字符就是<code>.</code>，那么返回空字符串。</li>\n</ul>\n<p>直接看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYXRoLmh0bWwjcGF0aF9wYXRoX2V4dG5hbWVfcGF0aA==\">官方文档</span>的例子</p>\n<pre><code class=\"javascript\">path.extname(&#39;index.html&#39;)\n// returns &#39;.html&#39;\n\npath.extname(&#39;index.coffee.md&#39;)\n// returns &#39;.md&#39;\n\npath.extname(&#39;index.&#39;)\n// returns &#39;.&#39;\n\npath.extname(&#39;index&#39;)\n// returns &#39;&#39;\n\npath.extname(&#39;.index&#39;)\n// returns &#39;&#39;\n</code></pre>\n<h3 id=\"1-3-路径组合\"><a href=\"#1-3-路径组合\" class=\"headerlink\" title=\"1.3 路径组合\"></a>1.3 路径组合</h3><ul>\n<li>path.join([…paths])</li>\n<li>path.resolve([…paths])</li>\n</ul>\n<h4 id=\"1-3-1-path-resolve-生成完成的绝对路径\"><a href=\"#1-3-1-path-resolve-生成完成的绝对路径\" class=\"headerlink\" title=\"1.3.1 path.resolve() 生成完成的绝对路径\"></a>1.3.1 path.resolve() 生成完成的绝对路径</h4><p>语法格式：</p>\n<pre><code class=\"js\">path.resolve([...myPaths])\n</code></pre>\n<p>解释：</p>\n<ul>\n<li>将路径或路径片段的序列解析为绝对路径。</li>\n<li>返回的路径是<strong>从右往左</strong>处理，后面的每个 myPath 被依次解析，直到构造出一个完整的绝对路径。</li>\n</ul>\n<blockquote>\n<p>你可以想象现在你在shell下面，从左到右运行一遍<code>cd path</code>命令，最终获取的绝对路径&#x2F;文件名，就是这个接口所返回的结果了。</p>\n</blockquote>\n<p>代码举例：</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;);\n\nlet arr1 = [&#39;/foo1/foo2&#39;, &#39;dselegent&#39;, &#39;foo3&#39;];\nlet result1 = path.resolve(...arr1);\nconsole.log(result1); // 打印结果：/foo1/foo2/dselegent/foo3\n\nlet arr2 = [&#39;/foo1/foo2&#39;, &#39;/dselegent&#39;, &#39;foo3&#39;];\nlet result2 = path.resolve(...arr2);\nconsole.log(result2); // 打印结果：/dselegent/foo3\n</code></pre>\n<pre><code class=\"javascript\">const path = require(&#39;path&#39;);\n\n// 假设当前工作路径是 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path\n\n// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path\nconsole.log( path.resolve(&#39;&#39;) )\n\n// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path\nconsole.log( path.resolve(&#39;.&#39;) )\n\n// 输出 /foo/bar/baz\nconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;) );\n\n// 输出 /foo/bar/baz\nconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;./baz/&#39;) );\n\n// 输出 /tmp/file\nconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;) );\n\n// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path/www/js/mod.js\nconsole.log( path.resolve(&#39;www&#39;, &#39;js/upload&#39;, &#39;../mod.js&#39;) );\n</code></pre>\n<h4 id=\"1-3-2-path-join-将多个路径进行拼接\"><a href=\"#1-3-2-path-join-将多个路径进行拼接\" class=\"headerlink\" title=\"1.3.2 path.join() 将多个路径进行拼接\"></a>1.3.2 path.join() 将多个路径进行拼接</h4><p>如果是我们手动拼接路径，容易出错。这个时候，可以利用 path.join() 方法将路径进行拼接。</p>\n<p>语法格式：</p>\n<pre><code class=\"js\">path.join([...paths]);\n</code></pre>\n<p>解释：使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。</p>\n<p>代码举例：</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;);\n\nconst result1 = path.join(__dirname, &#39;./app.js&#39;);\nconsole.log(result1); // 返回：/Users/smyhvae/dselegent/app.js\n\nconst result2 = path.join(&#39;/foo1&#39;, &#39;foo2&#39;, &#39;./foo3&#39;);\nconsole.log(result2); // 返回：/foo1/foo2/foo3\n\nconst result3 = path.join(&#39;/foo1&#39;, &#39;foo2&#39;, &#39;/foo3&#39;);\nconsole.log(result3); // 返回：/foo1/foo2/foo3\n</code></pre>\n<h4 id=\"1-3-3-path-resolve-和-path-join-区别\"><a href=\"#1-3-3-path-resolve-和-path-join-区别\" class=\"headerlink\" title=\"1.3.3 path.resolve 和 path.join 区别\"></a>1.3.3 path.resolve 和 path.join 区别</h4><p>path.resolve 和 path.join 都是属于 path 核心模块下的方法，用来拼接路径。</p>\n<p>都可以拼接成一个完整路径.</p>\n<pre><code class=\"js\">const path = require(&quot;path&quot;);\n\nvar dirname = &#39;/User/Desktop&#39;;\nvar basename = &#39;abc.txt&#39;;\n\npath.join(dirname, basename);  // /User/Desktop/abc.txt\n\npath.resolve(dirname, basename);  // /User/Desktop/abc.txt\n</code></pre>\n<p>如果 dirname 是以 .&#x2F; 、..&#x2F;、不加 &#x2F; 开头的话，那么 resolve 会找到磁盘下的根目录</p>\n<pre><code class=\"javascript\">const path = require(&quot;path&quot;);\n \nvar dirname = &#39;../User/Desktop&#39;;\nvar basename = &#39;abc.txt&#39;;\n \npath.join(dirname, basename);  // ../User/Desktop/abc.txt\n \npath.resolve(dirname, basename);  // /Users/Desktop/node/User/Desktop/abc.txt\n</code></pre>\n<p>如果 basename 是以 &#x2F; 开头的，那么 resolve 就会直接返回 basename </p>\n<pre><code class=\"javascript\">const path = require(&quot;path&quot;);\n \nvar dirname = &#39;/User/Desktop&#39;;\nvar basename = &#39;/abc.txt&#39;;\n \npath.join(dirname, basename);  // /User/Desktop/abc.txt\n \npath.resolve(dirname, basename);  // /abc.txt\n</code></pre>\n<h3 id=\"1-4-几个常见路径\"><a href=\"#1-4-几个常见路径\" class=\"headerlink\" title=\"1.4 几个常见路径\"></a>1.4 几个常见路径</h3><ul>\n<li><code>__dirname</code>：这是一个常量，表示：当前执行文件所在<strong>完整目录</strong>。</li>\n<li><code>__filename</code>：这是一个常量。表示：当前执行文件的<strong>完整目录 + 文件名</strong>。</li>\n<li><code>process.cwd</code>：获取当前执行 Node命令 时的目录名。</li>\n</ul>\n<p>代码举例：</p>\n<pre><code class=\"js\">console.log(__dirname);\n\nconsole.log(__filename);\n\nconsole.log(process.cwd());\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"bash\">$ node app.js\n\n/Users/smyhvae/dselegent\n/Users/smyhvae/dselegent/app.js\n/Users/smyhvae/dselegent\n</code></pre>\n<h2 id=\"2-本地文件操作模块-fs\"><a href=\"#2-本地文件操作模块-fs\" class=\"headerlink\" title=\"2.本地文件操作模块 fs\"></a>2.本地文件操作模块 fs</h2><blockquote>\n<h3 id=\"Node-js-中的同步和异步的区别\"><a href=\"#Node-js-中的同步和异步的区别\" class=\"headerlink\" title=\"Node.js 中的同步和异步的区别\"></a>Node.js 中的同步和异步的区别</h3><p>fs模块对文件的几乎所有操作都有同步和异步两种形式。例如：readFile() 和 readFileSync()。</p>\n<p>区别：</p>\n<ul>\n<li>同步调用会阻塞代码的执行，异步则不会。</li>\n<li>异步调用会将 读取任务 下达到任务队列，直到任务执行完成才会回调。</li>\n<li>异常处理方面：同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数。【重要】</li>\n</ul>\n</blockquote>\n<h3 id=\"2-1-文件读取\"><a href=\"#2-1-文件读取\" class=\"headerlink\" title=\"2.1 文件读取\"></a>2.1 文件读取</h3><p><strong>同步读取</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\nvar data;\n\ntry&#123;\n    data = fs.readFileSync(&#39;./fileForRead.txt&#39;, &#39;utf8&#39;);\n    console.log(&#39;文件内容: &#39; + data);\n&#125;catch(err)&#123;\n    console.error(&#39;读取文件出错: &#39; + err.message);\n&#125;\n</code></pre>\n<p>输出如下：</p>\n<pre><code class=\"bash\">/usr/local/bin/node readFileSync.js\n文件内容: hello world\n</code></pre>\n<p><strong>异步读取</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nfs.readFile(&#39;./fileForRead.txt&#39;, &#39;utf8&#39;, function(err, data)&#123;\n    if(err)&#123;\n        return console.error(&#39;读取文件出错: &#39; + err.message);\n    &#125;\n    console.log(&#39;文件内容: &#39; + data);\n&#125;);\n</code></pre>\n<p>输出如下</p>\n<pre><code class=\"bash\">/usr/local/bin/node readFile.js\n文件内容: hello world\n</code></pre>\n<blockquote>\n<p><strong>fs&#x2F;promises 从 Node.js 14 开始可用</strong><br>从 Node.js 14 开始，fs 模块提供了两种使用基于 promises 的文件系统的方法。这些 promises 可以通过 <code>require(&#39;fs&#39;).promises</code> 或 <code>require(&#39;fs/promises&#39;) </code>获得。</p>\n</blockquote>\n<pre><code class=\"js\">import &#123; readFile &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  const contents = await readFile(filePath, &#123; encoding: &#39;utf8&#39; &#125;);\n  console.log(contents);\n&#125; catch (err) &#123;\n  console.error(err.message);\n&#125;\n</code></pre>\n<h3 id=\"2-2-文件写入\"><a href=\"#2-2-文件写入\" class=\"headerlink\" title=\"2.2 文件写入\"></a>2.2 文件写入</h3><p>备注：以下代码，如果文件不存在，则创建文件；如果文件存在，则覆盖文件内容；</p>\n<p><strong>异步写入</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nfs.writeFile(&#39;./fileForWrite.txt&#39;, &#39;hello world&#39;, &#39;utf8&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;文件写入成功&#39;);\n&#125;);\n</code></pre>\n<p><strong>同步写入</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\ntry&#123;\n    fs.writeFileSync(&#39;./fileForWrite1.txt&#39;, &#39;hello world&#39;, &#39;utf8&#39;);\n    console.log(&#39;文件写入成功&#39;);\n&#125;catch(err)&#123;\n    throw err;\n&#125;\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"js\">import &#123; writeFile &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  const contents = await writeFile(&#39;message.txt&#39;, &#39;hello world&#39;, &#123; encoding: &#39;utf8&#39; &#125;);\n  console.log(contents);\n&#125; catch (err) &#123;\n  // When a request is aborted - err is an AbortError\n  console.error(err);\n&#125;\n</code></pre>\n<h3 id=\"2-3-文件是否存在\"><a href=\"#2-3-文件是否存在\" class=\"headerlink\" title=\"2.3 文件是否存在\"></a>2.3 文件是否存在</h3><p><code>fs.exists()</code>已经是<code>deprecated</code>状态，现在可以通过下面代码判断文件是否存在。</p>\n<p><strong>异步本</strong></p>\n<pre><code class=\"js\">const fs = require(&#39;fs&#39;)\n\n//检查文件是否存在于当前目录中\nfs.access(&#39;package.json&#39;, fs.constants.F_OK, err =&gt; &#123;\n    if(err) &#123;\n        console.log(&#39;package.json不存在于当前目录中&#39;)\n        return\n    &#125;\n    console.log(&#39;package.json存在于当前目录中&#39;)\n&#125;)\n\nfs.access(&#39;index.js&#39;, fs.constants.F_OK, err =&gt; &#123;\n    if(err) &#123;\n        console.log(&#39;index.js不存在于当前目录中&#39;)\n        return\n    &#125;\n    console.log(&#39;index.js存在于当前目录中&#39;)\n&#125;)\n</code></pre>\n<p><code>fs.access()</code>除了判断文件是否存在（默认模式），还可以用来判断文件的权限。</p>\n<p>备忘：<code>fs.constants.F_OK</code>等常量无法获取（node v6.1，mac 10.11.4下，<code>fs.constants</code>是<code>undefined</code>）</p>\n<p><strong>同步</strong></p>\n<pre><code class=\"js\">import &#123; accessSync, constants &#125; from &#39;fs&#39;;\n\ntry &#123;\n  accessSync(&#39;etc/passwd&#39;, constants.R_OK );\n  console.log(&#39;can read&#39;);\n&#125; catch (err) &#123;\n  console.error(&#39;no access!&#39;);\n&#125;\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"js\">import &#123; access, constants &#125; from &#39;node:fs/promises&#39;;\n\ntry &#123;\n  await access(&#39;/etc/passwd&#39;, constants.R_OK);\n  console.log(&#39;can access&#39;);\n&#125; catch &#123;\n  console.error(&#39;cannot access&#39;);\n&#125;\n</code></pre>\n<h3 id=\"2-4-删除文件\"><a href=\"#2-4-删除文件\" class=\"headerlink\" title=\"2.4 删除文件\"></a>2.4 删除文件</h3><p><strong>异步版本</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nfs.unlink(&#39;./fileForUnlink.txt&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;文件删除成功&#39;);\n&#125;);\n</code></pre>\n<p><strong>同步版本</strong></p>\n<pre><code class=\"js\">import &#123; unlinkSync &#125; from &#39;fs&#39;;\n\ntry &#123;\n  unlinkSync(&#39;/tmp/hello&#39;);\n  console.log(&#39;successfully deleted /tmp/hello&#39;);\n&#125; catch (err) &#123;\n  // handle the error\n&#125;\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"js\">import &#123; unlink &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  await unlink(&#39;/tmp/hello&#39;);\n  console.log(&#39;successfully deleted /tmp/hello&#39;);\n&#125; catch (err) &#123;\n  // handle the error\n&#125;\n</code></pre>\n<h3 id=\"2-5-创建目录\"><a href=\"#2-5-创建目录\" class=\"headerlink\" title=\"2.5 创建目录\"></a>2.5 创建目录</h3><p><strong>异步版本</strong>（如果目录已存在，会报错）</p>\n<pre><code class=\"javascript\">// fs.mkdir(path[, mode], callback)\nvar fs = require(&#39;fs&#39;);\n\nfs.mkdir(&#39;sub&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;创建目录成功&#39;);\n&#125;);\n</code></pre>\n<p><strong>同步版本</strong></p>\n<pre><code class=\"javascript\">// fs.mkdirSync(path[, mode])\nvar fs = require(&#39;fs&#39;);\n\ntry&#123;\n    fs.mkdirSync(&#39;hello&#39;);\n    console.log(&#39;创建目录成功&#39;);\n&#125;catch(e)&#123;\n    throw e;\n&#125;\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"js\">import &#123; mkdir &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  const createDir = await mkdir(projectFolder, &#123; recursive: true &#125;);\n  console.log(`created $&#123;createDir&#125;`);\n&#125; catch (err) &#123;\n  console.error(err.message);\n&#125;\n</code></pre>\n<h3 id=\"2-6-遍历目录\"><a href=\"#2-6-遍历目录\" class=\"headerlink\" title=\"2.6 遍历目录\"></a>2.6 遍历目录</h3><p>同步版本，注意：<code>fs.readdirSync()</code>只会读一层，所以需要判断文件类型是否目录，如果是，则进行递归遍历。</p>\n<pre><code class=\"js\">// fs.readdirSync(path[, options])\n\nvar fs = require(&#39;fs&#39;);\nvar path = require(&#39;path&#39;);\n\nvar getFilesInDir = function(dir)&#123;\n\n    var results = [ path.resolve(dir) ];\n    var files = fs.readdirSync(dir, &#39;utf8&#39;);\n\n    files.forEach(function(file)&#123;\n\n        file = path.resolve(dir, file);\n\n        var stats = fs.statSync(file);\n\n        if(stats.isFile())&#123;\n            results.push(file);\n        &#125;else if(stats.isDirectory())&#123;\n            results = results.concat( getFilesInDir(file) );\n        &#125;\n    &#125;);\n\n    return results;\n&#125;;\n\nvar files = getFilesInDir(&#39;../&#39;);\nconsole.log(files);\n</code></pre>\n<h3 id=\"2-7-读取目录\"><a href=\"#2-7-读取目录\" class=\"headerlink\" title=\"2.7 读取目录\"></a>2.7 读取目录</h3><pre><code class=\"js\">import &#123; readdir &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  const files = await readdir(path);\n  for (const file of files)\n    console.log(file);\n&#125; catch (err) &#123;\n  console.error(err);\n&#125;\n</code></pre>\n<h3 id=\"2-8-删除目录\"><a href=\"#2-8-删除目录\" class=\"headerlink\" title=\"2.8 删除目录\"></a>2.8 删除目录</h3><pre><code class=\"js\">// 删除目录(前提没有文件在里面)\nfs.rmdir(&#39;./avatar&#39;, err =&gt; &#123;\n  if (err &amp;&amp; err.code === &#39;ENOENT&#39;) &#123;\n    console.log(&#39;目录不存在&#39;);\n  &#125;\n&#125;);\n</code></pre>\n<h3 id=\"2-9-删除整个目录\"><a href=\"#2-9-删除整个目录\" class=\"headerlink\" title=\"2.9 删除整个目录\"></a>2.9 删除整个目录</h3><pre><code class=\"js\">//1\nconst fs = require(&quot;fs&quot;)\nfs.(&quot;./avatar&quot;,(err,data)=&gt;&#123;\n    // console.log(data)\n    data.forEach(item=&gt;&#123;\n        fs.unlinkSync(`./avatar/$&#123;item&#125;`)\n    &#125;)\n\n    fs.rmdir(&quot;./avatar&quot;,(err)=&gt;&#123;\n        console.log(err)\n    &#125;)\n&#125;)\n\n//2\nconst fs = require(&#39;fs&#39;)\nfs.readdir(&quot;./avatar&quot;).then(async (data)=&gt;&#123;\n    let arr = []\n    data.forEach(item=&gt;&#123;\n        arr.push(fs.unlink(`./avatar/$&#123;item&#125;`))\n    &#125;)\n    await Promise.all(arr)\n    fs.rmdir(&quot;./avatar&quot;)\n&#125;)\n\n//3\nconst fs = require(&#39;fs&#39;).promises;\nfs.readdir(&#39;./image2&#39;).then(async data =&gt; &#123;\n  await Promise.all(data.map(item =&gt; fs.unlink(`./image2/$&#123;item&#125;`)));\n  await fs.rmdir(&#39;./image2&#39;);\n&#125;);\n</code></pre>\n<h3 id=\"2-10-文件重命名\"><a href=\"#2-10-文件重命名\" class=\"headerlink\" title=\"2.10 文件重命名\"></a>2.10 文件重命名</h3><p><strong>异步版本</strong></p>\n<pre><code class=\"javascript\">// fs.rename(oldPath, newPath, callback)\nvar fs = require(&#39;fs&#39;);\n\nfs.rename(&#39;./hello&#39;, &#39;./world&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;重命名成功&#39;);\n&#125;);\n</code></pre>\n<p><strong>同步版本</strong></p>\n<pre><code class=\"js\">// fs.renameSync(oldPath, newPath)\nvar fs = require(&#39;fs&#39;);\n\nfs.renameSync(&#39;./world&#39;, &#39;./hello&#39;);\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"js\">import &#123; rename &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  await rename(&#39;./world&#39;, &#39;./hello&#39;);\n  console.log(`rename`);\n&#125; catch (err) &#123;\n  console.error(err.message);\n&#125;\n</code></pre>\n<h3 id=\"2-11-获取文件状态\"><a href=\"#2-11-获取文件状态\" class=\"headerlink\" title=\"2.11 获取文件状态\"></a>2.11 获取文件状态</h3><p>1.异步：fs.stat(path,callback):<br>  path是一个表示路径的字符串,callback接收两个参数(err,stats),其中stats就是fs.stats的一个实例；</p>\n<p>2.同步：fs.statSync(path)<br>  只接收一个path变量，fs.statSync(path)其实是一个fs.stats的一个实例；</p>\n<p>方法</p>\n<ul>\n<li>stats.isFile() – 是否文件</li>\n<li>stats.isDirectory() – 是否目录</li>\n</ul>\n<pre><code class=\"js\">// Node.js program to demonstrate the \n// fs.statSync() method \n  \n// Import the filesystem module \nconst fs = require(&#39;fs&#39;); \n  \n// Getting information for a file \nstatsObj = fs.statSync(&quot;test_file.txt&quot;); \n  \nconsole.log(statsObj);  \nconsole.log(&quot;Path is file:&quot;, statsObj.isFile()); \nconsole.log(&quot;Path is directory:&quot;, statsObj.isDirectory()); \n  \n// Getting information for a directory \nstatsObj = fs.statSync(&quot;test_directory&quot;); \n  \nconsole.log(statsObj); \nconsole.log(&quot;Path is file:&quot;, statsObj.isFile()); \nconsole.log(&quot;Path is directory:&quot;, statsObj.isDirectory());\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"js\">Stats &#123;\n  dev:3229478529,\n  mode:33206,\n  nlink:1,\n  uid:0,\n  gid:0,\n  rdev:0,\n  blksize:4096,\n  ino:1970324837039946,\n  size:0,\n  blocks:0,\n  atimeMs:1582306776282,\n  mtimeMs:1582482953967,\n  ctimeMs:1582482953968.2532,\n  birthtimeMs:1582306776282.142,\n  atime:2020-02-21T17:39:36.282Z,\n  mtime:2020-02-23T18:35:53.967Z,\n  ctime:2020-02-23T18:35:53.968Z,\n  birthtime:2020-02-21T17:39:36.282Z\n&#125;\nPath is file:true\nPath is directory:false\nStats &#123;\n  dev:3229478529,\n  mode:16822,\n  nlink:1,\n  uid:0,\n  gid:0,\n  rdev:0,\n  blksize:4096,\n  ino:562949953486669,\n  size:0,\n  blocks:0,\n  atimeMs:1582482965037.8445,\n  mtimeMs:1581074249467.7114,\n  ctimeMs:1582482964979.8303,\n  birthtimeMs:1582306776288.1958,\n  atime:2020-02-23T18:36:05.038Z,\n  mtime:2020-02-07T11:17:29.468Z,\n  ctime:2020-02-23T18:36:04.980Z,\n  birthtime:2020-02-21T17:39:36.288Z\n&#125;\nPath is file:false\nPath is directory:true\n</code></pre>\n<h3 id=\"2-12-追加文件内容\"><a href=\"#2-12-追加文件内容\" class=\"headerlink\" title=\"2.12 追加文件内容\"></a>2.12 追加文件内容</h3><blockquote>\n<p>fs.appendFile(file, data[, options], callback)</p>\n</blockquote>\n<ul>\n<li>file：可以是文件路径，也可以是文件句柄。（还可以是buffer？）</li>\n<li>data：要追加的内容。string或者buffer。</li>\n<li>options<ul>\n<li>encoding：编码，默认是<code>utf8</code></li>\n<li>mode：默认是<code>0o666</code></li>\n<li>flag：默认是<code>a</code></li>\n</ul>\n</li>\n</ul>\n<p>注意：如果<code>file</code>是文件句柄，那么</p>\n<ul>\n<li>开始追加数据前，file需要已经打开。</li>\n<li>file需要手动关闭。</li>\n</ul>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nfs.appendFile(&#39;./extra/fileForAppend.txt&#39;, &#39;hello&#39;, &#39;utf8&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;append成功&#39;);\n&#125;);\n</code></pre>\n<h2 id=\"3-事件机制模块-events\"><a href=\"#3-事件机制模块-events\" class=\"headerlink\" title=\"3.事件机制模块 events\"></a>3.事件机制模块 events</h2><p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>\n<pre><code class=\"javascript\">// 引入 events 模块\nvar EventEmitter = require(&#39;events&#39;);\n// 创建 eventEmitter 对象\nvar event = new EventEmitter();\n</code></pre>\n<p>以下程序绑定事件处理程序：</p>\n<pre><code class=\"javascript\">// 绑定事件及事件的处理程序\neventEmitter.on(&#39;eventName&#39;, eventHandler);\n</code></pre>\n<p>我们可以通过程序触发事件：</p>\n<pre><code class=\"javascript\">// 触发事件\neventEmitter.emit(&#39;eventName&#39;);\n</code></pre>\n<p><code>EventEmitter </code>的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，<code>EventEmitter </code>支持 若干个事件监听器。</p>\n<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>\n<p>让我们以下面的例子解释这个过程：</p>\n<pre><code class=\"javascript\">// 引入 events 模块\nvar EventEmitter = require(&#39;events&#39;);\n// 创建 eventEmitter 对象\nvar event = new EventEmitter();\nevent.on(&#39;someEvent&#39;, function(arg1, arg2) &#123; \n    console.log(&#39;listener1&#39;, arg1, arg2); \n&#125;); \nevent.on(&#39;someEvent&#39;, function(arg1, arg2) &#123; \n    console.log(&#39;listener2&#39;, arg1, arg2); \n&#125;); \nevent.emit(&#39;someEvent&#39;, &#39;arg1 参数&#39;, &#39;arg2 参数&#39;); \n</code></pre>\n<p>执行以上代码，运行的结果如下：</p>\n<pre><code class=\"bash\">$ node event.js \nlistener1 arg1 参数 arg2 参数\nlistener2 arg1 参数 arg2 参数\n</code></pre>\n<p>以上例子中，event 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p>\n<p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是<code>EventEmitter</code>最简单的用法。</p>\n<p><code>EventEmitter </code>提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件</p>\n<h1 id=\"07-【nodejs内置模块（下）】\"><a href=\"#07-【nodejs内置模块（下）】\" class=\"headerlink\" title=\"07 【nodejs内置模块（下）】\"></a>07 【nodejs内置模块（下）】</h1><h2 id=\"1-stream-模块\"><a href=\"#1-stream-模块\" class=\"headerlink\" title=\"1.stream 模块\"></a>1.stream 模块</h2><p><code>stream</code>是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>\n<p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>\n<p>如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。</p>\n<p>有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。</p>\n<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>\n<h3 id=\"1-1-读取流\"><a href=\"#1-1-读取流\" class=\"headerlink\" title=\"1.1 读取流\"></a>1.1 读取流</h3><pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建读取流\nlet rs = fs.createReadStream(&#39;hello.txt&#39;, &#39;utf-8&#39;);\n\nrs.on(&#39;open&#39;, function () &#123;\n  console.log(&#39;读取的文件已打开&#39;);\n&#125;).on(&#39;close&#39;, function () &#123;\n  console.log(&#39;读取流结束&#39;);\n&#125;).on(&#39;error&#39;, err =&gt; &#123;\n  console.log(err);\n&#125;).on(&#39;data&#39;, function (chunk) &#123;\n  //每一批数据流入完成\n  console.log(&#39;单批数据流入:&#39; + chunk.length);\n  console.log(chunk);\n&#125;);\n</code></pre>\n<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>\n<p><strong>读取视频</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建读取流\nlet rs = fs.createReadStream(&#39;video.mp4&#39;);\n\n//每一批数据流入完成\nrs.on(&#39;data&#39;, function (chunk) &#123;\n  console.log(&#39;单批数据流入:&#39; + chunk.length);\n  console.log(chunk);\n&#125;);\n</code></pre>\n<p><img data-src=\"https://tva1.sinaimg.cn/large/0074UQWJgy1h3eigfl898j31750iztjs.jpg\"></p>\n<h3 id=\"1-2-写入流\"><a href=\"#1-2-写入流\" class=\"headerlink\" title=\"1.2 写入流\"></a>1.2 写入流</h3><p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建写入流\nlet ws = fs.createWriteStream(&#39;hello.txt&#39;, &#39;utf-8&#39;);\n\n//监听文件打开事件\nws.on(&#39;open&#39;, function () &#123;\n  console.log(&#39;文件打开&#39;);\n&#125;);\n\n//监听文件关闭事件\nws.on(&#39;close&#39;, function () &#123;\n  console.log(&#39;文件写入完成，关闭&#39;);\n&#125;);\n\n//文件流式写入\nws.write(&#39;helloworld1!&#39;, function (err) &#123;\n  if (err) &#123;\n    console.log(err);\n  &#125; else &#123;\n    console.log(&#39;内容1流入完成&#39;);\n  &#125;\n&#125;);\nws.write(&#39;helloworld2!&#39;, function (err) &#123;\n  if (err) &#123;\n    console.log(err);\n  &#125; else &#123;\n    console.log(&#39;内容2流入完成&#39;);\n  &#125;\n&#125;);\n\n//文件写入完成\nws.end(function () &#123;\n  console.log(&#39;文件写入关闭&#39;);\n&#125;);\n</code></pre>\n<p><code>pipe</code> 就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>\n<p>在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的。</p>\n<p>让我们用<code>pipe()</code>把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建读取流\nlet rs = fs.createReadStream(&#39;video.mp4&#39;);\nlet ws = fs.createWriteStream(&#39;b.mp4&#39;);\n\nrs.on(&#39;close&#39;, function () &#123;\n  console.log(&#39;读取流结束&#39;);\n&#125;);\n\nrs.pipe(ws);\n</code></pre>\n<p><strong>pipe原理</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建读取流\nlet rs = fs.createReadStream(&#39;video.mp4&#39;);\nlet ws = fs.createWriteStream(&#39;b.mp4&#39;);\n\nrs.on(&#39;close&#39;, function () &#123;\n  ws.end();\n  console.log(&#39;读取流结束&#39;);\n&#125;);\n\n//每一批数据流入完成\nrs.on(&#39;data&#39;, function (chunk) &#123;\n  console.log(&#39;单批数据流入:&#39; + chunk.length);\n  ws.write(chunk, () =&gt; &#123;\n    console.log(&#39;单批输入流入完成&#39;);\n  &#125;);\n&#125;);\n</code></pre>\n<h2 id=\"2-资源压缩模块-zib\"><a href=\"#2-资源压缩模块-zib\" class=\"headerlink\" title=\"2.资源压缩模块 zib\"></a>2.资源压缩模块 zib</h2><h3 id=\"2-1-概览\"><a href=\"#2-1-概览\" class=\"headerlink\" title=\"2.1 概览\"></a>2.1 概览</h3><p>做过web性能优化的同学，对性能优化大杀器<strong>gzip</strong>应该不陌生。浏览器向服务器发起资源请求，比如下载一个js文件，服务器先对资源进行压缩，再返回给浏览器，以此节省流量，加快访问速度。</p>\n<p>浏览器通过HTTP请求头部里加上<strong>Accept-Encoding</strong>，告诉服务器，“你可以用gzip，或者defalte算法压缩资源”。</p>\n<blockquote>\n<p>Accept-Encoding:gzip, deflate</p>\n</blockquote>\n<p>那么，在nodejs里，是如何对资源进行压缩的呢？答案就是<strong>Zlib</strong>模块。&#x3D;</p>\n<h3 id=\"2-2-压缩的例子\"><a href=\"#2-2-压缩的例子\" class=\"headerlink\" title=\"2.2 压缩的例子\"></a>2.2 压缩的例子</h3><p>非常简单的几行代码，就完成了本地文件的gzip压缩。</p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\nvar zlib = require(&#39;zlib&#39;);\n\nvar gzip = zlib.createGzip();\n\nvar readstream = fs.createReadStream(&#39;./extra/fileForCompress.txt&#39;);\nvar writestream = fs.createWriteStream(&#39;./extra/fileForCompress.txt.gz&#39;);\n\nreadstream.pipe(gzip).pipe(writestream);\n</code></pre>\n<h3 id=\"2-3-解压的例子\"><a href=\"#2-3-解压的例子\" class=\"headerlink\" title=\"2.3 解压的例子\"></a>2.3 解压的例子</h3><p>同样非常简单，就是个反向操作。</p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\nvar zlib = require(&#39;zlib&#39;);\n\nvar gunzip = zlib.createGunzip();\n\nvar readstream  = fs.createReadStream(&#39;./extra/fileForCompress.txt.gz&#39;);\nvar writestream  = fs.createWriteStream(&#39;./extra/fileForCompress1.txt&#39;);\n\nreadstream.pipe(gunzip).pipe(writestream);\n</code></pre>\n<h3 id=\"2-4-服务端gzip压缩\"><a href=\"#2-4-服务端gzip压缩\" class=\"headerlink\" title=\"2.4 服务端gzip压缩\"></a>2.4 服务端gzip压缩</h3><p>首先判断 是否包含 <strong>accept-encoding</strong> 首部，且值为<strong>gzip</strong>。</p>\n<ul>\n<li>否：返回未压缩的文件。</li>\n<li>是：返回gzip压缩后的文件。</li>\n</ul>\n<pre><code class=\"js\">var http = require(&#39;http&#39;);\nvar zlib = require(&#39;zlib&#39;);\nvar fs = require(&#39;fs&#39;);\nvar filepath = &#39;./extra/fileForGzip.html&#39;;\n\nvar server = http.createServer(function(req, res)&#123;\n    var acceptEncoding = req.headers[&#39;accept-encoding&#39;];\n    var gzip;\n    \n    if(acceptEncoding.indexOf(&#39;gzip&#39;)!=-1)&#123; // 判断是否需要gzip压缩\n        \n        gzip = zlib.createGzip();\n        \n        // 记得响应 Content-Encoding，告诉浏览器：文件被 gzip 压缩过\n        res.writeHead(200, &#123;\n            &#39;Content-Encoding&#39;: &#39;gzip&#39;\n        &#125;);\n        fs.createReadStream(filepath).pipe(gzip).pipe(res);\n    \n    &#125;else&#123;\n\n        fs.createReadStream(filepath).pipe(res);\n    &#125;\n\n&#125;);\n\nserver.listen(&#39;3000&#39;);\n</code></pre>\n<p><strong>将js大文件返回</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\nconst zlib = require(&#39;zlib&#39;);//这两个要写在fs模块后面\nconst gzip = zlib.createGzip();\nconst http = require(&#39;http&#39;);\n\nhttp\n  .createServer((req, res) =&gt; &#123;\n    let rs = fs.createReadStream(&#39;hello.js&#39;);\n    res.writeHead(200, &#123;\n      &#39;Content-Type&#39;: &#39;application/x-javascript;charset=utf-8&#39;,\n      &#39;Content-Encoding&#39;: &#39;gzip&#39;,\n    &#125;);\n    rs.pipe(gzip).pipe(res);\n  &#125;)\n  .listen(3000, () =&gt; &#123;\n    console.log(&#39;server start&#39;);\n  &#125;);\n</code></pre>\n<h3 id=\"2-5-服务端字符串gzip压缩\"><a href=\"#2-5-服务端字符串gzip压缩\" class=\"headerlink\" title=\"2.5 服务端字符串gzip压缩\"></a>2.5 服务端字符串gzip压缩</h3><p>代码跟前面例子大同小异。这里采用了 <strong>zlib.gzipSync(str)</strong> 对字符串进行gzip压缩。</p>\n<pre><code class=\"javascript\">var http = require(&#39;http&#39;);\nvar zlib = require(&#39;zlib&#39;);\n\nvar responseText = &#39;hello world&#39;;\n\nvar server = http.createServer(function(req, res)&#123;\n    var acceptEncoding = req.headers[&#39;accept-encoding&#39;];\n    if(acceptEncoding.indexOf(&#39;gzip&#39;)!=-1)&#123;\n        res.writeHead(200, &#123;\n            &#39;content-encoding&#39;: &#39;gzip&#39;\n        &#125;);\n        res.end(zlib.gzipSync(responseText) );\n    &#125;else&#123;\n        res.end(responseText);\n    &#125;\n\n&#125;);\n\nserver.listen(&#39;3000&#39;);\n</code></pre>\n<h2 id=\"3-数据加密模块-crypto\"><a href=\"#3-数据加密模块-crypto\" class=\"headerlink\" title=\"3.数据加密模块 crypto\"></a>3.数据加密模块 crypto</h2><p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C&#x2F;C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>\n<h3 id=\"3-1-hash例子\"><a href=\"#3-1-hash例子\" class=\"headerlink\" title=\"3.1 hash例子\"></a>3.1 hash例子</h3><p>hash.digest([encoding])：计算摘要。encoding可以是<code>hex</code>、<code>latin1</code>或者<code>base64</code>。如果声明了encoding，那么返回字符串。否则，返回Buffer实例。注意，调用hash.digest()后，hash对象就作废了，再次调用就会出错。</p>\n<p>hash.update(data[, input_encoding])：input_encoding可以是<code>utf8</code>、<code>ascii</code>或者<code>latin1</code>。如果data是字符串，且没有指定 input_encoding，则默认是<code>utf8</code>。注意，hash.update()方法可以调用多次。</p>\n<pre><code class=\"js\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar content = fs.readFileSync(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\nvar hash = crypto.createHash(&#39;sha256&#39;);\nvar output;\n\nhash.update(content);\n\noutput = hash.digest(&#39;hex&#39;); \n\nconsole.log(output);\n// 输出内容为：\n// b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n</code></pre>\n<p>也可以这样：</p>\n<pre><code class=\"js\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar input = fs.createReadStream(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\nvar hash = crypto.createHash(&#39;sha256&#39;);\n\nhash.setEncoding(&#39;hex&#39;);\n\ninput.pipe(hash).pipe(process.stdout)\n\n// 输出内容为：\n// b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n</code></pre>\n<p>hash.digest()后，再次调用digest()或者update()</p>\n<pre><code class=\"js\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar content = fs.readFileSync(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\nvar hash = crypto.createHash(&#39;sha256&#39;);\nvar output;\n\nhash.update(content);\nhash.digest(&#39;hex&#39;); \n\n// 报错：Error: Digest already called\nhash.update(content);\n\n// 报错：Error: Digest already called\nhash.digest(&#39;hex&#39;);\n</code></pre>\n<h3 id=\"3-2-HMAC例子\"><a href=\"#3-2-HMAC例子\" class=\"headerlink\" title=\"3.2 HMAC例子\"></a>3.2 HMAC例子</h3><p>HMAC的全称是Hash-based Message Authentication Code，也即在hash的加盐运算。</p>\n<p>具体到使用的话，跟hash模块差不多，选定hash算法，指定“盐”即可。</p>\n<p>例子1：</p>\n<pre><code class=\"js\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar secret = &#39;secret&#39;;\nvar hmac = crypto.createHmac(&#39;sha256&#39;, secret);\nvar input = fs.readFileSync(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\n\nhmac.update(input);\n\nconsole.log( hmac.digest(&#39;hex&#39;) );\n// 输出：\n// 734cc62f32841568f45715aeb9f4d7891324e6d948e4c6c60c0621cdac48623a\n</code></pre>\n<p>例子2：</p>\n<pre><code class=\"js\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar secret = &#39;secret&#39;;\nvar hmac = crypto.createHmac(&#39;sha256&#39;, secret);\nvar input = fs.createReadStream(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\n\nhmac.setEncoding(&#39;hex&#39;);\n\ninput.pipe(hmac).pipe(process.stdout)\n// 输出：\n// 734cc62f32841568f45715aeb9f4d7891324e6d948e4c6c60c0621cdac48623a\n</code></pre>\n<h3 id=\"3-3-MD5例子\"><a href=\"#3-3-MD5例子\" class=\"headerlink\" title=\"3.3 MD5例子\"></a>3.3 MD5例子</h3><p>MD5（Message-Digest Algorithm）是计算机安全领域广泛使用的散列函数（又称哈希算法、摘要算法），主要用来确保消息的完整和一致性。常见的应用场景有密码保护、下载文件校验等。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>运算速度快：对<code>jquery.js</code>求md5值，57254个字符，耗时1.907ms</li>\n<li>输出长度固定：输入长度不固定，输出长度固定（128位）。</li>\n<li>运算不可逆：已知运算结果的情况下，无法通过通过逆运算得到原始字符串。</li>\n<li>高度离散：输入的微小变化，可导致运算结果差异巨大。</li>\n<li>弱碰撞性：不同输入的散列值可能相同。</li>\n</ol>\n<p><strong>应用场景</strong></p>\n<ol>\n<li>文件完整性校验：比如从网上下载一个软件，一般网站都会将软件的md5值附在网页上，用户下载完软件后，可对下载到本地的软件进行md5运算，然后跟网站上的md5值进行对比，确保下载的软件是完整的（或正确的）</li>\n<li>密码保护：将md5后的密码保存到数据库，而不是保存明文密码，避免拖库等事件发生后，明文密码外泄。</li>\n<li>防篡改：比如数字证书的防篡改，就用到了摘要算法。（当然还要结合数字签名等手段）</li>\n</ol>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\nvar md5 = crypto.createHash(&#39;md5&#39;);\n\nvar result = md5.update(&#39;a&#39;).digest(&#39;hex&#39;);\n\n// 输出：0cc175b9c0f1b6a831c399e269772661\nconsole.log(result);\n</code></pre>\n<h3 id=\"3-4-例子：密码保护\"><a href=\"#3-4-例子：密码保护\" class=\"headerlink\" title=\"3.4 例子：密码保护\"></a>3.4 例子：密码保护</h3><p>前面提到，将明文密码保存到数据库是很不安全的，最不济也要进行md5后进行保存。比如用户密码是<code>123456</code>，md5运行后，得到<code>输出：e10adc3949ba59abbe56e057f20f883e</code>。</p>\n<p>这样至少有两个好处：</p>\n<ol>\n<li>防内部攻击：网站主人也不知道用户的明文密码，避免网站主人拿着用户明文密码干坏事。</li>\n<li>防外部攻击：如网站被黑客入侵，黑客也只能拿到md5后的密码，而不是用户的明文密码。</li>\n</ol>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\n\nfunction cryptPwd(password) &#123;\n    var md5 = crypto.createHash(&#39;md5&#39;);\n    return md5.update(password).digest(&#39;hex&#39;);\n&#125;\n\nvar password = &#39;123456&#39;;\nvar cryptedPassword = cryptPwd(password);\n\nconsole.log(cryptedPassword);\n// 输出：e10adc3949ba59abbe56e057f20f883e\n</code></pre>\n<p><strong>单纯对密码进行md5不安全</strong></p>\n<p>前面提到，通过对用户密码进行md5运算来提高安全性。但实际上，这样的安全性是很差的，为什么呢？</p>\n<p>稍微修改下上面的例子，可能你就明白了。相同的明文密码，md5值也是相同的。</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\n\nfunction cryptPwd(password) &#123;\n    var md5 = crypto.createHash(&#39;md5&#39;);\n    return md5.update(password).digest(&#39;hex&#39;);\n&#125;\n\nvar password = &#39;123456&#39;;\n\nconsole.log( cryptPwd(password) );\n// 输出：e10adc3949ba59abbe56e057f20f883e\n\nconsole.log( cryptPwd(password) );\n// 输出：e10adc3949ba59abbe56e057f20f883e\n</code></pre>\n<p>也就是说，当攻击者知道算法是md5，且数据库里存储的密码值为<code>e10adc3949ba59abbe56e057f20f883e</code>时，理论上可以可以猜到，用户的明文密码就是<code>123456</code>。</p>\n<p>事实上，彩虹表就是这么进行暴力破解的：事先将常见明文密码的md5值运算好存起来，然后跟网站数据库里存储的密码进行匹配，就能够快速找到用户的明文密码。（这里不探究具体细节）</p>\n<p>那么，有什么办法可以进一步提升安全性呢？答案是：密码加盐。</p>\n<p><strong>密码加盐</strong></p>\n<p>“加盐”这个词看上去很玄乎，其实原理很简单，就是在密码特定位置插入特定字符串后，再对修改后的字符串进行md5运算。</p>\n<p>例子如下。同样的密码，当“盐”值不一样时，md5值的差异非常大。通过密码加盐，可以防止最初级的暴力破解，如果攻击者事先不知道”盐“值，破解的难度就会非常大。</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\n\nfunction cryptPwd(password, salt) &#123;\n    // 密码“加盐”\n    var saltPassword = password + &#39;:&#39; + salt;\n    console.log(&#39;原始密码：%s&#39;, password);\n    console.log(&#39;加盐后的密码：%s&#39;, saltPassword);\n\n    // 加盐密码的md5值\n    var md5 = crypto.createHash(&#39;md5&#39;);\n    var result = md5.update(saltPassword).digest(&#39;hex&#39;);\n    console.log(&#39;加盐密码的md5值：%s&#39;, result);\n&#125;\n\ncryptPwd(&#39;123456&#39;, &#39;abc&#39;);\n// 输出：\n// 原始密码：123456\n// 加盐后的密码：123456:abc\n// 加盐密码的md5值：51011af1892f59e74baf61f3d4389092\n\ncryptPwd(&#39;123456&#39;, &#39;bcd&#39;);\n// 输出：\n// 原始密码：123456\n// 加盐后的密码：123456:bcd\n// 加盐密码的md5值：55a95bcb6bfbaef6906dbbd264ab4531\n</code></pre>\n<h1 id=\"09-【原生nodejs路由、获取参数、静态目录】\"><a href=\"#09-【原生nodejs路由、获取参数、静态目录】\" class=\"headerlink\" title=\"09 【原生nodejs路由、获取参数、静态目录】\"></a>09 【原生nodejs路由、获取参数、静态目录】</h1><h2 id=\"1-路由\"><a href=\"#1-路由\" class=\"headerlink\" title=\"1.路由\"></a>1.路由</h2><p><strong>index.js</strong></p>\n<pre><code class=\"js\">// 启动服务\nconst server = require(&#39;./server.js&#39;);\n//路由模块\nconst route = require(&#39;./route.js&#39;);\n//api\nconst apiRouter = require(&#39;./api.js&#39;);\n\nserver.use(route);\nserver.use(apiRouter);\nserver.start();\n</code></pre>\n<p><strong>server.js</strong></p>\n<pre><code class=\"js\">const http = require(&#39;http&#39;);\n\n//创建一个大对象存储所有的路由和api\nconst route = &#123;&#125;;\n\n// 将所有路由和api合并的函数\nfunction use(routeObj) &#123;\n  Object.assign(route, routeObj);\n&#125;\n\nfunction start() &#123;\n  http\n    .createServer(async (req, res) =&gt; &#123;\n      const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n      route[url.pathname](res);\n    &#125;)\n    .listen(3000, () =&gt; &#123;\n      console.log(&#39;启动成功&#39;);\n    &#125;);\n&#125;\n\nmodule.exports = &#123;\n  use,\n  start,\n&#125;;\n</code></pre>\n<p><strong>route.js</strong></p>\n<pre><code class=\"js\">const fs = require(&#39;fs&#39;);\n\nfunction render(res, path, type = &#39;&#39;) &#123;\n  res.writeHead(200, &#123; &#39;Content-Type&#39;: `$&#123;type ? type : &#39;text/html&#39;&#125;;charset=utf8` &#125;);\n  res.write(fs.readFileSync(path), &#39;utf-8&#39;);\n  res.end();\n&#125;\n\nconst route = &#123;\n  &#39;/login&#39;(res) &#123;\n    render(res, &#39;./static/login.html&#39;);\n  &#125;,\n  &#39;/home&#39;(res) &#123;\n    render(res, &#39;./static/home.html&#39;);\n  &#125;,\n  &#39;/favicon.ico&#39;(res) &#123;\n    render(res, &#39;./static/favicon.ico&#39;, &#39;image/x-icon&#39;);\n  &#125;,\n  &#39;/404&#39;(res) &#123;\n    res.writeHead(404, &#123; &#39;Content-Type&#39;: &#39;text/html;charset=utf8&#39; &#125;);\n    res.write(fs.readFileSync(&#39;./static/404.html&#39;), &#39;utf-8&#39;);\n    res.end();\n  &#125;,\n&#125;;\n\nmodule.exports = route;\n</code></pre>\n<p><strong>api.js</strong></p>\n<pre><code class=\"js\">function render(res, data, type = &#39;&#39;) &#123;\n  res.writeHead(200, &#123; &#39;Content-Type&#39;: `$&#123;type ? type : &#39;application/json&#39;&#125;;charset=utf8` &#125;);\n  res.write(data);\n  res.end();\n&#125;\n\nconst apiRouter = &#123;\n  &#39;/api/login&#39;(res) &#123;\n    render(res, &#39;&#123; ok: 1 &#125;&#39;);\n  &#125;,\n&#125;;\n\nmodule.exports = apiRouter;\n</code></pre>\n<h2 id=\"2-获取参数\"><a href=\"#2-获取参数\" class=\"headerlink\" title=\"2.获取参数\"></a>2.获取参数</h2><p><strong>api.js</strong></p>\n<pre><code class=\"js\">function render(res, data, type = &#39;&#39;) &#123;\n  res.writeHead(200, &#123; &#39;Content-Type&#39;: `$&#123;type ? type : &#39;application/json&#39;&#125;;charset=utf8` &#125;);\n  res.write(data);\n  res.end();\n&#125;\n\nconst apiRouter = &#123;\n    //get请求\n  &#39;/api/login&#39;(req, res) &#123;\n    const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n    const data = &#123;&#125;;\n    let username = url.searchParams.get(&#39;username&#39;);\n    let password = url.searchParams.get(&#39;password&#39;);\n    if (username === &#39;ds&#39; &amp;&amp; password === &#39;123&#39;) &#123;\n      Object.assign(data, &#123;\n        ok: 1,\n      &#125;);\n    &#125; else &#123;\n      Object.assign(data, &#123;\n        ok: 0,\n      &#125;);\n    &#125;\n    render(res, JSON.stringify(data));\n  &#125;,\n    //post请求\n  &#39;/api/loginpost&#39;(req, res) &#123;\n    const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n    let data = &#39;&#39;;\n      //这里使用最原始的方法获取post请求参数\n      // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中\n    req.on(&#39;data&#39;, chunk =&gt; &#123;\n      data += chunk;\n    &#125;);\n       // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。\n    req.on(&#39;end&#39;, () =&gt; &#123;\n      data = JSON.parse(data);\n      if (data.username === &#39;ds&#39; &amp;&amp; data.password === &#39;123&#39;) &#123;\n        render(res, JSON.stringify(&#123; ok: 1 &#125;));\n      &#125; else &#123;\n        render(res, JSON.stringify(&#123; ok: 0 &#125;));\n      &#125;\n    &#125;);\n  &#125;,\n&#125;;\n\nmodule.exports = apiRouter;\n</code></pre>\n<p><strong>请求.js</strong></p>\n<pre><code class=\"js\"> login.onclick = () =&gt; &#123;\n        //get请求\n        fetch(`/api/login?username=$&#123;username.value&#125;&amp;password=$&#123;password.value&#125;`)\n          .then(res =&gt; res.text())\n          .then(res =&gt; &#123;\n            console.log(res);\n          &#125;);\n      &#125;;\n  loginpost.onclick = () =&gt; &#123;\n    //post请求\n    fetch(`/api/loginpost`, &#123;\n      method: &#39;POST&#39;,\n      body: JSON.stringify(&#123;\n        username: username.value,\n        password: password.value,\n      &#125;),\n      headers: &#123;\n        &#39;Content-Type&#39;: &#39;application/json&#39;,\n      &#125;,\n    &#125;)\n      .then(res =&gt; res.text())\n      .then(res =&gt; &#123;\n        console.log(res);\n      &#125;);\n</code></pre>\n<h2 id=\"3-静态目录\"><a href=\"#3-静态目录\" class=\"headerlink\" title=\"3.静态目录\"></a>3.静态目录</h2><p><strong>server.js</strong></p>\n<pre><code class=\"js\">const http = require(&#39;http&#39;);\n\nconst route = &#123;&#125;;\n\nfunction use(routeObj) &#123;\n  Object.assign(route, routeObj);\n&#125;\n\nfunction start() &#123;\n  http\n    .createServer(async (req, res) =&gt; &#123;\n      const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n      try &#123;\n        route[url.pathname](req, res);\n          //使所有匹配不到的路径走404网页\n      &#125; catch (err) &#123;\n        route[&#39;/404&#39;](req, res);\n      &#125;\n    &#125;)\n    .listen(3000, () =&gt; &#123;\n      console.log(&#39;启动成功&#39;);\n    &#125;);\n&#125;\n\nmodule.exports = &#123;\n  use,\n  start,\n&#125;;\n</code></pre>\n<p><strong>route.js</strong></p>\n<pre><code class=\"js\">const fs = require(&#39;fs&#39;);\nconst path = require(&#39;path&#39;);\n//根据文件后缀名自动获取响应头中content-type\nconst mime = require(&#39;mime&#39;);\n\nfunction render(res, path, type = &#39;&#39;) &#123;\n  res.writeHead(200, &#123; &#39;Content-Type&#39;: `$&#123;type ? type : &#39;text/html&#39;&#125;;charset=utf8` &#125;);\n  res.write(fs.readFileSync(path), &#39;utf-8&#39;);\n  res.end();\n&#125;\n\nconst route = &#123;\n  &#39;/login&#39;(req, res) &#123;\n    render(res, &#39;./static/login.html&#39;);\n  &#125;,\n  &#39;/home&#39;(req, res) &#123;\n    render(res, &#39;./static/home.html&#39;);\n  &#125;,\n  &#39;/404&#39;(req, res) &#123;\n    const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n     /*\n     &lt;link href=&#39;/css/index.css&#39;&gt;&lt;/link&gt;根路径访问，就等于127.0.0.1:3000/css/index.css。\n     这里将项目文件夹F://项目+static+/css/index.css合并成文件路径，如果存在就读取该文件返回\n     */\n    let pathname = path.join(__dirname, &#39;static&#39;, url.pathname);\n    if (readStaticFile(res, pathname)) &#123;\n      return;\n    &#125;\n    res.writeHead(404, &#123; &#39;Content-Type&#39;: &#39;text/html;charset=utf8&#39; &#125;);\n    res.write(fs.readFileSync(&#39;./static/404.html&#39;), &#39;utf-8&#39;);\n    res.end();\n  &#125;,\n&#125;;\n\nfunction readStaticFile(res, pathname) &#123;\n  let houzhui = pathname.split(&#39;.&#39;);\n    //如果存在这些静态资源就用fs的写入方法返回回去，不走404\n  if (fs.existsSync(pathname)) &#123;\n      //mime.getType(css)\n    render(res, pathname, mime.getType(houzhui[houzhui.length - 1]));\n    return true;\n  &#125; else &#123;\n    return false;\n  &#125;\n&#125;\n\nmodule.exports = route;\n</code></pre>\n","categories":["node.js"],"tags":["node.js"]}]