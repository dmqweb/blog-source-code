<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>杜明清的个人博客</title>
        <subtitle>👻欢迎一起交流学习👻</subtitle>
        <icon>https://dmqweb.cn/images/favicon.ico</icon>
        <link>https://dmqweb.cn</link>
        <author>
          <name>dmq</name>
        </author>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 08 May 2024 22:35:51 +0800</pubDate>
        <lastBuildDate>Wed, 08 May 2024 22:35:51 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/05/08/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</guid>
            <title>函数重载</title>
            <link>https://dmqweb.cn/2024/05/08/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</link>
            <category term="JS" scheme="https://dmqweb.cn/categories/JS/" />
            <category term="JS,函数重载" scheme="https://dmqweb.cn/tags/JS-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/" />
            <pubDate>Wed, 08 May 2024 22:35:51 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;概念&#34;&gt;&lt;a href=&#34;#概念&#34; class=&#34;headerlink&#34; title=&#34;概念&#34;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;函数重载是指在编程语言中允许定义多个同名函数，但是他们的参数类型、参数个数或者返回类型不同，编译器或解析器会根据调用时提供的参数类型和个数来确定使用哪个函数&lt;/p&gt;
&lt;h1 id=&#34;作用&#34;&gt;&lt;a href=&#34;#作用&#34; class=&#34;headerlink&#34; title=&#34;作用&#34;&gt;&lt;/a&gt;作用&lt;/h1&gt;&lt;p&gt;函数重载的主要目的就是提高代码的可读性和灵活性，同时避免了为不同功能编写不同的函数名导致的变量命名冲突和混乱。&lt;/p&gt;
&lt;h1 id=&#34;实现函数重载&#34;&gt;&lt;a href=&#34;#实现函数重载&#34; class=&#34;headerlink&#34; title=&#34;实现函数重载&#34;&gt;&lt;/a&gt;实现函数重载&lt;/h1&gt;&lt;h2 id=&#34;ts&#34;&gt;&lt;a href=&#34;#ts&#34; class=&#34;headerlink&#34; title=&#34;ts&#34;&gt;&lt;/a&gt;ts&lt;/h2&gt;&lt;p&gt;ts中进行函数重载其实就是根据型参数组的个数和对变量进行typeof检测，然后根据不同的情况进行分支处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;ts&#34;&gt;// 函数重载的声明
function average(numbers: number[]): number; // 函数签名1：接受数字数组并返回数字
function average(...numbers: number[]): number; // 函数签名2：接受可变数量的数字参数并返回数字
// 函数实现
function average(...args: any[]): number &amp;#123; // 实际函数实现
    let sum = 0;
    if (args.length === 1 &amp;amp;&amp;amp; Array.isArray(args[0])) &amp;#123; // 如果传入的是数组
        const numbers = args[0] as number[]; // 类型断言为数字数组
        for (const num of numbers) &amp;#123;
            sum += num;
        &amp;#125;
        return sum / numbers.length;
    &amp;#125; else if (args.length &amp;gt; 1) &amp;#123; // 如果传入的是多个数字
        for (const num of args) &amp;#123;
            sum += num;
        &amp;#125;
        return sum / args.length;
    &amp;#125; else &amp;#123;
        throw new Error(&amp;#39;Invalid arguments&amp;#39;); // 抛出错误，不支持的参数类型
    &amp;#125;
&amp;#125;

// 调用函数重载
console.log(average([1, 2, 3, 4, 5])); // 输出: 3
console.log(average(1, 2, 3, 4, 5)); // 输出: 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;js&#34;&gt;&lt;a href=&#34;#js&#34; class=&#34;headerlink&#34; title=&#34;js&#34;&gt;&lt;/a&gt;js&lt;/h2&gt;&lt;p&gt;js中也可以通过typeof和形参数组进行函数重载，不过当然还有更好的做法，jQuery作者常用如下实现函数重载（进行重载之前要调用一次函数）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function addMethod(object,name,fn)&amp;#123;
    const old = object[name];
    object[name] = function (...args)&amp;#123;
        if(args.length === fn.length)&amp;#123;
            return fn.apply(this,args);
        &amp;#125;else if(typeof old === &amp;#39;function&amp;#39;)&amp;#123;
            return old.apply(this,args);
        &amp;#125;
    &amp;#125;
&amp;#125;;
const searcher = &amp;#123;&amp;#125;; //将对象中对应属性的重载方法全部存储起来
addMethod(searcher,&amp;#39;getUsers&amp;#39;,()=&amp;gt;&amp;#123;
    console.log(&amp;#39;查询所有用户&amp;#39;);
&amp;#125;);
addMethod(searcher,&amp;#39;getUsers&amp;#39;,(name=&amp;#39;a&amp;#39;)=&amp;gt;&amp;#123; //注意默认参数的形参数量不与计数
    console.log(&amp;#39;按照姓名查询用户&amp;#39;);
&amp;#125;);

searcher.getUsers();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种实现方法就是使用映射：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function createOverload()&amp;#123;
    const fnMap = new Map();
    function overload(...args)&amp;#123;
        const key = args.map((it) =&amp;gt; typeof it).join(&amp;#39;,&amp;#39;);
        const fn = fnMap.get(key);
        if(!fn)&amp;#123;
            throw new TypeError(&amp;#39;没有找到对应的实现&amp;#39;);
        &amp;#125;
        return fn.apply(this,args);
    &amp;#125;
    overload.addImpl = function(...args)&amp;#123;
        const fn = args.pop();
        if(typeof fn !== &amp;#39;function&amp;#39;)&amp;#123;
            throw new TypeError(&amp;#39;最后一个参数必须是函数&amp;#39;)
        &amp;#125;
        const key = args.join(&amp;#39;,&amp;#39;);
        fnMap.set(key,fn);
    &amp;#125;;
    return overload;
&amp;#125;
const getUsers = createOverload();
getUsers.addImpl(()=&amp;gt;&amp;#123;
    console.log(&amp;#39;查询所有用户&amp;#39;);
&amp;#125;);
getUsers.addImpl(&amp;#39;number&amp;#39;,(page,size=10)=&amp;gt;&amp;#123;
    console.log(&amp;#39;按照页码和数量查询用户&amp;#39;);
&amp;#125;);
getUsers.addImpl(&amp;#39;number&amp;#39;,&amp;#39;number&amp;#39;,(page,size=10)=&amp;gt;&amp;#123;
    console.log(&amp;#39;按照页码和数量查询用户&amp;#39;);
&amp;#125;)
getUsers.addImpl(&amp;#39;string&amp;#39;,(name)=&amp;gt;&amp;#123;
    console.log(&amp;#39;按照姓名查询用户&amp;#39;);
&amp;#125;);
getUsers.addImpl(&amp;#39;string&amp;#39;,&amp;#39;string&amp;#39;,()=&amp;gt;&amp;#123;
    console.log(&amp;#39;按照性别查询用户&amp;#39;);
&amp;#125;);
getUsers(&amp;#39;asfsdf&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结一下实现思路，通过createOverload函数调用可以返回一个重载后的函数，createOverload函数中创建了一个map，map中将参数类型和个数与对应的函数相匹配，返回的重载函数在调用时会根据参数的类型去map中寻找对应的函数，通过apply绑定this作用域和参数执行即可。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/05/07/miniwebpack/</guid>
            <title>实现miniwebpack</title>
            <link>https://dmqweb.cn/2024/05/07/miniwebpack/</link>
            <category term="webpack" scheme="https://dmqweb.cn/categories/webpack/" />
            <category term="webpack,miniwebpack" scheme="https://dmqweb.cn/tags/webpack-miniwebpack/" />
            <pubDate>Tue, 07 May 2024 06:16:30 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#前置知识&#34; class=&#34;headerlink&#34; title=&#34;前置知识&#34;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;p&gt;我们都知道webpack是基于babel进行语法转换的，因此我们需要提前了解一些babel的使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@babel&amp;#x2F;parser模块：用于将js代码转为抽象语法树&lt;/li&gt;
&lt;li&gt;@babel&amp;#x2F;traverse模块：用于遍历和操作抽象语法树（处理导入的模块）&lt;/li&gt;
&lt;li&gt;@babel&amp;#x2F;core模块：babel的核心模块，用于将抽象语法树转换为代码信息对象（包含重要的code属性，表示转换后生成的代码）&lt;/li&gt;
&lt;li&gt;@babel&amp;#x2F;preset-env模块：babel中的一个预设，可以在babel.transformFromAst中第三个参数中presets字段传入，可以根据当前环境将代码转成相应的兼容版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;流程图&#34;&gt;&lt;a href=&#34;#流程图&#34; class=&#34;headerlink&#34; title=&#34;流程图&#34;&gt;&lt;/a&gt;流程图&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&#34;/images/Snipaste_2024-05-07_07-23-59.jpg&#34; alt=&#34;miniwebpack&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;开始编码&#34;&gt;&lt;a href=&#34;#开始编码&#34; class=&#34;headerlink&#34; title=&#34;开始编码&#34;&gt;&lt;/a&gt;开始编码&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const fs = require(&amp;quot;fs&amp;quot;);
const path = require(&amp;quot;path&amp;quot;);
// @babel/parser用于将js代码转化为抽象语法树
const parser = require(&amp;quot;@babel/parser&amp;quot;);
// @babel/traverse用于遍历和操作抽象语法树
const traverse = require(&amp;quot;@babel/traverse&amp;quot;).default;
// Babel 的核心功能包含在 @babel/core 模块中
const babel = require(&amp;quot;@babel/core&amp;quot;);
// 1. 分析依赖
function parseModules(file) &amp;#123;
  const entry = getModuleInfo(file);
  const temp = [entry];
  const depsGraph = &amp;#123;&amp;#125;;
  getDeps(temp, entry);
  temp.forEach((moduleInfo) =&amp;gt; &amp;#123; //遍历全部模块信息数组
    depsGraph[moduleInfo.file] = &amp;#123; //映射file路径和code、deps
      deps: moduleInfo.deps,
      code: moduleInfo.code,
    &amp;#125;;
  &amp;#125;);
  return depsGraph;
&amp;#125;
function getDeps(temp, &amp;#123;deps&amp;#125;) &amp;#123;
  Object.keys(deps).forEach((key) =&amp;gt; &amp;#123;
    const child = getModuleInfo(deps[key]);
    temp.push(child);
    getDeps(temp, child);
  &amp;#125;);
&amp;#125;
function getModuleInfo(file) &amp;#123;
  // 读取文件
  const body = fs.readFileSync(file, &amp;quot;utf-8&amp;quot;);
  // 转化为AST
  const ast = parser.parse(body, &amp;#123;sourceType: &amp;quot;module&amp;quot;&amp;#125;);
  const deps = &amp;#123;&amp;#125;;
  traverse(ast, &amp;#123;
    // 获取import导入的模块
    ImportDeclaration(&amp;#123;node&amp;#125;) &amp;#123;
      const dirname = path.dirname(file);
      // 获取标准化路径
      const absPath = &amp;quot;./&amp;quot; + path.join(dirname, node.source.value);
      deps[node.source.value] = absPath;
    &amp;#125;,
  &amp;#125;);
  const &amp;#123;code&amp;#125; = babel.transformFromAst(ast, null, &amp;#123;
    // 使用预设
    presets: [&amp;quot;@babel/preset-env&amp;quot;],
  &amp;#125;);
  const moduleInfo = &amp;#123;file, deps, code&amp;#125;;
  return moduleInfo;
&amp;#125;
// 2. 实现bundle
function bundle(file) &amp;#123;
  //将模块转为引用路径和映射code、deps的对象
  const depsGraph = JSON.stringify(parseModules(file));
  return `(function (graph) &amp;#123;
    function require(file) &amp;#123;
      function absRequire(realPath) &amp;#123;
        return require(graph[file].deps[realPath]);  //递归调用获取返回值
      &amp;#125;
      var exports = &amp;#123;&amp;#125;;   //exports对象，用于存储模块的返回值信息
      (function (require, exports, code) &amp;#123;
        eval(code);   //eval函数用于执行字符串的js代码，传入require，exports和code
      &amp;#125;)(absRequire, exports, graph[file].code);
      return exports;
    &amp;#125;
    require(&amp;#39;$&amp;#123;file&amp;#125;&amp;#39;);
  &amp;#125;)($&amp;#123;depsGraph&amp;#125;);`;
&amp;#125;
const content = bundle(&amp;quot;./src/index.js&amp;quot;);
//将内容写入到输出文件 
fs.writeFileSync(&amp;quot;./dist/bundle.js&amp;quot;, content);
//webpack打包后的js文件就是一个立即执行函数，传入的参数是一个对象，对象的键是模块路径，值是模块函数代码
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/04/30/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</guid>
            <title>深拷贝</title>
            <link>https://dmqweb.cn/2024/04/30/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</link>
            <category term="面试题" scheme="https://dmqweb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" />
            <category term="深拷贝,面试题" scheme="https://dmqweb.cn/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E9%9D%A2%E8%AF%95%E9%A2%98/" />
            <pubDate>Tue, 30 Apr 2024 17:34:25 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;深拷贝&#34;&gt;&lt;a href=&#34;#深拷贝&#34; class=&#34;headerlink&#34; title=&#34;深拷贝&#34;&gt;&lt;/a&gt;深拷贝&lt;/h1&gt;&lt;h2 id=&#34;介绍&#34;&gt;&lt;a href=&#34;#介绍&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;我们知道在javascript中有八种数据类型：其中number，string，undefined，null，boolean，symbol和bigint为基本数据类型，而object为复杂数据类型&lt;/p&gt;
&lt;h2 id=&#34;存储&#34;&gt;&lt;a href=&#34;#存储&#34; class=&#34;headerlink&#34; title=&#34;存储&#34;&gt;&lt;/a&gt;存储&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对于基本数据类型，其值直接存储于栈中。&lt;/li&gt;
&lt;li&gt;对于复杂数据类型，其值存储于堆中，而栈中只存储堆中的地址。这样做的好处有：&lt;ul&gt;
&lt;li&gt;节省内存空间：存储在堆中的对象可以通过栈内的引用被访问和操作，意味着对象可以在不同的上下文中被共享和引用，从而节省内存。&lt;/li&gt;
&lt;li&gt;垃圾回收：堆内存中的对象不再被引用时，垃圾回收机制就会自动进行回收，从而避免了内存泄漏和资源浪费。&lt;/li&gt;
&lt;li&gt;动态分配内存：堆内存允许对象动态的增长和缩小，因此可以根据需要灵活地修改对象的结构和内容，使得js对象可以轻松地扩展以适应不同的应用需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;深拷贝-1&#34;&gt;&lt;a href=&#34;#深拷贝-1&#34; class=&#34;headerlink&#34; title=&#34;深拷贝&#34;&gt;&lt;/a&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;而深拷贝和浅拷贝就是对于复杂数据类型object来说的，当拷贝了对象的一层（即堆的引用）时，就称之为浅拷贝，当拷贝了对象的两层（堆中创建新的对象）时，就称之为深拷贝。&lt;/p&gt;
&lt;h2 id=&#34;实现方案&#34;&gt;&lt;a href=&#34;#实现方案&#34; class=&#34;headerlink&#34; title=&#34;实现方案&#34;&gt;&lt;/a&gt;实现方案&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt;，第一种方法是使用JSON方法，但是这个方法有一些限制：JSON序列化时函数会被转为null，正则表达式会被转为空对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Object.assign(&amp;#123;&amp;#125;,obj)&lt;/code&gt;，第二方法是使用Object.assign()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;递归实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;

```js
function deepCopy(obj, parent = null) &amp;#123;
    // 创建一个新对象
    let result = &amp;#123;&amp;#125;;
    let keys = Object.keys(obj),
        key = null,
        temp = null,
        _parent = parent;
    // 该字段有父级则需要追溯该字段的父级
    while (_parent) &amp;#123;
        // 如果该字段引用了它的父级则为循环引用
        if (_parent.originalParent === obj) &amp;#123;
            // 循环引用直接返回同级的新对象
            return _parent.currentParent;
        &amp;#125;
        _parent = _parent.parent;
    &amp;#125;
    for (let i = 0; i &amp;lt; keys.length; i++) &amp;#123;
        key = keys[i];
        temp = obj[key];
        // 如果字段的值也是一个对象
        if (temp &amp;amp;&amp;amp; typeof temp === &amp;#39;object&amp;#39;) &amp;#123;
            // 递归执行深拷贝 将同级的待拷贝对象与新对象传递给 parent 方便追溯循环引用
            result[key] = DeepCopy(temp, &amp;#123;
                originalParent: obj,
                currentParent: result,
                parent: parent
            &amp;#125;);

        &amp;#125; else &amp;#123;
            result[key] = temp;
        &amp;#125;
    &amp;#125;
    return result;
&amp;#125;
```
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MessageChannel实现深克隆：由于浏览器不能将一个函数正确的复制到另一个线程中，所以不能支持函数的深克隆。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function deepCopy(obj) &amp;#123;
  return new Promise((resolve) =&amp;gt; &amp;#123;
    const &amp;#123;port1, port2&amp;#125; = new MessageChannel();
    port2.onmessage = ev =&amp;gt; resolve(ev.data);
    port1.postMessage(obj);
  &amp;#125;);
&amp;#125;

deepCopy(obj).then((copy) =&amp;gt; &amp;#123;// 异步的
    let copyObj = copy;
    console.log(copyObj, obj)
    console.log(copyObj == obj)
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/04/29/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/</guid>
            <title>前端监控</title>
            <link>https://dmqweb.cn/2024/04/29/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/</link>
            <category term="前端监控" scheme="https://dmqweb.cn/categories/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/" />
            <category term="前端监控" scheme="https://dmqweb.cn/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/" />
            <pubDate>Mon, 29 Apr 2024 08:36:51 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前端监控&#34;&gt;&lt;a href=&#34;#前端监控&#34; class=&#34;headerlink&#34; title=&#34;前端监控&#34;&gt;&lt;/a&gt;前端监控&lt;/h1&gt;&lt;h1 id=&#34;介绍&#34;&gt;&lt;a href=&#34;#介绍&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;为什么要进行前端监控：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面的访问行为，PV、UV、IP、PV点击率、UV点击率、停留时长&lt;/li&gt;
&lt;li&gt;用户的操作行为，模块曝光、&lt;/li&gt;
&lt;li&gt;模块点击&lt;/li&gt;
&lt;li&gt;页面的性能，首屏渲染时间、API请求时间&lt;/li&gt;
&lt;li&gt;异常的监控，JS Error、API异常、业务异常&lt;/li&gt;
&lt;li&gt;业务的监控，成交金额、每日消息数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的前端监控平台：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;百度统计&lt;/li&gt;
&lt;li&gt;阿里云ARMS&lt;/li&gt;
&lt;li&gt;友盟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前端监控的数据有什么作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量数据监控，如：PV、UV、点击率、页面停留时长等&lt;/li&gt;
&lt;li&gt;自定义事件监控，如：曝光事件、滑动事件、请求事件等&lt;/li&gt;
&lt;li&gt;交易指标监控，如：成交额、转化率等&lt;/li&gt;
&lt;li&gt;其他综合分析，如：用户画像分析、流量漏斗、销量预测等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前端监控的三个阶段&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初阶：使用第三方平台，百度、友盟、阿里云ARMS等&lt;/li&gt;
&lt;li&gt;中阶：自研前端监控库，缺乏完整的监控体系&lt;/li&gt;
&lt;li&gt;高阶：自研前端监控平台，具备完整的监控体系&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;百度统计接入&#34;&gt;&lt;a href=&#34;#百度统计接入&#34; class=&#34;headerlink&#34; title=&#34;百度统计接入&#34;&gt;&lt;/a&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90b25namkuYmFpZHUuY29tLw==&#34;&gt;百度统计接入&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;流量分析免费，行为分析需要付费。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;官网创建网站，设置域名和首页&lt;/li&gt;
&lt;li&gt;保证域名公共可读&lt;/li&gt;
&lt;li&gt;复制统计代码，添加到要跟踪的网页中（加入到head标签之前）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;阿里云ARM和友盟分析方案较全，接入方案大致相同，但是当数据量较大时，有一定的成本，所以考虑自建前端统计系统。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候需要考虑自建前端监控系统？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不仅仅需要流量分析，还需要做行为分析&lt;/li&gt;
&lt;li&gt;自建成本小于或等于平台付费&lt;/li&gt;
&lt;li&gt;希望网站监控数据能存到自己数据库中，并且数据隐私化。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;监控平台架构&#34;&gt;&lt;a href=&#34;#监控平台架构&#34; class=&#34;headerlink&#34; title=&#34;监控平台架构&#34;&gt;&lt;/a&gt;监控平台架构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;前端监控平台的分层：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前端监控JSSDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采集&lt;/li&gt;
&lt;li&gt;上报&lt;ul&gt;
&lt;li&gt;默认上报：页面PV、性能等&lt;/li&gt;
&lt;li&gt;手动上报：页面操作行为&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端监控API和大数据仓库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收上报的数据&lt;/li&gt;
&lt;li&gt;数据仓库：MaxCompute&lt;ul&gt;
&lt;li&gt;数据查询&lt;/li&gt;
&lt;li&gt;数据存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端监控数据可视化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志大数据清洗&lt;/li&gt;
&lt;li&gt;大数据回流RDS（非结构化数据 &amp;#x3D;&amp;gt; 结构化数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;监控平台架构说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/images/Snipaste_2024-04-29_08-11-46.jpg&#34; alt=&#34;监控平台架构&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;JS库的开发&#34;&gt;&lt;a href=&#34;#JS库的开发&#34; class=&#34;headerlink&#34; title=&#34;JS库的开发&#34;&gt;&lt;/a&gt;JS库的开发&lt;/h2&gt;&lt;h4 id=&#34;JS-SDK&#34;&gt;&lt;a href=&#34;#JS-SDK&#34; class=&#34;headerlink&#34; title=&#34;JS  SDK&#34;&gt;&lt;/a&gt;JS  SDK&lt;/h4&gt;&lt;p&gt;monitor.js：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function collect()&amp;#123;
    console.log(&amp;#39;collect&amp;#39;);
&amp;#125;
function upload()&amp;#123;
    console.log(&amp;#39;upload&amp;#39;);
&amp;#125;
window.testMonitor = &amp;#123;
    collect,
    upload,
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上传到服务器，在需要监控的页面引入脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、直接引入脚本：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接使用script标签引入在线地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、异步加载（确保脚本加载完成后再使用api）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;script&amp;gt;
(function()
    const script = document.createElement(&amp;#39;script&amp;#39;);
    script.src = &amp;#39;https://imooc.youbaobao.xyz/imooc-cli-monitor.js&amp;#39;
    const body = document.body;
    body.insertBefore(script,body.firstChild);
    script.onload = function()&amp;#123;
    var event = new CustomEvent(&amp;#39;onMonitorScriptLoad&amp;#39;);
    window.dispatchEvent(event);
)()
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    window.addEventListener(&amp;#39;onMonitorScriptLoad&amp;#39;,function()&amp;#123;
    window.testMonitor.collect();
    window.testMonitor.upload();
&amp;#125;):
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;PV埋点&#34;&gt;&lt;a href=&#34;#PV埋点&#34; class=&#34;headerlink&#34; title=&#34;PV埋点&#34;&gt;&lt;/a&gt;PV埋点&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;一、分包便于代码书写和维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设将项目分为：index.js、collect.js和upload.js三个js文件，分别用于整合、收集和上报。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、设置页面基本信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在meta标签中设置变量，假设为：test-app-id，在body标签中设置test-page-id，此变量用于区分不同的站点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、collect.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; upload &amp;#125; from &amp;#39;./upload&amp;#39;;
//自定义一些钩子函数
let beforeCreateParams;
let beforeUpload;
let afterUpload;
let onError=(err)=&amp;gt;&amp;#123;
    console.error(err);
&amp;#125;;

export function collect()&amp;#123;
    console.log(&amp;#39;收集开始...&amp;#39;);
&amp;#125;
// 采集信息
function collection(customData,eventType)&amp;#123;
    let appId , pageId , timeStamp , ua;
    beforeCreateParams &amp;amp;&amp;amp; beforeCreateParams();
    const metaList = document.getElementsByTagName(&amp;#39;meta&amp;#39;)
    for (let i=0;i&amp;lt; metaList.length;i++)&amp;#123;
        const meta = metaList[i];
        console.log(meta.getAttribute(&amp;#39;test-app-id&amp;#39;));
        if (meta.getAttribute(&amp;#39;test-app-id&amp;#39;))&amp;#123;
            appId = meta.getAttribute(&amp;#39;test-app-id&amp;#39;);
         &amp;#125;
       &amp;#125;
    const body = document.body;
    pageId = body.getAttribute(&amp;#39;test-page-id&amp;#39;);
    if (!appId || !pageId) return;
    timeStamp = new Date().getTime();
    ua = window.navigator.userAgent;
    console.log(appId,pageId,timeStamp,ua);
    let data = `appId=$&amp;#123;appId&amp;#125;&amp;amp;pageId=$&amp;#123;pageId&amp;#125;&amp;amp;timeStamp=$&amp;#123;timeStamp&amp;#125;&amp;amp;ua=$&amp;#123;ua&amp;#125;`;
    if(beforeUpload)&amp;#123;
        data = beforeUpload(data); //允许定制数据
    &amp;#125;
    //日志上报
    // upload(&amp;#123; appId,pageId,timeStamp,ua &amp;#125;)  不常用
    let url , uploadData;
    try&amp;#123;
        data = &amp;#123;...customData,...data&amp;#125;
        const ret = upload(data,&amp;#123;eventType&amp;#125;)
        url = ret.url;
        uploadData = ret.data;
    &amp;#125;catch(e)&amp;#123;
        onError(e);
    &amp;#125;finally&amp;#123;
        afterUpload &amp;amp;&amp;amp; afterUpload(url,uploadData);
    &amp;#125;
    
&amp;#125;
//发送PV日志
export function sendPV()&amp;#123;
    collection(&amp;#123;&amp;#125;,&amp;#39;PV&amp;#39;)
&amp;#125;
// 上报曝光埋点
export function sendExp(data=&amp;#123;&amp;#125;)&amp;#123;
    collection(data,&amp;#39;EXP&amp;#39;)
&amp;#125;
//注册钩子函数
export function registerBeforeCreateParams(fn)&amp;#123;
    beforeCreateParams = fn;
&amp;#125;
export function registerBeforeUpload(fn)&amp;#123;
    beforeUpload = fn;
&amp;#125;
export function registerAfterUpload(fn)&amp;#123;
    afterUpload = fn;
&amp;#125;
export function registerOnError(fn)&amp;#123;
    onError = fn;
&amp;#125;
export default &amp;#123; &amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;四、upload.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;export function upload(data) &amp;#123;
    const img = new Image(); //利用image标签跨域特性
    const &amp;#123; eventType = &amp;quot;PV&amp;quot; &amp;#125; = options;
    const params = encodeURIComponent(data) + &amp;#39;&amp;amp;eventType=&amp;#39; + eventType;
    const src = &amp;#39;http://dmqtest.com?data=&amp;#39; + params ;
    console.log(params,src,eventType);
    img.src = src;
    img = null; //注意内存释放
    return &amp;#123;
        url: src,
        data: &amp;#123;
            params,
        &amp;#125;
    &amp;#125;
&amp;#125;
export default upload;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;五、index.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;#123; sendPV , registerBeforeCreateParams,registerBeforeUpload,registerAfterUpload &amp;#125; from &amp;#39;./collect&amp;#39;;
import &amp;#123; upload &amp;#125; from &amp;#39;./upload&amp;#39;;
window.testMonitor = &amp;#123;
    upload,
    sendPV,
    registerBeforeCreateParams,
    registerBeforeUpload,
    registerAfterUpload,
    registerOnError
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;六、index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; test-app-id=&amp;quot;app123456&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
    &amp;lt;script src=&amp;#39;https://dmqtest.com/index.js&amp;#39;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;body test-page-id=&amp;quot;page123456&amp;quot;&amp;gt;
    &amp;lt;script&amp;gt;
        window.onload = function()&amp;#123;
            window.testMonitor.registerBeforeCreateParams(()=&amp;gt;&amp;#123;
                console.log(&amp;#39;创建之前&amp;#39;)
            &amp;#125;);
            window.testMonitor.registerBrforeUpload((params)=&amp;gt;&amp;#123;
                return params + &amp;#39;&amp;amp;custom=1&amp;#39;; //添加自定义数据
            &amp;#125;)
            window.testMonitor.registerAfterUpload((url,data)=&amp;gt;&amp;#123;
                
            &amp;#125;)
            window.testMonitor.sendPV();
        &amp;#125;
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;曝光埋点&#34;&gt;&lt;a href=&#34;#曝光埋点&#34; class=&#34;headerlink&#34; title=&#34;曝光埋点&#34;&gt;&lt;/a&gt;曝光埋点&lt;/h4&gt;&lt;p&gt;曝光埋点记录元素由不可变到可变的过程，需要浏览器IntersectionObserver这个API的支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器5种Observer：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MutationObserver（用于监听DOM树的变化，一般为属性、子节点的增删改）&lt;/li&gt;
&lt;li&gt;IntersectionObserver（用于监听一个元素和可视区域相交部分的比列，然后在可视比列到达某一阈值的时候触发回调）&lt;/li&gt;
&lt;li&gt;PerformanceObserver（用于检测性能度量事件，在浏览器的性能事件轴记录下一个新的performance entries的时候将会被通知）&lt;/li&gt;
&lt;li&gt;ResizeObserver（用于监听DOM的变化，一般为节点的出现和隐藏，节点大小的变化）&lt;/li&gt;
&lt;li&gt;ReportingObserver（用于监听过时的api、浏览器的一些干预行为的预告）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;IntersectionObserver：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;observe：开始监听一个目标元素&lt;/p&gt;
&lt;p&gt;语法：IntersectionObserver.disconnect();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;disconnect：停止监听&lt;/p&gt;
&lt;p&gt;语法：IntersectionObserver.observe(targetElement);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;takeRecords:返回所有观察目标的IntersectionObserverEntry对象数组。&lt;/p&gt;
&lt;p&gt;语法：intersectionObserverEntries &amp;#x3D; intersectionObserver.takeRecords();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;unobserve:使IntersectionObserver停止监听特定目标元素&lt;/p&gt;
&lt;p&gt;语法：IntersectionObserver.unobserve(targetElement);&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;配置项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;targetElement：目标DOM&lt;/li&gt;
&lt;li&gt;root：指定根目录，也就就是当目标元素显示在这个元素中时会触发监控回调&lt;/li&gt;
&lt;li&gt;rootMargin：类似于css的margin，设定root元素的边框区域。&lt;/li&gt;
&lt;li&gt;threhold：阈值，决定了什么时候触发回调函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;返回参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tIme:可见性发生变化的时间，是一个高精度时间戳，单位为毫秒&lt;/li&gt;
&lt;li&gt;rootBounds:是在根元素矩形区域的信息&lt;/li&gt;
&lt;li&gt;intersectionRatio:目标元素的可见比例&lt;/li&gt;
&lt;li&gt;intersectionRect:目标元素与根元素交叉区域的信息&lt;/li&gt;
&lt;li&gt;isIntersecting:判断元素是否符合options中的可见条件&lt;/li&gt;
&lt;li&gt;boundingClientRect:目标元素的矩形区域的信息&lt;/li&gt;
&lt;li&gt;target:被观察的目标元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;upload.js文件中添加：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// ....省略
// 上报曝光埋点
export function sendExp(data=&amp;#123;&amp;#125;)&amp;#123;
    collection(data,&amp;#39;EXP&amp;#39;)
&amp;#125;
// 最后在index.js中暴露出去。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;collect.js文件中添加：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//....省略
export function collectAppear()&amp;#123;
    const appearEvent = new CustomEvent(&amp;#39;onAppear&amp;#39;);
    const disappearEvent = new CustomEvent(&amp;#39;onDisappear&amp;#39;);
    let ob;
    if(window.testMonitorObserver)&amp;#123;
        ob = window.testMonitorObserver;
    &amp;#125;else&amp;#123;
        ob = new IntersectionObserver(function(e)&amp;#123;
        e.forEach(item=&amp;gt;&amp;#123;
            if(item.intersectionRatio &amp;gt; 0)&amp;#123;
                console.log(item.target.className + &amp;#39;appear&amp;#39;);
                item.target.dispatchEvent(appearEvent);
            &amp;#125;else&amp;#123;
                console.log(item.target.className + &amp;#39;disappear&amp;#39;);
                item.target.dispatchEvent(disappearEvent);
            &amp;#125;
        &amp;#125;)
    &amp;#125;);
    &amp;#125;
    let obList = [];
    const appear = document.querySelectorAll(&amp;#39;[appear]&amp;#39;);
    for(let i=0;i&amp;lt;appear.length;i++)&amp;#123;
        if(obList.includes(appear[i]))&amp;#123;
            ob.observe(appear[i]);
            obList.push(appear[i]);
        &amp;#125;
    &amp;#125;
    window.testMonitorObserver = ob; //存起来防止重复
    window.monitorObserverList = obList;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;index.js中使用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//...省略
// import引入collectAppear函数。
window.onload = function()&amp;#123;
    collectAppear();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;点击埋点&#34;&gt;&lt;a href=&#34;#点击埋点&#34; class=&#34;headerlink&#34; title=&#34;点击埋点&#34;&gt;&lt;/a&gt;&lt;strong&gt;点击埋点&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;collect.js中添加：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//...省略
//上报点击埋点
export function sendClick(data=&amp;#123;&amp;#125;)&amp;#123;
    collection(data,&amp;#39;CLICK&amp;#39;)
&amp;#125;
//暴露出去，index.js导入该方法并暴露出去。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义埋点&#34;&gt;&lt;a href=&#34;#自定义埋点&#34; class=&#34;headerlink&#34; title=&#34;自定义埋点&#34;&gt;&lt;/a&gt;自定义埋点&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;collect.js中添加：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自定义埋点行为就直接在内部添加CUSTOM对应的处理逻辑，可以使用其他的Observer实现更多功能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//...省略
//上报自定义埋点
export function sendCustom(data=&amp;#123;&amp;#125;)&amp;#123;
    collection(data,&amp;#39;CUSTOM&amp;#39;)
&amp;#125;
//暴露出去，index.js导入该方法并暴露出去。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;大数据平台开发&#34;&gt;&lt;a href=&#34;#大数据平台开发&#34; class=&#34;headerlink&#34; title=&#34;大数据平台开发&#34;&gt;&lt;/a&gt;大数据平台开发&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vemgvbWF4Y29tcHV0ZS8jOn46dGV4dD0lRTQlQkElOTElRTUlOEUlOUYlRTclOTQlOUYlRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUUlRTglQUUlQTElRTclQUUlOTclRTYlOUMlOEQlRTUlOEElQTEsJTI4TWF4Q29tcHV0ZSUyOSVFNiU5OCVBRiVFNCVCOCU4MCVFNyVBNyU4RCVFNSVCRiVBQiVFOSU4MCU5RiVFMyU4MCU4MSVFNSVBRSU4QyVFNSU4NSVBOCVFNiU4OSU5OCVFNyVBRSVBMSVFNyU5QSU4NFRCJTJGUEIlRTclQkElQTclRTYlOTUlQjAlRTYlOEQlQUUlRTQlQkIlOTMlRTUlQkElOTMlRTglQTclQTMlRTUlODYlQjMlRTYlOTYlQjklRTYlQTElODglRTMlODAlODIlMjBNYXhDb21wdXRlJUU1JTkwJTkxJUU3JTk0JUE4JUU2JTg4JUI3JUU2JThGJTkwJUU0JUJFJTlCJUU0JUJBJTg2JUU1JUFFJThDJUU1JTk2JTg0JUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU1JUFGJUJDJUU1JTg1JUE1JUU2JTk2JUI5JUU2JUExJTg4JUU0JUJCJUE1JUU1JThGJThBJUU1JUE0JTlBJUU3JUE3JThEJUU3JUJCJThGJUU1JTg1JUI4JUU3JTlBJTg0JUU1JTg4JTg2JUU1JUI4JTgzJUU1JUJDJThGJUU4JUFFJUExJUU3JUFFJTk3JUU2JUE4JUExJUU1JTlFJThCJUVGJUJDJThDJUU4JTgzJUJEJUU1JUE0JTlGJUU2JTlCJUI0JUU1JUJGJUFCJUU5JTgwJTlGJUU3JTlBJTg0JUU4JUE3JUEzJUU1JTg2JUIzJUU3JTk0JUE4JUU2JTg4JUI3JUU2JUI1JUI3JUU5JTg3JThGJUU2JTk1JUIwJUU2JThEJUFFJUU4JUFFJUExJUU3JUFFJTk3JUU5JTk3JUFFJUU5JUEyJTk4JUVGJUJDJThDJUU2JTlDJTg5JUU2JTk1JTg4JUU5JTk5JThEJUU0JUJEJThFJUU0JUJDJTgxJUU0JUI4JTlBJUU2JTg4JTkwJUU2JTlDJUFDJUVGJUJDJThDJUU1JUI5JUI2JUU0JUJGJTlEJUU5JTlBJTlDJUU2JTk1JUIwJUU2JThEJUFFJUU1JUFFJTg5JUU1JTg1JUE4JUUzJTgwJTgy&#34;&gt;MaxCompute阿里云原生大数据计算服务&lt;/span&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MaxCompute是基于数据分析场景的企业级SaaS模式云数据仓库，以Serverless架构提供快速、全托管的在线数据仓库服务，消除了传统数据平台在资源扩展性和弹性方面的限制，最小化用户运维投入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用MaxCompute创建数据库，在数据开发页面创建表进行记录前端监控数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用py脚本对接（暂时没有js包），需要安装python和pip（包管理工具）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装pyodps：&lt;code&gt;pip install pyodps&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;connect.py文件中写入示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from odps import ODPS;

odps = ODPS(&amp;#39;LTAI5tBDj3HajwRVhc6me5KR&amp;#39;,&amp;#39;DJqWAI1IWUBZnZGE#FKDSFJDEJLet&amp;#39;,&amp;#39;test_monitor&amp;#39;,endpoint=&amp;#39;https://service-cn-hangzhou.odps.aliyun-inc.com&amp;#39;)

result = odps.executexecute_sql(&amp;#39;select * from test_monitor where datetime=&amp;quot;20240325&amp;quot;&amp;#39;)

with result.open_reader() as reader:
    for record in reader:
        print(record[0],record[1])
# 打印表名
for table in odps.list_tables():
    print(table)
data = [
    [&amp;#39;appid123&amp;#39;,&amp;#39;pageid123&amp;#39;,&amp;#39;123456&amp;#39;,&amp;#39;ua123&amp;#39;,&amp;#39;http://www.baidu.com&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;20240325&amp;#39;,&amp;#39;202403&amp;#39;]
]
# 写入数据
odps.write_table(&amp;#39;test_table&amp;#39;, data)
# ....等等后续操作
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;前端监控平台可视化架构图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/images/Snipaste_2024-04-30_15-14-09.jpg&#34; alt=&#34;前端监控流程架构&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/04/16/%E4%B8%89%E6%96%B9%E5%8C%85/</guid>
            <title>三方库</title>
            <link>https://dmqweb.cn/2024/04/16/%E4%B8%89%E6%96%B9%E5%8C%85/</link>
            <category term="三方库" scheme="https://dmqweb.cn/categories/%E4%B8%89%E6%96%B9%E5%BA%93/" />
            <category term="三方库" scheme="https://dmqweb.cn/tags/%E4%B8%89%E6%96%B9%E5%BA%93/" />
            <pubDate>Tue, 16 Apr 2024 16:33:16 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;脚手架开发&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#脚手架开发&#34;&gt;#&lt;/a&gt; &lt;strong&gt;脚手架开发&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;常见工具包&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29tbWFuZGVy&#34;&gt;Commander&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;提供一个连贯的  &lt;code&gt;API&lt;/code&gt; ，用于定义  &lt;code&gt;CLI&lt;/code&gt;  应用程序的各个方面，如命令、选项、别名和帮助。简化了命令行应用程序的创建。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UveWFyZ3M=&#34;&gt;yargs&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;脚手架开发框架，通过解析参数和生成优雅的用户界面来帮助您构建交互式命令行工具。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbGVybmE=&#34;&gt;lerna&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;多 package 管理&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW5xdWlyZXI=&#34;&gt;Inquirer&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一个易于嵌入且美观的  &lt;code&gt;Node.js&lt;/code&gt;  命令行界面。 提供了很棒的查询会话流程。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2hhbGs=&#34;&gt;Chalk&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Chalk&lt;/code&gt;  是一个非常简单的库，创建它的目的很简单 —— 给你的终端字符串添加样式。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29sb3Jz&#34;&gt;colors&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;打印 &lt;code&gt;不同颜色的log信息&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb3Jh&#34;&gt;ora&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;命令行 &lt;code&gt;中高级的&lt;/code&gt; 、 &lt;code&gt;功能丰富的高可定制化加载动画&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xpLXNwaW5uZXI=&#34;&gt;cli-spinner&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;命令行中 &lt;code&gt;轻量的符号加载动画&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnBtbG9n&#34;&gt;npmlog&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;执行 npm 的日志记录。它支持 &lt;code&gt;自定义级别和彩色输出&lt;/code&gt; 。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW1wb3J0LWxvY2Fs&#34;&gt;import-local&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;当与全局冲突的时候，比如全局和本地都有这个脚手架时可以使用， &lt;code&gt;判断使用的是否是本地版本&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmluZHVw&#34;&gt;findup&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;向上查找指定文件&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGF0aC1leGlzdHM=&#34;&gt;path-exists&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;判断文件是否存在&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVidWc=&#34;&gt;Debug&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一个很小的  &lt;code&gt;JavaScript&lt;/code&gt;  调试实用程序。 只需将一个函数的名称传递给模块，它就会返回一个经过修饰的  &lt;code&gt;console.error&lt;/code&gt;  版本，以便你将调试语句传递给该模块&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZnMtZXh0cmE=&#34;&gt;fs-extra&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;fs 模块的扩展，支持更多文件操作功能&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2VtdmVy&#34;&gt;semver&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;版本比对工具&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmlnbGV0&#34;&gt;figlet&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;输出一些独特的大型 &lt;code&gt;ASCII文本横幅&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdXNlci1ob21l&#34;&gt;user-home&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;获取 &lt;code&gt;用户主目录&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZG90ZW52&#34;&gt;dotenv&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;获取 &lt;code&gt;环境变量&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvcm9vdC1jaGVjaw==&#34;&gt;root-check&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;检查是否是 &lt;code&gt;管理员权限启动并自动降级&lt;/code&gt; ，防止后续因普通权限导致无法使用。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGtnLWRpcg==&#34;&gt;pkg-dir&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;从某个目录开始向上查找，直到找到存在 &lt;code&gt;package.json&lt;/code&gt;  的目录，并返回该目录。如果未找到则返回 null&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWluaW1pc3Q=&#34;&gt;minimist&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用来 &lt;code&gt;解析命令行参数和选项的库&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnBtaW5zdGFsbA==&#34;&gt;npminstall&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;安装npm上的包&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZG93bmxvYWQtZ2l0LXJlcG8=&#34;&gt;download-git-repo&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;安装git仓库中的包&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWpz&#34;&gt;ejs&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;xml模板数据动态渲染&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2xvYg==&#34;&gt;glob&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;根据 &lt;code&gt;文件路径进行遍历和匹配文件&lt;/code&gt; ，拿到文件的内容。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;底层原理包&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;readline（node 内置库）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;命令行的输入输出&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;events（node 内置库）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;事件驱动&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3RyZWFt&#34;&gt;stream&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;输入输出流&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYW5zaS1lc2NhcGVz&#34;&gt;ansi-escapes&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;自定义 &lt;code&gt;命令行文字样式&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvcnhqcw==&#34;&gt;rxjs&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;处理异步事件流&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYnVzYm95&#34;&gt;busboy&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;多文件上传底层库&lt;/code&gt; ，尤其用于流式文件上传。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWNvbXBvbmVudHM=&#34;&gt;styled-components&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;css-in-js 理论工具，在 &lt;code&gt;js中书写css样式&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWpzeA==&#34;&gt;styled-jsx&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;css-in-js 理论工具，在 &lt;code&gt;js中书写css样式&lt;/code&gt; （ts 支持不友好）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZW1vdGlvbg==&#34;&gt;emotion&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;css-in-js 理论工具，在 &lt;code&gt;js中书写css样式&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3Qtcm91dGVyLWRvbQ==&#34;&gt;react-router-dom&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;react 在 dom 环境下的 &lt;code&gt;路由工具&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;vue&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vue&#34;&gt;#&lt;/a&gt; &lt;strong&gt;Vue&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQG53c2VlL2NvcmU=&#34;&gt;https://www.npmjs.com/package/@nwsee/core&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;vue 项目插件，用于页面性能监控&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;react&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#react&#34;&gt;#&lt;/a&gt; &lt;strong&gt;React&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGV4Y2FsaWRyYXcvZXhjYWxpZHJhdw==&#34;&gt;excalidraw&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt; &lt;code&gt;画板、流程图和思维导图&lt;/code&gt; 等&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZDM=&#34;&gt;d3&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;可视化数据图表库&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW1tZXI=&#34;&gt;immer&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;改变了 react &lt;code&gt;设置state状态的方式&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xhc3NuYW1lcw==&#34;&gt;classnames&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;有条件地将  &lt;code&gt;classNames 连接&lt;/code&gt; 在一起&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYWhvb2tz&#34;&gt;ahooks&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;国内常用的 &lt;code&gt;react-hooks函数集&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;nodejs&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nodejs&#34;&gt;#&lt;/a&gt; &lt;strong&gt;Node.js&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXhwcmVzcw==&#34;&gt;Express&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;轻量级 web 框架&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGhhcGkvaGFwaQ==&#34;&gt;Hapi&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;以最小的开销和完全开箱急用的功能构建强大的、拓展性强的应用程序&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2FpbHM=&#34;&gt;Sails&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;最流行的 Node.js 的 MVC 框架&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cua29hanMubmV0Lw==&#34;&gt;Koa&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;下一代 web 开发框架&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZnMtZXh0cmE=&#34;&gt;Fs-extra&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;fs -extra &lt;code&gt;包含了&lt;/code&gt;  Node.js &lt;code&gt; &lt;/code&gt; fs &lt;code&gt;包中没有包含的方法，比如&lt;/code&gt;  copy () &lt;code&gt;, &lt;/code&gt; remove() &lt;code&gt;, &lt;/code&gt; mkdirs()&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZS1jYWNoZQ==&#34;&gt;Node-cache&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;一个简单的缓存模块，具有设置，获取和删除方法的功能，类似于&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tZW1jYWNoZWQub3JnLw==&#34;&gt; memcached&lt;/span&gt;。 key 值可以具有一个超时设置（ttl），在此时间之后它们将过期并从缓存中删除。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2hhcnA=&#34;&gt;sharp&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt; &lt;code&gt;node图片处理&lt;/code&gt; 解决方案&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9hZHRlc3Q=&#34;&gt;Loadtest&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;node.js &lt;code&gt;压力测试工具&lt;/code&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;css&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#css&#34;&gt;#&lt;/a&gt; &lt;strong&gt;css&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGFpbHdpbmRjc3M=&#34;&gt;Tailwind&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;原子化 css&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWNvbXBvbmVudHM=&#34;&gt;Styled-components&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;css-in-js，js 中书写 css&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;日志&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#日志&#34;&gt;#&lt;/a&gt; &lt;strong&gt;日志&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9yZ2Fu&#34;&gt;Morgan&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;具体来说，它是一个  &lt;code&gt;HTTP&lt;/code&gt;  请求记录器，存储  &lt;code&gt;HTTP&lt;/code&gt;  请求，并为你提供有关应用程序如何使用以及可能存在潜在错误的简要信息。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2luc3Rvbg==&#34;&gt;Winston&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一个几乎所有内容的日志记录器，支持多种传输方式。它存储的时间比  &lt;code&gt;Morgan&lt;/code&gt;  长，它也有一个更大的维护者社区和更多的下载。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;数据库&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库&#34;&gt;#&lt;/a&gt; &lt;strong&gt;数据库&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9uZ29vc2U=&#34;&gt;Mongoose&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt; &lt;code&gt;Mongoose&lt;/code&gt;  是一个  &lt;code&gt;MongoDB&lt;/code&gt;  对象建模工具，设计用于在异步环境中工作。 &lt;code&gt;Mongoose&lt;/code&gt;  支持  &lt;code&gt;Promise&lt;/code&gt;  和回调。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2VxdWVsaXpl&#34;&gt;Sequelize&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Sequelize&lt;/code&gt;  是一个基于  &lt;code&gt;Promise&lt;/code&gt;  的  &lt;code&gt;Node.js&lt;/code&gt;   &lt;code&gt;ORM&lt;/code&gt;  工具，适用于  &lt;code&gt;Postgres&lt;/code&gt; 、MySQL、MariaDB、SQLite 和 Microsoft SQL Server。它具有可靠的事务支持、关系、即时和延迟加载、读取复制等特性。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;授权&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#授权&#34;&gt;#&lt;/a&gt; &lt;strong&gt;授权&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGFzc3BvcnQ=&#34;&gt;Passport&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt; &lt;code&gt;Passport&lt;/code&gt;  的目的是通过一组可扩展的插件 (称为策略) 对请求进行身份验证。向 &lt;code&gt;Passport&lt;/code&gt;  提供一个身份验证请求， &lt;code&gt;Passport&lt;/code&gt;  提供钩子来控制身份验证成功或失败时发生的操作。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmNyeXB0&#34;&gt;Bcrypt&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;它是可以帮助你生成哈希密码的库。 &lt;code&gt;Bcrypt&lt;/code&gt;  是由  &lt;code&gt;Niels Provos&lt;/code&gt;  和  &lt;code&gt;David Mazieres&lt;/code&gt;  基于  &lt;code&gt;Blowfish cipher&lt;/code&gt;  设计的密码哈希函数，并于 1999 年在 USENIX 上展出。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNvbndlYnRva2Vu&#34;&gt;JSONWebToken&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;JSON Web&lt;/code&gt;  令牌 (JWT) 是一种开放的、行业标准的  &lt;code&gt;RFC 7519&lt;/code&gt;  方法，用于在双方之间安全地表示声明。这个包允许你解码、验证和生成 JWT。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;静态网站生成&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#静态网站生成&#34;&gt;#&lt;/a&gt; &lt;strong&gt;静态网站生成&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2F0c2J5&#34;&gt;Gatsby&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;一个现代的网站生成器，可以创建快速，高质量，动态的  &lt;code&gt;React&lt;/code&gt;  应用程序，从博客到电子商务网站再到用户仪表板。具有很棒的插件生态系统和模板。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbmV4dA==&#34;&gt;NextJS&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;NextJS&lt;/code&gt;  首先支持服务器渲染以及静态生成的内容。 你还可以将  &lt;code&gt;serverless&lt;/code&gt;  功能定义为  &lt;code&gt;API&lt;/code&gt;  端点。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnV4dA==&#34;&gt;NuxtJS&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;在  &lt;code&gt;Vue&lt;/code&gt;  的生态系统中， &lt;code&gt;NuxtJS&lt;/code&gt;  基本上是  &lt;code&gt;NextJS&lt;/code&gt;  的替代品。 &lt;code&gt;NuxtJS&lt;/code&gt;  的目标是让  &lt;code&gt;web&lt;/code&gt;  开发功能强大，并且让开发者具有良好的开发意识。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;模板语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#模板语法&#34;&gt;#&lt;/a&gt; &lt;strong&gt;模板语法&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXVzdGFjaGU=&#34;&gt;Mustache&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt; &lt;code&gt;Mustache&lt;/code&gt;  是一种无逻辑的模板语法。它可以用于  &lt;code&gt;HTML&lt;/code&gt; ，配置文件，源代码等任何东西。它的工作原理是使用 hash 或对象中提供的值在模板中展开标记。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaGFuZGxlYmFycw==&#34;&gt;Handlebars&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;使用模板和输入对象生成  &lt;code&gt;HTML&lt;/code&gt;  或其他文本格式。 &lt;code&gt;Handlebars&lt;/code&gt;  模板看起来像一个嵌入了把手表达式的正则文本。 &lt;code&gt;Handlebars&lt;/code&gt;  很大程度上与  &lt;code&gt;Mustache&lt;/code&gt;  模板兼容。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWpz&#34;&gt;EJS&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;EJS&lt;/code&gt;  是一种简单的模板语言，可让你使用简单的语法，快速的执行和简单的调试  &lt;code&gt;JavaScript&lt;/code&gt;  来生成  &lt;code&gt;HTML&lt;/code&gt;  标记。  &lt;code&gt;EJS&lt;/code&gt;  拥有大量的活跃用户社区，并且该库正在积极开发中。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;mock数据&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mock数据&#34;&gt;#&lt;/a&gt; &lt;strong&gt;mock 数据&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdXVpZA==&#34;&gt;Uuid&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;方便而且体积小的包，可以快速、轻松地生成更复杂的通用惟一标识符 (UUIDs)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFrZXI=&#34;&gt;Faker&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;实用的  &lt;code&gt;npm&lt;/code&gt;  包，用于在浏览器和  &lt;code&gt;Node.js&lt;/code&gt;  中制造大量假数据。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNvbi1zZXJ2ZXI=&#34;&gt;jsonServer&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;mock 开发服务器数据&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbmFub2lk&#34;&gt;nanoid&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;字符串 ID 生成器&lt;/code&gt; ，没有其余依赖。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;表单和邮件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#表单和邮件&#34;&gt;#&lt;/a&gt; &lt;strong&gt;表单和邮件&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdmFsaWRhdG9y&#34;&gt;Validator&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;便捷的字符串验证器，使程序更加健壮的库。许多有用方法，例如  &lt;code&gt;isEmail()&lt;/code&gt; ，  &lt;code&gt;isCreditCard()&lt;/code&gt; ， &lt;code&gt;isDate()&lt;/code&gt;  和  &lt;code&gt;isURL()&lt;/code&gt; 。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZm9ybWlr&#34;&gt;Formik&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Formik&lt;/code&gt;  是  &lt;code&gt;React&lt;/code&gt;  和  &lt;code&gt;React Native&lt;/code&gt;  的一个流行开源表单库。它具有易于使用、声明性和适应性的特点。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXVsdGVy&#34;&gt;Multer&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Multer&lt;/code&gt;  是用于  &lt;code&gt;multipart/form-data&lt;/code&gt;  数据格式的  &lt;code&gt;Node.js&lt;/code&gt;  中间件，主要用于上传文件。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZW1haWxlcg==&#34;&gt;Nodemailer&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Nodemailer&lt;/code&gt;  是  &lt;code&gt;Node.js&lt;/code&gt;  应用程序的一个模块，允许轻松发送电子邮件。这个项目从 2010 年就开始了，现在它是大多数  &lt;code&gt;Node.js&lt;/code&gt;  用户默认使用的解决方案。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;测试&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#测试&#34;&gt;#&lt;/a&gt; &lt;strong&gt;测试&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvamVzdA==&#34;&gt;Jest&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt; &lt;code&gt;Jest&lt;/code&gt;  是一个令人愉快的  &lt;code&gt;JavaScript&lt;/code&gt;  测试框架，专注于简洁明快。它允许你使用易于使用、熟悉且功能丰富的  &lt;code&gt;API&lt;/code&gt;  编写测试，从而快速获得结果。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9jaGE=&#34;&gt;Mocha&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Mocha&lt;/code&gt;  是一个  &lt;code&gt;JavaScript&lt;/code&gt;  测试框架，使得异步测试简单而有趣。 &lt;code&gt;Mocha&lt;/code&gt;  测试是串行运行的，在将未捕获的异常映射到正确的测试用例的同时，允许进行灵活和准确的报告。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;代码规范&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#代码规范&#34;&gt;#&lt;/a&gt; &lt;strong&gt;代码规范&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXNsaW50&#34;&gt;ESLint&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt; &lt;code&gt;ESLint&lt;/code&gt;  是用于识别和报告  &lt;code&gt;ECMAScript / JavaScript&lt;/code&gt;  代码中的书写方式的工具。  &lt;code&gt;ESLint&lt;/code&gt;  是完全插件化的，每个规则都是一个插件，你可以在运行时添加更多内容。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcHJldHRpZXI=&#34;&gt;Prettier&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Prettier&lt;/code&gt;  是一种固执己见的代码格式化程序。它通过解析代码并使用自己的规则 (考虑到最大行的长度) 重新打印代码，以及在必要时包装代码，来强制执行一致的样式。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;打包和压缩&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#打包和压缩&#34;&gt;#&lt;/a&gt; &lt;strong&gt;打包和压缩&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2VicGFjaw==&#34;&gt;Webpack&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;一个著名的功能强大的模块打包器。它的主要目的是将  &lt;code&gt;JavaScript&lt;/code&gt;  文件打包以便在浏览器中使用，但它也能够转换、捆绑或打包任何资源。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaHRtbC1taW5pZmllcg==&#34;&gt;HTML-Minifier&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;轻巧，高度可配置且经过良好测试的基于  &lt;code&gt;Javascript&lt;/code&gt;  的  &lt;code&gt;HTML&lt;/code&gt;  压缩器 / 压缩器（支持  &lt;code&gt;Node.js&lt;/code&gt; ）。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xlYW4tY3Nz&#34;&gt;Clean-CSS&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;适用于  &lt;code&gt;Node.js&lt;/code&gt;  平台和任何现代浏览器的快速高效的  &lt;code&gt;CSS&lt;/code&gt;  优化器。 具有高度可配置和多种兼容模式。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdWdsaWZ5LWpz&#34;&gt;UglifyJS2&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;JavaScript&lt;/code&gt;  解析器，压缩程序和美化工具包。 它可以使用多个输入文件，并支持许多配置选项。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;进程管理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程管理&#34;&gt;#&lt;/a&gt; &lt;strong&gt;进程管理&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZW1vbg==&#34;&gt;Nodemon&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;在  &lt;code&gt;Node.js&lt;/code&gt;  应用程序的开发过程中使用的简单的监控脚本。对于开发非常有用，因为它非常容易重启，并且默认启用了文件监听&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcG0y&#34;&gt;PM2&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;带有内置负载均衡的  &lt;code&gt;Node.JS&lt;/code&gt;  应用程序的生产进程管理器。 更全面，更适合生产，给你很多参数以进行调整功能&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29uY3VycmVudGx5&#34;&gt;Concurrently&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;简单而直接 —— 这是同时运行多个命令的有用工具。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;其他&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他&#34;&gt;#&lt;/a&gt; &lt;strong&gt;其他&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYXhpb3M=&#34;&gt;Axios&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;基于  &lt;code&gt;Promise&lt;/code&gt;  的  &lt;code&gt;HTTP&lt;/code&gt;  客户端，用于浏览器和  &lt;code&gt;Node.js&lt;/code&gt; 。 与  &lt;code&gt;JS&lt;/code&gt;  内置 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSQ==&#34;&gt;Fetch API&lt;/span&gt; 相比，它易于设置，直观且简化了很多工作。&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&#34;https//www.npmjs.com/package/socket.io&#34;&gt;Socket.io&lt;/a&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Socket.IO&lt;/code&gt;  支持实时，双向和基于事件的通信。 它可以在每个平台，浏览器或其他设备上运行，并同时关注可靠性和速度。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd3M=&#34;&gt;WS&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;简单易用，快速且经过全面测试的  &lt;code&gt;WebSocket&lt;/code&gt;  客户端和服务器实现。 一个很好的，不太抽象的， &lt;code&gt;Socket.io&lt;/code&gt;  的替代方案&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGF5anM=&#34;&gt;DayJS&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;DayJS&lt;/code&gt;  是 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9tZW50&#34;&gt;MomentJS&lt;/span&gt; （自 2020 年 9 月起处于维护模式）的一种快速、轻巧的替代方案。它们的  &lt;code&gt;API&lt;/code&gt;  使用类似，如果你使用过 &lt;code&gt;MomentJS&lt;/code&gt; ，则已经知道如何使用大多数  &lt;code&gt;DayJS&lt;/code&gt; 。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9kYXNo&#34;&gt;Lodash&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;现代化的  &lt;code&gt;JavaScript&lt;/code&gt;  实用程序库，提供模块化，高性能以及其他功能。 公开关于  &lt;code&gt;JavaScript&lt;/code&gt;  数组，对象和其他数据结构的许多有用方法。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdW5kZXJzY29yZQ==&#34;&gt;Underscore&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Underscore&lt;/code&gt;  提供了许多常用的功能工具以及更专业的工具：函数绑定， &lt;code&gt;javascript&lt;/code&gt;  模板，创建快速索引，深度相等测试等。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYXN5bmM=&#34;&gt;Async&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;Async&lt;/code&gt;  是一个实用模块，它为异步  &lt;code&gt;JavaScript&lt;/code&gt;  提供了直接、强大的功能。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2Vk&#34;&gt;Marked&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用于解析  &lt;code&gt;markdown&lt;/code&gt;  而不需要缓存或长时间阻塞的低级编译器。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmFuZG9tY29sb3I=&#34;&gt;Randomcolor&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一个用于生成有吸引力的随机颜色的小脚本。 你可以传递选项对象从而决定其产生的颜色类型。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGx1cmFsaXpl&#34;&gt;Pluralize&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;该模块使用预先定义的规则列表，按顺序应用这些规则给指定单词单数或复数。 在许多情况下这很有用，例如基于用户输入的任何自动化。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVkZW50&#34;&gt;dedent&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;从多行字符串中去除缩进（空格）&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXM=&#34;&gt;ms&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;将易理解的时间转换为毫秒数。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaG90a2V5cy1qcw==&#34;&gt;hotkeys-js&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;键盘事件&lt;/code&gt; 使用库。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcXM=&#34;&gt;qs&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;code&gt;查询字符串解析和字符串化库&lt;/code&gt; ，具有一些附加的安全性&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/04/12/vue-router/</guid>
            <title>vue-router</title>
            <link>https://dmqweb.cn/2024/04/12/vue-router/</link>
            <category term="vue-router原理" scheme="https://dmqweb.cn/categories/vue-router%E5%8E%9F%E7%90%86/" />
            <category term="vue-router原理" scheme="https://dmqweb.cn/tags/vue-router%E5%8E%9F%E7%90%86/" />
            <pubDate>Fri, 12 Apr 2024 15:01:09 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;&#34;&gt;&lt;a href=&#34;#&#34; class=&#34;headerlink&#34; title=&#34;&#34;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&#34;vue-router源码&#34;&gt;&lt;a href=&#34;#vue-router源码&#34; class=&#34;headerlink&#34; title=&#34;vue-router源码&#34;&gt;&lt;/a&gt;vue-router源码&lt;/h1&gt;&lt;h3 id=&#34;vue-router路由模式&#34;&gt;&lt;a href=&#34;#vue-router路由模式&#34; class=&#34;headerlink&#34; title=&#34;vue-router路由模式&#34;&gt;&lt;/a&gt;vue-router路由模式&lt;/h3&gt;&lt;h4 id=&#34;hash模式（-）&#34;&gt;&lt;a href=&#34;#hash模式（-）&#34; class=&#34;headerlink&#34; title=&#34;hash模式（#）&#34;&gt;&lt;/a&gt;hash模式（#）&lt;/h4&gt;&lt;p&gt;SEO不友好，资源不变，不会刷新。&lt;/p&gt;
&lt;h4 id=&#34;history模式（-x2F-）&#34;&gt;&lt;a href=&#34;#history模式（-x2F-）&#34; class=&#34;headerlink&#34; title=&#34;history模式（&amp;#x2F;）&#34;&gt;&lt;/a&gt;history模式（&amp;#x2F;）&lt;/h4&gt;&lt;p&gt;SEO友好，重新请求资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;history模式发布时出现的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发布到服务器上时，点击路由跳转正常但是刷新后路由跳转404，出现的原因刷新后跳转的根路径并不是当前项目的index.html导致资源路径不匹配单页面应用路由，采取的方法是&lt;strong&gt;每次请求资源都fallback到index.html文件&lt;/strong&gt;，可以使用静态资源服务器的支持。（例如在nginx中location字段添加：&lt;strong&gt;try_files字段&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id=&#34;vue-router内部处理&#34;&gt;&lt;a href=&#34;#vue-router内部处理&#34; class=&#34;headerlink&#34; title=&#34;vue-router内部处理&#34;&gt;&lt;/a&gt;vue-router内部处理&lt;/h3&gt;&lt;h6 id=&#34;vue-router主体架构：&#34;&gt;&lt;a href=&#34;#vue-router主体架构：&#34; class=&#34;headerlink&#34; title=&#34;vue-router主体架构：&#34;&gt;&lt;/a&gt;vue-router主体架构：&lt;/h6&gt;&lt;p&gt;当使用vue.use(vue-router)时，会执行vue-router导出的实例中的install方法，将app作为参数传入，内部会用app.component注册两个全局组件RouterLink和RouterView，接着在app.config.globalProperties上设置$route和$router属性，通过app.provide将router和currentRoute传递下去。&lt;/p&gt;
&lt;h6 id=&#34;路由变化但不跳转原理：&#34;&gt;&lt;a href=&#34;#路由变化但不跳转原理：&#34; class=&#34;headerlink&#34; title=&#34;路由变化但不跳转原理：&#34;&gt;&lt;/a&gt;路由变化但不跳转原理：&lt;/h6&gt;&lt;p&gt;history.pushState和history.replaceState方法，会改变地址栏的但不进行跳转。&lt;/p&gt;
&lt;h6 id=&#34;history模式实现路由匹配：&#34;&gt;&lt;a href=&#34;#history模式实现路由匹配：&#34; class=&#34;headerlink&#34; title=&#34;history模式实现路由匹配：&#34;&gt;&lt;/a&gt;history模式实现路由匹配：&lt;/h6&gt;&lt;p&gt;内部的mather函数会将routes中的path路径转为正则表达式，与当前的路由进行匹配，匹配成功就将对应的组件添加到router-view中。&lt;/p&gt;
&lt;h6 id=&#34;router-view实现路由展示：&#34;&gt;&lt;a href=&#34;#router-view实现路由展示：&#34; class=&#34;headerlink&#34; title=&#34;router-view实现路由展示：&#34;&gt;&lt;/a&gt;router-view实现路由展示：&lt;/h6&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; defineComponent &amp;#125; from vue;
import Home from &amp;#39;../views/Home&amp;#39;;  //导入默认的全部组件
const routerView =  defineComponent(&amp;#123;
    name:&amp;quot;routerView&amp;quot;,
    props:&amp;#123;&amp;#125;,
    setup(props , &amp;#123; slots &amp;#125;)&amp;#123;
        return ()=&amp;gt;&amp;#123;
            // return h(&amp;#39;div&amp;#39;,&amp;#123;        //不使用组件默认的方式
            //     class:&amp;#39;routerViewClass&amp;#39;,
            //     onClick()&amp;#123;
            //         //处理点击 逻辑
            //     &amp;#125;,
            // &amp;#125;,slots.default())
            return h(Home,&amp;#123;
                onClick()&amp;#123;
                    //处理对应的逻辑
                &amp;#125;
            &amp;#125;)
        &amp;#125;
    &amp;#125;,
&amp;#125;)
export default routerView;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;路由provide一个currentRoute（shallowRef对象）将当前的路由路径捆绑在一起，传递下去，当currentRoute发生变化的时候就会改变相应的router-view。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/04/12/%E8%84%9A%E6%89%8B%E6%9E%B6/</guid>
            <title>脚手架开发</title>
            <link>https://dmqweb.cn/2024/04/12/%E8%84%9A%E6%89%8B%E6%9E%B6/</link>
            <category term="脚手架开发" scheme="https://dmqweb.cn/categories/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/" />
            <category term="脚手架开发" scheme="https://dmqweb.cn/tags/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/" />
            <pubDate>Fri, 12 Apr 2024 08:36:07 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;需求分析&#34;&gt;&lt;a href=&#34;#需求分析&#34; class=&#34;headerlink&#34; title=&#34;需求分析&#34;&gt;&lt;/a&gt;需求分析&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;为什么需要优化研发流程？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目量级增加：几干行代码-&amp;gt;几万行代码&lt;/li&gt;
&lt;li&gt;项目数量扩大：几个项目-&amp;gt;几干个项目&lt;/li&gt;
&lt;li&gt;项目复杂度高：Wb项目-&amp;gt;H5&amp;#x2F;PC&amp;#x2F;小程序&amp;#x2F;后端&amp;#x2F;脚手架&lt;/li&gt;
&lt;li&gt;团队人数增长：几个人-&amp;gt;几百人&lt;/li&gt;
&lt;li&gt;传统的项目研发流程已经无法满足业务需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;项目创建流程思考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当团队较大时，让每一个团队成员开发创建项目体验趋于一致就非常重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目创建流程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目代码&lt;/li&gt;
&lt;li&gt;抽象出项目模板&lt;/li&gt;
&lt;li&gt;存储到数据库&lt;/li&gt;
&lt;li&gt;脚手架读取数据库&lt;/li&gt;
&lt;li&gt;根据脚手架创建新的项目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;提升前端研发效率的手段&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物料和模板&lt;/li&gt;
&lt;li&gt;低代码搭建&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从使用角度理解什么是脚手架？&lt;/p&gt;
&lt;h1 id=&#34;脚手架简介&#34;&gt;&lt;a href=&#34;#脚手架简介&#34; class=&#34;headerlink&#34; title=&#34;脚手架简介&#34;&gt;&lt;/a&gt;脚手架简介&lt;/h1&gt;&lt;p&gt;脚手架本质是一个操作系统的客户端，它通过命令行执行，比如：&lt;/p&gt;
&lt;p&gt;vue create vue-test-app&lt;/p&gt;
&lt;p&gt;bash&lt;/p&gt;
&lt;p&gt;上面这条命令由3个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主命令：vue&lt;/li&gt;
&lt;li&gt;command:create&lt;/li&gt;
&lt;li&gt;command的param:vue-test-app&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它表示创建一个vue项目，项目的名称为vue-test-app,以上是最一个较为简单的脚手架命令，但实际场易&lt;br&gt;往更加复杂，比如：&lt;br&gt;当前目录已经有文件了，我们需要覆盖当前目录下的文件，强制进行安装ue项目，此时我们就可以输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;vue create vue-test-app --force
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的-force叫做option,用来辅助脚手架确认在特定场景下用户的选择（可以理解为配置）。还有一种场景&lt;br&gt;通过vue create&lt;br&gt;创建项目时，会自动执行npm install帮用户安装依赖，如果我们希望使用淘宝源来安装，&lt;br&gt;可以输入命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;vue create vue-test-app --force -r https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的-x也叫做option,它与–force不同的是它使用-，并且使用简写，这里的-x也可以替换成–registry,有的同学可能要问，为什么老师知道这个命令，其实我们输入下面的命令就可以看到vue create支持的所有options:&lt;br&gt;vue create  –help &lt;/p&gt;
&lt;p&gt;-r  https:&amp;#x2F;registry.npm.taobao.org后面的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9yZWdpc3RyeS5ucG0udGFvYmFvLm9yZ+aIkOS4um9wdGlvbueahHBhcmFtLOWFtuWunuS7uy1mb3JjZeWPr+S7peeQhuino+S4uu+8mi1mb3JjZQ==&#34;&gt;https://registry.npm.taobao.org成为option的param,其实任-force可以理解为：-force&lt;/span&gt; true,f简写为：–force或-f&lt;/p&gt;
&lt;h1 id=&#34;脚手架原理&#34;&gt;&lt;a href=&#34;#脚手架原理&#34; class=&#34;headerlink&#34; title=&#34;脚手架原理&#34;&gt;&lt;/a&gt;脚手架原理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;脚手架的执行原理如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在终端输入vue create vue-test-app&lt;/li&gt;
&lt;li&gt;终端解析出vue命令&lt;/li&gt;
&lt;li&gt;终端在环境变量中找到ue命令&lt;/li&gt;
&lt;li&gt;终端根据vue命令链接到实际文件vue.js&lt;/li&gt;
&lt;li&gt;终端利用node执行&amp;#96;ue.js&lt;/li&gt;
&lt;li&gt;vue.js解析command&amp;#x2F;options&lt;/li&gt;
&lt;li&gt;vue.js执行command&lt;/li&gt;
&lt;li&gt;执行完毕，退出执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;从应用的角度看如何开发一个脚手架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里以vue-cli为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发npm项目，该项目中应包含一个bin&amp;#x2F;vue.js文件，并将这个项目发布到npm&lt;/li&gt;
&lt;li&gt;将npm项目安装到node的lib&amp;#x2F;node_modules&lt;/li&gt;
&lt;li&gt;在node的bin目录下配置vue软链接指向lib&amp;#x2F;node modules&amp;#x2F;Qvue&amp;#x2F;cli&amp;#x2F;bin&amp;#x2F;vue.js&lt;/li&gt;
&lt;li&gt;这样我们在执行vue命令的时候就可以找到vue.js进行执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;还有很多疑问需要解答&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么全局安装vue&amp;#x2F;cli后会添加的命令为vue?  （npm install -g @vue&amp;#x2F;cli）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;答：vue&amp;#x2F;cli项目的package.json中的bin字段配置的名称为vue。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;全局安装vue&amp;#x2F;c1i时发生了什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;答：全局node_modules中下载项目文件，并根据项目package.json中的bin字段配置可执行文件软链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么vue指向一个js文件，我们却可以直接通过vue命令直接去执行它？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;答：js文件配置了蛇棒（操作系统的接口），例如：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;#!/usr/bin/env node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常使用环境变量中找node命令，因为每个电脑上的node文件位置不同，但是环境变量中都会有node软连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;脚手架的开发流程&#34;&gt;&lt;a href=&#34;#脚手架的开发流程&#34; class=&#34;headerlink&#34; title=&#34;脚手架的开发流程&#34;&gt;&lt;/a&gt;脚手架的开发流程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;脚手架开发流程详解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建npm项目&lt;/li&gt;
&lt;li&gt;创建脚手架入口文件，最上方添加#!&amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;env node&lt;/li&gt;
&lt;li&gt;配置package.json,添加bin属性&lt;/li&gt;
&lt;li&gt;编写脚手架代码&lt;/li&gt;
&lt;li&gt;将脚手架发布到npm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用流程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装脚手架&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install -g your-own-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用脚手架&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;your-own-cli-binName
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;脚手架开发难点解析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分包：将复杂的系统拆分成若干个模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令注册：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;- vue create
- vue add
- vue invoke
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参数解析：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;vue command [options &amp;lt;params&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;options:全称：–version、–help。简写为：-v   -h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;帮助文档：global help&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令行交互&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志打印&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令行文字变色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;开发细节&#34;&gt;&lt;a href=&#34;#开发细节&#34; class=&#34;headerlink&#34; title=&#34;开发细节&#34;&gt;&lt;/a&gt;开发细节&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;两种链接本地文件的方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;npm  link命令会将命令执行的当前文件夹根据bin字段软连接到全局的node_moduls。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;npm link 包名称 ，这个命令会将全局包添加软连接到当前项目的node_modules中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;npm unlink 包名称 ，这个命令用于移除全局node_modules中指定的软连接。（不过这个命令不好用，建议使用&lt;code&gt;npm uninstall -g &lt;/code&gt;包名称、或者&lt;code&gt;npm remove -g &lt;/code&gt;包名称  代替）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调试过程中，当本地包相互依赖时，可以使用File:路径进行指向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种方式的区别&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; npm  link的方式创建的软连接可以实时同步更改的文件，但是项目文件多了就不方便管理、很复杂，File路径不能实时同步文件修改，需要执行npm install，但是管理方便。&lt;/p&gt;
&lt;h1 id=&#34;脚手架发布体系&#34;&gt;&lt;a href=&#34;#脚手架发布体系&#34; class=&#34;headerlink&#34; title=&#34;脚手架发布体系&#34;&gt;&lt;/a&gt;脚手架发布体系&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;利用脚手架统一管理发布阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用脚手架做发布的优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规范：利用统一发布规范，如commiti记录、分支名称、代码规范等&lt;/li&gt;
&lt;li&gt;效率：避免大量重复操作，浪费开发时间&lt;/li&gt;
&lt;li&gt;安全：构建和发布全部在云端操作，避免个人发布时带来的安全隐患&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;脚手架发布的流程？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitF1low自动化代码提交&lt;/li&gt;
&lt;li&gt;远程代码自动检查&lt;/li&gt;
&lt;li&gt;云端完成构建与发布操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;脚手架发布流程&#34;&gt;&lt;a href=&#34;#脚手架发布流程&#34; class=&#34;headerlink&#34; title=&#34;脚手架发布流程&#34;&gt;&lt;/a&gt;脚手架发布流程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;检查package.json中name和bin字段，name字段不能和已存在的线上包名重复，&lt;/li&gt;
&lt;li&gt;检查版本号，是否需要更新&lt;/li&gt;
&lt;li&gt;npm login&lt;/li&gt;
&lt;li&gt;npm publish&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;npm新特性：workspace&#34;&gt;&lt;a href=&#34;#npm新特性：workspace&#34; class=&#34;headerlink&#34; title=&#34;npm新特性：workspace&#34;&gt;&lt;/a&gt;npm新特性：workspace&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地调试时，需要多次执行npm  link，node15版本推出workspace，workspace新特性可以帮助我们进行多package包管理，可以让多个npm包在同一个项目中进行开发和管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将子包中所有的依赖包都提升到根目录进行安装，提升包的安装速度&lt;/li&gt;
&lt;li&gt;初始化( npm install )后自动将子包之间的依赖进行关联&lt;/li&gt;
&lt;li&gt;各个子包共享一些流程（eslint、githook、publish flow等等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Lerna多package管理&#34;&gt;&lt;a href=&#34;#Lerna多package管理&#34; class=&#34;headerlink&#34; title=&#34;Lerna多package管理&#34;&gt;&lt;/a&gt;Lerna多package管理&lt;/h1&gt;&lt;h3 id=&#34;Lerna简介&#34;&gt;&lt;a href=&#34;#Lerna简介&#34; class=&#34;headerlink&#34; title=&#34;Lerna简介&#34;&gt;&lt;/a&gt;Lerna简介&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;原生脚手架开发痛点分析&lt;/strong&gt;（Lerna解决了哪些问题： ）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;痛点一：重复操作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多Package本地link&lt;/li&gt;
&lt;li&gt;多Package依赖安装&lt;/li&gt;
&lt;li&gt;多Package.单元测试&lt;/li&gt;
&lt;li&gt;多Package代码提交&lt;/li&gt;
&lt;li&gt;多Package代码发布&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;痛点二：版本一致性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布时版本一致性&lt;/li&gt;
&lt;li&gt;发布后相互依赖板本升级&lt;/li&gt;
&lt;li&gt;package越多，管理复杂度越高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lerna是一个优化基于git+npm的多package项目的管理工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大幅减少重复操作&lt;/li&gt;
&lt;li&gt;提升操作的标准化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lera是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。优化的主要目标往往都是以效能为核心。&lt;/p&gt;
&lt;h3 id=&#34;Lerna使用&#34;&gt;&lt;a href=&#34;#Lerna使用&#34; class=&#34;headerlink&#34; title=&#34;Lerna使用&#34;&gt;&lt;/a&gt;Lerna使用&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Lerna开发脚手架流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;npm上创建group&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化npm项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装lerna&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;package.json中配置workspaces&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;quot;workspaces&amp;quot;: [
    &amp;quot;packages/*&amp;quot;
  ],
//workspaces字段允许指定一个或多个目录作为工作区。一、可以在父级目录的package.json中管理他们的依赖，从而较少体积。二、工作区每个包之间直接相互引用，有助于提高开发效率。三、工作区所有包共享版本控制历史。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna init初始化项目（创建了git）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置gitignore排除不需要提交的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;—————————初始化完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna create创建package&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna add安装依赖（最新版废弃），使用npm install &lt;dependency&gt; –workspace  &lt;workspace&gt;代替。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna link链接依赖（最新版废弃），workspace自动链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;—————————-项目创建完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna exec执行shell脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna run执行npm命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna clean清空依赖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna bootstrap重装依赖（最新版废弃），使用npm install代替&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;—————————-项目开发完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git push提交到远程仓库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna version升级版本号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna changed查看上版本以来全部的变更。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git add . 添加到git工作区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna diff查看diff&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lerna publish进行项目发布&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;//默认是私有仓库，需要在package.json中进行配置：
&amp;quot;publishConfig&amp;quot;: &amp;#123;
    &amp;quot;access&amp;quot;:&amp;quot;public&amp;quot;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;—————————-项目发布完成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里注意npm最新版 workspace特性的推广导致lerna许多命令在最新版被废弃。&lt;/p&gt;
&lt;h3 id=&#34;Lerna学习收获&#34;&gt;&lt;a href=&#34;#Lerna学习收获&#34; class=&#34;headerlink&#34; title=&#34;Lerna学习收获&#34;&gt;&lt;/a&gt;Lerna学习收获&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;熟悉Yargs脚手架开发框架&lt;/li&gt;
&lt;li&gt;熟悉多Package管理工具Lerna的使用方法和实现原理&lt;/li&gt;
&lt;li&gt;深入理解Node.js模块路径解析流程&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一、yargs&#34;&gt;&lt;a href=&#34;#一、yargs&#34; class=&#34;headerlink&#34; title=&#34;一、yargs&#34;&gt;&lt;/a&gt;&lt;strong&gt;一、yargs&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;脚手架构成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bin:package,json中配置bin属性，npm link本地安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;command:命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;options:参数(boolean&amp;#x2F;string&amp;#x2F;number)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件顶部增加  #！&amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;env node&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;脚手架初始化流程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;构造函数：Yargs(0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常用方法：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Yargs.options&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.option&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.group&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.demandCommand&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.recommendCommands&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.strict&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.fail&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.alias&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.wrap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yargs.epilogue&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;脚手架参数解析&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;hideBin(process.argv)&amp;#x2F;Yargs.argv&lt;/li&gt;
&lt;li&gt;Yargs.parse(argv,options)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;命令注册方法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Yargs.command(command,describe,builder,handler)&lt;/li&gt;
&lt;li&gt;Yargs.command({command,describe,builder,handler )&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;二、Lerna实现原理&#34;&gt;&lt;a href=&#34;#二、Lerna实现原理&#34; class=&#34;headerlink&#34; title=&#34;二、Lerna实现原理&#34;&gt;&lt;/a&gt;&lt;strong&gt;二、Lerna实现原理&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Lerna是基于git+npm的多package项目管理工具&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过import-local优先调用本地lerna命令&lt;/li&gt;
&lt;li&gt;通过Yargs生成脚手架，先注册全局属性，再注册命令，最后通过parse方法解析参数&lt;/li&gt;
&lt;li&gt;lerna命令注册时需要传入builder和handler两个方法，builder方法用于注册命令专属的options&lt;/li&gt;
&lt;li&gt;handler用来处理命令的业务逻辑&lt;/li&gt;
&lt;li&gt;lerna通过配置npm本地依赖的方式来进行本地开发，具体写法是在package.json的依赖中写入：file:your-local–module-path,在lerna publish时会自动将该路径替换&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三、Node-js模块路径解析流程&#34;&gt;&lt;a href=&#34;#三、Node-js模块路径解析流程&#34; class=&#34;headerlink&#34; title=&#34;三、Node.js模块路径解析流程&#34;&gt;&lt;/a&gt;三、Node.js模块路径解析流程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Node.js项目模块路径解析是通过require.resolve方法来实现的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;require,resolve就是通过Module.reso1 veFileName方法实现的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;require,resolve实现原理：&lt;strong&gt;Module,resolveFileName方法核心流程有3点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断是否为内置模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过Module,resolveLookupPaths方法生成node_modules可能存在的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过Module,findPath查询模块的真实路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Module,findPath核心流程有4点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查询缓存（将request和paths通过\xoo合并成cacheKey)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;遍历paths,将path与request组成文件路径basePath&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果basePath存在则调用fs,realPathSync获取文件真实路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将文件真实路径缓存到Module.pathCache(key就是前面生成的cacheKey)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;fs.realPathSync核心流程有3点：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查询缓存（缓存的key为p,即Module.findPath中生成的文件路径）】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从左往右遍历路径字符串，查询到&amp;#x2F;时，拆分路径，判断该路径是否为软链接，如果是软链接则查询真实链接，并生成新路径P,然后继续往后遍历，这里有1个细节需要特别注意：&lt;/p&gt;
&lt;p&gt;遍历过程中生成的子路径base会缓存在knownHard和cache中，避免重复查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;遍历完成得到模块对应的真实路径，此时会将原始路径original作为key,真实路径作为value,保存到缓存中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;require.resolve,paths等价于Module.resolveLookupPaths，,该方法用于获取所有node_modules可能存在的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;require.resolve,paths实现原理：&lt;br&gt;如果路径为&amp;#x2F;（根目录），直接返回【’&amp;#x2F;node modules’】否则，将路径字符串从后往前遍历，查询到&amp;#x2F;时，拆分路径，在后面加上node_modules,并传入一个paths数组，直至查询不到&amp;#x2F;后返回paths数组&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;yargs&#34;&gt;&lt;a href=&#34;#yargs&#34; class=&#34;headerlink&#34; title=&#34;yargs&#34;&gt;&lt;/a&gt;yargs&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;yargs使用简要介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;#! /usr/bin/env node

//获得yargs构造实例
const yargs = require(&amp;#39;yargs/yargs&amp;#39;);
//参数解析函数
const &amp;#123; hideBin &amp;#125; = require(&amp;#39;yargs/helpers&amp;#39;);
const arg = hideBin(process.argv);
const cli = yargs(arg);
//配置命令：
cli
  .usage(&amp;#39;Usage: $0 [command] &amp;lt;options&amp;gt;&amp;#39;) //使用说明,$0表示命令
  .demandCommand(1,&amp;#39;A command is required,pass --help to see info&amp;#39;) //最少一个次命令
  .strict() //对于未知的命令行参数进行提示输出。
  .recommendCommands() //查找提示近似命令
  .alias(&amp;#39;h&amp;#39;,&amp;#39;help&amp;#39;) //options别名
  .alias(&amp;#39;v&amp;#39;,&amp;#39;version&amp;#39;)
  .wrap(cli.terminalWidth()) //命令行输出宽度
  .epilog(`welcomn use cli-core`) //结语
  .options(&amp;#123; //注册多个options选项
    debug:&amp;#123;
      type:&amp;quot;boolean&amp;quot;,
      describe: &amp;quot;bootstrap debug mode&amp;quot;,
      alias: &amp;quot;d&amp;quot; //添加别名
    &amp;#125;,
  &amp;#125;)
  .option(&amp;#39;registry&amp;#39;,&amp;#123; //添加单个选项
    hidden: true, //不对外暴露命令
    type:&amp;quot;string&amp;quot;,
    describe:&amp;quot;define global registry&amp;quot;,
    alias:&amp;#39;r&amp;#39;
  &amp;#125;)
  .group([&amp;#39;debug&amp;#39;],&amp;#39;Dev Options&amp;#39;) //对Options选项进行分类
  .group([&amp;#39;registry&amp;#39;],&amp;quot;Extra Options&amp;quot;)
  .command(&amp;#39;init [name]&amp;#39;,&amp;#39;init a project&amp;#39;,(yargs)=&amp;gt;&amp;#123; //注册次命令，制定对应options
    yargs
      .option(&amp;#39;name&amp;#39;,&amp;#123;
        type: &amp;#39;string&amp;#39;,
        describe: &amp;#39;Name of a project&amp;#39;,
        alias: &amp;#39;n&amp;#39;
      &amp;#125;);
  &amp;#125;,(argv)=&amp;gt;&amp;#123;
        console.log(argv);
  &amp;#125;)
  .command(&amp;#123;    //第二种注册命令的方法（更加精细）
    command: &amp;#39;list&amp;#39;,
    aliases: [&amp;#39;ls&amp;#39;,&amp;#39;la&amp;#39;,&amp;#39;ll&amp;#39;],
    describe: &amp;#39;List local packages&amp;#39;,
    builder: (yargs)=&amp;gt;[
      // ....操作
    ],
    handler: (argv)=&amp;gt;&amp;#123;
      console.log(argv);
    &amp;#125;
  &amp;#125;)
  .argv; //使用参数
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;commander&#34;&gt;&lt;a href=&#34;#commander&#34; class=&#34;headerlink&#34; title=&#34;commander&#34;&gt;&lt;/a&gt;commander&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;commander简单单例模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;#! /usr/bin/env node
const commander = require(&amp;#39;commander&amp;#39;);
const pkg = require(&amp;#39;../package.json&amp;#39;);
const &amp;#123; program &amp;#125; = commander; //commander单例，包含已注册好的基础命令
program
    .version(pkg.version)
    .parse(process.argv)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;commander强大功能&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;#! /usr/bin/env node
const commander = require(&amp;#39;commander&amp;#39;);
const pkg = require(&amp;#39;../package.json&amp;#39;);
const program = new commander.Command();//手动实例化一个commander实例
program
    .name(Object.keys(pkg.bin)[0])
    .usage(&amp;#39;&amp;lt;command&amp;gt; [options]&amp;#39;) //使用说明
    .version(pkg.version) //版本
    .option(&amp;#39;-d,--debug&amp;#39;,&amp;#39;是否开启调试模式&amp;#39;,false) //配置option选项：选项，帮助信息，默认值
    .option(&amp;#39;-e,--envName &amp;lt;envName&amp;gt;&amp;#39;,&amp;#39;获取变量名称&amp;#39;)//option获得传参
    .parse(process.argv) //解析参数
//使用command注册命令
const clone = program.command(&amp;#39;clone &amp;lt;source&amp;gt; [destination]&amp;#39;); //&amp;lt;必选项&amp;gt;，[可选项]
clone
    .description(&amp;#39;clone a repository&amp;#39;)
    .option(&amp;#39;-f,--force&amp;#39;,&amp;#39;是否强制克隆&amp;#39;)
    .action((source,destination,cmdObj)=&amp;gt;&amp;#123;
        console.log(&amp;#39;do clone&amp;#39;,source,destination,cmdObj.force);
    &amp;#125;)
//使用addCommand注册子命令
const service = new commander.Command(&amp;#39;service&amp;#39;);
service
    .command(&amp;#39;start [port]&amp;#39;)
    .description(&amp;#39;start service at port&amp;#39;)
    .action((port)=&amp;gt;&amp;#123;
        console.log(&amp;#39;do service start&amp;#39;,port);
    &amp;#125;);
service
    .command(&amp;#39;stop&amp;#39;)
    .description(&amp;#39;stop service&amp;#39;)
    .action(()=&amp;gt;&amp;#123;
        console.log(&amp;#39;stop service&amp;#39;);
    &amp;#125;)
program.addCommand(service);

//参数解释和自动匹配功能
program
    .arguments(&amp;#39;&amp;lt;cmd&amp;gt; [options]&amp;#39;) //强制传入命令
    .description(&amp;#39;test command&amp;#39;,&amp;#123; //描述
        cmd: &amp;#39;命令&amp;#39;,
        options: &amp;#39;参数&amp;#39;
    &amp;#125;)
    .action(function(cmd,options)&amp;#123; //匹配全部命令
        console.log(cmd,options);
    &amp;#125;)

//默认命令与命令转向功能
program
    .command(&amp;#39;install [name]&amp;#39;,&amp;#39;install package&amp;#39;,&amp;#123;
            executableFile: &amp;#39;imooc-cli&amp;#39;, //将install [name]命令转向imooc-cli
            isDefault: true,//设置为默认命令
            hidden: true,//命令不可见
        &amp;#125;)
        .alias(&amp;#39;i&amp;#39;);

//高级定制1：自定义help信息
program.helpInformation = function()&amp;#123;
    return &amp;#39;&amp;#39;;
&amp;#125;;
program.on(&amp;#39;--help&amp;#39;,function()&amp;#123;
    console.log(&amp;#39;my help information&amp;#39;);
&amp;#125;);

//高级定制2：监听debug
program.on(&amp;#39;option:debug&amp;#39;,function()&amp;#123;
    if(program.debug)&amp;#123;
        process.env.LOG_LEVEL = &amp;#39;verbose&amp;#39;;
    &amp;#125;;
    console.log(process.env.LOG_LEVEL);
&amp;#125;)

//高级定制3：监听未知命令（与默认命令冲突）
program.on(&amp;#39;command:*&amp;#39;,function(obj)&amp;#123;
    console.error(&amp;#39;未知命令:&amp;#39;+ obj[0]);
    const avaliableCommands = program.commands.map(cmd=&amp;gt;cmd.name());
    console.log(&amp;#39;可用命令：&amp;#39;+avaliableCommands.join(&amp;#39;,&amp;#39;));
&amp;#125;)

//最后要进行参数解析!
program.parse(process.argv)

//内置属性和方法
console.log(program.debug);
console.log(program.envName);
program.outputHelp();//内置方法，弹出帮助信息
console.log(program.opts());//内置方法，返回options信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;require加载机制&#34;&gt;&lt;a href=&#34;#require加载机制&#34; class=&#34;headerlink&#34; title=&#34;require加载机制&#34;&gt;&lt;/a&gt;require加载机制&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;require直接加载.js、.json和.node文件，其余文件按照js语法进行加载&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载js文件，require加载的js文件需要进行导出&lt;/li&gt;
&lt;li&gt;加载json文件，通过JSON.parse进行文件解析&lt;/li&gt;
&lt;li&gt;加载node文件，通过process.dlopen方法加载（node文件是C++语法）&lt;/li&gt;
&lt;li&gt;其余文件，使用js语法加载，此时语法错误的会报错。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;node多进程&#34;&gt;&lt;a href=&#34;#node多进程&#34; class=&#34;headerlink&#34; title=&#34;node多进程&#34;&gt;&lt;/a&gt;node多进程&lt;/h1&gt;&lt;h3 id=&#34;介绍&#34;&gt;&lt;a href=&#34;#介绍&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程是资源分配的最小单位，线程是CPU调度的最小单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么是进程&lt;/p&gt;
&lt;p&gt;进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单&lt;/p&gt;
&lt;p&gt;位，是操作系统结构的基础。&lt;/p&gt;
&lt;p&gt;进程的概念主要有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，进程是一个实体。每一个进程都有它自己的地址空间。&lt;/li&gt;
&lt;li&gt;第二，进程是一个“执行中的程序”，存在嵌套关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;node多进程官方文档：&lt;/p&gt;
&lt;p&gt;中文版：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL25vZGVpcy5jbi9hcGkvY2hpbGRfcHJvY2VzcyxodG1s&#34;&gt;http://nodeis.cn/api/child_process,html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统会使用时会开辟一个node进程，每个node文件在运行时都会创建一个child_process进行，也就是node.js的子进程。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;child-precess用法&#34;&gt;&lt;a href=&#34;#child-precess用法&#34; class=&#34;headerlink&#34; title=&#34;child_precess用法&#34;&gt;&lt;/a&gt;child_precess用法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一、执行可执行文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const cp = require(&amp;#39;child_process&amp;#39;) //默认内置库
//exec方法，可以传执行命令，也可以传文件路径，但不支持给文件传参。
cp.exec(&amp;#39;ls -al|grep node_modules&amp;#39;,function(err,stdout,stderr)&amp;#123;
    console.log(err,stdout,stderr);
&amp;#125;);
//execFile方法，传文件路径，并且支持给文件传参数。
cp.execFile(&amp;#39;ls&amp;#39;,[&amp;#39;-al&amp;#39;],function(err,stdout,stderr)&amp;#123;
    console.log(err,stdout,stderr);
&amp;#125;)
//spawn方法，传入文件路径，以流式的方式输出，是exec和execFile的底层原理
const child = cp.spawn(&amp;#39;npm&amp;#39;,[install],&amp;#123;
    cwd: path.resolve(&amp;#39;/User/dmq/Desktop/test&amp;#39;)
&amp;#125;);
child.stdout.on(&amp;#39;data&amp;#39;,function(chunk)&amp;#123;
    console.log(&amp;#39;stdout&amp;#39;,chunk.toString());
&amp;#125;);
child.stderr.on(&amp;#39;data&amp;#39;,function(chunk)&amp;#123;
    console.log(&amp;#39;stderr&amp;#39;,chunk.toString());
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;exec和spawn使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当文件操作过程复杂，并且需要频繁输出日志时，使用spawn进行流式操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const child = cp.spawn(&amp;#39;npm&amp;#39;,[install],&amp;#123;
    cwd: path.resolve(&amp;#39;/User/dmq/Desktop/test&amp;#39;),
    stdio: &amp;#39;inherit&amp;#39;, //将输出传给父进程。
&amp;#125;);
//监听错误事件
child.on(&amp;#39;error&amp;#39;,e=&amp;gt;&amp;#123;
    console.error(e.message);
&amp;#125;)
//监听退出事件
child.on(&amp;#39;exit&amp;#39;,e=&amp;gt;&amp;#123;
    console.log(&amp;#39;命令执行成功&amp;#39; + e)
&amp;#125;)
child.stdout.on(&amp;#39;data&amp;#39;,function(chunk)&amp;#123;
    console.log(&amp;#39;stdout&amp;#39;,chunk.toString());
&amp;#125;);
child.stderr.on(&amp;#39;data&amp;#39;,function(chunk)&amp;#123;
    console.log(&amp;#39;stderr&amp;#39;,chunk.toString());
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当文件操作过程简单，需要直接输出时，使用exec方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;cp.exec(&amp;#39;npm install&amp;#39;,&amp;#123;
    cwd: path.resolve(&amp;#39;/User/dmq/Desktop/test&amp;#39;)
&amp;#125;,function(err,stdout,stderr)&amp;#123;
    console.log(err);
    console.log(stdout);
    console.log(stderr);
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二、执行指定JS文件（不支持回调）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fork方法类似于require函数，但是区别在于fork方法会创建一个node子进程执行JS文件，使用独立的v8引擎去解析代码。&lt;/p&gt;
&lt;p&gt;index.js文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const child = cp.fork(path.resolve(__dirname,&amp;#39;child.js&amp;#39;));
child.send(&amp;#39;hello child process!&amp;#39;,()=&amp;gt;&amp;#123;
    child.disconnect(); //及时断开连接，防止主进程和子进程长期处于等待状态
&amp;#125;);
child.on(&amp;#39;message&amp;#39;,(msg)=&amp;gt;&amp;#123;
    console.log(msg);
&amp;#125;);
console.log(&amp;#39;main pid:&amp;#39;,process.pid);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;child.js文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;console.log(&amp;#39;child process pid:&amp;#39;,process.pid);
process.on(&amp;#39;message&amp;#39;,(msg)=&amp;gt;&amp;#123;
    console.log(msg);
&amp;#125;);
process.send(&amp;#39;hello main process&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;child-process源码&#34;&gt;&lt;a href=&#34;#child-process源码&#34; class=&#34;headerlink&#34; title=&#34;child_process源码&#34;&gt;&lt;/a&gt;child_process源码&lt;/h3&gt;&lt;p&gt;疑问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exec、execFile、spanwn和fork区别：&lt;ul&gt;
&lt;li&gt;exec:原理是调用&amp;#x2F;bin&amp;#x2F;sh-c执行我们传入的shell脚本，底层调用了execFile&lt;/li&gt;
&lt;li&gt;execFile:原理是直接执行我们传入的file和args,底层调用spawn创建和执行子进程，并建立了回调，一次性将所有的stdout和stderr结果返回&lt;/li&gt;
&lt;li&gt;spawn:原理是调用了internal&amp;#x2F;child_.process,实例化了ChildProcess子进程对象，再调用child.spawn创建子进程并执行命令，底层是调用了child._handle.spawn执行process_wrap中的spwn方法，执行过程是异步的，执行完毕后通过PIPE进行单向数据通信，通信结束后会子进程发起onexit回调，同时Socket会执行close回调&lt;/li&gt;
&lt;li&gt;fork:原理是通过spawn创建子进程和执行命令，通过setupchannel创建IPC用于子进程和父进程之&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;egg-js-mongodb&#34;&gt;&lt;a href=&#34;#egg-js-mongodb&#34; class=&#34;headerlink&#34; title=&#34;egg.js+mongodb&#34;&gt;&lt;/a&gt;egg.js+mongodb&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、egg.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于快速生成后端api的框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、npm init egg命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当执行&lt;code&gt;npm init egg&lt;/code&gt; 命令时，npm会自动找到create-egg这个包（其他包同理，找到create-包名），进行执行。&lt;strong&gt;当不想将脚手架安装到本地，而是在线上直接使用时，这个机制就显得十分重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、mongodb数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非关系型数据库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;云mongodb&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;云mongodb开通&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地址：https:&amp;#x2F;mongodb.console.aliyun.comL,创建实例并付款即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地mongodb&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;地址：https:&amp;#x2F;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5ydW5vb2IuY29tL21vbmdvZGIvbW9uZ29kYi10dXRvcmlhbC5odG1s&#34;&gt;www.runoob.com/mongodb/mongodb-tutorial.html&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mongodb使用方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucnVub29iLmNvbS9tb25nb2RiL21vbmdvZGItZGF0YWJhc2VzLWRvY3VtZW50cy1jb2xsZWN0aW9ucy5odG1s&#34;&gt;https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4、egg.js链接mongodb数据库&lt;/p&gt;
&lt;p&gt;utils&amp;#x2F;mongo.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;use strict&amp;#39;;
const logger = require(&amp;#39;npmlog&amp;#39;);
logger.level = process.env.LOG_LEVEL ? process.env.LOG_LEVEL : &amp;#39;info&amp;#39;;
logger.heading = &amp;#39;pick&amp;#39;; // 自定义头部
logger.addLevel(&amp;#39;success&amp;#39;, 2000, &amp;#123; fg: &amp;#39;green&amp;#39;, bold: true &amp;#125;); // 自定义success日志
logger.addLevel(&amp;#39;notice&amp;#39;, 2000, &amp;#123; fg: &amp;#39;blue&amp;#39;, bg: &amp;#39;black&amp;#39; &amp;#125;); // 自定义notice日志
const MongoClient = require(&amp;#39;mongodb&amp;#39;).MongoClient;
class Mongo &amp;#123;
  constructor(url, dbName) &amp;#123;
    this.url = url;
    this.dbName = dbName;
  &amp;#125;
  connect() &amp;#123;
    return new Promise((resolve, reject) =&amp;gt; &amp;#123;
      MongoClient.connect(
        this.url,
        &amp;#123;
          useNewUrlParser: true,
          useUnifiedTopology: true,
        &amp;#125;,
        (err, client) =&amp;gt; &amp;#123;
          if (err) &amp;#123;
            reject(err);
          &amp;#125; else &amp;#123;
            const db = client.db(this.dbName);
            resolve(&amp;#123; db, client &amp;#125;);
          &amp;#125;
        &amp;#125;);
    &amp;#125;);
  &amp;#125;
  connectAction(docName, action) &amp;#123;
    return new Promise(async (resolve, reject) =&amp;gt; &amp;#123;
      const &amp;#123; db, client &amp;#125; = await this.connect();
      try &amp;#123;
        const collection = db.collection(docName);
        action(collection, result =&amp;gt; &amp;#123;
          this.close(client);
          logger.verbose(&amp;#39;result&amp;#39;, result);
          resolve(result);
        &amp;#125;, err =&amp;gt; &amp;#123;
          this.close(client);
          logger.error(err.toString());
          reject(err);
        &amp;#125;);
      &amp;#125; catch (err) &amp;#123;
        this.close(client);
        logger.error(err.toString());
        reject(err);
      &amp;#125;
    &amp;#125;);
  &amp;#125;
  query(docName) &amp;#123;
    return this.connectAction(docName, (collection, onSuccess, onError) =&amp;gt; &amp;#123;
      collection.find(&amp;#123;&amp;#125;, &amp;#123; projection: &amp;#123; _id: 0 &amp;#125; &amp;#125;).toArray((err, docs) =&amp;gt; &amp;#123;
        if (err) &amp;#123;
          onError(err);
        &amp;#125; else &amp;#123;
          onSuccess(docs);
        &amp;#125;
      &amp;#125;);
    &amp;#125;);
  &amp;#125;
  insert(docName, data) &amp;#123;
    return this.connectAction(docName, (collection, onSuccess, onError) =&amp;gt; &amp;#123;
      collection.insertMany(data, (err, result) =&amp;gt; &amp;#123;
        if (err) &amp;#123;
          onError(err);
        &amp;#125; else &amp;#123;
          onSuccess(result);
        &amp;#125;
      &amp;#125;);
    &amp;#125;);
  &amp;#125;
  remove(docName, data) &amp;#123;
    return this.connectAction(docName, (collection, onSuccess, onError) =&amp;gt; &amp;#123;
      collection.deleteOne(data, (err, result) =&amp;gt; &amp;#123;
        if (err) &amp;#123;
          onError(err);
        &amp;#125; else &amp;#123;
          onSuccess(result);
        &amp;#125;
      &amp;#125;);
    &amp;#125;);
  &amp;#125;
  //   update(collection, data) &amp;#123;
  //   &amp;#125;
  close(client) &amp;#123;
    client &amp;amp;&amp;amp; client.close();
  &amp;#125;
&amp;#125;
module.exports = Mongo;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;db.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const mongo = new Mongodb(&amp;#39;mongodb://dmq:dmq0216@127.0.0.1:27017/dbName&amp;#39;,&amp;#39;dbName&amp;#39;);
const data = mongo().query(&amp;#39;project&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;inquirer源码&#34;&gt;&lt;a href=&#34;#inquirer源码&#34; class=&#34;headerlink&#34; title=&#34;inquirer源码&#34;&gt;&lt;/a&gt;inquirer源码&lt;/h1&gt;&lt;h2 id=&#34;学习路径&#34;&gt;&lt;a href=&#34;#学习路径&#34; class=&#34;headerlink&#34; title=&#34;学习路径&#34;&gt;&lt;/a&gt;学习路径&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;掌握一些库：readline（命令行读取）&amp;#x2F;events（事件驱动）&amp;#x2F;stream（输入输出流）&amp;#x2F;ansi-escapes（命令行文字样式）&amp;#x2F;rxjs（处理异步事件）&lt;/li&gt;
&lt;li&gt;掌握命令行交互的实现原理，并实现一个可交互的列表&lt;/li&gt;
&lt;li&gt;分析inquirer源码掌握其中的关键实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ejs-glob&#34;&gt;&lt;a href=&#34;#ejs-glob&#34; class=&#34;headerlink&#34; title=&#34;ejs+glob&#34;&gt;&lt;/a&gt;ejs+glob&lt;/h1&gt;&lt;p&gt;ejs三方库用于xml动态模板渲染，glob三方库用于根据&lt;code&gt;文件路径进行遍历和匹配文件&lt;/code&gt;，拿到文件的内容。&lt;/p&gt;
&lt;h1 id=&#34;ejs源码&#34;&gt;&lt;a href=&#34;#ejs源码&#34; class=&#34;headerlink&#34; title=&#34;ejs源码&#34;&gt;&lt;/a&gt;ejs源码&lt;/h1&gt;&lt;p&gt;省略，详见官网&lt;/p&gt;
&lt;h1 id=&#34;require源码&#34;&gt;&lt;a href=&#34;#require源码&#34; class=&#34;headerlink&#34; title=&#34;require源码&#34;&gt;&lt;/a&gt;require源码&lt;/h1&gt;&lt;p&gt;省略，详见官网&lt;/p&gt;
&lt;h1 id=&#34;代码复用实践&#34;&gt;&lt;a href=&#34;#代码复用实践&#34; class=&#34;headerlink&#34; title=&#34;代码复用实践&#34;&gt;&lt;/a&gt;代码复用实践&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代码复用目的：&lt;/strong&gt;提高人效，降低开发成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算公式&lt;/strong&gt;为：&lt;strong&gt;节约工时 &amp;#x3D; 服用代码节约时间  *  代码复用系数  *  复用次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背后思考：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同开发者、团队之间会产生了大量重复、通用的代码&lt;/li&gt;
&lt;li&gt;这些代码散落在各自团队的项目代码里&lt;/li&gt;
&lt;li&gt;复用的时候大家习惯于直接拷贝这些代码到项目中，因为这样做对个人成本最低（开发者往往更熟悉自己写的代码)，但是这种做法不利于团队之间代码共享，因为每个人开发不同的业务，对不同页面的熟悉程度不一样，而代码复用的宗旨就是要尽可能将团队中的开发着的整体水平拉齐&lt;/li&gt;
&lt;li&gt;所以需要通过工具化的方式降低代码复用的成本&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/04/12/%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/</guid>
            <title>复杂业务部署与优化</title>
            <link>https://dmqweb.cn/2024/04/12/%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/</link>
            <category term="复杂业务部署与优化" scheme="https://dmqweb.cn/categories/%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BC%98%E5%8C%96/" />
            <category term="复杂业务部署与优化" scheme="https://dmqweb.cn/tags/%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BC%98%E5%8C%96/" />
            <pubDate>Fri, 12 Apr 2024 08:33:58 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;软件生命周期：&#34;&gt;&lt;a href=&#34;#软件生命周期：&#34; class=&#34;headerlink&#34; title=&#34;软件生命周期：&#34;&gt;&lt;/a&gt;软件生命周期：&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&#34;/images/Snipaste_2024-04-16_12-54-33.jpg&#34; alt=&#34;/images/Snipaste_2024-04-16_12-54-33.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;架构流程图&#34;&gt;&lt;a href=&#34;#架构流程图&#34; class=&#34;headerlink&#34; title=&#34;架构流程图&#34;&gt;&lt;/a&gt;架构流程图&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&#34;/images/Snipaste_2024-04-17_12-16-04.jpg&#34; alt=&#34;/images/Snipaste_2024-04-17_12-16-04.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;复杂项目通用方案&#34;&gt;&lt;a href=&#34;#复杂项目通用方案&#34; class=&#34;headerlink&#34; title=&#34;复杂项目通用方案&#34;&gt;&lt;/a&gt;复杂项目通用方案&lt;/h1&gt;&lt;h4 id=&#34;业务的复杂度&#34;&gt;&lt;a href=&#34;#业务的复杂度&#34; class=&#34;headerlink&#34; title=&#34;业务的复杂度&#34;&gt;&lt;/a&gt;业务的复杂度&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;交互的复杂性&lt;/li&gt;
&lt;li&gt;数据结构和状态的复杂性&lt;/li&gt;
&lt;li&gt;多项目互相依赖的复杂性&lt;/li&gt;
&lt;li&gt;打包&lt;/li&gt;
&lt;li&gt;性能优化&lt;/li&gt;
&lt;li&gt;第三方库的使用和调研以及二次开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;流程的复杂度&#34;&gt;&lt;a href=&#34;#流程的复杂度&#34; class=&#34;headerlink&#34; title=&#34;流程的复杂度&#34;&gt;&lt;/a&gt;流程的复杂度&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;git flow&lt;/li&gt;
&lt;li&gt;lint工具&lt;/li&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;commit信息&lt;/li&gt;
&lt;li&gt;PR revirew&lt;/li&gt;
&lt;li&gt;CI &amp;#x2F; CD&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;CI-x2F-CD的概念&#34;&gt;&lt;a href=&#34;#CI-x2F-CD的概念&#34; class=&#34;headerlink&#34; title=&#34;CI &amp;#x2F; CD的概念&#34;&gt;&lt;/a&gt;CI &amp;#x2F; CD的概念&lt;/h1&gt;&lt;p&gt;业务组件库的开发和发布是随着一些列任务进化的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地commit钩子函数完成commit验证&lt;/li&gt;
&lt;li&gt;代码push到远端之后&lt;/li&gt;
&lt;li&gt;跑特定的test（不仅仅是本机的unit test，也可能有时间很长的E2E test）&lt;/li&gt;
&lt;li&gt;test通过之后检查是否有新的tag，如果有就自动publish一个新的版本&lt;/li&gt;
&lt;li&gt;甚至还有更多，自动部署文档站点等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些任务如果手动操作，就费时费力，所以需要自动化进行。&lt;/p&gt;
&lt;h4 id=&#34;CI（Continuous-integration）持续集成&#34;&gt;&lt;a href=&#34;#CI（Continuous-integration）持续集成&#34; class=&#34;headerlink&#34; title=&#34;CI（Continuous integration）持续集成&#34;&gt;&lt;/a&gt;CI（Continuous integration）持续集成&lt;/h4&gt;&lt;p&gt;持续集成是指频繁地将代码集成到主干，一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。&lt;/p&gt;
&lt;p&gt;作用有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速发现错误&lt;/li&gt;
&lt;li&gt;防止分支大幅偏离主干&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;持续集成的目的就是让产品可以快速迭代，同时保持高质量。&lt;/p&gt;
&lt;h4 id=&#34;CD（Continuous-Delivery）持续交付&#34;&gt;&lt;a href=&#34;#CD（Continuous-Delivery）持续交付&#34; class=&#34;headerlink&#34; title=&#34;CD（Continuous Delivery）持续交付&#34;&gt;&lt;/a&gt;CD（Continuous Delivery）持续交付&lt;/h4&gt;&lt;p&gt;持续交付是指频繁地将软件的新版本，交付给质量团队或者用户，以供评审。&lt;/p&gt;
&lt;h4 id=&#34;CD（Continuous-Deployment）持续部署&#34;&gt;&lt;a href=&#34;#CD（Continuous-Deployment）持续部署&#34; class=&#34;headerlink&#34; title=&#34;CD（Continuous Deployment）持续部署&#34;&gt;&lt;/a&gt;CD（Continuous Deployment）持续部署&lt;/h4&gt;&lt;p&gt;持续部署是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。&lt;/p&gt;
&lt;h4 id=&#34;CI-x2F-CD两大服务：&#34;&gt;&lt;a href=&#34;#CI-x2F-CD两大服务：&#34; class=&#34;headerlink&#34; title=&#34;CI &amp;#x2F; CD两大服务：&#34;&gt;&lt;/a&gt;CI &amp;#x2F; CD两大服务：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;github actions&lt;/li&gt;
&lt;li&gt;travis-ci&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;列表排序解决方案&#34;&gt;&lt;a href=&#34;#列表排序解决方案&#34; class=&#34;headerlink&#34; title=&#34;列表排序解决方案&#34;&gt;&lt;/a&gt;列表排序解决方案&lt;/h1&gt;&lt;p&gt;列表排序原理：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;ul class=&amp;quot;ul&amp;quot; @drop=&amp;quot;onDrop&amp;quot;&amp;gt;
        &amp;lt;li 
            v-for=&amp;quot;(item,index) in list&amp;quot; 
            :data-index=&amp;quot;index&amp;quot; 
            :key=&amp;quot;item.id&amp;quot; 
            @dragover=&amp;quot;onDragover($event,index)&amp;quot; 
            @dragstartart=&amp;quot;dragstart($event,index)&amp;quot; 
            @dragenter=&amp;quot;dragenter($event,index)&amp;quot; 
            draggable=&amp;quot;true&amp;quot; 
            :class=&amp;quot;[item.id==currentLi?&amp;#39;glost&amp;#39;:&amp;#39;&amp;#39;]&amp;quot;
        &amp;gt;&amp;#123;&amp;#123; item.name &amp;#125;&amp;#125;&amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
/*eslint-disable*/
import &amp;#123; ref &amp;#125; from &amp;quot;vue&amp;quot;;
import &amp;#123;arrayMoveImmutable&amp;#125; from &amp;#39;array-move&amp;#39;;
let currentLi = ref(1);
let index = ref(1);
const list = ref(
  [
  &amp;#123;id:1,name:&amp;#39;列表1&amp;#39;&amp;#125;,
  &amp;#123;id:2,name:&amp;#39;列表2&amp;#39;&amp;#125;,
  &amp;#123;id:3,name:&amp;#39;列表3&amp;#39;&amp;#125;,
  &amp;#123;id:4,name:&amp;#39;列表4&amp;#39;&amp;#125;,
  &amp;#123;id:5,name:&amp;#39;列表5&amp;#39;&amp;#125;,
]
)
const dragstart = (e,inde)=&amp;gt;&amp;#123;
  currentLi.value = inde;
&amp;#125;
const dragenter = (e,ind)=&amp;gt;&amp;#123;
  if(ind != currentLi.value)&amp;#123;
      list.value = arrayMoveImmutable(list.value,ind,currentLi.value)
      currentLi.value = ind;
  &amp;#125;
&amp;#125;
const onDrop = (e)=&amp;gt;&amp;#123;
  console.log(e.target.dataset.index,&amp;#39;drop&amp;#39;);
  list.value = arrayMoveImmutable(list.value,index.value,currentLi.value)
  console.log(list.value);
&amp;#125;
const onDragover = (e,inde)=&amp;gt;&amp;#123;
  e.preventDefault();
  index.value = inde;
&amp;#125;
&amp;lt;/script&amp;gt;

&amp;lt;style  scoped&amp;gt;
.ul&amp;gt;li&amp;#123;
  width: 100%;
  height: 50px;
  border: 1px solid red;
&amp;#125;
.glost&amp;#123;
  box-shadow: 10px 10px 3px 3px gray;
&amp;#125;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列表排序常用工具包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vue-draggable&lt;/li&gt;
&lt;li&gt;sortable.js&lt;/li&gt;
&lt;li&gt;array-move.js&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;拖动改变位置原理&#34;&gt;&lt;a href=&#34;#拖动改变位置原理&#34; class=&#34;headerlink&#34; title=&#34;拖动改变位置原理&#34;&gt;&lt;/a&gt;拖动改变位置原理&lt;/h1&gt;&lt;p&gt;通过监听mousedown和mousemove事件，用element.getBoundingClientRect方法获得x和y，left和top等属性，改变对应元素的top和left属性。&lt;/p&gt;
&lt;h1 id=&#34;拖动改变大小原理&#34;&gt;&lt;a href=&#34;#拖动改变大小原理&#34; class=&#34;headerlink&#34; title=&#34;拖动改变大小原理&#34;&gt;&lt;/a&gt;拖动改变大小原理&lt;/h1&gt;&lt;p&gt; 设置边框元素，边框元素的四个角添加圆点元素，监听mousedown事件和mousemove事件，并将最新的坐标赋值给元素的尺寸大小。&lt;/p&gt;
&lt;h1 id=&#34;快捷键实现原理&#34;&gt;&lt;a href=&#34;#快捷键实现原理&#34; class=&#34;headerlink&#34; title=&#34;快捷键实现原理&#34;&gt;&lt;/a&gt;快捷键实现原理&lt;/h1&gt;&lt;p&gt;好用的快捷键第三方库：Hotkeys.js&lt;/p&gt;
&lt;p&gt;事件原理：keydown事件的监听，通过event.key判断是那个快捷键，从而执行对应的操作。&lt;/p&gt;
&lt;h1 id=&#34;撤销重做原理&#34;&gt;&lt;a href=&#34;#撤销重做原理&#34; class=&#34;headerlink&#34; title=&#34;撤销重做原理&#34;&gt;&lt;/a&gt;撤销重做原理&lt;/h1&gt;&lt;p&gt;维护一个固定长度的histories数组和historyIndex指针，每次修改的时候添加一条记录（标识操作类型和数据）。回滚时改变historyIndex指针。&lt;/p&gt;
&lt;h1 id=&#34;右键菜单原理&#34;&gt;&lt;a href=&#34;#右键菜单原理&#34; class=&#34;headerlink&#34; title=&#34;右键菜单原理&#34;&gt;&lt;/a&gt;右键菜单原理&lt;/h1&gt;&lt;p&gt;在需要显示的区域拦截默认的右键点击事件，判断是否点击在组件元素上（通过event.target），显示一个自定义菜单，其中包括操作项，显示在鼠标的位置（event.clientX和event.clientY），点击完成操作，通过display:none隐藏。&lt;/p&gt;
&lt;h1 id=&#34;自动保存实现方案&#34;&gt;&lt;a href=&#34;#自动保存实现方案&#34; class=&#34;headerlink&#34; title=&#34;自动保存实现方案&#34;&gt;&lt;/a&gt;自动保存实现方案&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定时保存（语雀）&lt;/li&gt;
&lt;li&gt;实时保存（石墨）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现原理：添加isDrity字段标记数据是否有修改，当修改时将isDirty设置为true，根据isDIrty的值设置定时器，定时触发保存逻辑。&lt;/p&gt;
&lt;h1 id=&#34;DOM元素截图实现方案&#34;&gt;&lt;a href=&#34;#DOM元素截图实现方案&#34; class=&#34;headerlink&#34; title=&#34;DOM元素截图实现方案&#34;&gt;&lt;/a&gt;DOM元素截图实现方案&lt;/h1&gt;&lt;p&gt;工具包：html2canvas&lt;/p&gt;
&lt;p&gt;实现原理：根据DOM元素的styles样式，通过svg的foreignObject元素引入XML命名空间的元素，然后创建一个image标签，将svg通过url.createObjectURL方法创建一个路径赋值给image标签的src属性，通过canvas画笔 的drawImage方法将image图片绘制到canvas画布上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const data =
&amp;quot;&amp;lt;svg xmlns=&amp;#39;http://www.w3.org/2000/svg&amp;#39;width=&amp;#39;400px&amp;#39;height=&amp;#39;40
&amp;quot;&amp;lt;foreignabject width=&amp;#39;100%&amp;#39;height=&amp;#39;100%&amp;#39;&amp;gt;&amp;quot;+
&amp;quot;&amp;lt;div xmlns=&amp;#39;http://ww.w3.org/1999/xhtml&amp;#39;&amp;gt;&amp;quot;
element.innerHTML+
&amp;quot;&amp;lt;/div&amp;gt;&amp;quot;+
&amp;quot;&amp;lt;/foreignobject&amp;gt;&amp;quot; +
&amp;quot;&amp;lt;/svg&amp;gt;&amp;quot;

const svg = new Blob([data],&amp;#123;type:&amp;quot;image/svg+xml;charset=utf-8&amp;quot;&amp;#125;);
const url = URL.createobjectURL(svg)
const image = new Image()
image.src = url
image.addEventListener(&amp;#39;load&amp;#39;,()=&amp;gt;&amp;#123;
    const ctx =anvas.getContext(&amp;#39;2d&amp;#39;);
    if (ctx)&amp;#123;
    ctx.drawImage(image,0,0)
    &amp;#125;
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二维码生成方案&#34;&gt;&lt;a href=&#34;#二维码生成方案&#34; class=&#34;headerlink&#34; title=&#34;二维码生成方案&#34;&gt;&lt;/a&gt;二维码生成方案&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;工具包：node-qrcode&lt;/li&gt;
&lt;li&gt;ts项目中需要安装额外的定义文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单原理：将数据变为二进制，然后通过canvas将二进制变为图像。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;body&amp;gt;
  &amp;lt;canvas id=&amp;quot;qrcode&amp;quot; width=&amp;quot;128&amp;quot; height=&amp;quot;128&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
  &amp;lt;script&amp;gt;
    //将字符串转为二进制形式
    function toBianary(str)&amp;#123;
        let res = &amp;#39;&amp;#39;;
        for(let i=0;i&amp;lt;str.length;i++)&amp;#123;
            let charCode = str.charCodeAt(i);
            let binaryCharCode = charCode.toString(2);
            res += binaryCharCode.padStart(8,&amp;#39;0&amp;#39;);
        &amp;#125;
        return res;
    &amp;#125;
    //绘制
    function drawQRCode(text, canvas) &amp;#123;
      var context = canvas.getContext(&amp;quot;2d&amp;quot;);
      // 绘制黑白像素点
      for (var i = 0; i &amp;lt; text.length; i++) &amp;#123;
        var row = Math.floor(i / canvas.width);
        var col = i % canvas.width;
        var color = text.charAt(i) === &amp;quot;1&amp;quot; ? &amp;quot;#000000&amp;quot; : &amp;quot;#FFFFFF&amp;quot;;
        context.fillStyle = color; 
        context.fillRect(col, row, 1, 1);
      &amp;#125;
    &amp;#125;
    var qrcodeCanvas = document.getElementById(&amp;quot;qrcode&amp;quot;);
    drawQRCode(toBianary(&amp;#39;https://dmqweb.cn&amp;#39;), qrcodeCanvas); // 示例：绘制一个简单的二维码
  &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;复制功能实现原理&#34;&gt;&lt;a href=&#34;#复制功能实现原理&#34; class=&#34;headerlink&#34; title=&#34;复制功能实现原理&#34;&gt;&lt;/a&gt;复制功能实现原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;工具包：clipboard.js&lt;/li&gt;
&lt;li&gt;自带type定义文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;p&gt;方案一：document.execCommand()方法。内置一系列功能，包括复制文本（但&lt;strong&gt;前提是需要选中文本&lt;/strong&gt;），可以使用不可见元素迂回。&lt;/p&gt;
&lt;p&gt;方案二：Clipboard API（ navigator.clipboard ），但是对于&lt;strong&gt;浏览器兼容性有待加强。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;下载文件原理&#34;&gt;&lt;a href=&#34;#下载文件原理&#34; class=&#34;headerlink&#34; title=&#34;下载文件原理&#34;&gt;&lt;/a&gt;下载文件原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;工具包：FileSaver.js（小文件）&lt;/li&gt;
&lt;li&gt;StreamSaver.js（大文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方案一：超链接a标签添加download属性，属性值为文件名，rel属性设置打开页面的具体实现细节。（但前提是&lt;strong&gt;href属性为当前同源情况下&lt;/strong&gt;。）&lt;/p&gt;
&lt;p&gt;方案二：通过axios请求到图片地址，通过URL.createObjectURL创建为一个与document相绑定的地址，赋值给a标签即可。（不要忘记使用URL.revokeObjectURL将创建的地址移除。）&lt;/p&gt;
&lt;p&gt;方案三：通过FileReader.readAsDataURL，创建一个FileReader实例，使用readAsDataURL读取对象返回一段base64格式的字符串，监听reader实例的onload事件，创建a标签将reader.result赋值给a标签的href属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;downloadFile:function(data,fileName)&amp;#123;
   const reader = new FileReader()
   // 传入被读取的blob对象
   reader.readAsDataURL(data)
   // 读取完成的回调事件
   reader.onload = (e) =&amp;gt; &amp;#123;
       let a = document.createElement(&amp;#39;a&amp;#39;)
       a.download = fileName
       a.style.display = &amp;#39;none&amp;#39;
       // 生成的base64编码
       let url = reader.result
       a.href = url
       document.body.appendChild(a)
       a.click()
       document.body.removeChild(a)
   &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;终极解决方案：由于通过URL.createObjectURL和FileReader都会先将数据保存到内存中，业务中经常需要后端验证token之后才能拿到文件，不能直接使用a标签。因此实际中可以先发送ajax请求验证token，验证之后颁发一个过期时间短的cookie，之后使用a标签进行下载即可。但是同样会受到a标签download属性跨域请求的限制。&lt;/p&gt;
&lt;h1 id=&#34;应用部署的流程&#34;&gt;&lt;a href=&#34;#应用部署的流程&#34; class=&#34;headerlink&#34; title=&#34;应用部署的流程&#34;&gt;&lt;/a&gt;应用部署的流程&lt;/h1&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;构建&lt;/strong&gt;&lt;br&gt;Javascript语言本身是不需要编译的。&lt;br&gt;但是现代的前端项目使用的语言和或者的模块系统都无法在浏览器中使用，都需要使用特定的&lt;br&gt;bundler将源代码最终转换为浏览器支持的」avascript代码。&lt;br&gt;&lt;strong&gt;不同的环境:&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;开发环境(development) ：本地的测试环境&lt;br&gt;测试环境(test或者staging）：线上的测试环境&lt;/p&gt;
&lt;p&gt;生产环境（production)：线上的生产环境&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产和开发环境的区别&lt;/strong&gt;&lt;br&gt;*开发环境&lt;br&gt;*会添加丰富的错误提示&lt;br&gt;可以使用mock server或者本地后端环境&lt;br&gt;添加各种便利的功能-比如hot reload,自动刷新&lt;br&gt;*不太关心静态资源的大小，最好提供最丰富的调试信息(sourcemap)等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产环境&lt;/strong&gt;&lt;br&gt;稳定是最重要的原则&lt;br&gt;速度是第一要务&lt;br&gt;&lt;strong&gt;生产环境和测试环境的区别&lt;/strong&gt;&lt;br&gt;高度相似&lt;br&gt;使用的后端服务不一样&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境变量设置（按优先级）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨平台设置环境变量工具包：cross-env&lt;/li&gt;
&lt;li&gt;命令中添加环境变量（平台限制）&lt;/li&gt;
&lt;li&gt;环境变量文件中配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在项目根目录中放置下列文件来指定环境变量&lt;/strong&gt;&lt;br&gt;.env                                        #在所有的环境中被载入&lt;br&gt;.env.local                             #在所有的环境中被载入，但会被git忽略&lt;br&gt;env.[mode]                         #只在指定的模式中被载入&lt;br&gt;env.[mode].local             #只在指定的模式中被载入，但会被git忽略&lt;/p&gt;
&lt;h1 id=&#34;webpack构建优化&#34;&gt;&lt;a href=&#34;#webpack构建优化&#34; class=&#34;headerlink&#34; title=&#34;webpack构建优化&#34;&gt;&lt;/a&gt;webpack构建优化&lt;/h1&gt;&lt;h3 id=&#34;Bundler：&#34;&gt;&lt;a href=&#34;#Bundler：&#34; class=&#34;headerlink&#34; title=&#34;Bundler：&#34;&gt;&lt;/a&gt;Bundler：&lt;/h3&gt;&lt;p&gt;将浏览器不支持的模块进行编译，转换，&lt;br&gt;合并最后生成的代码可以在浏览器端良好的运行的工具。&lt;/p&gt;
&lt;h3 id=&#34;Loaders：&#34;&gt;&lt;a href=&#34;#Loaders：&#34; class=&#34;headerlink&#34; title=&#34;Loaders：&#34;&gt;&lt;/a&gt;&lt;strong&gt;Loaders：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uY2VwdHMvbG9hZGVycy8=&#34;&gt;https://webpack.docschina.org/concepts/loaders/&lt;/span&gt;&lt;br&gt;loader用于对模块的源代码进行转换。loader可以使你在import或”Ioad(加载)”模块时预处理文件。&lt;br&gt;&lt;strong&gt;多个Loader&lt;/strong&gt;&lt;br&gt;module.rules允许你在webpack配置中指定多个loader。这种方式是展示loader的一种简明方式，并且有助于使代码变得简洁和易于维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;webpack中loader配置：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;const path = require(&amp;#39;path&amp;#39;)
module.exports = &amp;#123;
    entry:&amp;#39;./main.js&amp;#39;,
    output:&amp;#123;
        path:path.resolve(dirname,&amp;#39;dist&amp;#39;),
        filename:bundle.js&amp;#39;,
    &amp;#125;
&amp;#125;,
module:&amp;#123;
    rules:[
    &amp;#123;
        test:/八.css$/,
        use: [
            loader:&amp;#39;style-loader&amp;#39;&amp;#125;,   //先写的loader后执行。
            loader:&amp;#39;css-loader&amp;#39;&amp;#125;
        ]
    &amp;#125;]
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;原理&#34;&gt;&lt;a href=&#34;#原理&#34; class=&#34;headerlink&#34; title=&#34;原理&#34;&gt;&lt;/a&gt;原理&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;webpack中loader原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 在webpack.config.js的module字段的rules数组中进行配置：添加一个对象标识一个独立的匹配项，test字段使用正则表示匹配的文件名，use数组表示对应文件需要执行的loader，webpack在打包时会&lt;strong&gt;将文件内容传入并执行对应的loader&lt;/strong&gt;（是一个函数），&lt;strong&gt;执行loader函数后会将函数返回值包装成一个新的函数&lt;/strong&gt;，因此webpack中的loader通常需要进行两次module.exports。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//手写一个md文件的loader
const marked = require(&amp;#39;marked&amp;#39;);  //第三方库，用于将md转为html
const utils = require(&amp;#39;loader-utils&amp;#39;)  //官方库，用于获取用户配置loader时传入的参数
const markdownLoader = (source) =&amp;gt; &amp;#123;
    const options = utils.getOptions(this);
    const html = marked(source , options);
    return  `module.exports = $&amp;#123;JSON.stringify(html)&amp;#125;`;
&amp;#125;
module.exports = markdownLoader;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const path = require(&amp;#39;path&amp;#39;)
module.exports = &amp;#123;
    entry:&amp;#39;./main.js&amp;#39;,
    output:&amp;#123;
        path:path.resolve(dirname,&amp;#39;dist&amp;#39;),
        filename:bundle.js&amp;#39;,
    &amp;#125;
&amp;#125;,
module:&amp;#123;
    rules:[
    &amp;#123;
        test:/八.css$/,
        use: [
            &amp;#123; loader:&amp;#39;style-loader&amp;#39; &amp;#125;,   //先写的loader后执行。
            &amp;#123; loader:&amp;#39;css-loader&amp;#39; &amp;#125;
        ]
    &amp;#125;,
    &amp;#123;
        test:/八.md$/,
        use: [
            &amp;#123; loader: &amp;#39;./markdonwn-loader&amp;#39;,options:&amp;#123; headerIds:false &amp;#125; &amp;#125; //其中options是给loader函数传入的第二个参数，loader中可以使用loader-utils官方三方库进行接受
        ]
    &amp;#125;]
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;多个Loader串联&lt;/strong&gt;&lt;br&gt;最后的loader最早调用，将会传入原始资源内容。&lt;br&gt;第一个loader最后调用，期望值是传出JavaScript和source map(可选)。&lt;br&gt;中间的loader执行时，会传入前一个loader传出的结果。&lt;br&gt;&lt;strong&gt;将markdown转换为html:turndown&lt;/strong&gt;&lt;br&gt;地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIub20vZG9tY2hyaXN0aWUvdHVybmRvd24=&#34;&gt;https://github.om/domchristie/turndown&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;plugins&#34;&gt;&lt;a href=&#34;#plugins&#34; class=&#34;headerlink&#34; title=&#34;plugins:&#34;&gt;&lt;/a&gt;&lt;strong&gt;plugins:&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uY2VwdHMvcGx1Z2lucy8=&#34;&gt;https://webpack.docschina.org/concepts/plugins/&lt;/span&gt;&lt;br&gt;插件是webpack的支柱功能。webpack自身也是构建开你在webpack配置中用到的相同的插件系统之上！插件目的在于解决loader无法实现的其他事。(我自己的理解，loader解决的是各种不同资源的问题，plugins更多解决的是项目整体的事情)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;const path = require(&amp;#39;path&amp;#39;);
const HtmlWebpackPlugin = require(&amp;#39;html-webpack-plugin&amp;#39;);
module.exports = &amp;#123;
    entry:&amp;#39;./main.js&amp;#39;,
    output:&amp;#123;
        path:path.resolve(dirname,&amp;#39;dist&amp;#39;),
        filename:bundle.js&amp;#39;,
    &amp;#125;
&amp;#125;,
module:&amp;#123;
    rules:[
    &amp;#123;
        test:/八.css$/,
        use: [
            loader:&amp;#39;style-loader&amp;#39;&amp;#125;,   //先写的loader后执行。
            loader:&amp;#39;css-loader&amp;#39;&amp;#125;
        ]
    &amp;#125;]
  &amp;#125;,
plugins:[
    new BundlesizeWebpackPlugin( &amp;#123; sizeLimit:3 &amp;#125; )  //自己手写的插件（如下）
    new webpack.ProgressPlugin(), //显示打包过程（webpack内置插件）
    new HtmlwebpackPlugin(),
]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;原理-1&#34;&gt;&lt;a href=&#34;#原理-1&#34; class=&#34;headerlink&#34; title=&#34;原理&#34;&gt;&lt;/a&gt;原理&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;webpack中plugins原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;webpack执行时会将plugins字段中的插件实例取出并将webpack实例传入并执行其&lt;strong&gt;apply方法&lt;/strong&gt;，通过webpack实例的hooks中的方法我们可以操控对应的钩子函数。&lt;/p&gt;
&lt;p&gt;官方的教程：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb250cmlidXRlL3dyaXRpbmctYS1wbHVnaW4v&#34;&gt;https://webpack.js.org/contribute/writing-a-plugin/&lt;/span&gt;&lt;br&gt;&lt;strong&gt;插件的格式&lt;/strong&gt;&lt;br&gt;一个JavaScript函数或JavaScript类&lt;br&gt;在它原型上定义的apply方法，会在安装插件时被调用，并被webpack compiler调用一次&lt;br&gt;指定一个触及到webpack本身的事件钩子，即hooks,用于特定时机处理额外的逻辑&lt;br&gt;Compiler Hooks列表&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZWJwYWNrLmlzLm9yZy9hcGkvY29tcGlsZXItaG9va3Mv&#34;&gt;https://webpack.is.org/api/compiler-hooks/&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//手写一个webpack插件，打包文件超出限制时，报错。
const &amp;#123; resolve &amp;#125; = require(&amp;#39;path&amp;#39;);
const &amp;#123; statSync &amp;#125; = require(&amp;#39;fs&amp;#39;); //fs模块中同步读取文件信息
class BundlesizeWebpackPlugin &amp;#123;
    constructor(options) &amp;#123;
        this.options = options;
    &amp;#125;
    apply(compiler) &amp;#123;
        //获取到传入的参数
        const &amp;#123; sizeLimit &amp;#125; = this.options;
        compiler.hooks.compile.tap(&amp;#39;BundleSizePlugin&amp;#39;,(compilationParams)=&amp;gt;&amp;#123; //编译时钩子,参数是参数
            console.log(&amp;#39;compile阶段&amp;#39;,compilationParams);
        &amp;#125;)
        compiler.hooks.done.tap(&amp;#39;BundleSizePlugin&amp;#39;,(stats)=&amp;gt;&amp;#123; //结束时钩子，参数是打包后的信息。
            console.log(&amp;#39;done&amp;#39;,stats); 
            //拿到打包后文件的路径和文件名
            const &amp;#123; path , filename &amp;#125; = stats.compilation.outputOptions;
            //拼接成文件路径
            const bundlePath = resolve(path,filename);
            //获取到文件size
            const &amp;#123; size &amp;#125; = statSync(bundlePath);
            const bundleSize = size / 1024;
            if(bundleSize &amp;lt; sizeLimit) &amp;#123;
                console.log(&amp;#39;Safe:Bundle-Size&amp;#39;,bundleSize,&amp;#39;\n Size Limit:&amp;#39;,sizeLimit);
            &amp;#125;else&amp;#123;
                console.error(&amp;#39;Unsafe:Bundle-Size&amp;#39;,bundleSize,&amp;#39;\n Size Limit:&amp;#39;,sizeLimit);
            &amp;#125;
        &amp;#125;) 
    &amp;#125;
&amp;#125;
module.exports = BundlesizeWebpackPlugin;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;a href=&#34;#总结&#34; class=&#34;headerlink&#34; title=&#34;总结&#34;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Loaders关注代码中的单个资源，Plugins关注整体流程，可以接触到webpack构建流程中的&lt;br&gt;各个阶段并劫持做一些代码处理。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;node后端框架&#34;&gt;&lt;a href=&#34;#node后端框架&#34; class=&#34;headerlink&#34; title=&#34;node后端框架&#34;&gt;&lt;/a&gt;node后端框架&lt;/h1&gt;&lt;h2 id=&#34;Node-js后端框架调研&#34;&gt;&lt;a href=&#34;#Node-js后端框架调研&#34; class=&#34;headerlink&#34; title=&#34;Node.js后端框架调研&#34;&gt;&lt;/a&gt;Node.js后端框架调研&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;后端框架应该注意的三大问题&lt;/strong&gt;&lt;br&gt;路由Routes&lt;br&gt;请求Request&lt;br&gt;响应Response&lt;/p&gt;
&lt;h4 id=&#34;Express&#34;&gt;&lt;a href=&#34;#Express&#34; class=&#34;headerlink&#34; title=&#34;Express&#34;&gt;&lt;/a&gt;Express&lt;/h4&gt;&lt;p&gt;官方网址：[https:l&amp;#x2F;expressis.com(https:expressis.com)&lt;br&gt;**安装**&lt;br&gt;官方网址：[&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9leHByZXNzaXMuY29tL3poLWNuL3N0YXJ0ZXIvaW5zdGFsbGluZy5odG1sXQ==&#34;&gt;https://expressis.com/zh-cn/starter/installing.html]&lt;/span&gt;(https:l&amp;#x2F;expressjs.com&amp;#x2F;zh-&lt;br&gt;cn&amp;#x2F;starter&amp;#x2F;installing.html)&lt;br&gt;使用生成器安装，可以自动生成一系列的脚手架代码：[https:&amp;#x2F;expressjs.com&amp;#x2F;zh&lt;br&gt;cn&amp;#x2F;starter&amp;#x2F;generator.htmll(&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9leHByZXNzaXMuY29tL3poLWNuL3N0YXJ0ZXIvZ2VuZXJhdG9yLmh0bWw=&#34;&gt;https://expressis.com/zh-cn/starter/generator.html&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快速简单、易上手&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由响应中，很可能有：从外部请求数据的服务，有验证路由的请求参数，返回特定的格式。&lt;/li&gt;
&lt;li&gt;所有逻辑不分青红皂白的写在一起！很容易产生冗长的难以维护的代码。&lt;/li&gt;
&lt;li&gt;一些大型必备的模块，如第三方服务初始化，安全，日志都没有明确的标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Express中间件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Express是一个基于中间件的框架，其余任务都会在中间件中执行，中间件是一个队列结构，先写入的任务先执行,中间件的写法是：app.use()，当调用中间件时，会向传入的函数中传入req,res和next函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中间件可以完成的任务&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行任何代码。&lt;/li&gt;
&lt;li&gt;对请求和响应对象进行更改。&lt;/li&gt;
&lt;li&gt;结束请求&amp;#x2F;响应循环。&lt;/li&gt;
&lt;li&gt;调用堆栈中的下一个中间件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;Koa2&#34;&gt;&lt;a href=&#34;#Koa2&#34; class=&#34;headerlink&#34; title=&#34;Koa2&#34;&gt;&lt;/a&gt;Koa2&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;官网地址&lt;/strong&gt;：[https:I&amp;#x2F;koajs.com(https:&amp;#x2F;koajs.com)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Koa2和Express的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Promise(async,await)代替callback (node&amp;gt;v7.6.0)&lt;/li&gt;
&lt;li&gt;使用ctx(上下文对象)封装req(Request)和res(Response),以及一些常用的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完全不同的中间件机制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更轻量级，没有捆绑任何中间件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;官方文章：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2tvYWpzL2tvYS9ibG9iL21hc3Rlci9kb2NzL2tvYS12cy1leHByZXNzLm1k&#34;&gt;https://github.com/koajs/koa/blob/naster/docs/koa-vs-express.md&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Koa2中间件：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Koa2中间件，由Express的队列模型（同步）转变为洋葱模型，当程序运行到&lt;code&gt;await next()&lt;/code&gt;的时候就会暂停当前程序，进入下一个中间件，处理完之后才会仔回过头来继续处理。&lt;/li&gt;
&lt;li&gt;Koa2洋葱模型解决的问题就是一个中间件可以调用其他中间件执行后，再继续自己的操作，Express框架中next()执行后就直接到下一个中间件操作，无法退回。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/images/Snipaste_2024-04-22_14-30-49.jpg&#34; alt=&#34;Koa2中间件&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const Koa = require(&amp;#39;koa&amp;#39;);
const app = new Koa();
const PORT = 3000;
app.use(async (ctx, next)=&amp;gt;&amp;#123;
    console.log(1)
    await next();
    console.log(1)
&amp;#125;);
app.use(async (ctx, next) =&amp;gt; &amp;#123;
    console.log(2)
    await next();
    console.log(2)
&amp;#125;)
app.use(async (ctx, next) =&amp;gt; &amp;#123;
    console.log(3)
&amp;#125;)
app.listen(PORT);
console.log(`http://localhost:$&amp;#123;PORT&amp;#125;`);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Koa2特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应机制的不同&lt;/li&gt;
&lt;li&gt;Express:我们直接操作的是res对象，直接res.send之后就立即响应了。&lt;/li&gt;
&lt;li&gt;Koa2:数据的响应是通过ctx.body进行设置，注意这里仅是设置并没有立即响应，而是在所有的中间件结束之后做了响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;Koa2在使用上有一定的缺点，因为太过于轻量使得在使用时需要手动处理很多操作，可以使用基于Koa2的上层框架（如：egg.js）&lt;/p&gt;
&lt;h4 id=&#34;egg-js&#34;&gt;&lt;a href=&#34;#egg-js&#34; class=&#34;headerlink&#34; title=&#34;egg.js&#34;&gt;&lt;/a&gt;egg.js&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Express和Koa2的不足&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单而且扩展性强，适合个人的比较小的项目&lt;/li&gt;
&lt;li&gt;没有约定，对于统一维护和开发非常不利&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对于后端框架的需求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要有一套优秀的统一的约定或者架构进行开发&lt;/li&gt;
&lt;li&gt;有丰富的扩展机制和可定制性&lt;/li&gt;
&lt;li&gt;Typescript支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;egg.js&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址：[https:l&amp;#x2F;eggis.org&amp;#x2F;zh-cnI(https:l&amp;#x2F;eggjs.org&amp;#x2F;zh-cn) （基于Koa2）&lt;/li&gt;
&lt;li&gt;阿里大厂出品，维护有保障。国内开发者开发，中文文档质量有保证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;约定优于配置，按照一套统一的约定进行应用开发。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个插件只做一件事，高度可扩展的插件机制&lt;/li&gt;
&lt;li&gt;支持Typescript&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;//nodejs版本10以上
npm init egg --type=ts
npm install
npm run dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;egg.js概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Application-全局应用对象，只有一个实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context-上下文对象，每次请求生成一个实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Request-请求对象，来自Koa。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Response-响应对象，来自Koa的一个新的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Helper-用来提供一些实用的utility函数。框架内置了几个简单的Helper函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;Nest-js&#34;&gt;&lt;a href=&#34;#Nest-js&#34; class=&#34;headerlink&#34; title=&#34;Nest.js&#34;&gt;&lt;/a&gt;Nest.js&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLm5lc3Rpcy5jb20v&#34;&gt;https:&amp;#x2F;docs.nestjs.com&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;内置并且完全支持Typescript&lt;/li&gt;
&lt;li&gt;开箱即用的应用程序架构&lt;/li&gt;
&lt;li&gt;可扩展，松散耦合&lt;/li&gt;
&lt;li&gt;大量采用了装饰器的写法 &lt;span class=&#34;exturl&#34; data-url=&#34;aHRwczovL2RvY3MubmVzdGlzLmNuLzgvY29udHJvbGxlcnM=&#34;&gt;https://docs.nestjs.cn/8/controllers&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vue-config-js&#34;&gt;&lt;a href=&#34;#vue-config-js&#34; class=&#34;headerlink&#34; title=&#34;vue.config.js&#34;&gt;&lt;/a&gt;vue.config.js&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;个性化构建结果-vue.config,js&lt;/strong&gt;&lt;br&gt;在基础的配置上，自定义构建的结果-可以使用vue.config.js&lt;br&gt;文档地址：https:l&amp;#x2F;cli.vuejs.org&amp;#x2F;zh&amp;#x2F;config#vue-config-js&lt;br&gt;简介两个字段&lt;br&gt;*&lt;strong&gt;PublicPath&lt;/strong&gt;-部署应用包时的基本URL,这个配置对应的是webpack的PublicPath属性&lt;br&gt;★&lt;br&gt;默认值为’&amp;#x2F;‘，Vue CLI会假设你的应用是被部署在一个域名的根路径上&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9hYmMuY29tLw==&#34;&gt;https://abc.com/&lt;/span&gt;&lt;br&gt;★&lt;br&gt;可以设置为子路径-如果你的应用被部署在https:abc,com&amp;#x2F;sub&amp;#x2F;那么就设置为’&amp;#x2F;sub’&lt;br&gt;*可以设置为CDN路径-在我们的应用中，最后静态资源是要全部上传到CDN的，（脚手&lt;br&gt;架自动完成)，所以这里可以设置为一个cDN域名-‘https:l&amp;#x2F;oss.imooc-Iego.com&amp;#x2F;editor’&lt;br&gt;*还可以设置为绝对路径(‘’或者’.&amp;#x2F;‘)，这样所有的资源都会被链接为相对路径&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;css.loaderOptions&lt;/strong&gt;属性&lt;br&gt;*向CSS相关的loader传递选项&lt;br&gt;*Ant-design-vue的样式变量：https:lww,antd,com docs&amp;#x2F;vue&amp;#x2F;customize-theme-cn&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3Z1ZUNvbXBvbmVudC9hbnQtZGVzaWduLQ==&#34;&gt;https://github.com/vueComponent/ant-design-&lt;/span&gt;&lt;br&gt;yue&amp;#x2F;blob&amp;#x2F;master&amp;#x2F;components&amp;#x2F;style&amp;#x2F;themes&amp;#x2F;default.less&lt;br&gt;*添加更多的CSS预处理器：&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbGkudnVlanMub3JnL3poL2d1aWRlL2Nzcy5odG1sIyVFOSVBMiU4NCVFNSVBNCU4NCVFNyU5MCU4NiVFNSU5OSVBOA==&#34;&gt;https://cli.vuejs.org/zh/guide/css.html#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8&lt;/span&gt;&lt;br&gt;*特别注意less和Iess-loader的版本问题。不要装最新的，建议选用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//vue.config.js配置：
const isstaging = !process.env.VUE_APP_STAGINE
const isProduction = process.env.NODE_ENV &amp;#39;production&amp;#39;
module.exports = &amp;#123;
    /生产环境要使用0SS地址
    /其他环境都使用绝对路径
    publicPath:(isProduction 6 !isStaging)&amp;#39;https://oss.imooc-lego.com/
    css:&amp;#123;
        loaderOptions:&amp;#123;
        less:&amp;#123;
            lessoptions:&amp;#123;
                modifyVars:&amp;#123;
                   &amp;#39;primary-color&amp;#39;:&amp;#39;#3E7FFF&amp;#39;,
                &amp;#125;，
                javascriptEnabled:true
            &amp;#125;
        &amp;#125;,
    configureWebpack: config =&amp;gt; &amp;#123;
        config.plugins.push(
            new webpack.IgnorePlugin(&amp;#123;        //打包时忽略对应的文件
                resourceRegExp: /^\.\/locale$/,
                contextRegExp: /moment$/,
            &amp;#125;)
        )
        if(isAnalyzeMode)&amp;#123;
            config.plugins.push(
                new BundleAnalyzerPlugin(&amp;#123;    //添加打包后的文件分析工具（BundleAnalyzerPlugin）
                    analyzerMode : &amp;#39;static&amp;#39;,
                &amp;#125;)
            )
        &amp;#125;
    &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;项目构建优化&#34;&gt;&lt;a href=&#34;#项目构建优化&#34; class=&#34;headerlink&#34; title=&#34;项目构建优化&#34;&gt;&lt;/a&gt;项目构建优化&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;好用的webpack插件:webpack-bundle-analyzer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可视化webpack打包后的工具包大小，便于分析依赖和进行项目优化。如上vue.config.js中配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据图表的优化步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、看看有没有什么重复的模块，或者没有用的模块被打包到了最终的代码中&lt;br&gt;二、看看package.json,对比一下是否有应该在devDeps的模块，被错误的放置到了deps当中&lt;br&gt;三、检查是否有重复加载的模块，或者是功能大体相同的模块。&lt;br&gt;比如：使用&lt;strong&gt;es&lt;/strong&gt;版本的第三方库，享受tree-shaking的红利。&lt;br&gt;四、检查是否有没有用的模块是否打包到了最终的文件中，通过如下插件忽略对应的文件，从而tree-shaking掉忽略的文件（如国际化需要的各种语言包）,详细配置如上vue.config.js中。&lt;/p&gt;
&lt;p&gt;*webpack ignore plugin &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZ2xwbHVnaW5zL2lnbm9yZS1wbHVnaW4vI3Jvb3Q=&#34;&gt;https://webpack.js.orglplugins/ignore-plugin/#root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将三方库中全部导入更换为按需导入&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123;Input,Dropdown,Slider,Select&amp;#125; from &amp;#39;Antd-vue&amp;#39;;
const components = [Input,Dropdown,Slider,Select];
const install = (app) =&amp;gt; &amp;#123;
    components.forEach(item=&amp;gt;&amp;#123;
        app.component(item.name,item);
    &amp;#125;)
&amp;#125;
export default&amp;#123; install &amp;#125;;
// 在main.js中导入，然后app.use
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;浏览器缓存优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、项目即使是上线之后也会在后续追加或修改代码，如果分包较少重新上线后就不能使用浏览器缓存的文件，当分包数量较多时，就可以充分利用浏览器缓存。&lt;/p&gt;
&lt;p&gt;二、分包较多时可以使用浏览器支持平行加载多个文件的特性。（HTTP1对同一域名并行请求的个数进行了限制，HTTP2完全突破了这个限制）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;手动分割第三方库为多个文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;webpack的config.optimization中自带一些优化的配置项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;minimize：压缩&lt;/li&gt;
&lt;li&gt;splitChunks：分包（可以配置minSize等）&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//vue.config.js配置：
module.exports = &amp;#123;
    // ....省略
    configureWebpack: config =&amp;gt; &amp;#123;
        config.optimization.splitChunks = &amp;#123;
            maxInitialRequests: Infinity,
            minSize: 300 * 1024,
            chunks: &amp;#39;all&amp;#39;,
            cacheGroups: &amp;#123;
                antVendor: &amp;#123;
                    name: &amp;#39;ant-design-vue&amp;#39;,
                    test: /[\\/]node_modules[\\/](ant-design-vue)[\\/]/,
                &amp;#125;,
                canvasVendor: &amp;#123;
                    name: &amp;#39;html2canvas,
                    test: /[\\/]node_modules[\\/](html2canvas)[\\/]/,
                &amp;#125;,
                vendor: &amp;#123;
                    name: &amp;#39;vendor&amp;#39;,
                    test: /[\\/]node_modules[\\/](!html2canvas)(!ant-design-vue)[\\/]/
                &amp;#125;,
                all &amp;#123;
                    test: /[\\/]node_modules[\\/]/, //匹配全部的node_modules中的文件
                    name (module) &amp;#123; const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)
                    return `npm.$&amp;#123;packageName.replace(&amp;#39;@&amp;#39;,&amp;#39;&amp;#39;)&amp;#125;`
                &amp;#125;,
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;项目运行优化&#34;&gt;&lt;a href=&#34;#项目运行优化&#34; class=&#34;headerlink&#34; title=&#34;项目运行优化&#34;&gt;&lt;/a&gt;项目运行优化&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;路由懒加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用import函数动态加载，配合魔法注释可以和webpack中的bundler相配合使用，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import(/* webpackChunkName: &amp;quot;my-lodash&amp;quot; */ &amp;#39;lodash&amp;#39;).then(lodash=&amp;gt;&amp;#123;
     // ....
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;改变HTML标题，增强SEO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目中动态添加标题的原理：使用HtmlWebpackPlugin插件，插入动态js语句进行占位，然后通过项目中package.json中的name进行替换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//vue.config.js配置：
module.exports = &amp;#123;
    // ....省略
   chainWebpack: config =&amp;gt; &amp;#123;
       config.plugin(&amp;#39;html&amp;#39;).tap(args=&amp;gt;&amp;#123;
           args[0].title = &amp;#39;网站标题&amp;#39;,
           args[0].desc = &amp;#39;网站详情描述&amp;#39;
           return args;
       &amp;#125;)
   &amp;#125;
&amp;#125;
//记得添加 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;&amp;lt;%= htmlWebpackPlugin.options.desc %&amp;gt;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同构渲染方式&lt;/strong&gt;&lt;br&gt;服务端渲染和客户端渲染的区别就在于在哪里完成html完整文件的拼接：&lt;/p&gt;
&lt;h3 id=&#34;客户端渲染&#34;&gt;&lt;a href=&#34;#客户端渲染&#34; class=&#34;headerlink&#34; title=&#34;客户端渲染&#34;&gt;&lt;/a&gt;客户端渲染&lt;/h3&gt;&lt;p&gt;客户端渲染由客户端完成html文件的拼接，服务端只负责提供数据。&lt;br&gt;优势：首屏加载快&lt;br&gt;劣势：不利于SEO&lt;/p&gt;
&lt;h3 id=&#34;服务端渲染&#34;&gt;&lt;a href=&#34;#服务端渲染&#34; class=&#34;headerlink&#34; title=&#34;服务端渲染&#34;&gt;&lt;/a&gt;服务端渲染&lt;/h3&gt;&lt;p&gt;服务端渲染由服务端完成html文件的凭借，客户端直接渲染即可&lt;br&gt;优势：利于SEO，&lt;br&gt;劣势：白屏问题（获取html文件较慢）,服务端压力大，占用CPU资源。&lt;/p&gt;
&lt;h3 id=&#34;同构渲染&#34;&gt;&lt;a href=&#34;#同构渲染&#34; class=&#34;headerlink&#34; title=&#34;同构渲染&#34;&gt;&lt;/a&gt;同构渲染&lt;/h3&gt;&lt;p&gt;服务端先通过服务端渲染，生成html以及初始化数据，客户端拿到代码和初始化数据，在客户端进行激活渲染。&lt;br&gt;优势：兼容了前端渲染的大部分优点（节省服务端资源、多终端适配渲染、局部刷新等），同时也具有服务端渲染首屏加载快，SEO支持好的特点。&lt;br&gt;劣势：服务端必须是要js支持的语言，增加了整个系统的复杂度和维护成本。&lt;/p&gt;
&lt;h1 id=&#34;部署与HTTP优化&#34;&gt;&lt;a href=&#34;#部署与HTTP优化&#34; class=&#34;headerlink&#34; title=&#34;部署与HTTP优化&#34;&gt;&lt;/a&gt;部署与HTTP优化&lt;/h1&gt;&lt;h3 id=&#34;部署&#34;&gt;&lt;a href=&#34;#部署&#34; class=&#34;headerlink&#34; title=&#34;部署&#34;&gt;&lt;/a&gt;&lt;strong&gt;部署&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;前端部署：https:llci,uejs,org&amp;#x2F;zh&amp;#x2F;guide&amp;#x2F;deployment.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原理就是：将构建生成的产物直接烤贝到任何的静态文件服务器当中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后端部署：https:&amp;#x2F;eggis.org&amp;#x2F;zh-cn&amp;#x2F;core&amp;#x2F;deployment.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几乎没有构建过程：除非你用了typescript等需要编译的语言。&lt;/p&gt;
&lt;p&gt;方案一：直接将本地的源代码打个压缩包拷贝到目标服务器，然后启动服务器。&lt;/p&gt;
&lt;p&gt;方案二：在服务器中直接pu川源代码，install,.然后启动服务器。&lt;/p&gt;
&lt;h3 id=&#34;Nginx-反向代理&#34;&gt;&lt;a href=&#34;#Nginx-反向代理&#34; class=&#34;headerlink&#34; title=&#34;Nginx:反向代理&#34;&gt;&lt;/a&gt;&lt;strong&gt;Nginx:反向代理&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;作为服务器软件，它的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特别适合前后端分离的项目&lt;/li&gt;
&lt;li&gt;保证安全&lt;/li&gt;
&lt;li&gt;非常快&lt;/li&gt;
&lt;li&gt;支持负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装nginx&lt;/li&gt;
&lt;li&gt;nginx    命令启动服务器&lt;/li&gt;
&lt;li&gt;nginx -s stop    命令关闭服务器&lt;/li&gt;
&lt;li&gt;nginx -v      命令查看配置信息&lt;/li&gt;
&lt;li&gt;nginx -s reload      命令重启服务&lt;/li&gt;
&lt;li&gt;配置nginx.conf文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;HTTP缓存&#34;&gt;&lt;a href=&#34;#HTTP缓存&#34; class=&#34;headerlink&#34; title=&#34;HTTP缓存&#34;&gt;&lt;/a&gt;&lt;strong&gt;HTTP缓存&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;（若服务器使用nginx，则在nginx.conf中配置）&lt;/p&gt;
&lt;p&gt;Expires &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0V4cGlyZXM=&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires&lt;/span&gt;&lt;br&gt;&lt;strong&gt;Expires响应头包含日期&amp;#x2F;时间，即在此时候之后，响应过期&lt;/strong&gt;&lt;br&gt;使用nginx添加对应的响应头：expires指令&lt;br&gt;文档地址：http:l&amp;#x2F;nginx.org&amp;#x2F;en&amp;#x2F;docs&amp;#x2F;http&amp;#x2F;ngx http headers module.html&lt;/p&gt;
&lt;p&gt;但是由于客户端时间和用户端时间并不总是相同的，于是有了Cache-Control：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt;:通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。&lt;br&gt;文档地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIv&#34;&gt;https://developer&lt;/span&gt; mozilla.org&amp;#x2F;zh-CN&amp;#x2F;docs&amp;#x2F;Web&amp;#x2F;HTTP&amp;#x2F;Headers&amp;#x2F;Cache-Control&lt;/p&gt;
&lt;p&gt;*&lt;strong&gt;Etag&lt;/strong&gt;:ETagHTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽&lt;br&gt;因为如果内容没有改变，Wb服务器不需要发送完整的响应，直接返回304表示可以使用缓存文件。&lt;br&gt;*文档地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0VUYWc=&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag&lt;/span&gt;&lt;br&gt;&lt;strong&gt;Last-Modified&lt;/strong&gt;:是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。&lt;br&gt;文档地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0xhc3QtTW9kaWZpZWQ=&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified&lt;/span&gt;&lt;br&gt;nginx Etag:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfY29yZV9tb2R1bGUuaHRtbCNldGFn&#34;&gt;http://nginx.org/en/docs/http/ngx_http_core_module.html#etag&lt;/span&gt;&lt;br&gt;304 Not Modified &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSElUUC9TdGF0dXMvMzA0&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HITP/Status/304&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;浏览器使用缓存：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/images/image.png&#34; alt=&#34;/images/image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;压缩算法&#34;&gt;&lt;a href=&#34;#压缩算法&#34; class=&#34;headerlink&#34; title=&#34;压缩算法&#34;&gt;&lt;/a&gt;压缩算法&lt;/h3&gt;&lt;p&gt;压缩比对照表&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9xdWl4ZGIuZ2l0aHViLmlvL3NxdWFzaC1iZW5jaG1hcmsvI3JhdGlvLXZzLWNvbXByZXNzaW9u&#34;&gt;https://quixdb.github.io/squash-benchmark/#ratio-vs-compression&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;gzip&#34;&gt;&lt;a href=&#34;#gzip&#34; class=&#34;headerlink&#34; title=&#34;gzip&#34;&gt;&lt;/a&gt;gzip&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;一、动态压缩（服务器在返回静态文件之前，由服务器对每个请求压缩后再进行输出）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx中启用gzip：在nginx.conf中配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gzip  on;        开启gzip&lt;/li&gt;
&lt;li&gt;gzip_types     text&amp;#x2F;plain  application&amp;#x2F;javascript              设置那些文件需要压缩&lt;/li&gt;
&lt;li&gt;gzip_min_length   1k;         小于设置值不会压缩&lt;/li&gt;
&lt;li&gt;gzip_comp_level     1;          压缩级别&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二、静态压缩（服务器直接使用压缩文件进行输出）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成压缩文件（gzip命令或使用webpack插件 compression-webpack-plugin）&lt;/li&gt;
&lt;li&gt;在ngin×开启支持静态压缩的模块（例如gzip_static  :  on）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;Brotli&#34;&gt;&lt;a href=&#34;#Brotli&#34; class=&#34;headerlink&#34; title=&#34;Brotli&#34;&gt;&lt;/a&gt;Brotli&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;一、动态压缩（服务器在返回静态文件之前，由服务器对每个请求压缩后再进行输出）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用前提&lt;/strong&gt;&lt;br&gt;浏览器支持：https:caniuse.com&amp;#x2F;brot山i&lt;br&gt;&lt;strong&gt;HTTPS协议&lt;/strong&gt;&lt;br&gt;NGINX对应的模块：https:&amp;#x2F;github.com&amp;#x2F;google&amp;#x2F;ngx._brot山i&lt;/p&gt;
&lt;p&gt;nginx中启用Brotli：在nginx.conf中配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brotli  on;        开启Brotli&lt;/li&gt;
&lt;li&gt;brotli_types     text&amp;#x2F;plain  application&amp;#x2F;javascript              设置那些文件需要压缩&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二、静态压缩（服务器直接使用压缩文件进行输出 ,如上。）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;HTTP优化&#34;&gt;&lt;a href=&#34;#HTTP优化&#34; class=&#34;headerlink&#34; title=&#34;HTTP优化&#34;&gt;&lt;/a&gt;HTTP优化&lt;/h3&gt;&lt;p&gt;HTTP是建立在TCP协议之上，所以&lt;strong&gt;HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性&lt;/strong&gt;，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的延迟时间。所以减少这些重新握手和至关重要。&lt;/p&gt;
&lt;h4 id=&#34;keepAlive属性&#34;&gt;&lt;a href=&#34;#keepAlive属性&#34; class=&#34;headerlink&#34; title=&#34;keepAlive属性&#34;&gt;&lt;/a&gt;keepAlive属性&lt;/h4&gt;&lt;p&gt;keepAlive属性可以保持服务器端和客户端建立的会话连接，开启之后除首次建立连接外的其他请求不会进行&lt;strong&gt;DNS Lookup&lt;/strong&gt;（NDS域名解析）和&lt;strong&gt;Initial connection&lt;/strong&gt;（三报文握手建立连接），可以在服务端文件中进行配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KeepAlive的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP连接更少，I这样就会节约TCP连接在建立、释放过程中，主机和路由器上的CPU和内存开销。&lt;/li&gt;
&lt;li&gt;网络拥塞也减少了，拿到响应的延时也减少了&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;HTTP2&#34;&gt;&lt;a href=&#34;#HTTP2&#34; class=&#34;headerlink&#34; title=&#34;HTTP2&#34;&gt;&lt;/a&gt;HTTP2&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;使用HTTP&amp;#x2F;2提升性能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2010年SPDY &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS8=&#34;&gt;https://baike&lt;/span&gt; baidu.com&amp;#x2F;item&amp;#x2F;SPDY演化到&lt;/li&gt;
&lt;li&gt;2015 HTTP&amp;#x2F;2 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIsbW96aWxsYSxvcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9IVFRQXzI=&#34;&gt;https://developer,mozilla,org/zh-CN/docs/Glossary/HTTP_2&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要浏览器支持-https:&amp;#x2F;caniuse.com&amp;#x2F;http2&lt;/p&gt;
&lt;p&gt;需要HTTPS协议支持&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、二进制协议：&lt;/p&gt;
&lt;p&gt;HTTP2由原来的文本请求（报文）转变为二进制请求帧，加快传输&lt;/p&gt;
&lt;p&gt;二、多路复用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP2多路复用解决了浏览器同一域名并行请求数量的限制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在HTTP&amp;#x2F;2中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟开一个TCP连接都需要慢慢提升传输速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同个域名只需要占用一个TCP连接&lt;/strong&gt;，使用一个连接并行发送多个请求和响应，&lt;strong&gt;消除了因多个TCP连接而带来的延时和内存消耗&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;三、Header压缩复用&lt;/p&gt;
&lt;p&gt;TTP&amp;#x2F;2在客户端和服务器端使用“&lt;strong&gt;首部表&lt;/strong&gt;”来跟踪和存储之前发送的键一值对，对于相同的数据，不再通过每次请求和响应发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置HTTP2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依nginx为例：在server字段的listen字段添加：listen   443   ssl   http2; &lt;/p&gt;
&lt;h1 id=&#34;Mongodb数据库&#34;&gt;&lt;a href=&#34;#Mongodb数据库&#34; class=&#34;headerlink&#34; title=&#34;Mongodb数据库&#34;&gt;&lt;/a&gt;Mongodb数据库&lt;/h1&gt;&lt;h3 id=&#34;基本操作&#34;&gt;&lt;a href=&#34;#基本操作&#34; class=&#34;headerlink&#34; title=&#34;基本操作&#34;&gt;&lt;/a&gt;&lt;strong&gt;基本操作&lt;/strong&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 导入Mongodb客户端构造函数
import &amp;#123; MongoClient,ObjectId, &amp;#125; from &amp;quot;mongodb&amp;quot;;
// 创建mongo实例(传入url)
const client = new MongoClient(&amp;#39;mongodb://localhost:27017/&amp;#39;);
// 执行函数，连接mongodb数据库
async function run() &amp;#123;
  try &amp;#123;
    await client.connect(); //等待实例连接
    const db = client.db(&amp;#39;hello&amp;#39;); //创建数据库
    const res = await db.command(&amp;#123; ping: 1 &amp;#125;); //ping命令
    console.log(&amp;#39;connected&amp;#39;, res);
    const userCollection = db.collection(&amp;#39;user&amp;#39;);//创建集合表
// 数据的插入
    // const result = await userCollection.insertOne(&amp;#123;name:&amp;quot;张三&amp;quot;,age:18&amp;#125;)
    // const results = await userCollection.insertMany([&amp;#123;name:&amp;quot;李四&amp;quot;,age:12&amp;#125;,&amp;#123;name:&amp;quot;王五&amp;quot;,age:13&amp;#125;]);
    // console.log(result,results); //返回影响的信息，id等
//数据的查找
    const result = await userCollection.findOne(&amp;#123;name:&amp;#39;张三&amp;#39;&amp;#125;);
    console.log(result);
    const resultCursor =  userCollection.find(); //find返回的是指针对象，不是结果
    //将游标变为数组结果
    const results = await userCollection.find().toArray();
    // console.log(results);
//比较操作符 $lt小于 $gt大于
    const results2 = await userCollection.find(&amp;#123;age:&amp;#123;$lt:16&amp;#125;&amp;#125;).toArray();
    // console.log(results2);
//逻辑操作符 $or
    const results3 = await userCollection.find(&amp;#123;$or:[&amp;#123;age:&amp;#123;$gt:12&amp;#125;&amp;#125;,&amp;#123;name:&amp;quot;王五&amp;quot;&amp;#125;]&amp;#125;).toArray();
    // console.log(results3);
//元素操作符  $exists存在与否  $type指定类型
    const results4 = await userCollection.find(&amp;#123;age:&amp;#123;$type:&amp;#39;number&amp;#39;&amp;#125;&amp;#125;).toArray();
    // console.log(results4);
//limit  第二个参数传入options配置（projection表示包含字段哪些字段）
    const result5 = await userCollection.find(&amp;#123;age:&amp;#123;$type:&amp;#39;number&amp;#39;&amp;#125;&amp;#125;,&amp;#123;limit:2,skip:3,sort:&amp;#123;age:-1&amp;#125;,projection:&amp;#123;name:0&amp;#125;&amp;#125;).toArray();
    // console.log(result5);
//更新替换数据   update更新数据  replaceOne替换数据 ,修改操作要传具体更新操作符：
//普通更新操作符： $set设置值 $inc增加 $rename重命名 $unset删除 
//数组更新操作符： $push数组字段添加 $pop删除 $all包含 $regex正则  .属性符 .$属性占位符
    const result6 = await userCollection.replaceOne(&amp;#123;name:&amp;quot;张三&amp;quot;&amp;#125;,&amp;#123;name:&amp;quot;Lebrown&amp;quot;&amp;#125;);
    const result7 = await userCollection.updateOne(&amp;#123;_id:new ObjectId(&amp;#39;6628b9876bac632e95ead1bb&amp;#39;)&amp;#125;,&amp;#123;$set:&amp;#123;name:&amp;quot;updateOne&amp;quot;&amp;#125;,$inc:&amp;#123;age:10&amp;#125;&amp;#125;);
    const result8 = await userCollection.updateOne(&amp;#123;_id: new ObjectId(&amp;#39;6628b9876bac632e95ead1bb&amp;#39;)&amp;#125;,&amp;#123;$set:&amp;#123;&amp;quot;hobbies.0&amp;quot;:&amp;quot;golf&amp;quot;&amp;#125;&amp;#125;)
    const result9 = await userCollection.updateOne(&amp;#123;_id: new ObjectId(&amp;#39;6628b9876bac632e95ead1bb&amp;#39;),hobbies:&amp;#39;glof&amp;#39;&amp;#125;,&amp;#123;$set:&amp;#123;&amp;quot;hobbies.$&amp;quot;:&amp;quot;golf-new&amp;quot;&amp;#125;&amp;#125;)
    // console.log(result8);//返回影响信息
//删除数据：deleteOne(filter) 和deleteMany
  &amp;#125; catch (e) &amp;#123;
    console.error(e);
  &amp;#125; finally &amp;#123;
    await client.close();
  &amp;#125;
&amp;#125;
run();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mongodb高级&#34;&gt;&lt;a href=&#34;#mongodb高级&#34; class=&#34;headerlink&#34; title=&#34;mongodb高级&#34;&gt;&lt;/a&gt;&lt;strong&gt;mongodb高级&lt;/strong&gt;&lt;/h3&gt;&lt;h5 id=&#34;索引&#34;&gt;&lt;a href=&#34;#索引&#34; class=&#34;headerlink&#34; title=&#34;索引&#34;&gt;&lt;/a&gt;索引&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;MongoDB索引&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引(Index)&lt;strong&gt;为了提高查询效率&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MongoDB的文件类型：&lt;strong&gt;BSON&lt;/strong&gt;,Binary JSON,主要被用作MongoDB数据库中的数据存储和网络传输格式。&lt;/li&gt;
&lt;li&gt;假如没有索引，必须扫描这个巨大BSON对象集合中的每个文档并选取那些符合查询条件的记录，这样是低效的。&lt;/li&gt;
&lt;li&gt;索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中。&lt;/li&gt;
&lt;li&gt;为某个字段创建索引之后查找速度非常快，ObjectId是自带的索引（ _ id _ ）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;创建索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建索引可以直接用Navicate等工具，也可以代码中使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//......省略
//给name字段创建索引之前耗时很大，创建之后耗时很小
const indexResult = await userCollection.find(&amp;#123;name:&amp;quot;James&amp;quot;&amp;#125;).explain();
console.log(indexResult);
//创建索引，属性表示字段，值表示升序降序
const result = await userCollection.createIndex(&amp;#123;name:1&amp;#125;) //1表示升序
//取消索引
const result1 = await userCollection.dropIndex(&amp;quot;name_1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;聚合&#34;&gt;&lt;a href=&#34;#聚合&#34; class=&#34;headerlink&#34; title=&#34;聚合&#34;&gt;&lt;/a&gt;聚合&lt;/h5&gt;&lt;p&gt;聚合操作将来自多个文档的值组合在一起，并且可以对分组数据执行各种操作以返回相应的结果。&lt;br&gt;&lt;strong&gt;linux常用的管道写法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;ps aux | grep mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;聚合常用的操作符：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$group将collection中的document:分组，可用于统计结果&lt;/li&gt;
&lt;li&gt;$natch过滤数据，只输出符合结果的文档&lt;/li&gt;
&lt;li&gt;$project修改输入文档的结构（例如重命名，增加、删除字段，创建结算结果等）&lt;/li&gt;
&lt;li&gt;$sot将结果进行排序后输出&lt;/li&gt;
&lt;li&gt;$imit限制管道输出的结果个数&lt;/li&gt;
&lt;li&gt;$skp跳过制定数量的结果，并且返回剩下的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;表达式操作符：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$sum计算总和，{$sum:1}表示返回总和×1的值（即总和的数量），使用{$sum:’$制定字段’}也能直接获取制定字段的值的总和&lt;/li&gt;
&lt;li&gt;$avg求平均值&lt;/li&gt;
&lt;li&gt;$min求min值&lt;/li&gt;
&lt;li&gt;$max求max值&lt;/li&gt;
&lt;li&gt;$push将结果文档中插入值到一个数组中&lt;/li&gt;
&lt;li&gt;$frst根据文档的排序获取第一个文档数据&lt;/li&gt;
&lt;li&gt;$last同理，获取最后一个数据&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//.....
const pipeLine = [
    &amp;#123; $match : &amp;#123; age : &amp;#123; $gt : 30 &amp;#125;&amp;#125;&amp;#125;,
    &amp;#123; $group : &amp;#123; _id : &amp;quot;$steam&amp;quot; , total : &amp;#123; $sum : &amp;quot;$age&amp;quot; &amp;#125; , count : &amp;#123; $sum : 1 &amp;#125;&amp;#125;&amp;#125;,
    &amp;#123; $sort : &amp;#123; total : 1 &amp;#125;&amp;#125;
]
cosnt result = await userCollection.aggregate(pipeLine).toArray();
//....
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;多表联查&#34;&gt;&lt;a href=&#34;#多表联查&#34; class=&#34;headerlink&#34; title=&#34;多表联查&#34;&gt;&lt;/a&gt;多表联查&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;普通方式使用多表联查需要两次查询&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 导入Mongodb客户端构造函数
import &amp;#123; MongoClient,ObjectId, &amp;#125; from &amp;quot;mongodb&amp;quot;;
// 创建mongo实例(传入url)
const client = new MongoClient(&amp;#39;mongodb://localhost:27017/&amp;#39;);
// 执行函数，连接mongodb数据库
async function run() &amp;#123;
  try &amp;#123;
    await client.connect(); //等待实例连接
    const db = client.db(&amp;#39;hello&amp;#39;); //创建数据库
    const res = await db.command(&amp;#123; ping: 1 &amp;#125;); //ping命令
    console.log(&amp;#39;connected&amp;#39;, res);
//获取表
     const teamCollection = db.collection(&amp;#39;team&amp;#39;);
     const playerCollection = db.collection(&amp;#39;player&amp;#39;);
     const netsTeam = await teamCollection.findOne(&amp;#123;team:&amp;quot;NETS&amp;quot;&amp;#125;);
     const netsPlayers = await playerCollection.find(&amp;#123;team:netsTeam._id&amp;#125;).toArray();
  &amp;#125; catch (e) &amp;#123;
    console.error(e);
  &amp;#125; finally &amp;#123;
    await client.close();
  &amp;#125;
&amp;#125;
run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用聚合中$lookup进行多表联查只需要一次查询：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//...
const pipeLine2 = [
    &amp;#123;
        $match : &amp;#123; team : &amp;#123; $exists : true &amp;#125; &amp;#125;
    &amp;#125;,
    &amp;#123;
        $lookup : &amp;#123;
            from : &amp;quot;team&amp;quot;,
            localField : &amp;quot;team&amp;quot;,
            foreignField : &amp;quot;_id&amp;quot;,
            as : &amp;quot;team&amp;quot;
        &amp;#125;
    &amp;#125;
] 
const playerWithTeam = await playerCollection.aggregate(pipeLine2).toArray();
console.log(playerWithTeam);
//...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据库设计&#34;&gt;&lt;a href=&#34;#数据库设计&#34; class=&#34;headerlink&#34; title=&#34;数据库设计&#34;&gt;&lt;/a&gt;数据库设计&lt;/h3&gt;&lt;p&gt;&lt;em&gt;MongoDB最佳设计实践：&lt;/em&gt;[https:l&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5tb25nb2RiLmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS9tb25nb2RiLXNjaGVtYS1kZXNpZ24tYmVzdC1wcmFjdGljZXMvXQ==&#34;&gt;www.mongodb.Com/developer/article/mongodb-schema-design-best-practices/]&lt;/span&gt;(&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZGV2ZWxvcGVyL2FydGljbGUvbW9uZ29kYi0=&#34;&gt;https://www.mongodb.com/developer/article/mongodb-&lt;/span&gt;&lt;br&gt;schema-design-best-practices&amp;#x2F;)&lt;/p&gt;
&lt;p&gt;  关键问题：数据产生关系的时候，选择内嵌还是引用？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内嵌模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只需要一次查询就可以查询所有的信息。&lt;/li&gt;
&lt;li&gt;避免多集合查询。&lt;/li&gt;
&lt;li&gt;只需要一个操作就可以更新多个信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;劣势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个文档太大，查询可能更耗时，获得的无关信息概率增大。&lt;/li&gt;
&lt;li&gt;针对每个文档，MongoDB有一个16M的最大限制，内嵌太多，可能超过这个限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;引用模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将数据分散到不同文档，数据量会变小。&lt;/li&gt;
&lt;li&gt;不太会超过16M最大限制。&lt;/li&gt;
&lt;li&gt;每次查询取得不必要数据的慨率降低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;劣势：需要多次查询才能获得最终数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最佳设计实践：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一对几个：推荐使用内嵌形式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一对很多：推荐使用引用形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子集合中使用一个字段保存父集合的_id   ； 或者：&lt;/li&gt;
&lt;li&gt;父集合中使用一个数组保存子集合的_id&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一对亿万：只能子集合中使用一个字段保存父集合的_id&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;访问权限管理&#34;&gt;&lt;a href=&#34;#访问权限管理&#34; class=&#34;headerlink&#34; title=&#34;访问权限管理&#34;&gt;&lt;/a&gt;&lt;strong&gt;访问权限管理&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;授权文档&lt;/strong&gt;：https:&amp;#x2F;docs.mongodb.com&amp;#x2F;manual&amp;#x2F;core&amp;#x2F;authentication&amp;#x2F;&lt;br&gt;&lt;strong&gt;内置的Roles&lt;/strong&gt;：https:&amp;#x2F;docs.mongodb.com&amp;#x2F;manual&amp;#x2F;reference&amp;#x2F;built-in-roles&amp;#x2F;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在mongo命令行中输入：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cmd&#34;&gt;show dbs
use admin
# mongodb基于RBAC进行权限管理，设置roles可以设置相应的全选，见上。
db.createUser(&amp;#123; user : &amp;#39;root&amp;#39; , pwd : &amp;#39;123456&amp;#39; , roles : [&amp;#39;root&amp;#39;] &amp;#125;) 
db.auth(&amp;#39;root&amp;#39;,&amp;#39;123456&amp;#39;)
# --auth 开启数据库的权限验证，也可以直接在mongo.conf中配置（先终止运行mongod）
mongod --config /usr/local/etc/mongo.conf --auth
# 操作配置了权限管理的数据库
mongo -u &amp;quot;root&amp;quot; -p &amp;quot;123456&amp;quot; --authenticationDatabase &amp;quot;admin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化一个新数据库以后期望的步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建admin级谜别的root用户&amp;#x2F;roles:root&lt;/li&gt;
&lt;li&gt;创建对应的数据库lego&lt;/li&gt;
&lt;li&gt;创建该数据库的管理员dmq&amp;#x2F;roles:readWrite&lt;/li&gt;
&lt;li&gt;代码中，使用管理员dmq的用户名密码链接数据库并且完成操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show dbs
use lego
db.createUser(&amp;#123; user : &amp;quot;dmq&amp;quot; , pwd : &amp;#39;123456&amp;#39; , roles : [&amp;#123; role : &amp;quot;readWrite&amp;quot; , db : &amp;quot;lego&amp;quot; &amp;#125;]&amp;#125;)
# 重启服务：mongod --config /usr/local/etc/mongo.conf --auth
# 这样在mongodb的配置文件中设置用户信息，就保证只能读取数据库信息，保证了数据库的安全。（如果用户信息来自admin数据库就需要配置authSource:&amp;#39;admin&amp;#39;。）
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;Mongoose&#34;&gt;&lt;a href=&#34;#Mongoose&#34; class=&#34;headerlink&#34; title=&#34;Mongoose&#34;&gt;&lt;/a&gt;Mongoose&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;出现的原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用原生的mongoDB nodejs driver数据结构及其操作过于灵活，类似于ORM：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mongoose：&lt;/strong&gt;（mongoose之于mongodb类似于ts之于js，都是在原有的基础之上加一层抽象层，进行类型定义等操作）&lt;/p&gt;
&lt;p&gt;mongoose：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tb25nb29zZWlzLmNvbS8=&#34;&gt;https://mongooseis.com/&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立在native mongoDB nodejs driver之上&lt;/li&gt;
&lt;li&gt;提出Modl,数据模型的概念，用来约束集合中的数据结构&lt;/li&gt;
&lt;li&gt;非常多扩展的内容&lt;/li&gt;
&lt;li&gt;它是一个ODM(Object Document Mapping)工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ORM&#34;&gt;&lt;a href=&#34;#ORM&#34; class=&#34;headerlink&#34; title=&#34;ORM&#34;&gt;&lt;/a&gt;ORM&lt;/h3&gt;&lt;p&gt;ORM指的是&lt;strong&gt;Object Relational Mapping对象关系映射&lt;/strong&gt;，针对于关系型数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单说，ORM就是通过实例对象的语法，完成关系型数据库的操作的技术。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ORM优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要再去写晦涩的SQL语句。&lt;/li&gt;
&lt;li&gt;使用面向对象的方式操作数据，代码量少，语义性好，容易理解。&lt;/li&gt;
&lt;li&gt;Classes类-Tables&lt;/li&gt;
&lt;li&gt;Objects实例-Records(表中的一行数据)&lt;/li&gt;
&lt;li&gt;Attributes属性-Records&lt;/li&gt;
&lt;li&gt;内置很多功能，数据验证，清洗，预处理等等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ODM&#34;&gt;&lt;a href=&#34;#ODM&#34; class=&#34;headerlink&#34; title=&#34;ODM&#34;&gt;&lt;/a&gt;ODM&lt;/h3&gt;&lt;p&gt;ODM指的是&lt;strong&gt;Object Document Mapping对象文档映射&lt;/strong&gt;。ODM针对于noSql数据库，关注文档模型，mongoose是ODM的一种实现，可以用于约束数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;const User = mongoose.model(&amp;quot;User&amp;quot;,&amp;#123;
    username:&amp;#123; type : string &amp;#125;,
    password:&amp;#123; type : String &amp;#125;
&amp;#125;)
//user object
const newUser new User(&amp;#123;
    username:&amp;quot;john-doe&amp;quot;,
    password:&amp;quot;helloworld&amp;quot;,
&amp;#125;)
await newUser.save()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;egg-mongoose&#34;&gt;&lt;a href=&#34;#egg-mongoose&#34; class=&#34;headerlink&#34; title=&#34;egg-mongoose&#34;&gt;&lt;/a&gt;egg-mongoose&lt;/h1&gt;&lt;p&gt;详见源码，此处省略。&lt;/p&gt;
&lt;h1 id=&#34;Stream&#34;&gt;&lt;a href=&#34;#Stream&#34; class=&#34;headerlink&#34; title=&#34;Stream&#34;&gt;&lt;/a&gt;Stream&lt;/h1&gt;&lt;h3 id=&#34;介绍&#34;&gt;&lt;a href=&#34;#介绍&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Stream的官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ub2RlanMsb3JnL2FwaS9zdHJlYW0uaHRtbA==&#34;&gt;https://nodejs,org/api/stream.html&lt;/span&gt;&lt;br&gt;&lt;strong&gt;流是Node.js中最好，也是最容易误解的慨念&lt;/strong&gt;&lt;br&gt;流就是数据的合集，数据可以是字符串也可以是数组，流的数据不是一次性全部获得的。&lt;/p&gt;
&lt;p&gt;大文件输出方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接读取&lt;/p&gt;
&lt;p&gt;输入的文件————读取到内存—————-输出文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流式读取&lt;/p&gt;
&lt;p&gt;输入的文件————通过可读流读取到管道—————–通过可写流输出文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Node.js支持流的内置模块：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Readable Streams:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP responses,on the client&lt;/li&gt;
&lt;li&gt;HTTP requests,on the server&lt;/li&gt;
&lt;li&gt;fs read streams&lt;/li&gt;
&lt;li&gt;zlib streams&lt;/li&gt;
&lt;li&gt;crypto streams&lt;/li&gt;
&lt;li&gt;TCP sockets&lt;/li&gt;
&lt;li&gt;child process stdout and stderr&lt;/li&gt;
&lt;li&gt;process.stdin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Writable  Streams:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP requests,on the client&lt;/li&gt;
&lt;li&gt;HTTP responses,on the server&lt;/li&gt;
&lt;li&gt;fs write streams&lt;/li&gt;
&lt;li&gt;zlib streams&lt;/li&gt;
&lt;li&gt;crypto streams&lt;/li&gt;
&lt;li&gt;TCP sockets&lt;/li&gt;
&lt;li&gt;child process stdin&lt;/li&gt;
&lt;li&gt;process.stdout,process.stderr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;流的类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Readable-可读操作。&lt;/li&gt;
&lt;li&gt;Vritable-可写操作。&lt;/li&gt;
&lt;li&gt;Duplex-可读可写操作. &lt;/li&gt;
&lt;li&gt;Transform-操作被写入数据，然后读出结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pipe&#34;&gt;&lt;a href=&#34;#pipe&#34; class=&#34;headerlink&#34; title=&#34;pipe&#34;&gt;&lt;/a&gt;pipe&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;流的流动：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可读流Readable（数据源input）———————-pipe管道—————————————-可写流Writable（输出output）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; createReadStream, createWriteStream &amp;#125; from &amp;#39;fs&amp;#39;;
const readStream = createReadStream(&amp;#39;./a.txt&amp;#39;);
readStream.pipe(process.stdout);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可读流Readable（数据源input）————-pipe管道—————转换流Transform—————-pipe管道———–可写流Writable（输出output）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; createReadStream, createWriteStream, write &amp;#125; from &amp;#39;fs&amp;#39;;
const readStream = createReadStream(&amp;#39;./a.txt&amp;#39;);
const writeStream = createWriteStream(&amp;#39;./b.txt&amp;#39;);
readStream.pipe(writeStream);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;原理-2&#34;&gt;&lt;a href=&#34;#原理-2&#34; class=&#34;headerlink&#34; title=&#34;原理&#34;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;流是基于EventEmitter（事件），pipe方法是基于事件封装的的语法糖，常见的事件有：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Readable  Streams：可读流事件和函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Events&lt;ul&gt;
&lt;li&gt;data–当没有数据时触发&lt;/li&gt;
&lt;li&gt;end–没有更多的数据可读时触发&lt;/li&gt;
&lt;li&gt;error–在接受和写入过程中发生错误时触发&lt;/li&gt;
&lt;li&gt;finish–所有数据已被写入到底层系统时触发&lt;/li&gt;
&lt;li&gt;close&lt;/li&gt;
&lt;li&gt;readable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functions&lt;ul&gt;
&lt;li&gt;pipe() , unpipe()&lt;/li&gt;
&lt;li&gt;read() , unshift() , resume()&lt;/li&gt;
&lt;li&gt;pause() , isPaused()&lt;/li&gt;
&lt;li&gt;setEncoding()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Writable  Streams：写入流事件和函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Events&lt;ul&gt;
&lt;li&gt;drain&lt;/li&gt;
&lt;li&gt;finish&lt;/li&gt;
&lt;li&gt;error&lt;/li&gt;
&lt;li&gt;close&lt;/li&gt;
&lt;li&gt;pipe&amp;#x2F;unpipe&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functions&lt;ul&gt;
&lt;li&gt;write()&lt;/li&gt;
&lt;li&gt;end()&lt;/li&gt;
&lt;li&gt;cork() , uncork()&lt;/li&gt;
&lt;li&gt;setDefaultEncoding()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;pipe方法原理：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; createReadStream , createWriteStream &amp;#125; from &amp;#39;fs&amp;#39;;
const readStream = createReadStream(&amp;#39;./a.txt&amp;#39;);
const writeStream = createWriteStream(&amp;#39;./b.txt&amp;#39;);
readStream.on(&amp;#39;data&amp;#39; , chunk=&amp;gt;&amp;#123;
    writeStream.write(chunk);
&amp;#125;)
readStream.on(&amp;#39;end&amp;#39;,()=&amp;gt;&amp;#123;
    writeStream.end();
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;压缩：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; createReadStream , createWriteStream &amp;#125; from &amp;#39;fs&amp;#39;;
import &amp;#123; createGzip &amp;#125; from &amp;#39;zlib&amp;#39;;
const readStream = createReadStream(&amp;#39;./a.txt&amp;#39;);
const writeStream = createWriteStream(&amp;#39;./b.txt&amp;#39;);
readStream.pipe(createGzip()).pipe(writeStream);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;封装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;cosnt savePromise = (readStream , writeStream = stdout)&amp;#123;
    return new Promise(resolve,reject)&amp;#123;
        readStream
            .pipe(writeStream)
            .on(&amp;#39;finish&amp;#39;,resolve)
            .on(&amp;#39;error&amp;#39;,reject)
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pipeline&#34;&gt;&lt;a href=&#34;#pipeline&#34; class=&#34;headerlink&#34; title=&#34;pipeline&#34;&gt;&lt;/a&gt;pipeline&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;使用pipe方法有时会存在一个问题：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//....
createReadStream(&amp;#39;./a.txt&amp;#39;)
    .pipe(stdout)
    .on(&amp;#39;finish&amp;#39;,finishFn)
    .on(&amp;#39;error&amp;#39;,errFn);  //这里监听的是pipe后的错误，对于createReadStream的错误则会卡死
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;于是推出了pipeline方法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//...
pipeLine(fs.createReadStream(&amp;#39;./a.txt&amp;#39;),zlib.createGzip(),fs.createWriteStream(&amp;#39;./b.txt&amp;#39;),(err)=&amp;gt;&amp;#123;
    if (err) &amp;#123; console.error(&amp;#39;pipeline failed&amp;#39;,error) &amp;#125;;
    else &amp;#123; console.log(&amp;#39;successed&amp;#39;) &amp;#125;
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;对象存储服务&#34;&gt;&lt;a href=&#34;#对象存储服务&#34; class=&#34;headerlink&#34; title=&#34;对象存储服务&#34;&gt;&lt;/a&gt;对象存储服务&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;自己完成静态文件存储的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nod.js不擅长处理静态文件的存储和展示，没有未静态文件做特殊的优化&lt;/li&gt;
&lt;li&gt;如果将图片生成多种处理格式要耗费大量的资源和空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;各三方比对&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;阿里云OSS&#34;&gt;&lt;a href=&#34;#阿里云OSS&#34; class=&#34;headerlink&#34; title=&#34;阿里云OSS&#34;&gt;&lt;/a&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0Li9vc3M=&#34;&gt;阿里云OSS&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持丰富的图片处理&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnQuX2RldGFpbC80NDY4Ni5odG1s&#34;&gt;https://help.aliyun.com/document._detail/44686.html&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;egg.js有对应的插件：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1vc3M=&#34;&gt;https://github.com/eggjs/egg-oss&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;价格&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下行流量100GB一年352元&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jb21tb24tYnV5LmFsaXl1bi5jb20vP3NwbT01MTc2Ljc5MzM2OTEuSl81MjUzNzg1MTYwLjEuMmUzOTRjNTlxM0ZJc0EmY29tbW9kaXR5Q29kZT1vc3NiYWcjL2J1eQ==&#34;&gt;https://common-buy.aliyun.com/?spm=5176.7933691.J_5253785160.1.2e394c59q3FIsA&amp;amp;commodityCode=ossbag#/buy&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;基本图片处理：每月0-10TB:免费&amp;gt;10TB:0.025元&amp;#x2F;GB&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七牛云KODO&#34;&gt;&lt;a href=&#34;#七牛云KODO&#34; class=&#34;headerlink&#34; title=&#34;七牛云KODO&#34;&gt;&lt;/a&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucWluaXUuY29tL3ByaWNlcy9rb2Rv&#34;&gt;七牛云KODO&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多媒体处理功能非常丰富&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZ2luaXUuY29tL3Byb2R1Y3RzL2RvcmE=&#34;&gt;https://www.giniu.com/products/dora&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;图片视频处理&lt;/li&gt;
&lt;li&gt;审核&lt;/li&gt;
&lt;li&gt;人工智能分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;价格：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外网流出100GB-年278.4元&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9xbWFsbC5xaW5pdS5jb20vdGVtcGxhdGUuL01URXk/c3BlY19jb21ibz1NekUwTlE=&#34;&gt;https://qmall.qiniu.com/template./MTEy?spec_combo=MzE0NQ&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;基本图片处理：每月0-20TB:免费20TB以上：0.025元&amp;#x2F;GB https:&amp;#x2F;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5xaW5pdS5jb20vcHJpY2VzL2RvcmE=&#34;&gt;www.qiniu.com/prices/dora&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;腾讯云COS&#34;&gt;&lt;a href=&#34;#腾讯云COS&#34; class=&#34;headerlink&#34; title=&#34;腾讯云COS&#34;&gt;&lt;/a&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzQzNg==&#34;&gt;腾讯云COS&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图像处理有一些新的亮点，比如自研的TPG压缩等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;价格：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外网流出100GB一年396元&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9idXkuY2xvdWQudGVuY2VudC4uY29tL3ByaWNlL2NvcyN0YWIwLWxpc3Qx&#34;&gt;https://buy.cloud.tencent..com/price/cos#tab0-list1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;基本图片处理：每月0-20TB:免费20TB以上：0.025元&amp;#x2F;GB&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzEyNDYvNDUyNzQ=&#34;&gt;https://cloud.tencent.com/document/product/1246/45274&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;图片压缩：1元&amp;#x2F;千次&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;SSR服务端渲染&#34;&gt;&lt;a href=&#34;#SSR服务端渲染&#34; class=&#34;headerlink&#34; title=&#34;SSR服务端渲染&#34;&gt;&lt;/a&gt;SSR服务端渲染&lt;/h1&gt;&lt;h3 id=&#34;介绍-1&#34;&gt;&lt;a href=&#34;#介绍-1&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;SSR-Server Side Rendering&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vue关于SSR的介绍：https:&amp;#x2F;sSr.uejs.org&amp;#x2F;zh&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSR的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更好的SEO&lt;/li&gt;
&lt;li&gt;更快的渲染时间(Time to content)，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SSR的缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开发的限制，浏览器相关的操作只能在特定的钩子函数中使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SPA应用完全静态化，而SSR app需要Node.js Server才能运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务端负荷更高&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SSR的实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本原理：@vue&amp;#x2F;server-renderer https:lv3.uejs.org&amp;#x2F;guide&amp;#x2F;ssr&amp;#x2F;getting-started.html#installation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用createSSRApp,renderToString以及renderToStream方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;成熟的，大而全的SSR通用开发框架：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nuxt.js &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9udXh0anMub3JnLw==&#34;&gt;https://nuxtjs.org/&lt;/span&gt;  （Vue）&lt;/li&gt;
&lt;li&gt;React类似的Next.js https:&amp;#x2F;nextjs.orgl （React）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;SSR&#34;&gt;&lt;a href=&#34;#SSR&#34; class=&#34;headerlink&#34; title=&#34;SSR&#34;&gt;&lt;/a&gt;SSR&lt;/h3&gt;&lt;p&gt;express等框架的res.render方法可以渲染html模板，使用的是nunjucks库进行数据填充。&lt;/p&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html class=&amp;quot;no-js&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;&amp;#123;&amp;#123; desc &amp;#125;&amp;#125;&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body style=&amp;quot;&amp;#123;&amp;#123; bodyStyle &amp;#125;&amp;#125;&amp;quot;&amp;gt;  //根据传入的props动态添加style样式
    &amp;#123;&amp;#123; html | safe &amp;#125;&amp;#125;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.js  (依据express框架为例：)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//...res是响应参数
res.render(&amp;#39;index&amp;#39;,function(err,html)&amp;#123;
    res.send(html);
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;vue中SSR&#34;&gt;&lt;a href=&#34;#vue中SSR&#34; class=&#34;headerlink&#34; title=&#34;vue中SSR&#34;&gt;&lt;/a&gt;vue中SSR&lt;/h3&gt;&lt;p&gt;1、vue3有包：@vue&amp;#x2F;server-renderer，在3.2.13版本以上内置了，低于此版本需要自行安装。&lt;/p&gt;
&lt;p&gt;2、使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;//.......... res是服务端返回
import &amp;#123; pipeline &amp;#125; from &amp;#39;stream/promises&amp;#39;;
import &amp;#123; createSSRApp &amp;#125; from &amp;#39;vue&amp;#39;;
import &amp;#123; renderToString , renderToNodeStream &amp;#125; from &amp;#39;@vue/server-renderer&amp;#39;
const vueApp = createSSRApp(&amp;#123;
    data:()=&amp;gt;&amp;#123; msg:&amp;#39;hello world&amp;#39; &amp;#125;,
    template: &amp;#39;&amp;lt;h1&amp;gt;&amp;#123;&amp;#123; msg &amp;#125;&amp;#125;&amp;lt;/h1&amp;gt;&amp;#39;
&amp;#125;)
const appContent = await renderToString(vueApp);
res.type = &amp;#39;text/html&amp;#39;;
res.body = appContent;
// 或者使用流式输出：
const stream = renderToNodeStream(vueApp);
res.statys = 200;
await pipeline(stream,res);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;RBAC权限验证&#34;&gt;&lt;a href=&#34;#RBAC权限验证&#34; class=&#34;headerlink&#34; title=&#34;RBAC权限验证&#34;&gt;&lt;/a&gt;RBAC权限验证&lt;/h1&gt;&lt;h3 id=&#34;介绍-2&#34;&gt;&lt;a href=&#34;#介绍-2&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;权限验证的场景以及需求：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特定的角色的用户才能操作特定的资源&lt;/li&gt;
&lt;li&gt;不同的用户能操作同类资源的特定实体&lt;/li&gt;
&lt;li&gt;不同的用户操作特定资源的不同属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;谁(User)拥有什么权限(Authority）去操作(Operation)哪些资源(Resource)&lt;/strong&gt;&lt;br&gt;根据角色完成权限的控制-RBAC(role based access control)，其实就是在原本用户——-权限的对应关系之上加一层中间层角色：用户——角色—–权限。好处是使得用户和权限的对应关系更加清晰和易于掌控。&lt;/p&gt;
&lt;h3 id=&#34;使用&#34;&gt;&lt;a href=&#34;#使用&#34; class=&#34;headerlink&#34; title=&#34;使用&#34;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;Node.js实现RBAC的库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL29udXJ5L2FjY2Vzc2NvbnRyb2w=&#34;&gt;AccessControl.js（不推荐，不维护了）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.6k Star&lt;/li&gt;
&lt;li&gt;3年没有更新，很多issue没人处理&lt;/li&gt;
&lt;li&gt;不支持ts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2Nhc2Jpbi9ub2RlLWNhc2Jpbg==&#34;&gt;Casbin&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.7k Star&lt;/li&gt;
&lt;li&gt;ts编写，支持多种编程语言&lt;/li&gt;
&lt;li&gt;概念比较复杂，使用略繁琐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3N0YWxuaXkvY2FzbA==&#34;&gt;Casl&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;3.4k Star&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ts编写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简单易用，可读性良好&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Casl使用&#34;&gt;&lt;a href=&#34;#Casl使用&#34; class=&#34;headerlink&#34; title=&#34;Casl使用&#34;&gt;&lt;/a&gt;&lt;strong&gt;Casl使用&lt;/strong&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; AbilityBuilder , Ability &amp;#125; from &amp;#39;@casl/ability&amp;#39;;
class Work &amp;#123;
    constructor(attrs)&amp;#123;
        Object.assign(this,attrs);
    &amp;#125;
&amp;#125;
const templateWork = new Work(&amp;#123; id : 1 , isTemplate : true &amp;#125;);
const notWork = new Work(&amp;#123; id : 2 , isTemplate : false &amp;#125;);
function defineRules()&amp;#123;
    const &amp;#123; can , cannot ,build &amp;#125; = new AbilityBuilder(Ability);
    can(&amp;#39;read&amp;#39;,&amp;#39;Work&amp;#39;);
    cannot(&amp;#39;delete&amp;#39;,&amp;#39;Work&amp;#39;);
    can(&amp;#39;update&amp;#39;,&amp;#39;Work&amp;#39;,&amp;#123;isTemplate:false&amp;#125;);
    return build();
&amp;#125;
console.log(templateWork.constructor.name)
const rules defineRules()
console.log(rules.can(&amp;#39;read&amp;#39;,&amp;#39;Work&amp;#39;))
console.log(rules.can(&amp;#39;delete&amp;#39;,&amp;#39;Work&amp;#39;))
console.log(rules.can(&amp;#39;update&amp;#39;,templateWork))
console.log(rules.can(&amp;#39;update&amp;#39;,notWork))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;部署-1&#34;&gt;&lt;a href=&#34;#部署-1&#34; class=&#34;headerlink&#34; title=&#34;部署&#34;&gt;&lt;/a&gt;部署&lt;/h1&gt;&lt;h3 id=&#34;传统模式&#34;&gt;&lt;a href=&#34;#传统模式&#34; class=&#34;headerlink&#34; title=&#34;传统模式&#34;&gt;&lt;/a&gt;传统模式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;本地开发&lt;/strong&gt;&lt;br&gt;使用egg-bin https:github.com&amp;#x2F;eggjs&amp;#x2F;egg-bin,提供了便捷的方式在本地进行开发、调试、单元测试，它可以自动的监控文件的修改，然后重新运行对应的命令。&lt;br&gt;采用的配置文件是：config.default.ts&lt;br&gt;启动开发环境命令为&lt;code&gt;egg-bin dev&lt;/code&gt;&lt;br&gt;&lt;strong&gt;生产环境运行程序&lt;/strong&gt;&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wbTIua2V5bWV0cmljcy5pby8=&#34;&gt;pm2-process manager&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node script.js pm2 start script.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PM2的优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cluster模式运行&lt;/li&gt;
&lt;li&gt;自动重启auto reload&lt;/li&gt;
&lt;li&gt;热替换hot reload&lt;/li&gt;
&lt;li&gt;性能监控Monitoring&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;egg.js中有对应于PM2的内置方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1zY3JpcHRz&#34;&gt;egg-scripts&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1jbHVzdGVy&#34;&gt;egg-cluster&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;egg.js生产环境启动和关闭&lt;/strong&gt;&lt;br&gt;&lt;code&gt;egg-scripts start egg-scripts stop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件&lt;/strong&gt;&lt;br&gt;config.prod.ts config.default.ts&lt;br&gt;&lt;strong&gt;编译过程&lt;/strong&gt;&lt;br&gt;需要手动将ts转换为js,借助&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3doeGF4ZXMvZWdnLXRzLWhlbHBlcg==&#34;&gt;ets&lt;/span&gt;&lt;br&gt;&lt;code&gt;特别注意将项目中的typscript版本升级到4.4.3 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm run tsc&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;Cluster模型&#34;&gt;&lt;a href=&#34;#Cluster模型&#34; class=&#34;headerlink&#34; title=&#34;Cluster模型&#34;&gt;&lt;/a&gt;Cluster模型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Egg.js Cluster模型的原理&lt;/strong&gt;&lt;br&gt;Egg.js关于这部分内容的文档：https:l&amp;#x2F;eggjs.org&amp;#x2F;zh-cn&amp;#x2F;core&amp;#x2F;cluster-and-ipc.html&lt;br&gt;&lt;strong&gt;为什么要采用Cluster模式&lt;/strong&gt;&lt;br&gt;JavaScript代码是运行在单线程上的，那么如果用Node.js来做Web Server,就无法享受到多核运算的好处。&lt;br&gt;&lt;strong&gt;什么是Cluster模式&lt;/strong&gt;&lt;br&gt;文档：http:l&amp;#x2F;nodejs.cn&amp;#x2F;api&amp;#x2F;cluster.html&lt;/p&gt;
&lt;p&gt;Node.jS的单个实例在单个线程中运行。为了利用多核系统，用户有时会想&lt;br&gt;要启动Node.js进程的集群来处理负载。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在服务器上同时启动多个进程&lt;/li&gt;
&lt;li&gt;每个进程里都跑的是同一份源代码（将一个进程的工作分给多个进程去做）&lt;/li&gt;
&lt;li&gt;这些进程可以同时监听一个端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Cluster的运行模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Request————-master_process主进程———————workers进程（多个）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程间通信（IPC）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUExJThDJUU3JUE4JThCJUU5JTk2JTkzJUU5JTgwJTlBJUU4JUE4JThB&#34;&gt;IPC Inter-Process Communication&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;IPC指的是至少两个进程或线程间传送数据或信号的一些技术或者方法，Node.js将其封装为基于事件的形式便于使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cluster使用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import http from &amp;#39;http&amp;#39;;
import cluster from &amp;#39;cluster&amp;#39;;
import &amp;#123; cpus &amp;#125; from &amp;#39;os&amp;#39;;
import process from &amp;#39;process&amp;#39;;
if(cluster.isPrimary)&amp;#123;
    console.log(`master $&amp;#123;process.pid&amp;#125; running`);
    const cpuLength = cpus().length;
    for(let i = 0 ; i &amp;lt; cpuLength ; i++)&amp;#123;
        cluster.fork();
    &amp;#125;
    cluster.on(&amp;#39;exit&amp;#39;,(worker)=&amp;gt;&amp;#123;
        console.log(`worker $&amp;#123;worker.process.pid&amp;#125; exited`);
    &amp;#125;)
&amp;#125;else&amp;#123;
    http.createServer((req,res)=&amp;gt;&amp;#123;
        res.writeHead(200);
        res.end(&amp;quot;hello world&amp;quot;);
    &amp;#125;).listen(8000);
    console.log(`worker $&amp;#123;process.pid&amp;#125; started`);
    console.log(cluster.workers); //获得子进程，可以通过process.send和on(&amp;#39;message&amp;#39;)事件进行进程间通信。
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;egg.js中对于Cluster的二次封装：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用egg-scripts启动master process&lt;/li&gt;
&lt;li&gt;使用egg-cluster启动和CPU核数相等的app_worker process&lt;/li&gt;
&lt;li&gt;使用egg-cluster启动的一个独特的agent_.worker process&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程守护&lt;/strong&gt;&lt;br&gt;考虑到生产环境的健壮性，必须保证进程异常的情况下怎样处理。&lt;br&gt;&lt;strong&gt;当代码抛出异常并没有被捕获的时候，worker使用process.on(‘uncaughtException’,handler)来捕获对应的错误，这时进程处于不确定的状态，需要优雅退出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统异常&lt;/strong&gt;&lt;br&gt;而当一个进程出现异常导致crash或者被系统杀死时，不像未捕获异常发生时我们还有机会让进程继续执行，Master立刻fork一个新的Worker。&lt;br&gt;&lt;strong&gt;Agent机制&lt;/strong&gt;&lt;br&gt;有一些特殊性质的工作，不能多个worker一起合作，容易造成混乱。对于这种工作egg.js提供了一个新的agent进程来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Egg.js三种进程的总结：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;进程数量&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;稳定性&lt;/th&gt;
&lt;th&gt;是否运行业务代码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Master进程&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;进程管理，进程间消息转发&lt;/td&gt;
&lt;td&gt;非常高&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Agent进程&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;后台运行工作&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;少量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Workers进程&lt;/td&gt;
&lt;td&gt;CPU核数&lt;/td&gt;
&lt;td&gt;执行业务代码&lt;/td&gt;
&lt;td&gt;一般&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Cluster模型和Node多进程的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cluster模块可以将一个node进程分裂成多个子进程，每个子进程独立运行在cpu内核上，以提升应用程序的并发能力和性能，通过主进程和子进程之间的通信来实现负载均衡，处理并发请求。&lt;/li&gt;
&lt;li&gt;node多进程使用child_process模块，其不具备负载均衡和通信机制，需要自行实现进程间通信和负载均衡逻辑。可用于处理长时操作，返回结果给主进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Node.js压力测试工具：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模拟高并发场景：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9hZHRlc3Q=&#34;&gt;Loadtest&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# n                   总过发送多少个请求
# c concurrency       同时有几个客户端在发送请求
# rps request per seconds   每秒发送多少个请求
loadtest -n 400 -c 10 --rps 200 http://mysite.com/ 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;云服务器&#34;&gt;&lt;a href=&#34;#云服务器&#34; class=&#34;headerlink&#34; title=&#34;云服务器&#34;&gt;&lt;/a&gt;云服务器&lt;/h1&gt;&lt;h4 id=&#34;购买&#34;&gt;&lt;a href=&#34;#购买&#34; class=&#34;headerlink&#34; title=&#34;购买&#34;&gt;&lt;/a&gt;购买&lt;/h4&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L2Vjcw==&#34;&gt;阿里云ECS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9wcm9kdWN0L2N2bQ==&#34;&gt;腾讯云CVM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;价格（学生优惠）：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9hY3QvY2FtcHVzP2Zyb209MTQ1OTk=&#34;&gt;https://cloud.tencent.com/act/campus?from=14599&lt;/span&gt; 12G 38&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuaHVhd2VpY2xvdWQuY29tL3Byb2R1Y3QvZWNzLmh0bWw=&#34;&gt;华为云ECS&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;登录&#34;&gt;&lt;a href=&#34;#登录&#34; class=&#34;headerlink&#34; title=&#34;登录&#34;&gt;&lt;/a&gt;登录&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;为什么使用root登录时一个不好的实践&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有非常多的bot会尝试使用root+pwd的ssh方式暴力登录机器，当尝试成功以后，黑客就会控制整个系统。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;假如使用特定用户名+pwd,bot需要先猜测用户名(N次)，然后是密码(M次)，这样复杂度提升到N&lt;/em&gt;M&lt;/li&gt;
&lt;li&gt;root可以造成更大的危害，影响整个系统，而某个特定用户只能影响它的文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;创建一个用户账号进行登录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 远程登录
ssh root@xxx.xx.xx.xx
# 添加用户以及设置密码
adduser dmq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;设置该用户拥有sudo权限，给予它在登录以后切换到root的能力&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 修改权限，u表示所有者，w表示写权限+表示添加
chmod u+w /etc/sudoers
# 编辑文件
vim /etc/sudoers
# 找到  `root ALL=(ALL)  ALL`
# 再加一行  `dmq ALL=(ALL)  ALL`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用新用户登录并且测试权限&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;ssh dmq@xxx.xx.xx.xx
# 可以使用 su 直接切换为root用户
# 也可以使用sudo快捷的使用root权限进行操作
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;禁止使用root远程登录ssh&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 修改ssh配置
vim /etc/ssh/sshd_config I
# 修改yes为no
PermitRootLogin no
# 重启sshd服务
service sshd restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可选：不使用密码登录&lt;/strong&gt;&lt;br&gt;为什么使用密码登录有时候是一个不好的实践？&lt;br&gt;&lt;strong&gt;非常简单：用户经常使用非常错误（简单的）用户密码，全球最常用的密码是123456以及bc123,而且用户会在多个账户大量重复使用，所以黑客从别的地方盗取的密码很可能在其他账户也可以使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用SSH kev讲行登录&lt;/strong&gt;&lt;br&gt;SSH key采角了经典的非对称加密技术，可以使用工具创建一个公钥和私钥，你可以将公钥放置在任何的服务器当中，在本地保留私钥。在ssh登录的时候，SSH验证公钥和私钥的合法性，当合法的时候，就可以免密码登录了。证书由1024Bits到4096Bits（128到512字符)的随机字符组成，&lt;br&gt;要比你自己的密码安全的多。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;#创建ssh key pair
ssh-keygen -t rsa -b 4096 -C &amp;quot;your email@example.com&amp;quot;
windows可以使用putty或者git scma软件生成，备注网址：
https://www.jianshu.com/p/95262f5eba7a
# 本地ssh证书的位置
-/.ssh/id rsa
-/.ssh/id rsa.pub
# 登录远程机器
ssh viking@xxx.xx.xx.xx
# 创建受信任的登录密钥
# 这个文件当中的公钥会被当前的主机设置为信任方
touch -/.ssh/authorized keys
# 将id rsa.pub的文本内容黏贴进来
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可选，关闭密码登录服务器的功能&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash#修改ssh配置&#34;&gt;vim /etc/ssh/sshd config
#修改为no
PasswordAuthentication no
#重启服务
service sshd i restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;使用-1&#34;&gt;&lt;a href=&#34;#使用-1&#34; class=&#34;headerlink&#34; title=&#34;使用&#34;&gt;&lt;/a&gt;使用&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;准备云服务器必备软件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nodejs (16)&lt;/li&gt;
&lt;li&gt;MongoDB&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux发行版的两大家族&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Debian(完全免费的Linux发行版)-Ubuntu(基于Debian,更加容易上手)-apt包管理系统-软件格式为deb包大&lt;/li&gt;
&lt;li&gt;Red Hat(商用Linux发行版)-CentOS(Red Hat减去收费软件)-yum包管理系统-软件格式为rpm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;软件安装&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;安装Node.js&lt;/strong&gt;&lt;br&gt;1安装nvm管理node版本&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=&#34;&gt;https://github.com/nvm-sh/nvm&lt;/span&gt;&lt;br&gt;2使用包管理器安装node最新版本&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL25vZGVzb3VyY2UvZGlzdHJpYnV0aW9ucy9ibG9iL21hc3Rlci9SRUFETUUubWQjZGVi&#34;&gt;https://github.com/nodesource/distributions/blob/master/README.md#deb&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装MongoDB&lt;/strong&gt;&lt;br&gt;1从源代码下载安装，回顾之前的内容&lt;br&gt;2使用包管理器安装&lt;br&gt;Ubuntu:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC90dXRvcmlhbC9pbnN0YWxsLW1vbmdvZGItb24tdWJ1bnR1Lw==&#34;&gt;https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/&lt;/span&gt;&lt;br&gt;Centos:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC90dXRvcmlhbC9pbnN0YWxsLW1vbmdvZGItb24tcmVkLWhhdC8=&#34;&gt;https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Redis&lt;/strong&gt;&lt;br&gt;*1从源代码下载安装，回顾之前的基础知识&lt;br&gt;*2使用包管理器安装&lt;br&gt;CentOS:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1pbnN0YWxsLXNlY3VyZS1yZWRpcy1jZW50b3MtNw==&#34;&gt;https://www.digitalocean.com/community/tutorials/how-to-install-secure-redis-centos-7&lt;/span&gt;&lt;br&gt;Ubuntu:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1pbnN0YWxsLWFuZC1zZWN1cmUtcmVkaXMtb24tdWJ1bnR1LTE4LTA0&#34;&gt;https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;管理&#34;&gt;&lt;a href=&#34;#管理&#34; class=&#34;headerlink&#34; title=&#34;管理&#34;&gt;&lt;/a&gt;管理&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;使用service或者systemctl管理服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# systemd 模块 - https://en.wikipedia.org/wiki/Systemd
service  服务名称(mongod)  操作指令(status/start/stop/restart)
systemctl  操作指令(start/stop/status/restart/reload)  服务名称service
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;普通部署&#34;&gt;&lt;a href=&#34;#普通部署&#34; class=&#34;headerlink&#34; title=&#34;普通部署&#34;&gt;&lt;/a&gt;普通部署&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;在服务器上部署并运行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1登录远程机器，使用普通用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2在自己的目录下面，clone代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3安装对应的依赖&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以使用sharp淘宝mirror来安装比较大的二进制文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zaGFycC5waXhlbHBsdW1iaW5nLmNvbS9pbnN0YWxsI2NoaW5lc2UtbWlycm9y&#34;&gt;https://sharp.pixelplumbing.com/install#chinese-mirror&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4创建并且设置.env文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5开启云服务对应的端口(7001)访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;阿里云：左侧导航“本实例安全组”，“配置规则”，“手动添加”端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他云平台请自行查看。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;6启动服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;确认mongo,redis在运行状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;npm run tsc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;npm run start&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于此可以完成基本的项目部署，但是这种部署方式启动和更新时过于复杂，存在如下问题：&lt;/p&gt;
&lt;p&gt;三个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前置软件的安装，它们在不同操作系统中安装的方式，启动的脚本，预设初始的方式有可能都不相同，这就给我们造成一个很大的困扰，假如你在多台机器上部署的话，可能会遇到各种各样的问题。&lt;/li&gt;
&lt;li&gt;项目需要运行一系列对应的命令才能启动&lt;/li&gt;
&lt;li&gt;项目更新的问题，需要一系列手动的步骤，这是一个非常繁琐，而且容易出错的步骤。有没有更方便的方式可以完成这个过程呢？&lt;ul&gt;
&lt;li&gt;完成对应的pu川代码，更新依赖，启动应用的过程&lt;/li&gt;
&lt;li&gt;是在特定的提交自动触发这个过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想要更加方便的进行部署可以使用如下工具：&lt;/p&gt;
&lt;h2 id=&#34;Docker&#34;&gt;&lt;a href=&#34;#Docker&#34; class=&#34;headerlink&#34; title=&#34;Docker&#34;&gt;&lt;/a&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS9wcm9kdWN0cy9kb2NrZXItZGVza3RvcA==&#34;&gt;Docker&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&#34;介绍-3&#34;&gt;&lt;a href=&#34;#介绍-3&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;br&gt;我们希望有一个工具可以帮我们一键智能部署，假如你要部署在多台不同的机器上，可以不用在担心不同系统，不同版本的差异，以及运行之前需要安装不同软件的痛苦。&lt;br&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;br&gt;当红的虚拟化软件：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZG9ja2VyLmNvbWwv&#34;&gt;Docker&lt;/span&gt;&lt;br&gt;Docker的进化&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/images/Snipaste_2024-04-26_20-27-53.jpg&#34; alt=&#34;Docker的进化&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统虚拟机，虚拟硬件以后，需要在上面安装一个完整的操作系统。&lt;/li&gt;
&lt;li&gt;Docker:推出了容器的概念，每个容器不需要安装完成的操作系统，里面的进程直接运行在Docker创造的宿主内核中，不需要虚拟硬件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Docker的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更快速的启动速度&lt;/li&gt;
&lt;li&gt;更少的资源占用&lt;/li&gt;
&lt;li&gt;一致的运行环境，使用户不关注操作系统而只关心应用程序。&lt;/li&gt;
&lt;li&gt;微服务架构，docker天生适配微服务架构（Docker 有助于将一个复杂系统分解成一系列可组合的部分，这让用户可以用更离散的方式来思考其服务。用户可以在不影响全局的前提下重组软件，使其各部分更易于管理和可插拔。）&lt;/li&gt;
&lt;li&gt;用户可以更准确地控制构建环境的状态，Docker 构建比传统软件构建方法更具有可重现性和可复制性。使持续交付的实现变得更容易。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Docker-images&#34;&gt;&lt;a href=&#34;#Docker-images&#34; class=&#34;headerlink&#34; title=&#34;Docker  images&#34;&gt;&lt;/a&gt;&lt;strong&gt;Docker  images&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;可以在https:&amp;#x2F;hub.docker.com&amp;#x2F;search?g&amp;#x3D;&amp;amp;type&amp;#x3D;image中获取各种官方的镜像，并且可以上传你自己的自定义镜像&lt;br&gt;Docker镜像仓库获取镜像的命令是docker pull&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 下载镜像
docker pull &amp;lt;image-name&amp;gt;:&amp;lt;tag&amp;gt;
# 查看以及下载的镜像
docker images
# 删除镜像
docker rmi &amp;lt;image-id&amp;gt;
# 上传
docker push &amp;lt;username&amp;gt;/&amp;lt;repository&amp;gt;:&amp;lt;tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用镜像代理：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.mirrors.ustc.edu.cn/&amp;quot;,
    &amp;quot;https://reg-mirror.qiniu.com&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Docker-Container&#34;&gt;&lt;a href=&#34;#Docker-Container&#34; class=&#34;headerlink&#34; title=&#34;Docker Container&#34;&gt;&lt;/a&gt;&lt;strong&gt;Docker Container&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;启动Docker容器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -d -p 主机端口:镜像端口 --name 容器名称 镜像名称
# 例如：（--name 容器名称省略）
docker run -d -p 81:80 nginx
# -d  后台运行
# -p  端口映射，81为主机的端口，80为镜像端口
# --name 自定义容器名称
# 镜像名称，假如本地没有，会自动pull一次镜像进行下载。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其他命令&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 查看所有容器
docker  ps
# 停止容器
docker stop container-id
# 删除容器
docker rm container-id
# 启动已终止容器
docker container start container-id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;进入容器内部&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker exec -it &amp;lt;container-id&amp;gt; command
-i : 即使没有附加也保持STDIN 打开
-t : 分配一个伪终端
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;持久化容器数据&#34;&gt;&lt;a href=&#34;#持久化容器数据&#34; class=&#34;headerlink&#34; title=&#34;持久化容器数据&#34;&gt;&lt;/a&gt;&lt;strong&gt;持久化容器数据&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;使用-v参数，可以设定一个数据的映射关系，将本地的文件映射到容器中对应的文件中去。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -d -p 81:80 -v host:container image-name
#例如：将本地数据卷映射到容器中
docker run -d -v /data/db:/data/db mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;创建对应的数据卷volumn&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 创建数据卷
docker volume create &amp;lt;volumn-name&amp;gt;
#例如：docker volume create mongo
# 使用volumn数据卷
docker run -d -v &amp;lt;volumn-name&amp;gt;:/data/db mongo
# 例如：docker run -d -v mongo:/data/db mongo
# 检查数据卷
docker volume inspect &amp;lt;volumn-name&amp;gt;
# 删除数据卷
docker volume remove mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Dockerfile自定义镜像&#34;&gt;&lt;a href=&#34;#Dockerfile自定义镜像&#34; class=&#34;headerlink&#34; title=&#34;Dockerfile自定义镜像&#34;&gt;&lt;/a&gt;Dockerfile自定义镜像&lt;/h3&gt;&lt;p&gt;Docker image中的镜像虽然非常多，但是不能完全符合自己项目的全部需求，可以自定义构建一个自己的镜像。&lt;/p&gt;
&lt;p&gt;Dockerfile是一个特殊的文本文件，其中包括一系列指令，用于构建对应的镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9idWlsZGVyLyNmcm9t&#34;&gt;指令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Dockerfile示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;dockerfile&#34;&gt;# 指定基础镜像，从node14开始构建
FROM node:14

# 创建对应的文件夹，作为项目运行的位置
RUN mkdir -p /usr/src/app

# 指定工作区，后面的运行任何命令都是在这个工作区中完成的
WORKDIR /usr/sec/app

# 从本地拷贝对应的文件 到 工作区
COPY server.js /usr/src/app

# 执行安装命令
RUN npm install --registry=https://registry.npm.taobao.org
RUN npm run tsc

#告知当前Docker image暴露的是3000端☐
EXPOSE 3000

#执行启动命令，一个Dockerfile只能有一个
CMD node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;构建：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 这里特别注意上下文的概念，不要在根目录使用Dockerfi1e
docker build [选项] &amp;lt;上下文路径/URL/-&amp;gt;
# 例如：(在项目文件夹中运行)
docker build -t test-node .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;.dockerignore文件用于忽略docker中需要打包进镜像的文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.dockerignore示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;dockerfile&#34;&gt;# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/
# Optional REPL history
.node_repl_history
# Output of &amp;#39;npm pack&amp;#39;
*.tgz
# Yarn Integrity file
.yarn-integrity
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;strong&gt;多个容器相互通信：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要点：Docker中每一个container应该只完成一个工作，并且将它做好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解耦，这样不同的服务和后端代砀都可以完全分离开来，方便管理以及未来的扩展。&lt;/li&gt;
&lt;li&gt;服务的更新以及升级都是完全独立的。&lt;/li&gt;
&lt;li&gt;在一个container中，启动多个不同的进程，需要一个进程管理器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通信过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker容器之间不能直接进行访问，而是应该通过docker网络进行访问。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 创建docker网络
docker network create test
# 在创建的docker网络中启动服务
docker run -d --network test --name mongo -p 27017:27017 mongo
# 将原来项目中的的ip地址替换为docker的name名称
# 例如原来为：mongodb://localhost:27017/api  的地址要替换为： mongodb://mongo:27017/api
# 只有在同一个docker网络中启动的项目间才能进行访问。
docker run -d --network test --name use -p 80:3000 use
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果每个容器都要这样操作一遍就会显得非常麻烦，这时就需要使用Docer compose工具（配置docker-compose.yml文件）&lt;/p&gt;
&lt;p&gt;Docker compose工具&lt;/p&gt;
&lt;p&gt;Docker compose是Docker官方推出的工具，用来管理和共享多个容器的应用，Mac系统和Windows系统安装客户端时自带。&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9pbnN0YWxsLw==&#34;&gt;Linux需要单独安装&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker-compose version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker compose通过一个特殊的yml文件，进行配置，这个文件必须命名为&lt;strong&gt;docker-compose.yml&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;docker-compose所有的字段参考文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9jb21wb3NlLWZpbGUvY29tcG9zZS1maWxlLXYzLw==&#34;&gt;https://docs.docker.com/compose/compose-file/compose-file-v3/&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;docker-compose.yml文件配置示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: &amp;#39;3&amp;#39; # docker指令版本
services: # 要启动的服务
  test-mongo: # 服务名称，这里的服务名称对应着容器通信时的前缀！
    image: mongo # 使用的镜像名称
    container_name: test-mongo # 容器名称
    volumes:  # 使用的数据卷映射
      - &amp;#39;.docker-volumes/mongo/data:/data/db&amp;#39;
    ports:  # 端口映射
      - 27017:27017
    environment: # 设置环境变量
      - MONGO_INITDB_ROOT_USERNAME=admin  # 内置的环境变量，可以初始化添加一个User
      - MONGO_INITDB_ROOT_PASSWORD=pass
    env_file: # 设置环境变量文件，将敏感信息放置到环境变量文件中
      - .env
  test-use: # 第二个项目，注意对齐关系
    depends_on: # 配置所依赖的服务
      - test-mongo
    build: # 设置构建配置
      context: . # 操作上下文为当前目录
      dockerfile: Dockerfile # 基于Dockerfile进行构建
    image: test-use-image
    container_name: test-use
    ports:
      - 7001:7001
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动以及关闭：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 启动
docker-compose up -d
# 关闭
docker-compose down
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据库配置&#34;&gt;&lt;a href=&#34;#数据库配置&#34; class=&#34;headerlink&#34; title=&#34;数据库配置&#34;&gt;&lt;/a&gt;数据库配置&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;数据库准备工作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库配置，初始化工作，比如插入一些特定的数据&lt;/li&gt;
&lt;li&gt;避免使用root用户去启动服务，从而提高安全性（配置数据库访问权限）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特殊的初始化数据库的位置：&amp;#x2F;docker-entrypoint-initdb.d（这个文件夹中的脚本会在容器启动前自动执行）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以创建js文件或者sh文件（shell）进行执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mongoDB：https:hub.docker,com&amp;#x2F;_&amp;#x2F;mongo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Postgres:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fbHBvc3RncmVz&#34;&gt;https://hub.docker.com/_lpostgres&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特别注意，只有在数据库没有被创建的情况下，也就是&lt;strong&gt;数据库的文件夹是空的情况下&lt;/strong&gt;，脚本才会被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;docker-compose.yml文件中配置env_file为当前文件夹下的.env文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用js文件或者sh文件，但是由于此文件在其余文件之前运行，此时js文件中通过process.env获取不到所需要的环境变量，可以选用sh文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shell中EOF&amp;lt;&amp;lt;的用法&lt;/strong&gt;&lt;br&gt;在Shell中我们通常将EOF与&amp;lt;结合使用，表示，二债的输入作为子命令或子Shell的输入，直到遇到EOF为止，再返回到主调Shell。.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;#!/bin/bash
mongo &amp;lt;&amp;lt;EOF
use admin
db.auth(&amp;#39;root&amp;#39;,&amp;#39;123456&amp;#39;)
use lego
db.createUser(&amp;#123;
    user: &amp;#39;$MONGO_DB_USERNAME&amp;#39;,
    pwd: &amp;#39;$MONGO_DB_PASSWORD&amp;#39;,
    roles: [&amp;#123;
        role: &amp;#39;readWrite&amp;#39;,
        db: &amp;#39;lego&amp;#39;
    &amp;#125;]
&amp;#125;)
db.createCollection(&amp;#39;works&amp;#39;)
db.works.insertMany([
    &amp;#123;
          id:19,
          title:&amp;#39;测试标题&amp;#39;,
          name:&amp;#39;张三&amp;#39;
    &amp;#125;
])
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;优化镜像大小&#34;&gt;&lt;a href=&#34;#优化镜像大小&#34; class=&#34;headerlink&#34; title=&#34;优化镜像大小&#34;&gt;&lt;/a&gt;优化镜像大小&lt;/h3&gt;&lt;p&gt; &lt;strong&gt;Docker镜像构建优化：使用alpine版本的镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优化镜像大小  ：   什么是Alpine Linux:https:l&amp;#x2F;alpinelinux.orgl&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Alpine的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Small小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认软件包，alpine选择busybox&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C运行库，一般会用glibc,alpine选择musl&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最简依赖，Simple&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很多内置软件的插件都去掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;国际化内容都被删除&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Secure安全&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用alpine版本的镜像可以大大减小镜像的体积。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DockerBuild构建提速&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker中运行命令是基于一层一层的，当修改文件之后，COPY后的缓存全部失效，这时就会重新执行后续命令，使用不了缓存，导致构建速度很慢。此时可以将原来COPY文件夹，改为COPY具体的文件（进行拆分），以更好地使用缓存。&lt;/p&gt;
&lt;h3 id=&#34;部署-2&#34;&gt;&lt;a href=&#34;#部署-2&#34; class=&#34;headerlink&#34; title=&#34;部署&#34;&gt;&lt;/a&gt;部署&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;安装Docker（有的云服务可以自定义安装）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu：（需要使用root账户进行安装）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucnVub29iLi5jb20vZG9ja2VyL3VidW50dS1kb2NrZXItaW5zdGFsbC5odG1s&#34;&gt;https://www.runoob..com/docker/ubuntu-docker-install.html&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvdWJ1bnR1Lw==&#34;&gt;https://docs.docker.com/engine/install/ubuntu/&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;配置用户组&lt;/strong&gt;&lt;br&gt;因为是root安装，普通用户执行对应的命令的时候有可能会报错：&lt;br&gt;&lt;code&gt;Can&amp;#39;t connect to docker daemonGot permission denied while trying to connect to the Docker daemonsocket at unix:///var/run/docker.sock&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要将对应的用户添加到docker的用户组中。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;#usermod命令修改用户账户
#a--append添加-G--groups
组的名称
sudo usermod-aG docker你的用户名
#如果组不存在，添加对应的docker组
sudo groupadd docker
#查看一个用户所属的组
groups
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;添加下载镜像：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# root
vim /etc/docker/daemon.json
&amp;#123;
&amp;quot;registry-mirrors&amp;quot;:
&amp;quot;https://docker.mirrors.ustc.edu.cn/&amp;quot;,
&amp;quot;https://reg-mirror.qiniu.com&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 拉最新的代码
git pull
# 先查看目前端口是否被占用
# 如果被占用，释放端口
# 或者改变docker-compose,yml的映射端口
docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;YAML语言&#34;&gt;&lt;a href=&#34;#YAML语言&#34; class=&#34;headerlink&#34; title=&#34;YAML语言&#34;&gt;&lt;/a&gt;YAML语言&lt;/h1&gt;&lt;p&gt;YAML&lt;br&gt;(YAML Ain’t a Markup Language)是一种标记语言，它使用空格作为缩进，看起来非常的简洁，可读性非常的好，非常适合一些内容大纲和配置文件。他最终是通过工具转化为JSON文件的，但是YAML的可读性比JSON强很多，因此复杂的配置文件一般使用YAML。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;# 字符串不用加引号
key: value
number: 100
boolean: true
# 字符串不用加引号，但是加上也不会报错
quote_string: &amp;#39;quote String&amp;#39;
# 多行字符串使用 literal block语法：也就是竖线
mutiple_string: |
  line one
  line two
  line three
# collection types 集合类型
# 使用缩进表示层级关系，最好使用两个空格，不是两个空格也没关系，对齐就行
person:
  name: dmq
  age: 18
  address:
    city: 上海

# sequences 数组或者列表
hobbies:
  - Item 1
  - Item 2
  - name: weson
    value: xyz
    address:
      city: 北京
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;Github-Action&#34;&gt;&lt;a href=&#34;#Github-Action&#34; class=&#34;headerlink&#34; title=&#34;Github Action&#34;&gt;&lt;/a&gt;Github Action&lt;/h1&gt;&lt;p&gt;Github官方的CI&amp;#x2F;CD工具，作为github的亲儿子，和github几乎是完美的无缝衔接的，功能非常强大。&lt;/p&gt;
&lt;p&gt;CI   CD常用工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Github actions &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vYWN0aW9ucw==&#34;&gt;https://docs.github.com/en/actions&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Travis &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudHJhdmlzLWNpLmNvbS8=&#34;&gt;https://www.travis-ci.com/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;CircleCl &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jaXJjbGVjaS5jb20v&#34;&gt;https://circleci.com/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Jenkins &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuamVua2lucy5pby8=&#34;&gt;https://www.jenkins.io/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;优势讨论：htps:&amp;#x2F;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy56aGlodS5jb20vcXVlc3Rpb24vMzA2MTk1MDMzL2Fuc3dlci8xODcwMzIyMTE4&#34;&gt;www.zhihu.com/question/306195033/answer/1870322118&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/images/Snipaste_2024-04-27_18-37-04.jpg&#34; alt=&#34;/images/Snipaste_2024-04-16_12-54-33.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Workflow&lt;/strong&gt;&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy91bmRlcnN0YW5kaW5nLWdpdGh1Yi1hY3Rpb25zI3dvcmtmbG93cw==&#34;&gt;https://docs.github.com/cn/actions/learn-github-actions/understanding-github-actions#workflows&lt;/span&gt;&lt;br&gt;Workflow是一个可配置的自动化流程，可以包含多个jobs,通过一个在repo当中的yml文件来定义对应的流程，一个repo可以包含多个workflow。&lt;br&gt;&lt;strong&gt;Events&lt;/strong&gt;&lt;br&gt;Event是触发workflow的特殊事件，比如pull request,push或者issue,也可以完全自定义，完整列表请看：https:&amp;#x2F;docs.github.com&amp;#x2F;cn&amp;#x2F;actions&amp;#x2F;learn-github-actions&amp;#x2F;events-that-trigger-workflows&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jobs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Job是Workflow当中一系列的可执行步骤，每个Job是在同一个runner中进行的（(Runner是指处于github的一台特殊的虚拟机，支持各种操作系统)，每个步骤或者是一个shell脚本，抑或是一个可执行的action,每个步骤是按顺序执行，并且互相依赖的。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/Snipaste_2024-04-27_19-54-06.jpg&#34; alt=&#34;/images/Snipaste_2024-04-16_12-54-33.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Actions&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Action是github actions中的一个自定义应用，它可以运行一系列复杂的并且常用的任务，使用action可以帮我们减少在workflow中写重复代码，Github提供了非常多常用的action,可以在&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlP3R5cGU9YWN0aW9ucw==&#34;&gt;这里查阅&lt;/span&gt;，同时我们也可以写自己的action。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github secrets&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目中有的私密信息不希望公开暴露，通常的做法是将私密信息写道env文件中，使用gitingore将其忽略掉，这里还有一个做法就是github secrets，在github官网设置github secret，然后在文件中直接书写变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：.github文件夹下workflow文件夹下创建一个yml文件，写入：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;name: Github Actions Demo
on: [push]
jobs:
  Check-Github-actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo &amp;quot;triggered by a $&amp;#123;&amp;#123; github.event_name &amp;#125;&amp;#125; event&amp;quot;
      - run: echo &amp;quot;running on a $&amp;#123;&amp;#123; runner.os &amp;#125;&amp;#125; server hosted by github&amp;quot;
      - name: check out repo code
        uses: actions/checkout@v2 # 在工作流程中检出代码仓库的内容、确保工作流程始终使用一致的代码版本
      - run: echo &amp;quot;the $&amp;#123;&amp;#123; github.reopsitory &amp;#125;&amp;#125; has been cloned&amp;quot;
      - name: List files in the repo
        run: |
          ls $&amp;#123;&amp;#123; github.workspace &amp;#125;&amp;#125;
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        width:
          repository: &amp;#39;vikingmute/lego-bricks&amp;#39;
      - name: List files in the repo
        run: |
          ls $&amp;#123;&amp;#123; github.workspace &amp;#125;&amp;#125;
      - uses: actions/setup-node@v2
        with:
          node-version: &amp;#39;16&amp;#39;
      - run: node -v
      - run: npm install -g typescript
      - run: tsc -v
  jobs:
    SECRET-SSH-ACTIONS:
      runs-on: ubuntu-latest
      steps:
      #使用ssh-action完成远程登陆：文档地址：https://github.com/appleboy/ssh-action
        - uses: appleboy/ssh-action@master 
          with:
            host: $&amp;#123;&amp;#123; secrets.HOST &amp;#125;&amp;#125;
            username: $&amp;#123;&amp;#123; secrets.SSH_USER &amp;#125;&amp;#125;
            password: $&amp;#123;&amp;#123; secrets.SSH_PWD &amp;#125;&amp;#125;
            script_stop: true
            script: |
              pwd
              ls -l
              touch secret.txt
              echo $&amp;#123;&amp;#123; secrets.MY_SECRET &amp;#125;&amp;#125; &amp;gt;&amp;gt; secret.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;自动化部署&#34;&gt;&lt;a href=&#34;#自动化部署&#34; class=&#34;headerlink&#34; title=&#34;自动化部署&#34;&gt;&lt;/a&gt;自动化部署&lt;/h1&gt;&lt;h2 id=&#34;推送远程镜像仓库&#34;&gt;&lt;a href=&#34;#推送远程镜像仓库&#34; class=&#34;headerlink&#34; title=&#34;推送远程镜像仓库&#34;&gt;&lt;/a&gt;推送远程镜像仓库&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;普通线上更新流程：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 每次代码更新以后，登录到ssh服务器
# 关闭服务
docker-compose down
# 更新代码
git pull
# 假如有.env，的更新需要重新设置，env文件
# 重新build应用镜像
docker-compose build lego-backend
# 重启服务
docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;弊端：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初次上线和更新属于两步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初次上线需要特别的操作，就是之前手动部署上线的运行的过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clone代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置环境变量.env&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;docker-compose up -d&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;追求的成果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次提交，可以自动一次性的部署到任何服务器，实现初次启动或者更新的效果，这才是一个完美的devops的流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将上面本地的镜像存在于docker hub服务器中，这样每次就不用重新build，而是直接拉取。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;services:
  lego-redis:
    image:redis:6
  lego-mongo:
    image:mongo:latest
  lego-backend:
    image:lego-backend
#我们需要每次手动的build镜像，也就说镜像只存在于本地
  build:
    ......context:.
    dockerfile:Dockerfile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;改为：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;# 更好的方案
# 不需要任何代码库中的文件，只需要一个docker-compose,yml文件
# 就可以轻松的在任何服务器运行
services:
  lego-redis:
    image:redis:6
  lego-mongo
    image:mongo:latest
  lego-backend:
# 不需要build,而是存在于docker hub服务器中，可以每次直接拉取
    image:lego-backend:1.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;docker hub免费版有限制，推荐使用阿里云容器镜像服务：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sd3d3LmFsaXl1bi5jb20vcHJvZHVjdC9hY3I=&#34;&gt;阿里云容器镜像服务ACR&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;个人版完全免费&lt;/p&gt;
&lt;p&gt;创建镜像仓库之后，需要将本地镜像推送到ACR仓库中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 来到镜像仓库的基本信息页面
# 登录
docker login --username=用户名 registry.cn-hangzhou.aliyuncs.com
# tag两种方式：
# 1:使用tag bui1d
docker build--tag &amp;quot;registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]&amp;quot;
# 2:给 build 好的打 tag
docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]
# 查看镜像是否 build 完成
docker images
# 推送镜像
docker push registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]
# 在阿里云ACR界面检查看是否已经存在
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Github-Actions自动部署&#34;&gt;&lt;a href=&#34;#Github-Actions自动部署&#34; class=&#34;headerlink&#34; title=&#34;Github Actions自动部署&#34;&gt;&lt;/a&gt;Github Actions自动部署&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;使用github actions加成自动化部署：当推送代码到github仓库时，让我们的代码自动提交镜像到镜像仓库。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大体分为两步&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h6 id=&#34;在github服务器上build-image并且push&#34;&gt;&lt;a href=&#34;#在github服务器上build-image并且push&#34; class=&#34;headerlink&#34; title=&#34;在github服务器上build image并且push&#34;&gt;&lt;/a&gt;在github服务器上build image并且push&lt;/h6&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用docker-compose-online文件在服务器上运行应用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第一步详细流程分析，在github runner上运行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;checkout代码（在github服务器上）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建.env文件，并且添加两个环境变量( upload to OSS需要两个对应的信息 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用阿里云ACR完成docker login&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用正确的阿里云tag进行docker build&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怎样每次push生成特殊的tag？是一个后续的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;docker push&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：【1】在项目文件夹.github&amp;#x2F;workflow下创建yml文件，写入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: build image,push to ACR
on: [push]
jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      # checkout 代码
      - uses: actions/checkout@v2
      # 创建env文件
      - run: touch .env
      # 使用“ &amp;gt;&amp;gt; ”添加信息
      - run: echo ALC_ACCESS_KEY=$&amp;#123;&amp;#123; secrets.ALC_ACCESS_KEY &amp;#125;&amp;#125; &amp;gt;&amp;gt; .env
      - run: echo ALC_SECRET_KEY=$&amp;#123;&amp;#123; secrets.ALC_SECRET_KEY &amp;#125;&amp;#125; &amp;gt;&amp;gt; .env
      # 使用阿里云ACR 完成 docker login
      - name: Login to Aliyun ACR
        uses: aliyun/acr-login@v1 # 使用专属的镜像
        with:
          login-server: https://registry.cn-hangzhou.aliyuncs.com
          region-id: cn-hangzhou # 查看官网自己仓库的信息
          username: &amp;quot;$&amp;#123;&amp;#123; secrets.ACR_USERNAME &amp;#125;&amp;#125;&amp;quot;
          password: &amp;quot;$&amp;#123;&amp;#123; secrets.ACR_PASSWORD &amp;#125;&amp;#125;&amp;quot;
        # 使用正确的阿里云 tag 进行 docker build
        - name: Build image for Docker
          run: docker build --tag &amp;quot;registry.cn-hangzhou.aliyuncs.com/dmq00/test:0.0.2&amp;quot;
        - name: Push Image to ACR
          run: docker push registry.cn-hangzhou.aliyuncs.com/dmq00/test:0.0.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就能保证代码push到github上之后自动将镜像推送到docker镜像仓库，结合dockerfile文件就能保证使用docker镜像时自动执行命令，安装对应依赖并执行项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步详细流程分析，在服务器上部署对应的代码并且运行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;checkout代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建.env文件，添加多个环境变量。(应用所有需要的环境变量)，github  secrets中添加。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建文件夹，拷贝如下文件到文件夹内&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.env&lt;/li&gt;
&lt;li&gt;docker-compose-online.yml&lt;/li&gt;
&lt;li&gt;mongo-entrypoint文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将新建的文件夹拷贝到服务器(SCP)当中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 https:&amp;#x2F;github.com&amp;#x2F;appleboy&amp;#x2F;scp-action&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SSH到服务器中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进入拷贝的文件夹内&lt;/li&gt;
&lt;li&gt;登录阿里云ACR&lt;/li&gt;
&lt;li&gt;停止服务docker-compose down （第一次的话，没有启动也不会报错）&lt;/li&gt;
&lt;li&gt;启动服务docker-compose up&lt;/li&gt;
&lt;li&gt;清理工作可选，保证安全（删除.env文件，登出docker账户）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;后续过程需要完成：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在push tags的时候才触发对应的job&lt;/p&gt;
&lt;p&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy9ldmVudHMtdGhhdC10cmlnZ2VyLXdvcmtmbG93cw==&#34;&gt;https://docs.github.com/cn/actions/learn-github-actions/events-that-trigger-workflows&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;怎样获取对应的每次提交相关的特殊信息&lt;/p&gt;
&lt;p&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy9jb250ZXh0cw==&#34;&gt;https://docs.github.com/en/actions/learn-github-actions/contexts&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用这个特殊信息，在对应的docker-compose-online.yml中进行替换，将要启动的版本替换为将要构建的版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/30/jest/</guid>
            <title>jest</title>
            <link>https://dmqweb.cn/2024/03/30/jest/</link>
            <category term="TDD" scheme="https://dmqweb.cn/categories/TDD/" />
            <category term="jest" scheme="https://dmqweb.cn/tags/jest/" />
            <pubDate>Sat, 30 Mar 2024 20:33:01 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;jest测试&#34;&gt;&lt;a href=&#34;#jest测试&#34; class=&#34;headerlink&#34; title=&#34;jest测试&#34;&gt;&lt;/a&gt;jest测试&lt;/h1&gt;&lt;p&gt;市面上有很多测试框架，例如：mocha 、jasmine、vue test utils、vitest、react testing library和testing frameworks for jacascript等，但语法和思想大致相同，现在依jest框架进行简单的使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;/**
 * jest简单的语法
 * expect  toBe 语法
 */
test(&amp;#39;tow plus to 4&amp;#39;,()=&amp;gt;&amp;#123;
    expect(2+2).toBe(4);
&amp;#125;)
/**
 * toEqual语法，递归检查对象或数组的每个字段
 */
test(&amp;#39;object assignment&amp;#39;,()=&amp;gt;&amp;#123;
    const data = &amp;#123;name:&amp;quot;张三&amp;quot;&amp;#125;;
    data[&amp;#39;age&amp;#39;] = 18;
    expect(data).toEqual(&amp;#123;name:&amp;quot;张三&amp;quot;,age:18&amp;#125;)
&amp;#125;)
/**
 * expect  not  toBe
 */
test(&amp;#39;adding is not 0&amp;#39;,()=&amp;gt;&amp;#123;
    for(let i=0;i&amp;lt;10;i++)&amp;#123;
        for(let j=0;j&amp;lt;5;j++)&amp;#123;
            expect(i + j).not.toBe(-1);
        &amp;#125;
    &amp;#125;
&amp;#125;)
/**
 * 检查指定空类型（null,undefined,defined，true和false）
 */
test(&amp;#39;toBe null&amp;#39;,()=&amp;gt;&amp;#123;
    const n = null;
    expect(n).toBeNull();
&amp;#125;)
test(&amp;#39;toBe defined&amp;#39;,()=&amp;gt;&amp;#123;
    const n = 1;
    expect(n).toBeDefined();
&amp;#125;)
test(&amp;#39;toBe Undefined&amp;#39;,()=&amp;gt;&amp;#123;
    let n;
    expect(n).toBeUndefined();
&amp;#125;)
test(&amp;#39;toBe Truthy&amp;#39;,()=&amp;gt;&amp;#123;
    const n = 1;
    const m = true;
    expect(n &amp;amp;&amp;amp; m).toBeTruthy();
&amp;#125;)
test(&amp;#39;toBe falsy&amp;#39;,()=&amp;gt;&amp;#123;
    const n = 0;
    const m = false;
    expect(n &amp;amp;&amp;amp; m).toBeFalsy();
&amp;#125;)
/**
 * jest对0进行精确测试的结果
 */
test(&amp;#39;zero&amp;#39;, () =&amp;gt; &amp;#123;
    const z = 0;
    expect(z).not.toBeNull(); //非null
    expect(z).toBeDefined(); //defined
    expect(z).not.toBeUndefined(); 
    expect(z).not.toBeTruthy(); //非true
    expect(z).toBeFalsy(); //false
  &amp;#125;);
/**
 * jest测试数字
 */
test(&amp;#39;two and two&amp;#39;,()=&amp;gt;&amp;#123;
    const value = 2 + 2;
    expect(value).toBeGreaterThan(3);
    expect(value).toBeGreaterThanOrEqual(4)
    expect(value).toBeLessThanOrEqual(4.5)
    expect(value).toBeLessThanOrEqual(4)
    expect(value).toBe(4)
    expect(value).toEqual(4)
&amp;#125;)
/**
 * toBeCloseTo检查浮点数相等
 */
test(&amp;#39;test float number&amp;#39;,()=&amp;gt;&amp;#123;
    const value = 0.1 + 0.2;
    // expect(value).toBe(0.3)  报错，因为计算机精度的原因
    expect(value).toBeCloseTo(0.3)
&amp;#125;)
/**
 * toMatch根据正则表达式检查字符串
 */
test(&amp;#39;test reg&amp;#39;,()=&amp;gt;&amp;#123;
    expect(&amp;#39;team&amp;#39;).not.toMatch(/I/)
    expect(&amp;#39;Christoph&amp;#39;).toMatch(/stop/)
    expect(&amp;#39;hello world&amp;#39;).toMatch(&amp;#39;lo w&amp;#39;)
&amp;#125;)
/**
 * toContain测试数组和可迭代对象
 */
const List = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;];
test(&amp;#39;list to be&amp;#39;,()=&amp;gt;&amp;#123;
    expect(List).toContain(&amp;#39;c&amp;#39;);
    expect(List).not.toContain(1);
&amp;#125;)
/**
 * 测试异步代码
 */
const testPromise = Promise.resolve(&amp;#39;hello&amp;#39;);
//1 使用return
test(&amp;#39;return异步代码&amp;#39;,()=&amp;gt;&amp;#123;
    return testPromise.then(data=&amp;gt;&amp;#123;
        expect(data).toBe(&amp;#39;hello&amp;#39;)
    &amp;#125;)
&amp;#125;)
//2 使用async和await语法
function fetchMessage() &amp;#123;
    return new Promise((resolve) =&amp;gt; &amp;#123;
        setTimeout(() =&amp;gt; &amp;#123;
            resolve(&amp;#39;hello&amp;#39;);
        &amp;#125;, 1000);
    &amp;#125;);
&amp;#125;
test(&amp;#39;async and await&amp;#39;, async () =&amp;gt; &amp;#123;
    const result = await fetchMessage();
    expect(result).toBe(&amp;#39;hello&amp;#39;);
&amp;#125;);
//expect.assertions验证是否调用了一定数量的断言，确保兑现的承若通过测试
//catch捕捉（确保Promise不会被兑现）
// test(&amp;#39;catch fails with errors&amp;#39;,()=&amp;gt;&amp;#123;
//     return fetchData2().catch(e=&amp;gt;expect(e).toMatch(&amp;#39;error&amp;#39;))
// &amp;#125;)

// 3 使用回调函数done
test(&amp;#39;done to async&amp;#39;,(done)=&amp;gt;&amp;#123;
    testPromise.then(res=&amp;gt;&amp;#123;
        expect(res).toBe(&amp;#39;hello&amp;#39;);
    &amp;#125;)
    done();
&amp;#125;)
// 4 .resolves匹配器等待Promise解析（reject则失败）
test(&amp;#39;.resolves匹配器&amp;#39;,()=&amp;gt;&amp;#123;
    expect(testPromise).resolves.toBe(&amp;#39;hello&amp;#39;)
&amp;#125;)
/**
 * beforeEach和afterEach钩子函数
 * 当每一个测试之前或之后都需要调用相同的方法就可以使用这两个钩子函数
 */

/**
 * describe块
 */

/**
 * test.only只运行一个测试
 */
test.only(&amp;#39;test only&amp;#39;,()=&amp;gt;&amp;#123;
    expect(&amp;#39;test only&amp;#39;).toMatch(&amp;#39;t o&amp;#39;)
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/30/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/</guid>
            <title>本地文件链接</title>
            <link>https://dmqweb.cn/2024/03/30/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/</link>
            <category term="脚手架开发" scheme="https://dmqweb.cn/categories/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/" />
            <category term="脚手架 cli" scheme="https://dmqweb.cn/tags/%E8%84%9A%E6%89%8B%E6%9E%B6-cli/" />
            <pubDate>Sat, 30 Mar 2024 19:31:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;链接本地文件的方式&#34;&gt;&lt;a href=&#34;#链接本地文件的方式&#34; class=&#34;headerlink&#34; title=&#34;链接本地文件的方式&#34;&gt;&lt;/a&gt;链接本地文件的方式&lt;/h1&gt;&lt;h3 id=&#34;npm-link&#34;&gt;&lt;a href=&#34;#npm-link&#34; class=&#34;headerlink&#34; title=&#34;npm link&#34;&gt;&lt;/a&gt;npm link&lt;/h3&gt;&lt;p&gt;1、带有package.json文件的文件夹内运行：npm link ，即可在用户全局中创建该文件夹的全局链接。&lt;/p&gt;
&lt;p&gt;2、在需要使用文件的地方执行：npm link  文件名，注意文件名是package.json中的name字段值。&lt;/p&gt;
&lt;h3 id=&#34;file路径&#34;&gt;&lt;a href=&#34;#file路径&#34; class=&#34;headerlink&#34; title=&#34;file路径&#34;&gt;&lt;/a&gt;file路径&lt;/h3&gt;&lt;p&gt;在需要使用的package.json的dependence中添加：文件名：”file:  ….”，添加上file路径指向本地文件。&lt;/p&gt;
&lt;h3 id=&#34;区别：&#34;&gt;&lt;a href=&#34;#区别：&#34; class=&#34;headerlink&#34; title=&#34;区别：&#34;&gt;&lt;/a&gt;区别：&lt;/h3&gt;&lt;p&gt;两种方式的区别在于如果项目较为简单，使用file:路径即可解决，但如果项目较为复杂，且文件包括文件地址需要不断移动时，使用npm  link的方式更好。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/29/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
            <title>前端模块化</title>
            <link>https://dmqweb.cn/2024/03/29/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
            <category term="前端工程化" scheme="https://dmqweb.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" />
            <category term="ESModules" scheme="https://dmqweb.cn/tags/ESModules/" />
            <pubDate>Fri, 29 Mar 2024 22:34:14 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;modules模块化&#34;&gt;&lt;a href=&#34;#modules模块化&#34; class=&#34;headerlink&#34; title=&#34;modules模块化&#34;&gt;&lt;/a&gt;modules模块化&lt;/h1&gt;&lt;h3 id=&#34;模块化的优点：&#34;&gt;&lt;a href=&#34;#模块化的优点：&#34; class=&#34;headerlink&#34; title=&#34;模块化的优点：&#34;&gt;&lt;/a&gt;模块化的优点：&lt;/h3&gt;&lt;p&gt;可维护性、可复用性。&lt;/p&gt;
&lt;h4 id=&#34;模块化的发展&#34;&gt;&lt;a href=&#34;#模块化的发展&#34; class=&#34;headerlink&#34; title=&#34;模块化的发展&#34;&gt;&lt;/a&gt;模块化的发展&lt;/h4&gt;&lt;p&gt;1、ES6之前没有模块化时，浏览器环境需要使用script进行引入js文件&lt;br&gt;2、后来使用全局变量+命名空间（namespace）处理，就是使用IIFE自动执行函数创建一个函数作用域，赋值给一个全局变量。&lt;br&gt;这样做的缺点是：依赖于全局变量，污染全局变量，不安全。&lt;br&gt;    依赖于约定命名空间来避免冲突，可靠性不高。&lt;br&gt;    需要手动管理依赖并控制执行顺序，容易出错。&lt;br&gt;    需要在最终上线前手动合并所有用到的模块。&lt;br&gt;3、node端模块系统：Common.js，缺点是浏览器端无法使用&lt;br&gt;4、AMD(Asynchronous module definition)异步加载模块定义，CMD(模块标准)&lt;br&gt;    采用异步方式加载，需要全局环境定义require和define，不需要引入其他的变量。&lt;br&gt;5、ES6 modules、引入和暴露方式更加多样，支持复杂的静态分析和静态、动态导入。&lt;/p&gt;
&lt;h1 id=&#34;Bundler打包工具&#34;&gt;&lt;a href=&#34;#Bundler打包工具&#34; class=&#34;headerlink&#34; title=&#34;Bundler打包工具&#34;&gt;&lt;/a&gt;Bundler打包工具&lt;/h1&gt;&lt;h3 id=&#34;诞生原因：&#34;&gt;&lt;a href=&#34;#诞生原因：&#34; class=&#34;headerlink&#34; title=&#34;诞生原因：&#34;&gt;&lt;/a&gt;诞生原因：&lt;/h3&gt;&lt;p&gt;使用import export这种异步加载方式在大多数浏览器中无法使用。&lt;/p&gt;
&lt;h3 id=&#34;常见工具&#34;&gt;&lt;a href=&#34;#常见工具&#34; class=&#34;headerlink&#34; title=&#34;常见工具&#34;&gt;&lt;/a&gt;常见工具&lt;/h3&gt;&lt;p&gt;一、&lt;strong&gt;Webpack&lt;/strong&gt;（单JS文件入口），Webpack采用代码分割、异步加载等技术，可以将多个模块打包成一个或者多个bundle,，构建的产物是一个函数。Webpack主要用于构建复杂的前端项目，如Web应用、SPA单页面应用等，支持模块化开发、代码分割、资源优化和静态文件处理等功能。。&lt;/p&gt;
&lt;p&gt;二、&lt;strong&gt;rollup&lt;/strong&gt;用静态的方式分析代码，对未使用的代码更加彻底的进行树摇优化，输出的bundle更加的精简。&lt;/p&gt;
&lt;p&gt;三、&lt;strong&gt;snowpack&lt;/strong&gt;（使用于新版浏览器）&lt;br&gt;1、出现的原因（其他Bundler的问题）：&lt;br&gt;当资源越来越多时，打包的速度会越来越慢，大中型项目中，启动时间可能达到好几分钟。（vite的理念来源于snowpack，充分使用了新版浏览器支持es modules的特性。）&lt;br&gt;2、优势：&lt;br&gt;snowpack利用新版浏览器支持es modules的特性，开发模式不会被打包，每个文件编译一次，永久被缓存，当一个文件修改的时候就只需要重新build那一个文件。（适用于新版浏览器）&lt;br&gt;四、&lt;strong&gt;vite&lt;/strong&gt;&lt;br&gt;vite基于snowpack的理念（利用新版浏览器支持es modules的特性），基于esbuild，采用rollup进行构建 ，开发模式不会打包，每个文件当使用时才会去加载，修改时只需要重新build那一个文件。&lt;br&gt;五、&lt;strong&gt;vue-cli&lt;/strong&gt;&lt;br&gt;vue-cli底层基于webpack，webpack通过导入导出的语句分析整个项目，将目标代码转化成兼容浏览器的js代码，只有打包后的几个文件，这个过程需要耗费一些时间。&lt;/p&gt;
&lt;h1 id=&#34;webpack配置支持ES-Module&#34;&gt;&lt;a href=&#34;#webpack配置支持ES-Module&#34; class=&#34;headerlink&#34; title=&#34;webpack配置支持ES Module&#34;&gt;&lt;/a&gt;webpack配置支持ES Module&lt;/h1&gt;&lt;p&gt;webpack默认只支持CommonJS规范，配置支持ES Module规范，需要进行如下配置：&lt;br&gt;一：将ES Module语法的js文件通过webpack进行打包即可。&lt;br&gt;二：webpack默认target为web，在使用node内置库时会报错，可以修改target属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const path = require(&amp;#39;path&amp;#39;);
module.exports = &amp;#123;
    entry: &amp;#39;./bin/core.js&amp;#39;,
    output: &amp;#123;
        path:path.join(__dirname,&amp;#39;/dist&amp;#39;),
        filename: &amp;#39;core.js&amp;#39;,
    &amp;#125;,
    mode: &amp;#39;production&amp;#39;, //改变打包模式
    target: &amp;#39;node&amp;#39; //进入node环境，默认是web
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三、webpack配置babel-loader，兼容低版本node&lt;br&gt;方案一：安装babel-loader、@babel&amp;#x2F;core、@babel&amp;#x2F;preset-env（有时需要@babel&amp;#x2F;plugin-transform-runtime插件）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const path = require(&amp;#39;path&amp;#39;);
module.exports = &amp;#123;
    entry: &amp;#39;./bin/core.js&amp;#39;,
    output: &amp;#123;
        path:path.join(__dirname,&amp;#39;/dist&amp;#39;),
        filename: &amp;#39;core.js&amp;#39;,
    &amp;#125;,
    mode: &amp;#39;production&amp;#39;, //改变打包模式
    target: &amp;#39;node&amp;#39;, //进入node环境，默认是web
    module: &amp;#123;
        rules: [
            &amp;#123;
                test: /\.js$/,
                use: &amp;#123;
                    loader: &amp;#39;babel-loader&amp;#39;,  //使用babel-loader
                    options: &amp;#123;
                        presets: [&amp;#39;@babel/preset-env&amp;#39;],
                        plugins:[
                            [
                                &amp;#39;@babel/plugin-transform-runtime&amp;#39;,
                                &amp;#123;
                                    corejs: 3,
                                    regenerator: true,
                                    useESModules: true,
                                    helpers: true,
                                &amp;#125;,
                            ],
                        ]
                    &amp;#125;,
                &amp;#125;
            &amp;#125;
        ]
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方案二：node.js实验功能&lt;br&gt;将js后缀更改为mjs后缀，即可（需要node版本为14以上）,小于14版本的时候，node执行时需要加上–experimental-modules参数，例如：&lt;br&gt;&lt;code&gt;node --experimental-modules index.js&lt;/code&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/29/TDD/</guid>
            <title>TDD测试驱动开发</title>
            <link>https://dmqweb.cn/2024/03/29/TDD/</link>
            <category term="开发模式" scheme="https://dmqweb.cn/categories/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/" />
            <category term="开发模式" scheme="https://dmqweb.cn/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/" />
            <pubDate>Fri, 29 Mar 2024 21:47:28 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;TDD-test-drive-development-测试驱动开发&#34;&gt;&lt;a href=&#34;#TDD-test-drive-development-测试驱动开发&#34; class=&#34;headerlink&#34; title=&#34;TDD(test drive development)测试驱动开发&#34;&gt;&lt;/a&gt;TDD(test drive development)测试驱动开发&lt;/h1&gt;&lt;h3 id=&#34;测试驱动开发的口号：&#34;&gt;&lt;a href=&#34;#测试驱动开发的口号：&#34; class=&#34;headerlink&#34; title=&#34;测试驱动开发的口号：&#34;&gt;&lt;/a&gt;测试驱动开发的口号：&lt;/h3&gt;&lt;p&gt;测试先行&lt;/p&gt;
&lt;h3 id=&#34;测试驱动开发的目标：&#34;&gt;&lt;a href=&#34;#测试驱动开发的目标：&#34; class=&#34;headerlink&#34; title=&#34;测试驱动开发的目标：&#34;&gt;&lt;/a&gt;测试驱动开发的目标：&lt;/h3&gt;&lt;p&gt;保证代码的简洁可用&lt;/p&gt;
&lt;h3 id=&#34;TDD-的规则&#34;&gt;&lt;a href=&#34;#TDD-的规则&#34; class=&#34;headerlink&#34; title=&#34;TDD 的规则&#34;&gt;&lt;/a&gt;TDD 的规则&lt;/h3&gt;&lt;p&gt;在 TDD 的过程中，需要遵循两条简单的规则：&lt;/p&gt;
&lt;p&gt;仅在自动测试失败时才编写新代码。&lt;br&gt;消除重复设计（去除不必要的依赖关系），优化设计结构（逐渐使代码一般化）。&lt;/p&gt;
&lt;p&gt;第一条规则的言下之意是每次只编写刚刚好使测试通过的代码，并且只在测试运行失败的时候才编写新的代码，因为每次增加的代码少，即使有问题定位起来也非常快，确保我们可以遵循小步快跑的节奏；第二条规则就是让小步快跑更加踏实，在自动化测试的支撑下，通过重构环节消除代码的坏味道来避免代码日渐腐烂，为接下来编码打造一个舒适的环境。&lt;br&gt;关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“简洁”目标，每次只关注一件事&lt;/p&gt;
&lt;h3 id=&#34;采用-TDD-的动机&#34;&gt;&lt;a href=&#34;#采用-TDD-的动机&#34; class=&#34;headerlink&#34; title=&#34;采用 TDD 的动机&#34;&gt;&lt;/a&gt;采用 TDD 的动机&lt;/h3&gt;&lt;p&gt;控制编程过程中的忧虑感。&lt;/p&gt;
&lt;p&gt;有一个有趣的想象，当我感觉压力越大，自身就越不想去做足够多的测试。当知道自己做的测试不够时，就会增加自身的压力，因为我担心自己写的代码有 BUG，对自己编写的代码不够自信，这是一种心态上的变化。此时测试是开发人员的试金石，可以将对压力的恐惧变为平日的琐事，采用自动化测试，就有机会选择恐惧的程度。&lt;/p&gt;
&lt;p&gt;把控编程过程中的反馈与决策之间的差距。&lt;/p&gt;
&lt;p&gt;如果我做了一周的规划，并且量化成一个个可操作的任务写到 to-do list，然后使用测试驱动编码，把完成的任务像这样划掉，那么我的工作目标将变得非常清晰，因为我明确工期，明确待办事项，明确难点，可以在持续细微的反馈中有意识地做一些适当的调整，比如添加新的任务，删除冗余的测试；还有一点更加让人振奋，我可以知道我大概什么时候可以完工。项目经理对软件开发进度可以更精确的把握。&lt;/p&gt;
&lt;p&gt;标注：本文摘抄自：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzgwOTcwOTIxOTkx&#34;&gt;https://juejin.cn/post/6844903780970921991&lt;/span&gt;&lt;br&gt;感兴趣可自行进行查看&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/29/%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87/</guid>
            <title>本地预览图片</title>
            <link>https://dmqweb.cn/2024/03/29/%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87/</link>
            <category term="业务处理" scheme="https://dmqweb.cn/categories/%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86/" />
            <category term="业务" scheme="https://dmqweb.cn/tags/%E4%B8%9A%E5%8A%A1/" />
            <category term="图片" scheme="https://dmqweb.cn/tags/%E5%9B%BE%E7%89%87/" />
            <pubDate>Fri, 29 Mar 2024 21:20:56 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;图片上传预览&#34;&gt;&lt;a href=&#34;#图片上传预览&#34; class=&#34;headerlink&#34; title=&#34;图片上传预览&#34;&gt;&lt;/a&gt;图片上传预览&lt;/h1&gt;&lt;p&gt;业务中经常有上传图片的需求在，有时我们需要去尽快预览要上传的图片，此时会有两种常见的方法：&lt;/p&gt;
&lt;h3 id=&#34;URL-createObjectURL&#34;&gt;&lt;a href=&#34;#URL-createObjectURL&#34; class=&#34;headerlink&#34; title=&#34;URL.createObjectURL&#34;&gt;&lt;/a&gt;URL.createObjectURL&lt;/h3&gt;&lt;p&gt;直接返回，同步执行，会为图片文件创建一个地址，存储在document中，并且不会被垃圾回收机制所回收。清除方式只有unload事件或revokeObjectURL进行手动清除。&lt;/p&gt;
&lt;h3 id=&#34;FileReader-readAsDataURL&#34;&gt;&lt;a href=&#34;#FileReader-readAsDataURL&#34; class=&#34;headerlink&#34; title=&#34;FileReader.readAsDataURL&#34;&gt;&lt;/a&gt;FileReader.readAsDataURL&lt;/h3&gt;&lt;p&gt;通过回调的形式返回，异步执行，将图片文件转为base64格式，可以通过链接形式直接引用，会依据垃圾回收机制进行回收，&lt;br&gt;2&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/29/new%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
            <title></title>
            <link>https://dmqweb.cn/2024/03/29/new%E5%85%B3%E9%94%AE%E5%AD%97/</link>
            <pubDate>Fri, 29 Mar 2024 13:29:43 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;new关键字实现分为三步&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#new关键字实现分为三步&#34;&gt;#&lt;/a&gt; new 关键字实现分为三步：&lt;/h1&gt;
&lt;p&gt;1、根据构造函数的原型创建新的对象&lt;br /&gt;
 2、执行构造函数，绑定 this 指向为新对象，传入参数&lt;br /&gt;
 3、返回执行后的结果&lt;/p&gt;
&lt;figure class=&#34;highlight js&#34;&gt;&lt;figcaption data-lang=&#34;JavaScript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;myNew&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;constructor&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 创建对象，原型为构造函数的原型对象&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; obj &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; Object&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;constructor&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;prototype&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 执行构造函数，传入创建的对象和参数&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; res &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;constructor&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;apply&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;obj&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;args&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;// 注意 apply 方法是函数对象的方法，普通对象不可用&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;res &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;typeof&lt;/span&gt; res &lt;span class=&#34;token operator&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;object&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;?&lt;/span&gt;res&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;obj&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;    &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token constant&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;name&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;sdjf&#39;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; ab &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;myNew&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token constant&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;console&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;ab&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/02/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
            <title>前端性能优化</title>
            <link>https://dmqweb.cn/2024/03/02/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
            <category term="前端性能优化" scheme="https://dmqweb.cn/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
            <category term="性能优化" scheme="https://dmqweb.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
            <pubDate>Sat, 02 Mar 2024 12:24:04 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;5-1-前端性能优化&#34;&gt;&lt;a href=&#34;#5-1-前端性能优化&#34; class=&#34;headerlink&#34; title=&#34;5-1 前端性能优化&#34;&gt;&lt;/a&gt;5-1 前端性能优化&lt;/h1&gt;&lt;h2 id=&#34;课程介绍&#34;&gt;&lt;a href=&#34;#课程介绍&#34; class=&#34;headerlink&#34; title=&#34;课程介绍&#34;&gt;&lt;/a&gt;课程介绍&lt;/h2&gt;&lt;p&gt;任何小型企业，博主或成长型公司在网上出现时面临的最大挑战之一就是“页面加载时间”问题。除非您能确保尽可能快速无缝地加载每个页面，您才可以拥有世界上最好最引人注目的网站，否则您仍然无法赢得关注者的尊重和忠诚度。&lt;/p&gt;
&lt;p&gt;根据当今网络上的所有主要浏览器公司的说法，如果每个网站都想要排名靠前，表现良好并确保客户满意，那么每个网站都需要快。毕竟，如果您的网页加载速度很慢，那么您会立即增加客户开始在其他地方搜索信息，而不是坚持下去的风险。&lt;/p&gt;
&lt;p&gt;这也是为什么很多公司去找专门的技术人员来做SEO（&lt;strong&gt;Search Engine Optimization&lt;/strong&gt;），即搜索引擎优化。 因为，页面的加载会影响到爬虫的爬取，页面加载速度是一项非常重要的指标。况且，页面优化直接影响到了用户体验。所以学习前端性能优化势在必行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经常有面试官会问：从用户输入浏览器输入url到页面最后呈现 有哪些过程？有什么办法能优化页面性能？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户输入URL地址&lt;/li&gt;
&lt;li&gt;浏览器解析URL解析出主机名&lt;/li&gt;
&lt;li&gt;浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）&lt;/li&gt;
&lt;li&gt;浏览器将端口号从URL中解析出来&lt;/li&gt;
&lt;li&gt;浏览器建立一条与目标Web服务器的TCP连接（三次握手）&lt;/li&gt;
&lt;li&gt;浏览器向服务器发送一条HTTP请求报文&lt;/li&gt;
&lt;li&gt;服务器向浏览器返回一条HTTP响应报文&lt;/li&gt;
&lt;li&gt;关闭连接 浏览器解析文档&lt;/li&gt;
&lt;li&gt;如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619100048897.png&#34; alt=&#34;/images/image-20190619100048897&#34;&gt;&lt;/p&gt;
&lt;p&gt;再深一点层次：会问到&lt;strong&gt;渲染机制&lt;/strong&gt;，重排、重绘&lt;/p&gt;
&lt;p&gt;重排：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义：DOM结构中的各个元素都有自己的盒子(模型)，这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;触发Reflow：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你增加、删除、修改DOM结点时，会导致Reflow或Repaint&lt;/li&gt;
&lt;li&gt;当你移动DOM的位置，或是搞个动画的时候&lt;/li&gt;
&lt;li&gt;当你修改CSS样式的时候&lt;/li&gt;
&lt;li&gt;当你Resize窗口的时候(移动端没有这个问题)，或者是滚动的时候&lt;/li&gt;
&lt;li&gt;当你修改网页的&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;最常问：如何减少Reflow?或者避免Reflow？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重绘：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为repaint。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;页面要呈现的内容，通通都绘制到页面上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;触发Repaint&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM改动&lt;/li&gt;
&lt;li&gt;CSS改动&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;最常问：如何避免最小程序的Repaint？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然页面的性能优化这么重要，&lt;strong&gt;你知道有哪些原因是影响页面性能的？&lt;/strong&gt;比如…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP请求&lt;/li&gt;
&lt;li&gt;复杂的页面逻辑(JS设计)&lt;/li&gt;
&lt;li&gt;重度的DOM操作&lt;/li&gt;
&lt;li&gt;服务端响应&lt;/li&gt;
&lt;li&gt;大量的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有哪些办法可以加速我们的页面性能？比如…&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源压缩与合并（代码打包）&lt;/li&gt;
&lt;li&gt;异步加载&lt;/li&gt;
&lt;li&gt;CDN&lt;/li&gt;
&lt;li&gt;DNS预解析&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本课程的主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面加载缓慢原因分析&lt;/li&gt;
&lt;li&gt;性能优化原则&lt;/li&gt;
&lt;li&gt;优化工具介绍&lt;/li&gt;
&lt;li&gt;浏览器的工作机制，了解一些基本常识的原理：&lt;ol&gt;
&lt;li&gt;为什么要将js放到页脚部分&lt;/li&gt;
&lt;li&gt;引入样式的几种方式的权重&lt;/li&gt;
&lt;li&gt;css属性书写顺序建议&lt;/li&gt;
&lt;li&gt;何种类型的DOM操作是耗费性能的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;学习本门课你能收获什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端页面优化，为成为SEO路添砖加瓦&lt;/li&gt;
&lt;li&gt;写出优质代码，页面性能蹭蹭蹭的往上走&lt;/li&gt;
&lt;li&gt;面试如果提到页面优化，可以娓娓道来，牛皮吹的飞起…&lt;/li&gt;
&lt;li&gt;几种常见的页面优化工具的使用PageSpeed，JSPerf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;课程准备：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册github账号&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;页面性能优化&#34;&gt;&lt;a href=&#34;#页面性能优化&#34; class=&#34;headerlink&#34; title=&#34;页面性能优化&#34;&gt;&lt;/a&gt;页面性能优化&lt;/h2&gt;&lt;p&gt;前端性能优化可以分为两大部分：浏览器部分、代码部分。&lt;/p&gt;
&lt;p&gt;浏览器部分又可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络层面&lt;/li&gt;
&lt;li&gt;浏览器渲染层面&lt;/li&gt;
&lt;li&gt;服务端层面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码部分又可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建层面&lt;/li&gt;
&lt;li&gt;编码层面&lt;/li&gt;
&lt;li&gt;机制(SSR，英文Server Side Render：服务器端渲染)&lt;/li&gt;
&lt;li&gt;规范&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先来看看浏览器部分：前端的页面主要在浏览器上运行着，那么我们追根溯源，从浏览器的原理开始，研究如何进行页面性能优化。&lt;/p&gt;
&lt;h3 id=&#34;浏览器&#34;&gt;&lt;a href=&#34;#浏览器&#34; class=&#34;headerlink&#34; title=&#34;浏览器&#34;&gt;&lt;/a&gt;浏览器&lt;/h3&gt;&lt;p&gt;目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2dzLnN0YXRjb3VudGVyLmNvbS8=&#34;&gt;StatCounter 浏览器统计数据&lt;/span&gt;，目前（2019年 6 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率 62.7%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190618165435861.png&#34; alt=&#34;/images/image-20190618165435861&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;浏览器的主要作用&#34;&gt;&lt;a href=&#34;#浏览器的主要作用&#34; class=&#34;headerlink&#34; title=&#34;浏览器的主要作用&#34;&gt;&lt;/a&gt;浏览器的主要作用&lt;/h4&gt;&lt;p&gt;浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这些网络资源包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;JavaScript的&lt;/li&gt;
&lt;li&gt;媒体（图片，视频等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以分为HTML文档(HTML&amp;#x2F;CSS&amp;#x2F;JS)、PDF、图片、视频和其他类型。&lt;/p&gt;
&lt;p&gt;浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。&lt;br&gt;多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。&lt;/p&gt;
&lt;p&gt;浏览器的用户界面有很多彼此相同的元素，其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来输入 URI 的地址栏&lt;/li&gt;
&lt;li&gt;前进和后退按钮&lt;/li&gt;
&lt;li&gt;书签设置选项&lt;/li&gt;
&lt;li&gt;用于刷新和停止加载当前文档的刷新和停止按钮&lt;/li&gt;
&lt;li&gt;用于返回主页的主页按钮&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一些比较有趣的事情：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Safari是乔布斯在2003年的Macworld大会发布的，9年过去了，08年才发展起来的Chrome用了不到Safari一半的时间远远把Safari甩在了后面，这让Safari情何以堪。&lt;/p&gt;
&lt;p&gt;两大浏览器都是基于苹果的布局引擎Webkit，按道理Safari是占优势的，因为两者都分别是自己操作系统的默认浏览器，许多人就顺便使用了，懒得去下载别的浏览器。&lt;/p&gt;
&lt;p&gt;许多人可能会想，这还不简单，Chrome运行于Windows操作系统，而Safari大部分时候都用于苹果自己的系统，Windows .VS. OS X，哪个使用人群广？很显然是前者，所以Chrome当然比Safari发真快，&lt;strong&gt;可是，实际上Safari要比Chrome更早登陆Windows。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在2007年六月，Safari for Windows Beta版就已经发布，正式版于2008年三月发布，而Chrome直到2008年的九月才发布，Chrome只用了一年的时间就超过了Safari。&lt;/p&gt;
&lt;p&gt;大量Benchmark测试表明Chrome不管在网页打开还是JavaScript表现方面，速度都最快。&lt;/p&gt;
&lt;p&gt;但是，当Safari发布Windows版的时候，测试结果也是一样的，不管在Mac还是PC上测试，那时候都是最快的，如果仅仅是因为速度，那么Safari在2007年六月的表现就应该和chrome在2008年九月的时候一样。&lt;/p&gt;
&lt;p&gt;难道Chrome胜在插件？也许，不过Safari在2010年年中的时候也有了许多插件，当然，Chrome的插件质量更好更丰富，如果这也足够让Safari落后于Chrome，那么开发商们可能早就将游戏植入Chrome，而且，Firefox也先于Chrome和Safari植入插件，现在不也败给了Chrome吗？&lt;/p&gt;
&lt;p&gt;主要原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Safari用起来不舒服，google推广给力&lt;/li&gt;
&lt;li&gt;独特的用户体验(UI、交互、云、Google全家桶)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;那么Safari就一文不值了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，Mac上的用户使用safari更加的省电、省资源，稳定性会更好。&lt;strong&gt;插件不需要爬梯子！！！&lt;/strong&gt;更低的学习成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IE(Internet Explorer)的黑历史：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IE 浏览器的开发应该是在 1994 年中开始的，那是我还在读大学。微软为了对抗当时的主流浏览器 NetScape，准备开发自己的浏览器并在 Windows 中默认捆绑销售。但是，留给微软的时间并不充裕，他们没时间从零开始，于是和 Spyglass 合作开发，于是，计算机历史上最著名也最臭名昭著的浏览器 IE 诞生了。因为强大的功能和捆绑策略，IE 迅速击败了 NetScape，成为浏览器市场的绝对霸主。&lt;/p&gt;
&lt;p&gt;在 2002 年，IE 已经拥有了95%的市场份额，几乎打败了所有的竞争对手。大为僵，又不思进取，于是颠覆者前仆后继。Firefox 开始迅速崛起，Chrome 后来居上，反观 IE，出现了各种安全漏洞和兼容性问题。2006年，IE 被评为“史上第八糟科技产品”。在相当长的时间里，&lt;strong&gt;IE 浏览器是前端程序员员的噩梦&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;带给我们的思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件迭代更新的重要性(居安思危)&lt;/li&gt;
&lt;li&gt;用户体验、用户感知的重要性(人性化产品)&lt;/li&gt;
&lt;li&gt;互联网时代，什么都是可以替代的&lt;/li&gt;
&lt;li&gt;分享、免费、共筑共赢才是互联网的精神&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;浏览器的组成结构&#34;&gt;&lt;a href=&#34;#浏览器的组成结构&#34; class=&#34;headerlink&#34; title=&#34;浏览器的组成结构&#34;&gt;&lt;/a&gt;浏览器的组成结构&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&#34;/./assets/layers.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;用户界面（User Interface）&lt;/strong&gt; - 包括地址栏、前进&amp;#x2F;后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;浏览器引擎（Browser engine）&lt;/strong&gt; - 在用户界面和渲染引擎之间传送指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;渲染引擎（Rendering engine）&lt;/strong&gt; - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以叫呈现引擎（Rendering Engine）或者布局引擎（Layout Engine）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;默认情况下，渲染引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。&lt;/p&gt;
&lt;p&gt;浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种渲染引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的渲染引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;浏览器&lt;/th&gt;
&lt;th&gt;渲染引擎（开发语言）&lt;/th&gt;
&lt;th&gt;脚本引擎（开发语言）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Chrome&lt;/td&gt;
&lt;td&gt;Blink (c++)&lt;/td&gt;
&lt;td&gt;V8 (c++)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Opera&lt;/td&gt;
&lt;td&gt;Blink (c++)&lt;/td&gt;
&lt;td&gt;V8 (c++)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Safari&lt;/td&gt;
&lt;td&gt;Webkit (c++)&lt;/td&gt;
&lt;td&gt;JavaScript Core (nitro)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FireFox&lt;/td&gt;
&lt;td&gt;Gecko (c++)&lt;/td&gt;
&lt;td&gt;SpiderMonkey (c&amp;#x2F;c++)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge&lt;/td&gt;
&lt;td&gt;EdgeHTML (c++)&lt;/td&gt;
&lt;td&gt;Chakra JavaScript Engine (c++)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IE&lt;/td&gt;
&lt;td&gt;Trident (c++)&lt;/td&gt;
&lt;td&gt;Chakra JScript Engine (c++)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;Firefox在2017年启用了新的web引擎Quantum，Quantum 以 Gecko 引擎为基础，同时利用了 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS9ydXN0LWxhbmcvcnVzdA==&#34;&gt;Rust&lt;/span&gt; 的良好并发性和 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NlcnZvL3NlcnZv&#34;&gt;Servo&lt;/span&gt; 的高性能组件，为 Firefox 带来了更多的并行化和 GPU 运算，让 Firefox 更快更可靠。&lt;/p&gt;
&lt;p&gt;2015 年 3 月，微软将放弃自家Edge：转而开发Chromium内核浏览器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它们的开发时间轴：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190618172835156.png&#34; alt=&#34;/images/image-20190618172835156&#34;&gt;&lt;/p&gt;
&lt;p&gt;WebKit 是一种开放源代码渲染引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3dlYmtpdC5vcmcv&#34;&gt;webkit.org&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;网络（Networking）&lt;/strong&gt; - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;用户界面后端（UI Backend）&lt;/strong&gt; - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JavaScript 解释器（JavaScript Interpreter）&lt;/strong&gt;。用于解析和执行 JavaScript 代码，如 V8 引擎。&lt;/p&gt;
&lt;p&gt;JS引擎线程负责解析Javascript脚本，运行代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS引擎一直等待任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中只有一个JS线程在运行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据存储（Data Persistence）&lt;/strong&gt;。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;浏览器是多进程的&#34;&gt;&lt;a href=&#34;#浏览器是多进程的&#34; class=&#34;headerlink&#34; title=&#34;浏览器是多进程的&#34;&gt;&lt;/a&gt;浏览器是多进程的&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;进程线程简单的理解：进程里面可以有多个线程，进程就是QQ，线程就是会话。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;浏览器是多进程的&lt;/li&gt;
&lt;li&gt;浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）&lt;/li&gt;
&lt;li&gt;简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器里面的进程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责浏览器界面显示，与用户交互。如前进，后退等&lt;/li&gt;
&lt;li&gt;负责各个页面的管理，创建和销毁其他进程&lt;/li&gt;
&lt;li&gt;将Renderer进程得到的内存中的Bitmap，绘制到用户界面上&lt;/li&gt;
&lt;li&gt;网络资源的管理，下载等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GPU进程：最多一个，用于3D绘制等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;渲染进程（浏览器内核）（Renderer进程，内部是多线程的）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认每个Tab页面一个进程，互不影响。&lt;/li&gt;
&lt;li&gt;主要作用为页面渲染，脚本执行，事件处理等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;渲染进程是多线程的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;GUI渲染线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;js引擎线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）&lt;/li&gt;
&lt;li&gt;JS引擎线程负责解析Javascript脚本，运行代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JS引擎一直等待任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中只有一个JS线程在运行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同样注意，GUI渲染线程与JS引擎线程是互斥的。所以如果JS执行的时间过长，要放在body下面，否则就会导致页面渲染加载阻塞。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件触发线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理着事件队列&lt;/li&gt;
&lt;li&gt;监听事件，符合条件时把回调函数放入事件队列中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定时触发器线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setInterval与setTimeout在此线程中计时完毕后，把回调函数放入事件队列中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浏览器定时计数器并不是由JavaScript引擎计数的&lt;/strong&gt;,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确），因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）&lt;/li&gt;
&lt;li&gt;注意，W3C在HTML标准中规定，规定要求&lt;strong&gt;setTimeout中低于4ms的时间间隔算为4ms&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异步http请求线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检测到XHR对象状态变化时，将回调函数放入事件队列中&lt;/li&gt;
&lt;li&gt;将检测到状态变更时，如果设置有回调函数，异步线程就&lt;strong&gt;产生状态变更事件&lt;/strong&gt;，将这个回调再放入事件队列中。再由JavaScript引擎执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解 一下，执行线：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619165952240.png&#34; alt=&#34;/images/image-20190619165952240&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;渲染线程与JS引擎线程互斥&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。&lt;/p&gt;
&lt;p&gt;因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。&lt;/p&gt;
&lt;p&gt;举一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
      // 页面上的hello world不会变成红色
      document.getElementById(&amp;quot;app&amp;quot;).style.color = &amp;quot;red&amp;quot;;
    &amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
      hello world!
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;JS阻塞页面加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。&lt;/p&gt;
&lt;p&gt;譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。&lt;/p&gt;
&lt;p&gt;所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;css加载不会阻塞DOM树解析（异步加载时DOM照常构建），但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）&lt;/li&gt;
&lt;li&gt;Javascript 阻塞 DOM 解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;浏览器的渲染机制&#34;&gt;&lt;a href=&#34;#浏览器的渲染机制&#34; class=&#34;headerlink&#34; title=&#34;浏览器的渲染机制&#34;&gt;&lt;/a&gt;浏览器的渲染机制&lt;/h4&gt;&lt;p&gt;对于渲染，我们首先需要了解一个概念：设备刷新率。&lt;/p&gt;
&lt;p&gt;设备刷新率是设备屏幕渲染的频率，通俗一点就是，把屏幕当作墙，设备刷新率就是多久重新粉刷一次墙面。基本我们平常接触的设备，如手机、电脑，它们的默认刷新频率都是60FPS，也就是屏幕在1s内渲染60次，约16.7ms渲染一次屏幕。&lt;/p&gt;
&lt;p&gt;这就意味着，我们的浏览器最佳的渲染性能就是所有的操作在一帧16.7ms内完成，能否做到一帧内完成直接决定着渲染性，影响用户交互。&lt;/p&gt;
&lt;p&gt;渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。&lt;/p&gt;
&lt;p&gt;然后进行如下所示的&lt;strong&gt;基本流程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/flow.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;渲染引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI0RPTQ==&#34;&gt;DOM&lt;/span&gt; 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI1JlbmRlcl90cmVlX2NvbnN0cnVjdGlvbg==&#34;&gt;呈现树&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。&lt;/p&gt;
&lt;p&gt;呈现树构建完毕之后，进入“&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI2xheW91dA==&#34;&gt;布局&lt;/span&gt;”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI1BhaW50aW5n&#34;&gt;绘制&lt;/span&gt; - 渲染引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。&lt;/p&gt;
&lt;p&gt;需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那么我们知道了，CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM 树与 CSSOM 树合并后形成渲染树。&lt;/li&gt;
&lt;li&gt;渲染树只包含渲染网页所需的节点。&lt;/li&gt;
&lt;li&gt;布局计算每个对象的精确位置和大小。&lt;/li&gt;
&lt;li&gt;最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/render-tree-construction.png&#34; alt=&#34;DOM CSSOM RenderTree&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意 &lt;code&gt;visibility: hidden&lt;/code&gt; 与 &lt;code&gt;display: none&lt;/code&gt; 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (&lt;code&gt;display: none&lt;/code&gt;) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们以webkit的渲染作为示例：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/webkitflow.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用调试工具来看一个真实的例子：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190618182337662.png&#34; alt=&#34;/images/image-20190618182337662&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;script&lt;/code&gt;标签的处理&lt;/p&gt;
&lt;p&gt;JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在解析HTML时，一旦碰到&lt;code&gt;script&lt;/code&gt;，就会立即停止HTML的解析（而CSS不会），执行JS，再返还控制权。&lt;/p&gt;
&lt;p&gt;事实上，JS执行前不仅仅是停止了HTML的解析，它还必须等待CSS的解析完成。当浏览器碰到&lt;code&gt;script&lt;/code&gt;元素时，发现该元素前面的CSS还未解析完，就会等待CSS解析完成，再去执行JS。&lt;/p&gt;
&lt;p&gt;JS阻塞了HTML的解析，也阻塞了其后的CSS解析，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。一个script标签，推迟了DOM的生成、CSSOM的生成以及之后的所有渲染过程，从性能角度上讲，将&lt;code&gt;script&lt;/code&gt;放在页面底部，也就合情合理了。&lt;/p&gt;
&lt;p&gt;简单来说：渲染线程与JS引擎线程是互斥的，当JS引擎执行时渲染线程会被挂起（相当于被冻结了），渲染更新会被保存在一个队列中等到JS引擎空闲时立即被执行。&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;p&gt;浏览器的渲染流程分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM树构建 &lt;/li&gt;
&lt;li&gt;CSSOM树构建 &lt;/li&gt;
&lt;li&gt;RenderObject树构建 &lt;/li&gt;
&lt;li&gt;布局&lt;/li&gt;
&lt;li&gt;绘制&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;重排reflow与重绘repaint&#34;&gt;&lt;a href=&#34;#重排reflow与重绘repaint&#34; class=&#34;headerlink&#34; title=&#34;重排reflow与重绘repaint&#34;&gt;&lt;/a&gt;重排reflow与重绘repaint&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;重排reflow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;reflow指的是重新计算页面布局。&lt;/p&gt;
&lt;p&gt;某个节点reflow时会重新计算节点的尺寸和位置，而且还有可能触发其子节点、祖先节点和页面上的其他节点reflow。在这之后再触发一次repaint。&lt;/p&gt;
&lt;p&gt;当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流,每个页面至少需要一次回流，就是在页面第一次加载的时候。&lt;/p&gt;
&lt;p&gt;导致reflow的操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调整窗口大小&lt;/li&gt;
&lt;li&gt;改变字体&lt;/li&gt;
&lt;li&gt;增加或者移除样式表&lt;/li&gt;
&lt;li&gt;内容变化，比如用户在input框中输入文字&lt;/li&gt;
&lt;li&gt;激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)&lt;/li&gt;
&lt;li&gt;操作 class 属性&lt;/li&gt;
&lt;li&gt;脚本操作 DOM&lt;/li&gt;
&lt;li&gt;计算 offsetWidth 和 offsetHeight 属性&lt;/li&gt;
&lt;li&gt;设置 style 属性的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;触发页面重布局的一些css属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盒子模型相关属性会触发重布局&lt;ul&gt;
&lt;li&gt;&lt;code&gt;width&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;height&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;padding&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;margin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;display&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border-width&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min-height&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定位属性及浮动也会触发重布局&lt;ul&gt;
&lt;li&gt;&lt;code&gt;top&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bottom&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;left&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;right&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;position&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;改变节点内部文字结构也会触发重布局&lt;ul&gt;
&lt;li&gt;&lt;code&gt;text-align&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;overflow-y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font-weight&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;overflow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font-family&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;line-height&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vertical-align&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;white-space&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font-size&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;重绘repaint&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;repiant或者redraw遍历所有的节点检测各节点的可见性、颜色、轮廓等可见的样式属性，然后根据检测的结果更新页面的响应部分。&lt;/p&gt;
&lt;p&gt;当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘&lt;/p&gt;
&lt;p&gt;只触发重绘不触发重排的一些CSS属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border-style&lt;/code&gt;、&lt;code&gt;border-radius&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;visibility&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text-decoration&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;background&lt;/code&gt;、&lt;code&gt;background-image&lt;/code&gt;、&lt;code&gt;background-position&lt;/code&gt;、&lt;code&gt;background-repeat&lt;/code&gt;、&lt;code&gt;background-size&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;outline&lt;/code&gt;、&lt;code&gt;outline-color&lt;/code&gt;、&lt;code&gt;outline-style&lt;/code&gt;、&lt;code&gt;outline-width&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;box-shadow&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var bstyle = document.body.style; // cache

bstyle.padding = &amp;quot;20px&amp;quot;; // reflow, repaint
bstyle.border = &amp;quot;10px solid red&amp;quot;; //  再一次的 reflow 和 repaint

bstyle.color = &amp;quot;blue&amp;quot;; // repaint
bstyle.backgroundColor = &amp;quot;#fad&amp;quot;; // repaint

bstyle.fontSize = &amp;quot;2em&amp;quot;; // reflow, repaint

// new DOM element - reflow, repaint
document.body.appendChild(document.createTextNode(&amp;#39;dude!&amp;#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。&lt;/p&gt;
&lt;p&gt;但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少重绘与重排：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重绘和回流在实际开发中是很难避免的，我们能做的就是尽量减少这种行为的发生。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;js尽量少访问dom节点和css 属性，尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。(虚拟DOM)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量通过class来设计元素样式，切忌用style 多次操作单个属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;// bad
var left = 10,
top = 10;
el.style.left = left + &amp;quot;px&amp;quot;;
el.style.top  = top  + &amp;quot;px&amp;quot;;

// Good
el.className += &amp;quot; theclassname&amp;quot;;

// Good
el.style.cssText += &amp;quot;; left: &amp;quot; + left + &amp;quot;px; top: &amp;quot; + top + &amp;quot;px;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽可能的为产生动画的 HTML 元素使用 &lt;code&gt;fixed&lt;/code&gt; 或 &lt;code&gt;absolute&lt;/code&gt; 的 &lt;code&gt;position&lt;/code&gt; ，那么修改他们的 CSS 是不会 Reflow 的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;img标签要设置高宽，以减少重绘重排&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把DOM离线后修改，如将一个dom脱离文档流，比如&lt;code&gt;display：none&lt;/code&gt; ，再修改属性，这里只发生一次回流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量用 &lt;code&gt;transform&lt;/code&gt; 来做形变和位移，不会造成回流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS:  display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;p&gt;重排：元素的尺寸变了、位置变了&lt;/p&gt;
&lt;p&gt;重绘：元素的颜色、背景、边框、轮廓变了，但是，元素的几何尺寸没有变。&lt;/p&gt;
&lt;p&gt;Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。&lt;/p&gt;
&lt;h3 id=&#34;页面加载缓慢的原因&#34;&gt;&lt;a href=&#34;#页面加载缓慢的原因&#34; class=&#34;headerlink&#34; title=&#34;页面加载缓慢的原因&#34;&gt;&lt;/a&gt;页面加载缓慢的原因&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/./assets/browser-rendering.gif&#34; alt=&#34;browser-rendering&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/backend-generation.gif&#34; alt=&#34;backend-generation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/wpo-front-backend.png&#34; alt=&#34;wpo-front-backend&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;浏览器部分&#34;&gt;&lt;a href=&#34;#浏览器部分&#34; class=&#34;headerlink&#34; title=&#34;浏览器部分&#34;&gt;&lt;/a&gt;浏览器部分&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网络层面&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;过多的HTTP请求&lt;/p&gt;
&lt;p&gt;打开一个网页的时候，后台程序的响应并不所需太多时间，等待的时间主要花费在下载网页元素上了，即HTML、CSS、JavaScript、Flash、图片等。据统计，每增加一个元素，网页载入的时间就会增加25-40毫秒（具体取决于用户的带宽情况）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;资源访问带宽小&lt;/p&gt;
&lt;p&gt;两方面，一方面是客户端的带宽，一方面是服务器端的带宽。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网页元素(图片、视频、样式)太大&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器渲染层面&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;渲染阻塞：&lt;/p&gt;
&lt;p&gt;浏览器想要渲染一个页面就必须先构建出&lt;code&gt;DOM&lt;/code&gt;树与&lt;code&gt;CSSOM&lt;/code&gt;树，如果&lt;code&gt;HTML&lt;/code&gt;与&lt;code&gt;CSS&lt;/code&gt;文件结构非常庞大与复杂，这显然会给页面加载速度带来严重影响。&lt;/p&gt;
&lt;p&gt;所谓渲染阻塞资源，即是对该资源发送请求后还需要先构建对应的&lt;code&gt;DOM&lt;/code&gt;树或&lt;code&gt;CSSOM&lt;/code&gt;树，这种行为显然会延迟渲染操作的开始时间。&lt;/p&gt;
&lt;p&gt;JS阻塞与CSS阻塞：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML、CSS、JavaScript都是会对渲染产生阻塞的资源，HTML是必需的（没有DOM还谈何渲染），但还可以从CSS与JavaScript着手优化，尽可能地减少阻塞的产生。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重复渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DNS解析&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务端层面&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬件配置低：这个是双向的&lt;/li&gt;
&lt;li&gt;服务器软件，比如防火墙、内网策略等&lt;/li&gt;
&lt;li&gt;未对Nginx这类web服务器进行配置优化&lt;/li&gt;
&lt;li&gt;CPU占满、数据库未优化&lt;/li&gt;
&lt;li&gt;代码问题，代码效率，代码性能&lt;/li&gt;
&lt;li&gt;包含了过多的分析类工具&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;代码部分&#34;&gt;&lt;a href=&#34;#代码部分&#34; class=&#34;headerlink&#34; title=&#34;代码部分&#34;&gt;&lt;/a&gt;代码部分&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;构建层面&lt;/p&gt;
&lt;p&gt;未对代码进行打包、压缩、兼容性优化。&lt;/p&gt;
&lt;p&gt;未合并重复的请求、代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编码层面&lt;/p&gt;
&lt;p&gt;没有良好的编码习惯，错误的编排JS与CSS&lt;/p&gt;
&lt;p&gt;for循环、迭代、同步、重定向、阻塞请求&lt;/p&gt;
&lt;p&gt;未删除重复、无用的代码&lt;/p&gt;
&lt;p&gt;未对逻辑业务复杂的代码进行重构，了解设计模式，对业务进行疏理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;机制(SSR，英文Server Side Render：服务器端渲染)&lt;/p&gt;
&lt;p&gt;未加入Async异步机制&lt;/p&gt;
&lt;p&gt;未思考页面加载、用户体验&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;规范&lt;/p&gt;
&lt;p&gt;CSS规范&lt;/p&gt;
&lt;p&gt;HTML规范&amp;#x2F;HTML5规范&lt;/p&gt;
&lt;p&gt;Airbnb代码规范等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优化原则&#34;&gt;&lt;a href=&#34;#优化原则&#34; class=&#34;headerlink&#34; title=&#34;优化原则&#34;&gt;&lt;/a&gt;优化原则&lt;/h3&gt;&lt;h4 id=&#34;尽量减少HTTP请求&#34;&gt;&lt;a href=&#34;#尽量减少HTTP请求&#34; class=&#34;headerlink&#34; title=&#34;尽量减少HTTP请求&#34;&gt;&lt;/a&gt;尽量减少HTTP请求&lt;/h4&gt;&lt;p&gt;在浏览器(客户端)和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。&lt;/p&gt;
&lt;p&gt;一个正常HTTP请求的流程简述：如在浏览器中输入”&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy54eHh4eHguY29t&#34;&gt;www.xxxxxx.com&amp;quot;并按下回车，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而当我们请求的网页文件中有很多图片、CSS、JS甚至音乐等信息时，将会频繁的与服务器建立连接，与释放连接，这必定会造成资源的浪费，且每个HTTP请求都会对服务器和浏览器产生性能负担。&lt;/p&gt;
&lt;p&gt;网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要耗费的网络资源更多。所以，请减少HTTP请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;组合文件，优化图片，使用sprites设计风格: 将背景图片合并成一个文件，通过&lt;code&gt;background-image&lt;/code&gt; 和 &lt;code&gt;background-position&lt;/code&gt; 控制显示；&lt;/p&gt;
&lt;p&gt;确保您的图像不大于它们所需的图像，它们采用正确的文件格式（PNG通常更适用于少于16种颜色的图形，而JPEG通常更适合照片）并且它们是针对Web压缩的。&lt;/p&gt;
&lt;p&gt;使用CSS sprites在网站上经常使用的图像创建模板，如按钮和图标。CSS sprites将您的图像组合成一个大图像，一次加载所有（这意味着更少的HTTP请求），然后只显示您想要显示的部分。这意味着您通过不让用户等待加载多个图像来节省加载时间。&lt;/p&gt;
&lt;p&gt;有一些在线工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5zcHJpdGVjb3cuY29tLw==&#34;&gt;Sprite Cow&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuc3ByaXRlYm94Lm5ldC8=&#34;&gt;Spritebox&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;肉联图片，使用&lt;code&gt;data:URL&lt;/code&gt;方案将图像数据嵌入实际页面中。这可以增加HTML文档的大小。将内嵌图像组合到（缓存的）样式表中是一种减少HTTP请求并避免增加页面大小的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简化页面的设计&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;使用内容传送网络CDN&#34;&gt;&lt;a href=&#34;#使用内容传送网络CDN&#34; class=&#34;headerlink&#34; title=&#34;使用内容传送网络CDN&#34;&gt;&lt;/a&gt;使用内容传送网络CDN&lt;/h4&gt;&lt;p&gt;内容分发网络（CDN），也称为内容传送网络，是用于分发传送内容的负载的服务器网络。从本质上讲，您网站的副本存储在多个地理位置不同的数据中心，以便用户可以更快，更可靠地访问您的网站。&lt;/p&gt;
&lt;p&gt;对于初创公司和私人网站来说，CDN服务的成本可能过高，但随着您的目标受众变得越来越大并变得更加全球化，CDN对于实现快速响应时间是必要的。&lt;/p&gt;
&lt;p&gt;请记住，最终用户响应时间的80-90％用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是&lt;em&gt;Performance Golden Rule&lt;/em&gt;。而不是从重新设计应用程序架构的艰巨任务开始，最好首先分散您的静态内容。这不仅可以大大缩短响应时间，而且由于内容交付网络，它更容易实现。&lt;/p&gt;
&lt;p&gt;内容传送网络（CDN）是分布在多个位置的Web服务器的集合，以更有效地向用户传送内容。选择用于向特定用户传送内容的服务器通常基于网络接近度的度量。例如，选择具有最少网络跳数的服务器或具有最快响应时间的服务器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CDN服务商有很多，这里就不再多说：专门做CDN服务器的蓝讯、网宿、帝联、快网，还有阿里云、腾讯云、华为云等。国外如&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5ha2FtYWkuY29tLw==&#34;&gt;Akamai Technologies&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5lZGdlY2FzdC5jb20v&#34;&gt;EdgeCast&lt;/span&gt;或&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5sZXZlbDMuY29tL2luZGV4LmNmbT9wYWdlSUQ9MzY=&#34;&gt;level3&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了去购买一些CDN服务商的服务以外，对于大多数开发者，可以使用公共CDN网络上的资源，如以下的方式去使用CDN加速：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!-- google --&amp;gt;
&amp;lt;script
  type=&amp;quot;text/javascript&amp;quot;
  src=&amp;quot;http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js&amp;quot;
&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- cdnjs --&amp;gt;
&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- qiniu cloud --&amp;gt;
&amp;lt;script src=&amp;quot;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- other cdn --&amp;gt;
&amp;lt;script
  crossorigin=&amp;quot;anonymous&amp;quot;
  integrity=&amp;quot;sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh&amp;quot;
  src=&amp;quot;https://lib.baomitu.com/jquery/3.4.1/jquery.min.js&amp;quot;
&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;避免空src或者是href值&#34;&gt;&lt;a href=&#34;#避免空src或者是href值&#34; class=&#34;headerlink&#34; title=&#34;避免空src或者是href值&#34;&gt;&lt;/a&gt;避免空src或者是href值&lt;/h4&gt;&lt;p&gt;空的src和href都会导致多余的HTTP请求，虽然不影响加载时间，但是会对服务器产生不必要的流量和压力。浏览器仍然会向服务器发起一个 HTTP 请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IE 向页面所在的目录发送请求&lt;/li&gt;
&lt;li&gt;Safari、Chrome、Firefox 向页面本身发送请求&lt;/li&gt;
&lt;li&gt;Opera 不执行任何操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;空的src的image严重的以至于影响整个网站的用户体验，空 &lt;code&gt;src&lt;/code&gt; 产生请求的后果不容小憩：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给服务器造成意外的流量负担，尤其时日 PV 较大时；&lt;/li&gt;
&lt;li&gt;浪费服务器计算资源；&lt;/li&gt;
&lt;li&gt;可能产生报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有两种形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTML形式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JavaScript形式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var img = new Image();
img.src = &amp;quot;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除空的&lt;code&gt;src&lt;/code&gt;和&lt;code&gt;href&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;给&lt;code&gt;a&lt;/code&gt;标签的&lt;code&gt;href&lt;/code&gt;属性，连接到实际的页面：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;#nogo&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;##&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;###&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;void(0);&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;void(0)&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;禁止跳转，添加&lt;code&gt;cursor:pointer&lt;/code&gt;样式&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;style&amp;gt;
    a&amp;#123;cursor: pointer&amp;#125;
&amp;lt;/style&amp;gt;
&amp;lt;a&amp;gt;点击一&amp;lt;/a&amp;gt;
&amp;lt;a onclick=&amp;quot;doSomething()&amp;quot;&amp;gt;点击二&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;给&lt;code&gt;a&lt;/code&gt; 标签创建一个带有描述信息的&lt;code&gt;href&lt;/code&gt; 属性，并监控&lt;code&gt;click&lt;/code&gt;事件调用&lt;code&gt;preventDefault()&lt;/code&gt;函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;a href=&amp;quot;#Something_De scriptive&amp;quot; id=&amp;quot;my_id&amp;quot;&amp;gt;Trigger&amp;lt;/a&amp;gt;
&amp;lt;script&amp;gt;
    $(&amp;quot;#my_id&amp;quot;).click(function(e)&amp;#123;
        e.preventDefault(); //取消单击事件的默认动作以阻止链接的跳转。
        //  其他的代码
&amp;#125;)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;够响应键盘事件并获得焦点（从而屏幕阅读器能够读出背后的内容，增强可访问性）&lt;/li&gt;
&lt;li&gt;优雅降级，在网络连接很差，还没有加载到CSS的时候，&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;依然有手型与正常的link样式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;gzip的组件&#34;&gt;&lt;a href=&#34;#gzip的组件&#34; class=&#34;headerlink&#34; title=&#34;gzip的组件&#34;&gt;&lt;/a&gt;gzip的组件&lt;/h4&gt;&lt;p&gt;所有现代浏览器都支持 &lt;code&gt;gzip&lt;/code&gt; 压缩并会为所有 HTTP 请求自动协商此类压缩。启用 &lt;code&gt;gzip&lt;/code&gt; 压缩可大幅缩减所传输的响应的大小（最多可缩减 90%），从而显著缩短下载相应资源所需的时间、减少客户端的流量消耗并加快网页的首次呈现速度。 &lt;/p&gt;
&lt;p&gt;从HTTP &amp;#x2F; 1.1开始，Web客户端表示支持使用HTTP请求中的Accept-Encoding标头进行压缩。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Accept-Encoding：gzip，deflate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;压缩包括XML和JSON在内的任何文本响应都是值得的。不应对图像和PDF文件进行gzip压缩，因为它们已经过压缩。试图对它们进行gzip不仅会浪费CPU，还可能会增加文件大小。&lt;/p&gt;
&lt;p&gt;比如，在nginx中开启gzip压缩：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 开启gzip
gzip on;
# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩
gzip_min_length 1k;
# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明
gzip_comp_level 2;
# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。
gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;
# 是否在http header中添加Vary: Accept-Encoding，建议开启
gzip_vary on;
# 禁用IE 6 gzip
gzip_disable &amp;quot;MSIE [1-6]\.&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他web容器启动gzip的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache：使用 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2h0dHBkLmFwYWNoZS5vcmcvZG9jcy9jdXJyZW50L21vZC9tb2RfZGVmbGF0ZS5odG1s&#34;&gt;mod_deflate&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Nginx：使用 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfZ3ppcF9tb2R1bGUuaHRtbA==&#34;&gt;ngx_http_gzip_module&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;IIS：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3RlY2huZXQubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjNzcxMDAzKHY9V1MuMTApLmFzcHg=&#34;&gt;配置 HTTP 压缩功能&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;CSS放在顶部，JS放在底部&#34;&gt;&lt;a href=&#34;#CSS放在顶部，JS放在底部&#34; class=&#34;headerlink&#34; title=&#34;CSS放在顶部，JS放在底部&#34;&gt;&lt;/a&gt;CSS放在顶部，JS放在底部&lt;/h4&gt;&lt;p&gt;把Javascript脚本在底部，删除阻止渲染的JavaScript&lt;br&gt;在HTML文件&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;中指定外部样式表和内联样式块可能对浏览器的渲染性能产生不利影响。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器阻塞渲染网页直到所有外部的样式表都已被下载。&lt;/li&gt;
&lt;li&gt;（用&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;标记指定的）内联样式块可能会导致reflows和页面跳动。&lt;br&gt;因此，把外部样式表和内联样式块放在页面的&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中是很重要的。通过确保样式表首先被下载和解析，可以让浏览器逐步渲染页面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将内联样式块和&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;元素从页面&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;移动到页面&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;HTML 4.01规范（第12.3节）规定，始终把使用&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;标签的外部样式表放在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;部分里，还要确保您指定的样式有正确的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;区块放在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;部分里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用css媒体类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果可以让&lt;code&gt;CSS&lt;/code&gt;资源只在特定条件下使用，这样这些资源就可以在首次加载时先不进行构建&lt;code&gt;CSSOM&lt;/code&gt;树，只有在符合特定条件时，才会让浏览器进行阻塞渲染然后构建&lt;code&gt;CSSOM&lt;/code&gt;树。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CSS&lt;/code&gt;的媒体查询正是用来实现这个功能的，它由媒体类型以及零个或多个检查特定媒体特征状况的表达式组成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!-- 没有使用媒体查询，这个css资源会阻塞渲染  --&amp;gt;
&amp;lt;link href=&amp;quot;style.css&amp;quot;    rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;!-- all是默认类型，它和不设置媒体查询的效果是一样的 --&amp;gt;
&amp;lt;link href=&amp;quot;style.css&amp;quot;    rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;all&amp;quot;&amp;gt;
&amp;lt;!-- 动态媒体查询， 将在网页加载时计算。
根据网页加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。--&amp;gt;
&amp;lt;link href=&amp;quot;portrait.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;orientation:portrait&amp;quot;&amp;gt;
&amp;lt;!-- 只在打印网页时应用，因此网页首次在浏览器中加载时，它不会阻塞渲染。 --&amp;gt;
&amp;lt;link href=&amp;quot;print.css&amp;quot;    rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;print&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用媒体查询可以让CSS资源不在首次加载中阻塞渲染，但不管是哪种CSS资源它们的下载请求都不会被忽略，浏览器仍然会先下载CSS文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把Javascript脚本在底部，删除阻止渲染的JavaScript&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器必须通过在呈现页面之前解析HTML来构建DOM树。如果您的浏览器在此过程中遇到脚本，则必须先停止并执行它，然后才能继续。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;/p&gt;
&lt;p&gt;将脚本定义或引用放置到&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;底部。&lt;br&gt;&lt;code&gt;&amp;lt;script defer=&amp;quot;defer&amp;quot;&amp;gt;&lt;/code&gt; defer 属性规定是否对脚本执行进行延迟， 脚本将在页面完成解析时执行。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/bVcQV0.jpeg&#34; alt=&#34;请输入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。&lt;/p&gt;
&lt;p&gt;此图告诉我们以下几个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;defer&lt;/code&gt;和 &lt;code&gt;async&lt;/code&gt; 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）&lt;/li&gt;
&lt;li&gt;它俩的差别在于脚本下载完之后何时执行，显然 &lt;code&gt;defer&lt;/code&gt;*是最接近我们对于应用脚本加载和执行的要求的&lt;/li&gt;
&lt;li&gt;关于 &lt;code&gt;defer&lt;/code&gt;，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async&lt;/code&gt; 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行&lt;/li&gt;
&lt;li&gt;仔细想想，&lt;code&gt;async&lt;/code&gt;对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;减少DNS查找&#34;&gt;&lt;a href=&#34;#减少DNS查找&#34; class=&#34;headerlink&#34; title=&#34;减少DNS查找&#34;&gt;&lt;/a&gt;减少DNS查找&lt;/h4&gt;&lt;p&gt;用户访问网站的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在地址栏输入网站地址，如&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5leGFtcGxlLmNvbS8=&#34;&gt;www.example.com&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地DNS得到这个请求，查询本地DNS缓存，如果有这条记录，则直接返回对应的IP；否则，请求网络上的DNS服务器，得到相应的IP，返回给客户机，并缓存这条记录；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器向得到的IP发起建立连接请求，得到响应后建立连接，请求数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Server端计算所需数据，并返回给client端；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client端，即浏览器，解析数据并显示在浏览器窗口中，至此，请求完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 一次请求中，DNS解析可以占到请求时间的三分之一左右（这点有待验证），所以如果可以缩短DNS解析时间，就可以加快页面的打开速度。&lt;/p&gt;
&lt;p&gt;缩短DNS解析的 方法可以&lt;strong&gt;通过延长DNS缓存的时间&lt;/strong&gt;，&lt;strong&gt;选用更快的DNS Server&lt;/strong&gt;，&lt;strong&gt;减少域名总数&lt;/strong&gt;（例如原来有5个img server，分别为img1.xxx.com至img5.xxx.com，则现在可以减少到3个）等等，但是减少域名个数又会降低资源并行下载的数量， 因为同一域名最多可以并行下载两个资源，所以这里需要一个折衷方案，作者的建议就是将资源分布在大于等于2但小于等于4个域名上（这个也有待验证，例如针 对多大的系统选用多少个域名是最合理的等）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用DNS预解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里会有一些兼容性问题，可以参见：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWxpbmstcmVsLWRucy1wcmVmZXRjaA==&#34;&gt;http://caniuse.com/#feat=link-rel-dns-prefetch&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/sdfdsf.png&#34; alt=&#34;sdfdsf&#34;&gt;&lt;/p&gt;
&lt;p&gt;在网页体验中我们常会遇到这种情况，即在调用百度联盟、谷歌联盟以及当前网页所在域名外的域名文件时会遇到请求延时非常严重的情况。那么有没有方法去解决这种请求严重延时的现象呢？&lt;/p&gt;
&lt;p&gt;一般来说这种延时的原因不会是对方网站带宽或者负载的原因，那么到底是什么导致了这种情况呢。湛蓝试着进行推测，假设是DNS的问题，因为DNS解析速度很可能是造成资源延时的最大原因。在页面header中添加了以下代码（用以DNS预解析）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;meta http-equiv=&amp;quot;x-dns-prefetch-control&amp;quot; content=&amp;quot;on&amp;quot; /&amp;gt;

&amp;lt;link rel=&amp;quot;dns-prefetch&amp;quot; href=&amp;quot;http://bdimg.share.baidu.com&amp;quot; /&amp;gt;
&amp;lt;link rel=&amp;quot;dns-prefetch&amp;quot; href=&amp;quot;http://nsclick.baidu.com&amp;quot; /&amp;gt;
&amp;lt;link rel=&amp;quot;dns-prefetch&amp;quot; href=&amp;quot;http://hm.baidu.com&amp;quot; /&amp;gt;
&amp;lt;link rel=&amp;quot;dns-prefetch&amp;quot; href=&amp;quot;http://eiv.baidu.com&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新用户访问，后端可以通过 Cookie 判断是否为首次进入站点，对于这类用户，DNS Prefetch 可以比较明显地提升访问速度&lt;/li&gt;
&lt;li&gt;登录页，提前在页面上进行下一跳页用到资源的 DNS Prefetch&lt;/li&gt;
&lt;li&gt;页面中的静态资源在不同的domain下，如CSS、JS、图片等文件&lt;/li&gt;
&lt;li&gt;电商网站的商品页大量载入不同domain下的商品图，如淘宝&lt;/li&gt;
&lt;li&gt;手机网页&lt;/li&gt;
&lt;li&gt;大型网站&lt;/li&gt;
&lt;li&gt;js或服务端重定向&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Chrome中的一些指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chrome://histograms/DNS.PrefetchQueue&lt;/code&gt;：查看队列状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chrome://histograms/DNS&lt;/code&gt;：查看从浏览器启动到上一页的DNS记录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chrome://dns&lt;/code&gt;：查看个域名DNS统计&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chrome://net-internals/#dns&lt;/code&gt;：清除host缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;压缩资源&#34;&gt;&lt;a href=&#34;#压缩资源&#34; class=&#34;headerlink&#34; title=&#34;压缩资源&#34;&gt;&lt;/a&gt;压缩资源&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;压缩js，css，image&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过对外部资源进行压缩可以大幅度地减少浏览器需要下载的资源量，它会减少关键路径长度与关键字节，使页面的加载速度变得更快。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对数据进行压缩其实就是使用更少的位数来对数据进行重编码&lt;/strong&gt;。如今有非常多的压缩算法，且每一个的作用领域也各不相同，它们的复杂度也不相同，不过在这里我不会讲压缩算法的细节，感兴趣的朋友可以自己Google。&lt;/p&gt;
&lt;p&gt;在对&lt;code&gt;HTML&lt;/code&gt;、&lt;code&gt;CSS&lt;/code&gt;和&lt;code&gt;JavaScript&lt;/code&gt;这些文件进行压缩之前，还需要先进行一次冗余压缩。&lt;strong&gt;所谓冗余压缩，就是去除多余的字符，例如注释、空格符和换行符&lt;/strong&gt;。这些字符对于程序员是有用的，毕竟没有格式化的代码可读性是非常恐怖的，但它们对于浏览器是没有任何意义的，去除这些冗余可以减少文件的数据量。&lt;/p&gt;
&lt;p&gt;小图片采用base64的格式，直接嵌入代码中，可以帮我们减少http请求，但是同样，这个会造成我们代码的提及变大。请求的速度会减慢，这个需要平衡。&lt;/p&gt;
&lt;p&gt;常用工具：webpack，gulp&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器接收到服务器返回的HTML、CSS和JavaScript字节数据并对其进行解析和转变成像素的渲染过程被称为&lt;code&gt;关键渲染路径&lt;/code&gt;。通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除重复的脚本，类似&lt;code&gt;tree-shaking&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在一个页面中重复引用一个脚本可能存在的问题：浏览器会重复下载并执行脚本文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用合适大小的图片&lt;/p&gt;
&lt;p&gt;如果你只需要一个小图，就不要传一个大图。例如你实际需要显示的是一个60x60的头像，就不要传一个100x100的然后再通过设置宽高将它缩小为60x60的。原因很简单，这样会消耗不必要的带宽和系统资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;减少DOM元素的数量&lt;/p&gt;
&lt;p&gt;复杂页面意味着要下载更多字节，这也意味着JavaScript中的DOM访问速度更慢。如果您想要添加事件处理程序，例如，在页面上循环500或5000个DOM元素，则会有所不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用异步加载，async、defer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务端渲染也是一种减少浏览器资源消耗，减少页面重排重绘，也是一种现行MVVM框架单页应用最主要的SEO优化手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;避免3xx-x2F-4xx&#34;&gt;&lt;a href=&#34;#避免3xx-x2F-4xx&#34; class=&#34;headerlink&#34; title=&#34;避免3xx&amp;#x2F;4xx&#34;&gt;&lt;/a&gt;避免3xx&amp;#x2F;4xx&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;避免重定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3xx是重定向相关的HTTP响应代码&lt;/p&gt;
&lt;p&gt;重定向的意思是，用户的原始请求（例如请求A）被重定向到其他的请求（例如请求B）。&lt;/p&gt;
&lt;p&gt;每次页面重定向到另一个页面时，您的访问者都会面临等待HTTP请求 - 响应周期完成的额外时间。例如，如果移动重定向模式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;example.com&lt;/code&gt; - &amp;gt; &lt;code&gt;www.example.com&lt;/code&gt; - &amp;gt; &lt;code&gt;m.example.com&lt;/code&gt; - &amp;gt; &lt;code&gt;m.example.com/home&lt;/code&gt;，这两个额外重定向中的每一个都会使您的页面成为可能加载速度慢。&lt;/p&gt;
&lt;p&gt;HTTP 重定向通过 &lt;code&gt;301&lt;/code&gt;&amp;#x2F;&lt;code&gt;302&lt;/code&gt; 状态码实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 301 Moved Permanently  
Location: http://example.com/newuri  
Content-Type: text/html  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;301 Moved Permanently&lt;/code&gt;，这个状态码标识用户所请求的资源被移动到了另外的位置，客户端接收到此响应后，需要发起另外一个请求去下载所需的资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;302 Found&lt;/code&gt;，这个状态码标识用户所请求的资源被找到了，但不在原始位置，服务器会回复其他的一个位置，客户端收到此响应后，也需要发起另外一个请求去下载所需的资源。&lt;/p&gt;
&lt;p&gt;客户端收到服务器的重定向响应后，会根据响应头中 &lt;code&gt;Location&lt;/code&gt; 的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。&lt;/p&gt;
&lt;p&gt;有时重定向无法避免，在糟糕也比抛出 &lt;code&gt;404&lt;/code&gt; 好。虽然通过 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01ldGFfcmVmcmVzaA==&#34;&gt;HTML meta refresh&lt;/span&gt; 和 JavaScript 也能实现，但首选 HTTP &lt;code&gt;3xx&lt;/code&gt; 跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的优化办法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加 &lt;code&gt;/&lt;/code&gt; 但未添加。比如，访问 &lt;code&gt;http://astrology.yahoo.com/astrology&lt;/code&gt; 将被 301 重定向到 &lt;code&gt;http://astrology.yahoo.com/astrology/&lt;/code&gt;（注意末尾的 &lt;code&gt;/&lt;/code&gt;）。如果使用 Apache，可以通过 &lt;code&gt;Alias&lt;/code&gt; 或 &lt;code&gt;mod_rewrite&lt;/code&gt; 或 &lt;code&gt;DirectorySlash&lt;/code&gt; 解决这个问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网站域名变更：CNAME 结合 &lt;code&gt;Alias&lt;/code&gt; 或 &lt;code&gt;mod_rewrite&lt;/code&gt; 或者其他服务器类似功能实现跳转。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在定义链接地址的href属性的时候，尽量使用最完整的、直接的地址。例如：&lt;br&gt;使用 &lt;code&gt;www.cnblogs.com&lt;/code&gt; 而不是&lt;code&gt;cnblogs.com&lt;/code&gt;&lt;br&gt;使用&lt;code&gt;cn.bing.com&lt;/code&gt;而不是&lt;code&gt;bing.com&lt;/code&gt;&lt;br&gt;使用&lt;code&gt;www.google.com.hk&lt;/code&gt;而不是&lt;code&gt;google.com&lt;/code&gt;&lt;br&gt;使用&lt;code&gt;www.mysite.com/products/&lt;/code&gt;而不是&lt;code&gt;www.mysite.com/products&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;避免404浏览器找不到资源的情况发生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发出HTTP请求并获得无用的响应（即404 Not Found）是完全没必要的。特别糟糕的是当外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应主体，就像它是JavaScript代码一样，这样就带来的性能的浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;404的影响：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，404错误发生了，用户可能根本没有感觉到。例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如请求favicon.ico文件，或者请求了某个不存在的脚本文件、样式表、图片文件，页面还是会按照正常的方式进行呈现。&lt;/li&gt;
&lt;li&gt;丢失的脚本文件、样式表、图片文件，会导致页面的某些行为、界面效果出现异常（也可能不是很明显）&lt;/li&gt;
&lt;li&gt;最大的问题可能是性能方面的影响。尤其是如果请求一个不存在的脚本文件，因为浏览器在请求脚本文件的时候，即便是返回404，它也会尝试去按照Javascript的方式解析响应中的内容。这无疑会增加很多处理的时间，而因为该文件不存在，所以这些都是无用功。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看得到的影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果用户请求的某个页面不存在，那么他将收到明确的回应&lt;/li&gt;
&lt;li&gt;默认情况下，他将收到一个标准的错误页面（请注意：不少用户会被这个页面吓到）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的优化办法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;404 意味着Not Found，意思是说未找到资源。既然如此，那么至少会有两种原因导致404错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该资源按理说是要有，但我们没有提供。用户按照正常的方式来请求，所以资源找不到。&lt;ul&gt;
&lt;li&gt;为网站提供favicon.ico这种经常可能会被忽略的资源&lt;/li&gt;
&lt;li&gt;使用一些检查工具：比如Link checker&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;该资源本来就不存在，用户按照不正常的方式来请求，当然还是找不到。&lt;ul&gt;
&lt;li&gt;避免用户收藏绝对地址，给后期更新带来隐患。可以使用地址Rewrite来重写，或者在设计阶段定义一些灵活友好的地址&lt;/li&gt;
&lt;li&gt;使用Routing技术，配置路由规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;AJAX优化&#34;&gt;&lt;a href=&#34;#AJAX优化&#34; class=&#34;headerlink&#34; title=&#34;AJAX优化&#34;&gt;&lt;/a&gt;AJAX优化&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;使Ajax可缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AJAX&amp;#x3D;Asynchronous JavaScript And XML，AJAX不是新的编程语言，而是一种使用现有标准的新方法。&lt;br&gt;AJAX是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。&lt;/p&gt;
&lt;p&gt;由于AJAX其实也是需要发起请求，然后服务器执行，并将结果（通常是JSON格式的）发送给浏览器进行最后的呈现或者处理，所以对于网站设计优化的角度而言，我们同样需要考虑对这些请求，是否可以尽可能的利用到缓存的功能来提高性能。&lt;/p&gt;
&lt;p&gt;对于AJAX而言，有一些特殊性，并不是所有的AJAX请求都是可以缓存的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt;的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码200。（这里可以优化的是，服务器端对数据进行缓存，以便提高处理速度）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;的请求，是可以（并且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一地址的AJAX请求，不会重复再服务器执行，而是返回304。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有的时候，我们可能希望&lt;code&gt;GET&lt;/code&gt;请求不被缓存，有几种做法来达到这样的目的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次调用的时候，请求不同的地址（可以在原始地址后面添加一个随机的号码）。&lt;/li&gt;
&lt;li&gt;如果你所使用的是jquery的话，则可以考虑禁用AJAX的缓存。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;$.ajaxSetup(&amp;#123; cache: false &amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;axios中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var config = &amp;#123;	headers: &amp;#123;&amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,&amp;#39;Cache-Control&amp;#39; : &amp;#39;no-cache&amp;#39;&amp;#125;&amp;#125;;
 
axios.get(&amp;#39;/post&amp;#39;,config)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用GET的Ajax请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用XMLHttpRequest（目前的AJAX都是基于它实现的）的时候，浏览器中的POST实现为两步走的过程，首先发送头部信息，然后再发送数据。但如果是使用GET的话，就只有一个TCP的包发送出去（除非有大量的Cookie），这样无疑可以提高性能。&lt;/p&gt;
&lt;p&gt;但是get有容量限制，大于2K(对get的限制IE是2K，firefox、chrome是4K)的内容只能用post。&lt;/p&gt;
&lt;h4 id=&#34;Cookie优化&#34;&gt;&lt;a href=&#34;#Cookie优化&#34; class=&#34;headerlink&#34; title=&#34;Cookie优化&#34;&gt;&lt;/a&gt;Cookie优化&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;减小cookie大小&lt;/p&gt;
&lt;p&gt;减小cookie的大小，因为在发请求时浏览器会将cookie信息发送到server端，所以应该只在cookie中存必要的信息且越长度越小越好。在 写cookie的时候要记得给cookie设置一个合理的过期时间及域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对一些静态资源不需要使用cookie的单独设置域&lt;/p&gt;
&lt;p&gt;当浏览器发出静态图像请求并将cookie与请求一起发送时，服务器对这些cookie没有任何用处。因此，他们只会毫无理由地创建网络流量。您应该确保使用无cookie请求请求静态组件。创建一个子域并在那里托管所有静态组件。&lt;/p&gt;
&lt;p&gt;如果您的域名是&lt;code&gt;www.example.org&lt;/code&gt;，您可以托管您的静态组件&lt;code&gt;static.example.org&lt;/code&gt;。但是，如果您已经在顶级域上设置了cookie &lt;code&gt;example.org&lt;/code&gt;而不是&lt;code&gt;www.example.org&lt;/code&gt;，则所有请求都 &lt;code&gt;static.example.org&lt;/code&gt;将包含这些cookie。在这种情况下，您可以购买一个全新的域，在那里托管您的静态组件，并保持此域无cookie。雅虎 用途&lt;code&gt;yimg.com&lt;/code&gt;，YouTube使用&lt;code&gt;ytimg.com&lt;/code&gt;，亚马逊使用&lt;code&gt;images-amazon.com&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;在无cookie域上托管静态组件的另一个好处是，某些代理可能拒绝缓存使用cookie请求的组件。在相关说明中，如果您想知道是否应该使用&lt;code&gt;example.org&lt;/code&gt;或&lt;code&gt;www.example.org&lt;/code&gt;作为主页，请考虑cookie的影响。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;省略www会让您别无选择，只能写入cookie &lt;code&gt;*.example.org&lt;/code&gt;，因此出于性能原因，最好使用www子域并将cookie写入该子域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归类一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去除不必要的 Cookie；&lt;/li&gt;
&lt;li&gt;尽量压缩 Cookie 大小；&lt;/li&gt;
&lt;li&gt;注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；&lt;/li&gt;
&lt;li&gt;设置合适的过期时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;利用缓存&#34;&gt;&lt;a href=&#34;#利用缓存&#34; class=&#34;headerlink&#34; title=&#34;利用缓存&#34;&gt;&lt;/a&gt;利用缓存&lt;/h4&gt;&lt;p&gt;浏览器会缓存大量信息（样式表，图像，JavaScript文件等），以便当访问者返回您的站点时，浏览器不必重新加载整个页面。然后设置“expires”标题，以表示希望缓存该信息的时间。在许多情况下，除非您的网站设计经常更改，否则一年是合理的时间段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用浏览器缓存 ，为链接或者资源，添加Expires或Cache-Control头&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于静态组件：通过设置远期未来&lt;code&gt;Expires&lt;/code&gt;标头实现“永不过期”策略&lt;/li&gt;
&lt;li&gt;对于动态组件：使用适当的&lt;code&gt;Cache-Control&lt;/code&gt;标头来帮助浏览器处理条件请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Expires = &amp;quot;Expires&amp;quot; &amp;quot;:&amp;quot; HTTP-date
# e.g.
Expires: Thu, 01 Dec 1994 16:00:00 GMT 
#（必须是GMT格式）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过HTTP的META设置expires和cache-control&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;meta http-equiv=&amp;quot;Cache-Control&amp;quot; content=&amp;quot;max-age=7200&amp;quot; /&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Expires&amp;quot; content=&amp;quot;Mon, 01 Aug 2019 00:00:00 GMT&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述设置仅为举例，实际使用其一即可。这样写的话仅对该网页有效，对网页中的图片或其他请求无效，并不会做任何&lt;code&gt;cache&lt;/code&gt;。&lt;br&gt;这样客户端的请求就多了，尽管只是检查&lt;code&gt;Last-modified&lt;/code&gt;状态的东西，但是请求一多对浏览速度必定有影响。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cache-Control&lt;/code&gt; 的参数包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;max-age&amp;#x3D;&lt;/strong&gt;[单位：秒 seconds] — 设置缓存最大的有效时间. 类似于 &lt;code&gt;Expires&lt;/code&gt;, 但是这个参数定义的是时间大小（比如：60）而不是确定的时间点.单位是[秒 seconds].&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s-maxage&amp;#x3D;&lt;/strong&gt;[单位：秒 seconds] — 类似于 &lt;code&gt;max-age&lt;/code&gt;, 但是它只用于公享缓存 (e.g., proxy) .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt; — 响应会被缓存，并且在多用户间共享。正常情况, 如果要求 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzIwNzY0MDguaHRt&#34;&gt;HTTP 认证&lt;/span&gt;,响应会自动设置为 private.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt; — 响应只能够作为私有的缓存(e.g., 在一个浏览器中)，不能再用户间共享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no-cache&lt;/strong&gt; — 响应不会被缓存,而是实时向服务器端请求资源。这一点很有用，这对保证&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzIwNzY0MDguaHRt&#34;&gt;HTTP 认证&lt;/span&gt;能够严格地禁止缓存以保证安全性很有用（这是指页面与public结合使用的情况下）.既没有牺牲缓存的效率，又能保证安全。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no-store&lt;/strong&gt; — 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;must-revalidate&lt;/strong&gt; — 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proxy-revalidate&lt;/strong&gt; — 类似于 &lt;code&gt;must-revalidate&lt;/code&gt;,但不适用于代理缓存.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;把css与js使用外联的方式进行使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建议将css和js以外联方式引用以充分利用&lt;code&gt;cache&lt;/code&gt;，只有一个例外就是针对首页，首页可以采用内联来减少http请求数，加快页面显示速度，文中说首 页内联的原因是首页被人们访问的次数不会太多，而且样式一般比较特殊，不像其它页面一样有相同的页面模板（因为就有相同的样式部分），所以首页的样式可以 内联。并且应该在首页加载完成之后，再在后台动态加载后续页面的css和js，以提高后续页面的访问速度。&lt;/p&gt;
&lt;p&gt;如果站点上的用户每个会话有多个页面查看，并且您的许多页面重复使用相同的脚本和样式表，则缓存的外部文件可能会带来更大的潜在好处。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于现在的单页面的应用，更适合于动态加载的方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缓存favicon.ico，并设置最好小于1k&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;favicon.ico是一个保留在服务器根目录中的图片，为了减轻拥有favicon.ico的带来的性能问题，请确保：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化它的大小，最好不到1K。&lt;/li&gt;
&lt;li&gt;设置Expires标头，使其缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;配置的ETag&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ETag，全程为：&lt;code&gt;Entity Tag&lt;/code&gt;，意思是实体标签，它属于HTTP协议的一部分，也就是所有的Web服务器都应该支持这个特性。它的作用是用一个特殊的字符串来标识某个资源的“版本”，客户端（浏览器）请求的时候，比较ETag如果一致，则表示该资源并没有被修改过，客户端（浏览器）可以使用自己缓存的版本，避免重复下载。&lt;br&gt;它比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;响应标&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;优势 和特点&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;劣势 和可能的问题&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Expires&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;- HTTP 1.0就有，简单易用。 - 服务器通过这个Header告诉浏览器，某资源直到某个时间才会过期，所以在没有过期之前，浏览器就直接使用本地的缓存了。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;- 因为这是时间是由服务器发送的（UTC），但如果服务器时间和客户端事件存在不一致，可能会有些问题。 - 可能存在版本的问题，因为如果在到期之前修改过了，客户端是不会知道的。 - Cache-Control中的max-age可以实现类似的效果，但更加好，因为max-age是一个以秒为单位的时间数，而不是具体的时间，所以不存在上面提到的第一个问题。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Cache-Contro&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;- 服务器通过一个Header（Last-Modified）告诉浏览器，某资源最后修改的时间。 - 浏览器在请求的时候，包含一个Header（If-Modified-Since）,然后服务器可以进行比较，如果在该时间后没有修改过，则返回304。 - 它比Expires多很多选项设置&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;- Last-Modified 也是一个时间，但该时间只能精确到秒，如果在同一个秒中有多次修改（这个在现在的环境下应该确实是可能的），则可能会发生问题。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ETag&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;- 可以更加精确地判断资源是否被修改，因为它不是一个时间值，而是对时间经过处理的一个长整型数值（当然具体算法我们目前还不得而知）。 - 浏览器发起新请求时需要包含 If-None-Match。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;- 如果部署在服务器场环境中，配置不当的话，可能每个服务器会对相同的资源生成不一样的ETag，这样就增加了重复下载的可能性。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;我们来看一个真实的例子：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619145105413.png&#34; alt=&#34;/images/image-20190619145105413&#34;&gt;&lt;/p&gt;
&lt;p&gt;其他的一些缓存使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用本地缓存，缓存部分常用用户数据、公开数据&lt;/li&gt;
&lt;li&gt;缓存机制设计：缓存+过期时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加Expires或Cache-Control&lt;/li&gt;
&lt;li&gt;Etag&lt;/li&gt;
&lt;li&gt;缓存favicon.ico&lt;/li&gt;
&lt;li&gt;外联js&amp;#x2F;css&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缩短服务器响应时间&#34;&gt;&lt;a href=&#34;#缩短服务器响应时间&#34; class=&#34;headerlink&#34; title=&#34;缩短服务器响应时间&#34;&gt;&lt;/a&gt;缩短服务器响应时间&lt;/h4&gt;&lt;p&gt;服务器响应时间受到访问流量，每个页面使用的资源，服务器使用的软件以及硬件本身的影响。要改善服务器响应时间，请查找性能瓶颈，如慢速数据库查询，慢速路由或缺少足够的内存并修复它们。最佳服务器响应时间低于200毫秒。&lt;/p&gt;
&lt;p&gt;很多潜在因素都可能会延缓服务器响应，例如缓慢的应用逻辑、缓慢的数据库查询、缓慢的路由、框架、库、资源 CPU 不足或内存不足。您需要充分考虑所有这些因素，才能改善服务器的响应用时。 若想找出服务器响应用时过长的原因，首先要进行衡量。然后，准备好相关数据，并参阅有关如何解决该问题的相应指导。当解决问题后，您必须继续衡量服务器响应用时，并设法应对任何会在将来出现的性能瓶颈问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;收集并检查&lt;/strong&gt;现有性能和数据。若无可用内容，请使用自动化的网络应用监测解决方案（市面上有托管的开源版本，适用于大多数平台）进行评估，或添加自定义的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;找出并修复&lt;/strong&gt;首要的性能瓶颈问题。如果z您使用的是热门网页框架或内容管理平台，请参阅与性能优化最佳做法相关的文档。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监测并提醒&lt;/strong&gt;任何会在将来出现的性能衰退问题！&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;通常来说，服务器的响应时间由数据库的问题居多，还有错误的程序设计(比如：烂用for循环去查数据库)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;优化工具&#34;&gt;&lt;a href=&#34;#优化工具&#34; class=&#34;headerlink&#34; title=&#34;优化工具&#34;&gt;&lt;/a&gt;优化工具&lt;/h3&gt;&lt;h4 id=&#34;Google-Page-Speed&#34;&gt;&lt;a href=&#34;#Google-Page-Speed&#34; class=&#34;headerlink&#34; title=&#34;Google Page Speed&#34;&gt;&lt;/a&gt;Google Page Speed&lt;/h4&gt;&lt;p&gt;Google Page Speed以帮助开发人员和网站所有者确保他们的网页尽可能顺畅，快速地运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google Page Speed特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在CSS方面更加注重细节，对于CSS选择器，Google Page Speed提供了大量有用的建议&lt;/li&gt;
&lt;li&gt;页面速度活动功能类似于加载计时器评估，但它实时提供图表，因此可以在任何给定时间准确查看网站上发生的情况。&lt;/li&gt;
&lt;li&gt;自动优化：使用PageSpeed模块，可以将Google与您的Nginx或Apache网站服务器集成，以自动优化您的网站。&lt;/li&gt;
&lt;li&gt;优化库集成：可以找到PageSpeed模块背后优化建议，允许设计和构建自己的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于某些人来说，Google Page Speed将是显而易见的选择，因为它可以与其他对维护网站性能至关重要的Google工具一起使用，例如Google Analytics。&lt;/p&gt;
&lt;h4 id=&#34;JsPerf-amp-Benchmark-js&#34;&gt;&lt;a href=&#34;#JsPerf-amp-Benchmark-js&#34; class=&#34;headerlink&#34; title=&#34;JsPerf &amp;amp; Benchmark.js&#34;&gt;&lt;/a&gt;JsPerf &amp;amp; Benchmark.js&lt;/h4&gt;&lt;p&gt;经常看到项目中有一个benchmark的文件夹，那么这个benchmark是干嘛用的？&lt;/p&gt;
&lt;p&gt;JsPerf在线：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qc3BlcmYuY29tLw==&#34;&gt;https://jsperf.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JsPerf Github地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2pzcGVyZi9qc3BlcmYuY29t&#34;&gt;https://github.com/jsperf/jsperf.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Benchmark.js网址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2JlbmNobWFyay5qcw==&#34;&gt;https://github.com/bestiejs/benchmark.js&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;BenchMark.js可以本地安装，而JsPerf.js是线上使用的。&lt;/p&gt;
&lt;p&gt;HTML中引入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;script src=&amp;quot;lodash.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;platform.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;benchmark.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用&lt;code&gt;npm&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ &amp;#123;sudo -H&amp;#125; npm i -g npm
$ npm i --save benchmark
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是一个具体的用例：&lt;/p&gt;
&lt;p&gt;Reg vs IndexOf&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var suite = new Benchmark.Suite;

// add tests
suite.add(&amp;#39;RegExp#test&amp;#39;, function() &amp;#123;
  /o/.test(&amp;#39;Hello World!&amp;#39;);
&amp;#125;)
.add(&amp;#39;String#indexOf&amp;#39;, function() &amp;#123;
  &amp;#39;Hello World!&amp;#39;.indexOf(&amp;#39;o&amp;#39;) &amp;gt; -1;
&amp;#125;)
// add listeners
.on(&amp;#39;cycle&amp;#39;, function(event) &amp;#123;
  console.log(String(event.target));
&amp;#125;)
.on(&amp;#39;complete&amp;#39;, function() &amp;#123;
  console.log(&amp;#39;Fastest is &amp;#39; + this.filter(&amp;#39;fastest&amp;#39;).map(&amp;#39;name&amp;#39;));
&amp;#125;)
// run async
.run(&amp;#123; &amp;#39;async&amp;#39;: true &amp;#125;);

// logs:
// =&amp;gt; RegExp#test x 4,161,532 +-0.99% (59 cycles)
// =&amp;gt; String#indexOf x 6,139,623 +-1.00% (131 cycles)
// =&amp;gt; Fastest is String#indexOf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来看一个 call与apply的对比：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var Benchmark = require(&amp;#39;benchmark&amp;#39;);
var suite = new Benchmark.Suite;
var arr1 = function (str) &amp;#123;
    return [].slice.apply(str);
&amp;#125;;
var str2 = function (str) &amp;#123;
    return [].slice.call(str);
&amp;#125;;
// 添加测试
suite.add(&amp;#39;arr1&amp;#39;, function() &amp;#123;
    arr1(&amp;#39;test&amp;#39;);
&amp;#125;)
    .add(&amp;#39;str2&amp;#39;, function() &amp;#123;
        str2(&amp;#39;test&amp;#39;);
    &amp;#125;)
// add listeners
    .on(&amp;#39;cycle&amp;#39;, function(event) &amp;#123;
        console.log(String(event.target));
    &amp;#125;)
    .on(&amp;#39;complete&amp;#39;, function() &amp;#123;
        console.log(&amp;#39;Fastest is &amp;#39; + this.filter(&amp;#39;fastest&amp;#39;).pluck(&amp;#39;name&amp;#39;));
    &amp;#125;)
// run async
    .run(&amp;#123; &amp;#39;async&amp;#39;: true &amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;benckmark是对js运行能效的一个对比测试，让你能够知道自己的JS代码中与其他方案对比的时候，是否有优化的空间。当然，这些新的方案，需要自己去编写去测试。同样，也可以在JsPerf的官网上去看其他的测试结果。&lt;/p&gt;
&lt;p&gt;执行办法 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;npm init -y

npm install -S benchmark

touch test.js //Linux

node test.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;代码优化——写出优质的代码&#34;&gt;&lt;a href=&#34;#代码优化——写出优质的代码&#34; class=&#34;headerlink&#34; title=&#34;代码优化——写出优质的代码&#34;&gt;&lt;/a&gt;代码优化——写出优质的代码&lt;/h2&gt;&lt;p&gt;命题很大，但是我们要简化来谈一下。&lt;/p&gt;
&lt;p&gt;代码优化，先要写出优质的代码，有几点原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用辅助应用对代码进行检查，Eslint等&lt;/li&gt;
&lt;li&gt;使用预编译工具，如less，sass，stylus。&lt;/li&gt;
&lt;li&gt;使用官方的开发规范：命名规范、注释、使用规范、文档规范&lt;/li&gt;
&lt;li&gt;写出逻辑上易于阅读的代码：设计模式、代码结构、文档编排(目录结构)&lt;/li&gt;
&lt;li&gt;代码审查&lt;/li&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;异常与错误机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后就是练习与阅读，阅读别人的代码，学习别人的精华，了解别人代码中的缺点。使用JsPerf或者benchemark去对比优化性能。&lt;/p&gt;
&lt;p&gt;前端代码规范：Airbnb，github，Google，腾讯，阿里等。&lt;/p&gt;
&lt;h2 id=&#34;JsPerf&#34;&gt;&lt;a href=&#34;#JsPerf&#34; class=&#34;headerlink&#34; title=&#34;JsPerf&#34;&gt;&lt;/a&gt;JsPerf&lt;/h2&gt;&lt;h3 id=&#34;JsPerf使用简介&#34;&gt;&lt;a href=&#34;#JsPerf使用简介&#34; class=&#34;headerlink&#34; title=&#34;JsPerf使用简介&#34;&gt;&lt;/a&gt;JsPerf使用简介&lt;/h3&gt;&lt;h4 id=&#34;线上使用方案&#34;&gt;&lt;a href=&#34;#线上使用方案&#34; class=&#34;headerlink&#34; title=&#34;线上使用方案&#34;&gt;&lt;/a&gt;线上使用方案&lt;/h4&gt;&lt;p&gt;需要使用Github进行登录：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190618210408261.png&#34; alt=&#34;/images/image-20190618210408261&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;Login with Github to Create Test Cases&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619103010414.png&#34; alt=&#34;/images/image-20190619103010414&#34;&gt;&lt;/p&gt;
&lt;p&gt;登录之后，进入授权页面：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619103140822.png&#34; alt=&#34;/images/image-20190619103140822&#34;&gt;&lt;/p&gt;
&lt;p&gt;登录过后，就可以创建自己的测试用例啦：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619143549467.png&#34; alt=&#34;/images/image-20190619143549467&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;线下使用方案：&#34;&gt;&lt;a href=&#34;#线下使用方案：&#34; class=&#34;headerlink&#34; title=&#34;线下使用方案：&#34;&gt;&lt;/a&gt;线下使用方案：&lt;/h4&gt;&lt;p&gt;环境准备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mysql&lt;/li&gt;
&lt;li&gt;Nodejs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装Mysql&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mysql -uroot -e &amp;quot;CREATE DATABASE jsperf; GRANT ALL ON jsperf.* TO &amp;#39;jsuser&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;jspass&amp;#39;; FLUSH PRIVILEGES;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYnJvd3NlcnNjb3BlLm9yZy8=&#34;&gt;Browserscope.org&lt;/span&gt; 注册一个API key ，在 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYnJvd3NlcnNjb3BlLm9yZy91c2VyL3NldHRpbmdz&#34;&gt;the settings page&lt;/span&gt;页面中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注册一个 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2FwcGxpY2F0aW9ucy9uZXc=&#34;&gt;new OAuth GitHub application&lt;/span&gt;. 使用callback URL 留空. 复制 “Client ID” 和 “Client Secret”到github的页面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;npm install&lt;/code&gt;安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置&lt;code&gt;.env&lt;/code&gt;的文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;NODE_ENV=development
# from Prerequisites step 1
MYSQL_USER=jsuser
MYSQL_PASSWORD=jspass
MYSQL_DATABASE=jsperf
# from Prerequisites step 2
BROWSERSCOPE=
# from Prerequisites step 3
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
GITHUB_CALLBACK=http://localhost:3000

BELL_COOKIE_PASS=password-should-be-32-characters
COOKIE_PASS=password-should-be-32-characters

# customizable but not recommended for local development
# SCHEME=http
# DOMAIN=localhost
# PORT=3000
# MYSQL_HOST=localhost
# MYSQL_PORT=3306
# LOGGLY_TOKEN=
# LOGGLY_SUBDOMAIN=
# REDIS_HOST=
# REDIS_PORT=
# REDIS_PASSWORD=
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;运行&lt;code&gt;npm start&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;代码示例for-vs-foreach&#34;&gt;&lt;a href=&#34;#代码示例for-vs-foreach&#34; class=&#34;headerlink&#34; title=&#34;代码示例for vs foreach&#34;&gt;&lt;/a&gt;代码示例for vs foreach&lt;/h3&gt;&lt;p&gt;我们对比一下for 与 foreach&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/screencapture-jsperf-2019-06-18-21_15_29.png&#34; alt=&#34;screencapture-jsperf-2019-06-18-21_15_29&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试过程：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190618211820471.png&#34; alt=&#34;/images/image-20190618211820471&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190618211915799.png&#34; alt=&#34;/images/image-20190618211915799&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里有一个更全面的对比结果：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qc3BlcmYuY29tL2Zvci12cy1mb3JlYWNoLzc1&#34;&gt;https://jsperf.com/for-vs-foreach/75&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190618213130251.png&#34; alt=&#34;/images/image-20190618213130251&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190618213201840.png&#34; alt=&#34;/images/image-20190618213201840&#34;&gt;&lt;/p&gt;
&lt;p&gt;还有一些比较有意思的测试：&lt;/p&gt;
&lt;p&gt;可以通过浏览：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qc3BlcmYuY29tL3BvcHVsYXI=&#34;&gt;https://jsperf.com/popular&lt;/span&gt;进行查看&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619143653346.png&#34; alt=&#34;/images/image-20190619143653346&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;前端项目优化实践&#34;&gt;&lt;a href=&#34;#前端项目优化实践&#34; class=&#34;headerlink&#34; title=&#34;前端项目优化实践&#34;&gt;&lt;/a&gt;前端项目优化实践&lt;/h3&gt;&lt;p&gt;我们来对比下Date()与Moment()中的format&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;const Benchmark = require(&amp;#39;benchmark&amp;#39;);
const moment = require(&amp;#39;moment&amp;#39;)

Date.prototype.Format = function (fmt) &amp;#123;
  var o = &amp;#123;
    &amp;quot;M+&amp;quot;: this.getMonth() + 1, //月份
    &amp;quot;d+&amp;quot;: this.getDate(), //日
    &amp;quot;h+&amp;quot;: this.getHours(), //小时
    &amp;quot;m+&amp;quot;: this.getMinutes(), //分
    &amp;quot;s+&amp;quot;: this.getSeconds(), //秒
    &amp;quot;q+&amp;quot;: Math.floor((this.getMonth() + 3) / 3), //季度
    &amp;quot;S&amp;quot;: this.getMilliseconds() //毫秒
  &amp;#125;;
  if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &amp;quot;&amp;quot;).substr(4 - RegExp.$1.length));
  for (var k in o) &amp;#123;
    if (new RegExp(&amp;quot;(&amp;quot; + k + &amp;quot;)&amp;quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&amp;quot;00&amp;quot; + o[k]).substr((&amp;quot;&amp;quot; + o[k]).length)));
  &amp;#125;
  return fmt;
&amp;#125;

var suite = new Benchmark.Suite;

// add tests
suite.add(&amp;#39;Date format&amp;#39;, function () &amp;#123;
  console.log(new Date().Format(&amp;#39;yyyy-MM-dd hh:mm:ss&amp;#39;))
&amp;#125;)
  .add(&amp;#39;Moment format&amp;#39;, function () &amp;#123;
    console.log(moment().format(&amp;#39;YYYY-MM-DD HH:mm:ss&amp;#39;))
  &amp;#125;)
  // add listeners
  .on(&amp;#39;cycle&amp;#39;, function (event) &amp;#123;
    console.log(String(event.target));
  &amp;#125;)
  .on(&amp;#39;complete&amp;#39;, function () &amp;#123;
    console.log(&amp;#39;Fastest is &amp;#39; + this.filter(&amp;#39;fastest&amp;#39;).map(&amp;#39;name&amp;#39;));
  &amp;#125;)
  // run async
  .run(&amp;#123; &amp;#39;async&amp;#39;: true &amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Moment format x 73,570 ops/sec ±4.93% (82 runs sampled)
Fastest is Moment format
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;PageSpeed&#34;&gt;&lt;a href=&#34;#PageSpeed&#34; class=&#34;headerlink&#34; title=&#34;PageSpeed&#34;&gt;&lt;/a&gt;PageSpeed&lt;/h2&gt;&lt;h3 id=&#34;PageSpeed简介&#34;&gt;&lt;a href=&#34;#PageSpeed简介&#34; class=&#34;headerlink&#34; title=&#34;PageSpeed简介&#34;&gt;&lt;/a&gt;PageSpeed简介&lt;/h3&gt;&lt;p&gt;PageSpeed Insights 的Chrome扩展是由谷歌官方开发的一款可以分析页面载入的各个方面，包括资源、网络、DOM以及时间线等等信息的插件，也提供在线访问方式。&lt;/p&gt;
&lt;h4 id=&#34;使用Google-PageSpeed-Insights&#34;&gt;&lt;a href=&#34;#使用Google-PageSpeed-Insights&#34; class=&#34;headerlink&#34; title=&#34;使用Google PageSpeed Insights&#34;&gt;&lt;/a&gt;使用&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw==&#34;&gt;Google PageSpeed Insights&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;打开&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw==&#34;&gt;https://developers.google.com/speed/pagespeed/insights/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输入需要分析的网址即可，这里面需要注意必须在公网可以访问到网址。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619212956061.png&#34; alt=&#34;/images/image-20190619212956061&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用Chrome插件-x2F-Mozila插件&#34;&gt;&lt;a href=&#34;#使用Chrome插件-x2F-Mozila插件&#34; class=&#34;headerlink&#34; title=&#34;使用Chrome插件&amp;#x2F;Mozila插件&#34;&gt;&lt;/a&gt;使用Chrome插件&amp;#x2F;Mozila插件&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619203556941.png&#34; alt=&#34;/images/image-20190619203556941&#34;&gt;&lt;/p&gt;
&lt;p&gt;下载安装办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用插件ID:&lt;code&gt;djfpadpbeemogokhllpiakdeadpoclan&lt;/code&gt; 到&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jaHJvbWUtZXh0ZW5zaW9uLWRvd25sb2FkZXIuY29tLyVFNiU5RCVBNSVFNCVCOCU4QiVFOCVCRCVCRA==&#34;&gt;https://chrome-extension-downloader.com/来下载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开：&lt;span class=&#34;exturl&#34; data-url=&#34;Y2hyb21lOi8vZXh0ZW5zaW9ucy8=&#34;&gt;chrome:&amp;#x2F;&amp;#x2F;extensions&amp;#x2F;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;ctx&lt;/code&gt;文件拖进去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有梯子，那么直接在商店里面搜索&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;插件使用：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190619212836235.png&#34; alt=&#34;/images/image-20190619212836235&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;前端项目优化实践-1&#34;&gt;&lt;a href=&#34;#前端项目优化实践-1&#34; class=&#34;headerlink&#34; title=&#34;前端项目优化实践&#34;&gt;&lt;/a&gt;前端项目优化实践&lt;/h3&gt;&lt;h2 id=&#34;补充学习&#34;&gt;&lt;a href=&#34;#补充学习&#34; class=&#34;headerlink&#34; title=&#34;补充学习&#34;&gt;&lt;/a&gt;补充学习&lt;/h2&gt;&lt;h3 id=&#34;编码、解码形成DOM树的过程&#34;&gt;&lt;a href=&#34;#编码、解码形成DOM树的过程&#34; class=&#34;headerlink&#34; title=&#34;编码、解码形成DOM树的过程&#34;&gt;&lt;/a&gt;编码、解码形成DOM树的过程&lt;/h3&gt;&lt;p&gt;浏览器从网络或硬盘中获得&lt;code&gt;HTML&lt;/code&gt;字节数据后会经过一个流程将字节解析为&lt;code&gt;DOM&lt;/code&gt;树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编码： &lt;strong&gt;先将HTML的原始字节数据转换为文件指定编码的字符。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;令牌化： 然后&lt;strong&gt;浏览器会根据HTML规范来将字符串转换成各种令牌&lt;/strong&gt;（如&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;这样的标签以及标签中的字符串和属性等都会被转化为令牌，每个令牌具有特殊含义和一组规则）。令牌记录了标签的开始与结束，通过这个特性可以轻松判断一个标签是否为子标签（假设有&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;与&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;两个标签，当&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标签的令牌还未遇到它的结束令牌&lt;code&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;就遇见了&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签令牌，那么&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;就是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的子标签）。&lt;/li&gt;
&lt;li&gt;生成对象： &lt;strong&gt;接下来每个令牌都会被转换成定义其属性和规则的对象（这个对象就是节点对象）。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;构建完毕： &lt;strong&gt;DOM树构建完成，整个对象集合就像是一棵树形结构&lt;/strong&gt;。可能有人会疑惑为什么&lt;code&gt;DOM&lt;/code&gt;是一个树形结构，这是因为标签之间含有复杂的父子关系，树形结构正好可以诠释这个关系（&lt;code&gt;CSSOS&lt;/code&gt;同理，层叠样式也含有父子关系。例如： &lt;code&gt;div p &amp;#123;font-size: 18px&amp;#125;&lt;/code&gt;，会先寻找所有&lt;code&gt;p&lt;/code&gt;标签并判断它的父标签是否为&lt;code&gt;div&lt;/code&gt;之后才会决定要不要采用这个样式进行渲染）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个&lt;code&gt;DOM&lt;/code&gt;树的构建过程其实就是： &lt;strong&gt;字节 -&amp;gt; 字符 -&amp;gt; 令牌 -&amp;gt; 节点对象 -&amp;gt; 对象模型&lt;/strong&gt;，下面将通过一个示例&lt;code&gt;HTML&lt;/code&gt;代码与配图更形象地解释这个过程。&lt;/p&gt;
&lt;p&gt;如下面的这段HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;style.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Critical Path&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello &amp;lt;span&amp;gt;web performance&amp;lt;/span&amp;gt; students!&amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;img src=&amp;quot;awesome-photo.jpg&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/63503acbly1fk2te7tuh0j20nv0dbjtl.jpg&#34; alt=&#34;DOM Rendering&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;优化工作清单&#34;&gt;&lt;a href=&#34;#优化工作清单&#34; class=&#34;headerlink&#34; title=&#34;优化工作清单&#34;&gt;&lt;/a&gt;优化工作清单&lt;/h3&gt;&lt;p&gt;当小伙伴们出现了页面性能问题时，或者在设计我们的应用之前，就可以参考如下的条目进行快速检查。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面内容&lt;ul&gt;
&lt;li&gt;减少 HTTP 请求数&lt;/li&gt;
&lt;li&gt;减少 DNS 查询&lt;/li&gt;
&lt;li&gt;避免重定向&lt;/li&gt;
&lt;li&gt;缓存 Ajax 请求&lt;/li&gt;
&lt;li&gt;延迟加载&lt;/li&gt;
&lt;li&gt;预先加载&lt;/li&gt;
&lt;li&gt;减少 DOM 元素数量&lt;/li&gt;
&lt;li&gt;划分内容到不同域名&lt;/li&gt;
&lt;li&gt;尽量减少 iframe 使用&lt;/li&gt;
&lt;li&gt;避免 404 错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务器&lt;ul&gt;
&lt;li&gt;使用 CDN&lt;/li&gt;
&lt;li&gt;添加 Expires 或 Cache-Control 响应头&lt;/li&gt;
&lt;li&gt;启用 Gzip&lt;/li&gt;
&lt;li&gt;配置 Etag&lt;/li&gt;
&lt;li&gt;尽早输出缓冲&lt;/li&gt;
&lt;li&gt;Ajax 请求使用 GET 方法&lt;/li&gt;
&lt;li&gt;避免图片 src 为空&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cookie&lt;ul&gt;
&lt;li&gt;减少 Cookie 大小&lt;/li&gt;
&lt;li&gt;静态资源使用无 Cookie 域名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CSS&lt;ul&gt;
&lt;li&gt;把样式表放在 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;不要使用 CSS 表达式&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;link&lt;/code&gt; 替代 &lt;code&gt;@import&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不要使用 filter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JavaScript&lt;ul&gt;
&lt;li&gt;把脚本放在页面底部&lt;/li&gt;
&lt;li&gt;使用外部 JavaScript 和 CSS&lt;/li&gt;
&lt;li&gt;压缩 JavaScript 和 CSS&lt;/li&gt;
&lt;li&gt;移除重复脚本&lt;/li&gt;
&lt;li&gt;减少 DOM 操作&lt;/li&gt;
&lt;li&gt;使用高效的事件处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图片&lt;ul&gt;
&lt;li&gt;优化图片&lt;/li&gt;
&lt;li&gt;优化 CSS Sprite&lt;/li&gt;
&lt;li&gt;不要在 HTML 中缩放图片&lt;/li&gt;
&lt;li&gt;使用体积小、可缓存的 favicon.ico&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移动端&lt;ul&gt;
&lt;li&gt;保持单个文件小于 25 KB&lt;/li&gt;
&lt;li&gt;打包内容为分段（multipart）文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优化关键渲染路径&#34;&gt;&lt;a href=&#34;#优化关键渲染路径&#34; class=&#34;headerlink&#34; title=&#34;优化关键渲染路径&#34;&gt;&lt;/a&gt;优化关键渲染路径&lt;/h3&gt;&lt;p&gt;假设有一个&lt;code&gt;HTML&lt;/code&gt;页面，它只引入了一个&lt;code&gt;CSS&lt;/code&gt;外部文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;style.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello &amp;lt;span&amp;gt;web performance&amp;lt;/span&amp;gt; students!&amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;img src=&amp;quot;awesome-photo.jpg&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它的关键渲染路径如下：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/63503acbly1fk56dzdbn9j20nr068dga.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先浏览器要先对服务器发送请求获得&lt;code&gt;HTML&lt;/code&gt;文件，得到&lt;code&gt;HTML&lt;/code&gt;文件后开始构建&lt;code&gt;DOM&lt;/code&gt;树，在遇见&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;标签时浏览器需要向服务器再次发出请求来获得&lt;code&gt;CSS&lt;/code&gt;文件，然后则是继续构建&lt;code&gt;DOM&lt;/code&gt;树和&lt;code&gt;CSSOM&lt;/code&gt;树，浏览器合并出渲染树，根据渲染树进行布局计算，执行绘制操作，页面渲染完成。&lt;/p&gt;
&lt;p&gt;有以下几个用于描述关键渲染路径性能的词汇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键资源：可能阻塞网页首次渲染的资源（上图中为2个，&lt;code&gt;HTML&lt;/code&gt;文件与外部&lt;code&gt;CSS&lt;/code&gt;文件&lt;code&gt;style.css&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;关键路径长度： 获取关键资源所需的往返次数或总时间（上图为2次或以上，一次获取&lt;code&gt;HTML&lt;/code&gt;文件，一次获取&lt;code&gt;CSS&lt;/code&gt;文件，这个次数基于&lt;code&gt;TCP&lt;/code&gt;协议的最大拥塞窗口，一个文件不一定能在一次连接内传输完毕）。&lt;/li&gt;
&lt;li&gt;关键字节：所有关键资源文件大小的总和（上图为&lt;code&gt;9KB&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，案例代码的需求发生了变化，它新增了一个&lt;code&gt;JavaScript&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;style.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello &amp;lt;span&amp;gt;web performance&amp;lt;/span&amp;gt; students!&amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;img src=&amp;quot;awesome-photo.jpg&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://wx1.sinaimg.cn/large/63503acbly1fk56e0i20xj20or06ygmi.jpg&#34;&gt;&lt;img data-src=&#34;http://wx1.sinaimg.cn/large/63503acbly1fk56e0i20xj20or06ygmi.jpg&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;文件阻塞了&lt;code&gt;DOM&lt;/code&gt;树的构建，并且在执行&lt;code&gt;JavaScript&lt;/code&gt;脚本时还需要先等待构建&lt;code&gt;CSSOM&lt;/code&gt;树，上图的关键渲染路径特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键资源： 3（&lt;code&gt;HTML&lt;/code&gt;、&lt;code&gt;style.css&lt;/code&gt;、&lt;code&gt;app.js&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;关键路径长度： 2或以上（浏览器会在一次连接中一起下载&lt;code&gt;style.css&lt;/code&gt;和&lt;code&gt;app.js&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;关键字节：11KB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，我们要优化关键渲染路径，首先将&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签添加异步属性&lt;code&gt;async&lt;/code&gt;，这样浏览器的&lt;code&gt;HTML&lt;/code&gt;解析器就不会阻塞这个&lt;code&gt;JavaScript&lt;/code&gt;文件了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;style.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello &amp;lt;span&amp;gt;web performance&amp;lt;/span&amp;gt; students!&amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;img src=&amp;quot;awesome-photo.jpg&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;app.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/63503acbly1fk56e0sokqj20oj074ab1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键资源：2（&lt;code&gt;app.js&lt;/code&gt;为异步加载，不会成为阻塞渲染的资源）&lt;/li&gt;
&lt;li&gt;关键路径长度： 2或以上&lt;/li&gt;
&lt;li&gt;关键字节： 9KB（&lt;code&gt;app.js&lt;/code&gt;不再是关键资源，所以没有算上它的大小）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来对&lt;code&gt;CSS&lt;/code&gt;进行优化，比如添加上媒体查询。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;style.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;print&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello &amp;lt;span&amp;gt;web performance&amp;lt;/span&amp;gt; students!&amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;img src=&amp;quot;awesome-photo.jpg&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;app.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/63503acbly1fk56e15x4jj20ny082mxu.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键资源：1（&lt;code&gt;app.js&lt;/code&gt;为异步加载，&lt;code&gt;style.css&lt;/code&gt;只有在打印时才会使用，所以只剩下&lt;code&gt;HTML&lt;/code&gt;一个关键资源，也就是说当&lt;code&gt;DOM&lt;/code&gt;树构建完毕，浏览器就会开始进行渲染）&lt;/li&gt;
&lt;li&gt;关键路径长度：1或以上&lt;/li&gt;
&lt;li&gt;关键字节：5KB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优化关键渲染路径就是在对关键资源、关键路径长度和关键字节进行优化&lt;/strong&gt;。关键资源越少，浏览器在渲染前的准备工作就越少；同样，关键路径长度和关键字节关系到浏览器下载资源的效率，它们越少，浏览器下载资源的速度就越快。&lt;/p&gt;
&lt;h3 id=&#34;其他JS在线测试网站&#34;&gt;&lt;a href=&#34;#其他JS在线测试网站&#34; class=&#34;headerlink&#34; title=&#34;其他JS在线测试网站&#34;&gt;&lt;/a&gt;其他JS在线测试网站&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qc2JlbmNoLm1lLw==&#34;&gt;jsbench.me&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2pzYmVuLmNoLw==&#34;&gt;jsben.ch&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tZWFzdXJldGhhdC5uZXQv&#34;&gt;measurethat.net&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZWJwYWdldGVzdC5vcmcv&#34;&gt;webpagetest.org&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsv&#34;&gt;浏览器的工作原理：新式网络浏览器幕后揭秘&lt;/span&gt; &lt;strong&gt;强烈推荐&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9wZXJmb3JtYW5jZS9jcml0aWNhbC1yZW5kZXJpbmctcGF0aC9yZW5kZXItdHJlZS1jb25zdHJ1Y3Rpb24=&#34;&gt;渲染树构建、布局及绘制&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tb3ouY29tL2Jsb2cvaW1wcm92aW5nLXNlYXJjaC1yYW5rLWJ5LW9wdGltaXppbmcteW91ci10aW1lLXRvLWZpcnN0LWJ5dGU=&#34;&gt;优化第一个字节的时间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6Y3N1L2FydGljbGUvZGV0YWlscy83Mjg2MTg5MQ==&#34;&gt;TCP的三次握手与四次挥手（详解+动图）&lt;/span&gt;推荐&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTYvMTIvMDIvcGVyZm9ybWFuY2UtdHVubmluZy5odG1s&#34;&gt;常见性能优化策略的总结&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tb3ouY29tL2xlYXJuL3Nlby9wYWdlLXNwZWVk&#34;&gt;Page Speed&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzAxMWUwYzUxODgyNTJlYTY2YWZkZmEjaGVhZGluZy02OA==&#34;&gt;web性能优化篇&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTk2NmJkMTZmYjlhMDYzNTE3MmE1MGE=&#34;&gt;2018 前端性能优化清单&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ2Y2JhZWU1MWQ0NTNmNDU2MTJhMmM=&#34;&gt;（译）2019年前端性能优化清单 — 上篇&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ3MWVhZmYyNjVkYTYxNmQ1NDdjOGM=&#34;&gt;（译）2019年前端性能优化清单 — 中篇&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ3M2NkYWU1MWQ0NTUxOGQ0NzAxZmY=&#34;&gt;（译）2019年前端性能优化清单 — 下篇&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvZG9jcy9pbnNpZ2h0cy9ydWxlcw==&#34;&gt;PageSpeed Insights 规则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zeWx2YW5hc3N1bi5naXRodWIuaW8vMjAxNy8xMC8wMy8yMDE3LTEwLTAzLUJyb3dzZXJDcml0aWNhbFJlbmRlcmluZ1BhdGgv&#34;&gt;浏览器渲染过程与性能优化&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yNjhjN2YzZGQ3YTY=&#34;&gt;如何提升 CSS 选择器性能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuaHRtbC5jbi9hcmNoaXZlcy85NTE3&#34;&gt;前端性能优化：2018年JavaScript开销及优化工具和方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTY1NDdkMGYyNjVkYTNlMjgzYTFkZjc=&#34;&gt;从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理&lt;/span&gt;推荐&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWFkODZjMTZmMjY1ZGE1MDVhNzdkY2E0&#34;&gt;彻底理解浏览器的缓存机制&lt;/span&gt; 推荐2&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</guid>
            <title>自动化测试</title>
            <link>https://dmqweb.cn/2024/03/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link>
            <category term="自动化测试" scheme="https://dmqweb.cn/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" />
            <category term="自动化测试" scheme="https://dmqweb.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" />
            <pubDate>Sat, 02 Mar 2024 10:04:04 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;5-3-自动化测试&#34;&gt;&lt;a href=&#34;#5-3-自动化测试&#34; class=&#34;headerlink&#34; title=&#34;5-3 自动化测试&#34;&gt;&lt;/a&gt;5-3 自动化测试&lt;/h1&gt;&lt;h2 id=&#34;介绍&#34;&gt;&lt;a href=&#34;#介绍&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在前端界，浏览器兼容性是让工程师们头疼的问题，对于经验丰富的人来说，很清楚浏览器有哪些坑，但是对于大部分程序员，最可怕的是代码明明在这个浏览器运行得很好，但是到了另一个浏览器中就不能正常运行了。对于这部分的程序员，保障代码能正常运行的方法便是能尽早发现问题，然后将其解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端项目如何做测试？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试同学：功能测试，性能测试，测试用例&lt;/li&gt;
&lt;li&gt;前端同学：单元测试，常用于组件库、AP等(Jest、Mocha),上线项目如何做测试？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;上线项目如何进行测试&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用前端监控，进行监控项目稳定性和性能，并上报前端日志&lt;/li&gt;
&lt;li&gt;稳定性：如ljserror、白屏检测等&lt;/li&gt;
&lt;li&gt;性能：如秒开率、首屏渲染时长、接请求时长等&lt;/li&gt;
&lt;li&gt;前端日志：如console.log、API请求记录等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为什么需要自动化测试？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目经过不断的开发，最终肯定会趋于稳定，在&lt;strong&gt;适当的时机下&lt;/strong&gt;引入自动化测试能及早发现问题，&lt;strong&gt;保证产品的质量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;测试作为完整的开发流程中最后的一环，是保证产品质量重要的一环。而前端测试一般在产品开发流程中属于偏后的环节，在整个开发架构中属于较高层次，前端测试更加偏向于GUI的特性，因此前端的测试难度很大。&lt;/p&gt;
&lt;p&gt;测试的目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有利于写出高质量的代码，尽早发现问题&lt;/li&gt;
&lt;li&gt;有利于代码的扩展&lt;/li&gt;
&lt;li&gt;有利于代码的维护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本课程的学习路径：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习基础的概念，清晰测试不同的应用场景&lt;/li&gt;
&lt;li&gt;学习不同的前端测试工具，了解如何进行选择&lt;/li&gt;
&lt;li&gt;在项目中进行实践&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本课程的主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍测试框架的分类&lt;/li&gt;
&lt;li&gt;单元测试工具介绍：Mocha，Jest，AVA，Karma&lt;/li&gt;
&lt;li&gt;E2E测试工具介绍：Nightmare&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本课程的学习准备：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IDE vscode，node  LTS&lt;/li&gt;
&lt;li&gt;包管理工具：yarn, cnpm&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;前端自动化测试&#34;&gt;&lt;a href=&#34;#前端自动化测试&#34; class=&#34;headerlink&#34; title=&#34;前端自动化测试&#34;&gt;&lt;/a&gt;前端自动化测试&lt;/h2&gt;&lt;p&gt;测试是一个庞大的主题，包括各种分类的测试，诸如黑盒测试&amp;#x2F;白盒测试、单元测试&amp;#x2F;集成测试&amp;#x2F;端到端测试等。通常程序员在测试自己的代码的时候用得最多的便是单元测试，但是因为测试也是需要代价，很多人是不喜欢写测试的，甚至是一点都不写。&lt;/p&gt;
&lt;p&gt;那么是什么原因让大家不愿意写呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不熟悉&lt;/li&gt;
&lt;li&gt;浪费时间&lt;/li&gt;
&lt;li&gt;知识不成体系&lt;/li&gt;
&lt;li&gt;团队氛围&lt;/li&gt;
&lt;li&gt;缺少实践&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们要从基础的东西学起，打消对测试的恐惧。&lt;/p&gt;
&lt;h3 id=&#34;测试的分类&#34;&gt;&lt;a href=&#34;#测试的分类&#34; class=&#34;headerlink&#34; title=&#34;测试的分类&#34;&gt;&lt;/a&gt;测试的分类&lt;/h3&gt;&lt;p&gt;在多浏览器的自动化测试，我们多半是进行端到端的测试工作，一小部分是大粒度的单元测试。端到端测试测试模拟用户的行为。在 Web 应用程序中，他们会启动服务器，打开浏览器，模拟用户的行为进行点击、输入、提交等动作，断言浏览器中发生了特定的事情或者是得到了期待的结果，从而让我们相信功能可以正常的运行。&lt;/p&gt;
&lt;p&gt;而单元测试根据代码单元的公共 API 运行它们。这些测试需要创建一个类的实例，使用特定的输入调用它的方法，断言被调用的方法达到了预期的效果。在下文中我们会看到这两种测试的实践，当然有时候区分度并不大，可能无法明显地区分哪些是端对端测试哪些是单元测试，有时候他们是混合起来的，不过只要记住我们的目标是保证功能可以正常运行救足够了。&lt;/p&gt;
&lt;p&gt;按照软件工程自底而上的概念，前端测试一般分为单元测试（Unit Testing ）、集成测试（Integration Testing）和端到端测试（E2E Testing）。从下面的图可以看出，从底向上测试的复杂度将不断提高，另一方面测试的收益反而不断降低的。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/16415de723a8d411.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于软件测试分类，可见&lt;a href=&#34;#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB&#34;&gt;软件测试的分类&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;测试工具对比&#34;&gt;&lt;a href=&#34;#测试工具对比&#34; class=&#34;headerlink&#34; title=&#34;测试工具对比&#34;&gt;&lt;/a&gt;测试工具对比&lt;/h3&gt;&lt;p&gt;在进行项目实践前，很重要的一项工作是选择合适的技术栈。好比在前端开发时应该选择 React，Vue 还是 Angular 作为框架一样，前端的测试工作也需要选择一套技术栈。很多时候大家在制定技术栈时容易走偏，在选择技术框架时不是选择最合适的框架，而是选择最热门的框架。当然一定程度上热门的框架能反应其受欢迎程度，可能是因为其出众的优点，如较高的开发效率、高效的渲染特性或者是活跃的社区。在前端开发中，很容易有这样的感受，就是只要半个月没有关注业界的最新动态，就感觉恍若隔世，新的解决方案层出不穷，让人喘不过气。&lt;/p&gt;
&lt;p&gt;经过几年的前端洗礼之后，就已经过了慌乱的年纪，再也不会盲目地追寻新技术，而转向关注技术背后解决的痛点，原理等。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/v2-af09ebe8167f63a49ea49287fe04526f_hd-20190706122102737.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;如何选择测试框架&#34;&gt;&lt;a href=&#34;#如何选择测试框架&#34; class=&#34;headerlink&#34; title=&#34;如何选择测试框架&#34;&gt;&lt;/a&gt;如何选择测试框架&lt;/h4&gt;&lt;p&gt;测试框架基本上都做了一件事儿：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述你要测试的东西&lt;/li&gt;
&lt;li&gt;对其进行测试&lt;/li&gt;
&lt;li&gt;判断是否符合预期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择框架会考虑下面的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;测试框架是否有简明的语法与文档。&lt;/p&gt;
&lt;p&gt;Mocha、Jasmine、Jest、AVA、Karma、Nightmare&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;断言(Assertions)：用于判断结果是否符合预期。有些框架需要单独的断言库。&lt;/p&gt;
&lt;p&gt;Should.js、chai、expect.js等等，断言库提供了很多语义化的方法来对值做各种各样的判断。当然也可以不用断言库，Node.js中也可以直接使用原生assert库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;适合 TDD &amp;#x2F; BDD：是否适合 测试驱动型 &amp;#x2F; 行为驱动型 的测试风格。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BDD(Bebavior Driven Developement，行为驱动测试)和TDD(Testing Driven Developement，测试驱动开发)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BDD和TDD均有各自的适用场景，BDD一般更偏向于系统功能和业务逻辑的自动化测试设计，而TDD在快速开发并测试功能模块的过程中则更加高效，以快速完成开发为目的。下面我们看下BDD和TDD具体的特点：&lt;/p&gt;
&lt;p&gt;BDD的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从业务逻辑的角度定义具体的输入与预期输出，以及可衡量的目标；&lt;/li&gt;
&lt;li&gt;尽可能覆盖所有的测试用例情况；&lt;/li&gt;
&lt;li&gt;描述一系列可执行的行为，根据业务的分析来定义预期输出。例如，expect, should, assert；&lt;/li&gt;
&lt;li&gt;设定关键的测试通过节点输出提示，便于测试人员理解；&lt;/li&gt;
&lt;li&gt;最大程度的交付出符合用户期望的产品，避免输出不一致带来的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TDD的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求分析，快速编写对应的输入输出测试脚本；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仅在自动测试失败时才编写新代码&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;重构去除不必要的依赖关系，然后重复测试，最终让程序符合所有要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异步测试：有些框架对异步测试支持良好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用的语言：大部分 js 测试框架使用 js。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用于特定目的：每个框架可能会擅长处理不同的问题。&lt;/p&gt;
&lt;p&gt;是要测试单个功能、单个组件、还是集成化测试？&lt;/p&gt;
&lt;p&gt;是要测试GUI逻辑、交互？&lt;/p&gt;
&lt;p&gt;是要测试非功能性指标？兼容性？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;社区是否活跃。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;测试工具的类型&#34;&gt;&lt;a href=&#34;#测试工具的类型&#34; class=&#34;headerlink&#34; title=&#34;测试工具的类型&#34;&gt;&lt;/a&gt;测试工具的类型&lt;/h4&gt;&lt;p&gt;测试工具可分为以下功能。有些只为我们提供了一种功能，有些功能为我们提供了一种组合。&lt;/p&gt;
&lt;p&gt;为了实现最灵活的集合功能，通常使用多种工具的组合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;提供UI界面或者CLI工具：（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLw==&#34;&gt;Karma&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==&#34;&gt;Jasmine&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=&#34;&gt;Jest&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=&#34;&gt;TestCafe&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=&#34;&gt;Cypress&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CLI工具&lt;/strong&gt;会给出一系列测试，以及运行这些测试所需的各种配置和脚手架（运行什么浏览器，使用什么babel插件，如何格式化输出等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供测试框架（形成文件目录）：(&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tb2NoYWpzLm9yZy8=&#34;&gt;Mocha&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==&#34;&gt;Jasmine&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=&#34;&gt;Jest&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2N1Y3VtYmVyL2N1Y3VtYmVyLWpz&#34;&gt;Cucumber&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=&#34;&gt;TestCafe&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=&#34;&gt;Cypress&lt;/span&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供断言：（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2NoYWlqcy5jb20v&#34;&gt;Chai&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==&#34;&gt;Jasmine&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=&#34;&gt;Jest&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3VuZXhwZWN0ZWQuanMub3JnLw==&#34;&gt;Unexpected&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=&#34;&gt;TestCafe&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=&#34;&gt;Cypress&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;断言函数&lt;/strong&gt;检查测试返回的结果是否符合预期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成，展示测试结果（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tb2NoYWpzLm9yZy8=&#34;&gt;Mocha&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==&#34;&gt;Jasmine&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=&#34;&gt;Jest&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLw==&#34;&gt;Karma&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=&#34;&gt;TestCafe&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=&#34;&gt;Cypress&lt;/span&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;快照测试（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=&#34;&gt;Jest&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YQ==&#34;&gt;Ava&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;快照测试(snapshot testing)，测试 UI 或数据结构是否和之前完全一致，通常 UI 测试不在单元测试中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供仿真（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3Npbm9uanMub3JnLw==&#34;&gt;Sinon&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==&#34;&gt;Jasmine&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2FpcmJuYi5pby9lbnp5bWUvZG9jcy9hcGkv&#34;&gt;enzyme&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=&#34;&gt;Jest&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90ZXN0ZG91YmxlLmNvbS8=&#34;&gt;testdouble&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;仿真(mocks, spies, and stubs)：获取方法的调用信息，模拟方法，模块，甚至服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成测试覆盖率报告 (&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9nb3R3YXJsb3N0LmdpdGh1Yi5pby9pc3RhbmJ1bC8=&#34;&gt;Istanbul&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=&#34;&gt;Jest&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2JsYW5rZXRqcy5vcmcv&#34;&gt;Blanket&lt;/span&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供类浏览器环境(&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL25pZ2h0d2F0Y2hqcy5vcmcv&#34;&gt;Nightwatch&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5uaWdodG1hcmVqcy5vcmcv&#34;&gt;Nightmare&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3BoYW50b21qcy5vcmcv&#34;&gt;Phantom&lt;/span&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9wdXBwZXRlZXI=&#34;&gt;Puppeteer&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=&#34;&gt;TestCafe&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=&#34;&gt;Cypress&lt;/span&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可视化回归工具(&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9hcHBsaXRvb2xzLmNvbS8=&#34;&gt;Applitools&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wZXJjeS5pby8=&#34;&gt;Percy&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2JiYy1uZXdzLmdpdGh1Yi5pby93cmFpdGgv&#34;&gt;Wraith&lt;/span&gt;, &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3dlYmRyaXZlcmlvLWJvbmV5YXJkL3dlYmRyaXZlcmNzcw==&#34;&gt;WebdriverCSS&lt;/span&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单元测试类工具&#34;&gt;&lt;a href=&#34;#单元测试类工具&#34; class=&#34;headerlink&#34; title=&#34;单元测试类工具&#34;&gt;&lt;/a&gt;单元测试类工具&lt;/h4&gt;&lt;p&gt;npm trends: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtdHJlbmRzLmNvbS9tb2NoYS12cy1qZXN0LXZzLWF2YS12cy1qYXNtaW5lLWNvcmU=&#34;&gt;点击链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/image-20190706101634263.png&#34; alt=&#34;/images/image-20190706101634263&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Karma&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Karma是一个Runner（即运行环境），具体详细的介绍见 &lt;a href=&#34;#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83&amp;%E5%B8%AE%E6%89%8BKarma&#34;&gt;后面的章节Karma&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A test runner is the library or tool that picks up an assembly (or a source code directory) that contains unit tests, and a bunch of settings, and then executes them and writes the test results to the console or log files.&lt;br&gt;there are many runners for different languages. See Nunit and MSTest for C#, or Junit for Java.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;karma 设计目标主要有下面四点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高效&lt;br&gt;扩展性&lt;br&gt;运行在真实设备&lt;br&gt;无缝的使用流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;karma 是一个典型的 C&amp;#x2F;S 程序，包含 client 和 server ，通讯方式基于 Http ，通常情况下，客户端和服务端基本都运行在开发者本地机器上。&lt;/p&gt;
&lt;p&gt;一个服务端实例对应一个项目，假如想同时运行多个项目，得同时开启多个服务端实例。&lt;/p&gt;
&lt;p&gt;Karma 的&lt;strong&gt;优点&lt;/strong&gt;是能通过插件和配置的方式集成大部分的主流的测试框架和前端库，能方便的一次在多浏览器环境执行测试用例，并集成了测试覆盖率生成功能，生成页面形式覆盖率报告并能导出不同形式的覆盖率报告数据。&lt;/p&gt;
&lt;p&gt;它的&lt;strong&gt;缺点&lt;/strong&gt;是，对测试页面环境的搭建和资源文件的加载不是常见的形式，最开始搭建环境时会有很多跟预期不一致的情况，配置不直观。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jasmine&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jasmine 带有 assertions(断言)，spies (用来模拟函数的执行环境)和 mocks (mock 工具)，Jasmine 初始化设置简单，同时，如果你需要一些单元功能的时候你仍然可以加一些库进来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mocha&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mocha 是一个灵活的库，提供给开发者的只有一个基础测试结构。然后，其它功能性的功能如 assertions， spies和mocks，这些功能&lt;strong&gt;需要引用添加其它库&lt;/strong&gt;&amp;#x2F;插件来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jest&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被 Facebook 和各种 React 应用推荐和使用，Jest 得到了很好的支持。Jest 也被发现是一个非常快速的测试库在平行测试报告中。&lt;/p&gt;
&lt;p&gt;对于小型项目来说你可能在开始的时候不用过多担心，而性能的提高，对于希望全天持续部署的大型应用 app 来说是非常之好的。&lt;/p&gt;
&lt;p&gt;而开发人员主要是用 Jest 去测试 React 应用，Jest 可以很容易地集成到其它应用程序中充许你使用更独特的特性在其它地方&lt;/p&gt;
&lt;p&gt;快照测试是一个非常好用的工具，去确保你的应用 UI 不会有超出预期的错误，在产品发布替换的期间发生。虽然大部分功能，专门设计都是使用在 React 上。&lt;/p&gt;
&lt;p&gt;Jest 有着很广阔的 API 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AVA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AVA 它的优势是 JavaScript 的异步特性和并发运行测试.&lt;/p&gt;
&lt;p&gt;利用了 JavaScript 的异步特性优势，优化了在部署的时间等待&lt;/p&gt;
&lt;p&gt;保留了简单的 API 为你提供你所需要的功能。&lt;/p&gt;
&lt;p&gt;如果搭配 mocking 来使用它会显得更加友好，但是必须安装一个单独的库。&lt;/p&gt;
&lt;h4 id=&#34;E2E测试类工具&#34;&gt;&lt;a href=&#34;#E2E测试类工具&#34; class=&#34;headerlink&#34; title=&#34;E2E测试类工具&#34;&gt;&lt;/a&gt;E2E测试类工具&lt;/h4&gt;&lt;p&gt;npm trends: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubnBtdHJlbmRzLmNvbS9jeXByZXNzLXZzLW5pZ2h0bWFyZS12cy1uaWdodHdhdGNoLXZzLXRlc3RjYWZlLXZzLXdlYmRyaXZlcmlv&#34;&gt;点击链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/image-20190706100636750.png&#34; alt=&#34;/images/image-20190706100636750&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;最佳实践&#34;&gt;&lt;a href=&#34;#最佳实践&#34; class=&#34;headerlink&#34; title=&#34;最佳实践&#34;&gt;&lt;/a&gt;最佳实践&lt;/h3&gt;&lt;p&gt;测试有很多好处，但不代表一上来就要写出100%场景覆盖的测试用例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最佳的实践：基于投入产出比来做测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于维护测试用例也是一大笔开销（毕竟没有多少测试会专门帮前端写业务测试用例，而前端使用的流程自动化工具更是没有测试参与了）。&lt;/p&gt;
&lt;p&gt;对于像基础组件、基础模型之类的不常变更且复用较多的部分，可以考虑去写测试用例来保证质量。个&lt;/p&gt;
&lt;p&gt;先写少量的测试用例覆盖到80%+的场景，保证覆盖主要使用流程。&lt;/p&gt;
&lt;p&gt;一些极端场景出现的bug可以在迭代中形成测试用例沉淀，场景覆盖也将逐渐趋近100%。&lt;/p&gt;
&lt;p&gt;但对于迭代较快的业务逻辑以及生存时间不长的活动页面之类的就别花时间写测试用例了，维护测试用例的时间大了去了，成本太高。&lt;/p&gt;
&lt;p&gt;大型项目，可以使用Jest快速形成配置并且开始单元测试。&lt;/p&gt;
&lt;p&gt;需要测试快照，则可以选择Jest或者Ava。&lt;/p&gt;
&lt;p&gt;对于配置性要求高，对测试框架性能有要求的可以选择mocha。&lt;/p&gt;
&lt;p&gt;对模拟还原浏览器业务操作有很大的需求的，可以选择nightmare&lt;/p&gt;
&lt;p&gt;配合CI工具完成自动化测试、测试覆盖率、测试结果推送。&lt;/p&gt;
&lt;h2 id=&#34;喜欢简单，选择Mocha&#34;&gt;&lt;a href=&#34;#喜欢简单，选择Mocha&#34; class=&#34;headerlink&#34; title=&#34;喜欢简单，选择Mocha&#34;&gt;&lt;/a&gt;喜欢简单，选择Mocha&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://mochajs.org/&#34;&gt;&lt;code&gt;Mocha&lt;/code&gt;&lt;/a&gt;（发音”摩卡”）诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。所谓”测试框架”，就是运行测试的工具。通过它，可以为JavaScript应用添加测试，从而保证代码的质量。&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;&lt;a href=&#34;#安装&#34; class=&#34;headerlink&#34; title=&#34;安装&#34;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;全局安装Mocha&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install -g mocha
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;项目中也安装Mocha&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install --save-dev mocha
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在package.json中加入下面脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;&amp;quot;scripts&amp;quot;: &amp;#123;
    &amp;quot;test&amp;quot;: &amp;quot;mocha&amp;quot;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Chai 是一个针对 Node.js 和浏览器的行为驱动测试和测试驱动测试的&lt;strong&gt;断言库&lt;/strong&gt;，可与任何 JavaScript 测试框架集成。它是Mocha的好帮手~~&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install --save-dev chai
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在package.json中加入下面脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;quot;scripts&amp;quot;: &amp;#123;
    &amp;quot;test&amp;quot;: &amp;quot;mocha&amp;quot;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;关于断言&#34;&gt;&lt;a href=&#34;#关于断言&#34; class=&#34;headerlink&#34; title=&#34;关于断言&#34;&gt;&lt;/a&gt;关于断言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;expect&lt;/code&gt;断言的优点是很接近自然语言，下面是一些例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 相等或不相等
expect(4 + 5).to.be.equal(9);
expect(4 + 5).to.be.not.equal(10);
expect(foo).to.be.deep.equal(&amp;#123; bar: &amp;#39;baz&amp;#39; &amp;#125;);

// 布尔值为true
expect(&amp;#39;everthing&amp;#39;).to.be.ok;
expect(false).to.not.be.ok;

// typeof
expect(&amp;#39;test&amp;#39;).to.be.a(&amp;#39;string&amp;#39;);
expect(&amp;#123; foo: &amp;#39;bar&amp;#39; &amp;#125;).to.be.an(&amp;#39;object&amp;#39;);
expect(foo).to.be.an.instanceof(Foo);

// include
expect([1,2,3]).to.include(2);
expect(&amp;#39;foobar&amp;#39;).to.contain(&amp;#39;foo&amp;#39;);
expect(&amp;#123; foo: &amp;#39;bar&amp;#39;, hello: &amp;#39;universe&amp;#39; &amp;#125;).to.include.keys(&amp;#39;foo&amp;#39;);

// empty
expect([]).to.be.empty;
expect(&amp;#39;&amp;#39;).to.be.empty;
expect(&amp;#123;&amp;#125;).to.be.empty;

// match
expect(&amp;#39;foobar&amp;#39;).to.match(/^foo/);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两种使用方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// commonjs
const expect = require(&amp;#39;chai&amp;#39;).expect

// es6
import &amp;#123; expect &amp;#125; from &amp;#39;chai&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测试案例&#34;&gt;&lt;a href=&#34;#测试案例&#34; class=&#34;headerlink&#34; title=&#34;测试案例&#34;&gt;&lt;/a&gt;测试案例&lt;/h3&gt;&lt;p&gt;其中index.js为我们的被测试代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;/**
 * 加法函数
 * @param &amp;#123;第一个数&amp;#125; a 
 * @param &amp;#123;第二个数&amp;#125; b 
 */
function addNum(a,b)&amp;#123;
    return a+b;
&amp;#125;
module.exports=addNum;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建测试脚本&lt;code&gt;test/demo.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const expect = require(&amp;#39;chai&amp;#39;).expect;
const addNum = require(&amp;#39;../src/index&amp;#39;)

describe(&amp;#39;测试index.js&amp;#39;, function() &amp;#123;
  describe(&amp;#39;测试addNum函数&amp;#39;, function() &amp;#123;
    it(&amp;#39;两数相加结果为两个数字的和&amp;#39;, function() &amp;#123;
      expect(addNum(1,2)).to.be.equal(3);
      // 以上语法为chai的expect语法，它还有should语法和asset语法。
    &amp;#125;);
  &amp;#125;);
&amp;#125;);


// 等价的意思
var addNum=require(&amp;#39;../src/index&amp;#39;)

describe(&amp;#39;测试index.js&amp;#39;, function() &amp;#123;
  describe(&amp;#39;测试addNum函数&amp;#39;, function() &amp;#123;
    it(&amp;#39;两数相加结果为两个数字的和&amp;#39;, function() &amp;#123;
       if(addNum(1,2)!==3)&amp;#123;
         throw new Error(&amp;quot;两数相加结果不为两个数字的和&amp;quot;)；
       &amp;#125;
    &amp;#125;);
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Mocha测试命令&#34;&gt;&lt;a href=&#34;#Mocha测试命令&#34; class=&#34;headerlink&#34; title=&#34;Mocha测试命令&#34;&gt;&lt;/a&gt;Mocha测试命令&lt;/h3&gt;&lt;p&gt;如果想测试单一的测试js，可以用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mocha test/index.test.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者多个js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mocha test/index.test.js test/add.test.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也可以用通配符测试某个文件夹下所有的js和jsx：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# node 通配符
mocha &amp;#39;test/some/*.@(js|jsx)&amp;#39;

# shell 通配符
mocha test/unit/*.js

mocha spec/&amp;#123;my,awesome&amp;#125;.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ES6语法支持&#34;&gt;&lt;a href=&#34;#ES6语法支持&#34; class=&#34;headerlink&#34; title=&#34;ES6语法支持&#34;&gt;&lt;/a&gt;ES6语法支持&lt;/h3&gt;&lt;p&gt;在上面我们用的并非是ES6的语法，那么让我们把其中的代码都改为ES6的语法。&lt;br&gt; 其中index.js为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;/**
 * 加法函数
 * @param &amp;#123;第一个数&amp;#125; a 
 * @param &amp;#123;第二个数&amp;#125; b 
 */
function addNum(a, b) &amp;#123;
  return a + b
&amp;#125;

export &amp;#123;
  addNum
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而index.test.js为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; expect &amp;#125; from &amp;#39;chai&amp;#39;
import &amp;#123; addNum &amp;#125; from &amp;#39;../src/index&amp;#39;

describe(&amp;#39;测试index.js&amp;#39;, function () &amp;#123;
  describe(&amp;#39;测试addNum函数&amp;#39;, function () &amp;#123;
    it(&amp;#39;两个参数相加结果为两个数字的和&amp;#39;, function () &amp;#123;
      expect(addNum(1, 2)).to.be.equal(3);
    &amp;#125;)
    it(&amp;#39;两个参数相加结果不为和以外的数&amp;#39;, function () &amp;#123;
      expect(addNum(1, 2)).to.be.not.equal(4);
    &amp;#125;)
  &amp;#125;)
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时直接运行mocha肯定是不行的，我们现需要安装一下babel：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install --save-dev @babel/cli @babel/core @babel/node @babel/register @babel/preset-env chai mocha nodemon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，在项目目录下面，新建一个.babelrc文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
  &amp;quot;presets&amp;quot;: [&amp;quot;@babel/preset-env&amp;quot;]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着讲package.json中的脚本改为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;quot;scripts&amp;quot;: &amp;#123;
  &amp;quot;test&amp;quot;: &amp;quot;mocha --require @babel/register&amp;quot;
&amp;#125;,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令变得更加简单了&lt;/p&gt;
&lt;h3 id=&#34;更多用法&#34;&gt;&lt;a href=&#34;#更多用法&#34; class=&#34;headerlink&#34; title=&#34;更多用法&#34;&gt;&lt;/a&gt;更多用法&lt;/h3&gt;&lt;h4 id=&#34;超时&#34;&gt;&lt;a href=&#34;#超时&#34; class=&#34;headerlink&#34; title=&#34;超时&#34;&gt;&lt;/a&gt;超时&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;  --timeout, -t, --timeouts  Specify test timeout threshold (in milliseconds)
                                                        [number] [default: 2000]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方默认的超时是2000毫秒，即2s。&lt;/p&gt;
&lt;p&gt;有三种方式来修改超时：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--no-timeout&lt;/code&gt;参数或者&lt;code&gt;debug&lt;/code&gt;模式中，全局禁用了超时；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--timeout&lt;/code&gt;后面接时间（毫秒），全局修改了本次执行测试用例的超时时间；&lt;/p&gt;
&lt;p&gt;在测试用例里面，使用&lt;code&gt;this.timeout&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;it(&amp;#39;should take less than 500ms&amp;#39;, function(done) &amp;#123;
  this.timeout(500);
  setTimeout(done, 300);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;a href=&#34;#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%EF%BC%89&#34;&gt;钩子方法&lt;/a&gt;里面使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;describe(&amp;#39;a suite of tests&amp;#39;, function() &amp;#123;
  beforeEach(function(done) &amp;#123;
    this.timeout(3000); // A very long environment setup.
    setTimeout(done, 2500);
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;同样，可以使用&amp;#96;&amp;#96;this.timeout(0)&lt;code&gt; &lt;/code&gt;去禁用超时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;钩子方法（生命周期函数）&#34;&gt;&lt;a href=&#34;#钩子方法（生命周期函数）&#34; class=&#34;headerlink&#34; title=&#34;钩子方法（生命周期函数）&#34;&gt;&lt;/a&gt;钩子方法（生命周期函数）&lt;/h4&gt;&lt;p&gt;Mocha在describe块之中，提供测试用例的四个钩子：before()、after()、beforeEach()和afterEach()。它们会在指定时间执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;describe(&amp;#39;测试index.js&amp;#39;,()=&amp;gt; &amp;#123;
  before(()=&amp;gt;console.info(&amp;quot;在本区块的所有测试用例之前执行&amp;quot;))

  after(()=&amp;gt;console.info(&amp;quot;在本区块的所有测试用例之后执行&amp;quot;))

  beforeEach(()=&amp;gt;console.info(&amp;quot;在本区块的每个测试用例之前执行&amp;quot;))

  afterEach(()=&amp;gt;console.info(&amp;quot;在本区块的每个测试用例之后执行&amp;quot;))

  describe(&amp;#39;测试addNum函数&amp;#39;, ()=&amp;gt; &amp;#123;
    it(&amp;#39;两数相加结果为两个数字的和&amp;#39;, ()=&amp;gt; &amp;#123;
      assert.equal(addNum(1,2),3)
    &amp;#125;)
  &amp;#125;)
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;异步测试&#34;&gt;&lt;a href=&#34;#异步测试&#34; class=&#34;headerlink&#34; title=&#34;异步测试&#34;&gt;&lt;/a&gt;异步测试&lt;/h4&gt;&lt;p&gt;Mocha本身是支持异步测试的。只需要为&lt;code&gt;describe&lt;/code&gt;回调函数添加一个&lt;code&gt;done&lt;/code&gt;参数， 成功时调用&lt;code&gt;done()&lt;/code&gt;，失败时调用&lt;code&gt;done(err)&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var expect = require(&amp;#39;chai&amp;#39;).expect;
describe(&amp;#39;db&amp;#39;, function() &amp;#123;
    it(&amp;#39;#get&amp;#39;, function(done) &amp;#123;
        db.get(&amp;#39;foo&amp;#39;, function(err, foo)&amp;#123;
            if(err) done(err);        
            expect(foo).to.equal(&amp;#39;bar&amp;#39;);
            done();
        &amp;#125;);
    &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;如果未调用&lt;code&gt;done&lt;/code&gt;函数，Mocha会一直等待直到超时。&lt;/li&gt;
&lt;li&gt;如果未添加&lt;code&gt;done&lt;/code&gt;参数，Mocha会直接返回成功，不会捕获到异步的断言失败。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;it(&amp;#39;#get&amp;#39;, function()&amp;#123;
    setTimeout(function()&amp;#123;
        expect(1).to.equal(2);
    &amp;#125;, 100);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行上述测试&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tb2NoYWpzLm9yZy8=&#34;&gt;Mocha&lt;/span&gt;总会提示Passing。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mocha怎么知道是否要等待异步断言呢？因为JavaScript中的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24=&#34;&gt;Function&lt;/span&gt;有一个&lt;code&gt;length&lt;/code&gt;属性， 通过它可以获得该函数的形参个数。Mocha通过传入回调的&lt;code&gt;length&lt;/code&gt;来判断是否需要等待。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者，&lt;code&gt;done()&lt;/code&gt;您可以返回&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZQ==&#34;&gt;Promise&lt;/span&gt;，而不是使用回调。如果您正在测试的API返回promises而不是回调，可以这样进行使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;beforeEach(function() &amp;#123;
  return db.clear().then(function() &amp;#123;
    return db.save([tobi, loki, jane]);
  &amp;#125;);
&amp;#125;);

describe(&amp;#39;#find()&amp;#39;, function() &amp;#123;
  it(&amp;#39;respond with matching records&amp;#39;, function() &amp;#123;
    return db.find(&amp;#123;type: &amp;#39;User&amp;#39;&amp;#125;).should.eventually.have.length(3);
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，可以使用&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9hc3luY19mdW5jdGlvbg==&#34;&gt;async &amp;#x2F; await&lt;/span&gt;，您还可以编写如下的异步测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;beforeEach(async function() &amp;#123;
  await db.clear();
  await db.save([tobi, loki, jane]);
&amp;#125;);

describe(&amp;#39;#find()&amp;#39;, function() &amp;#123;
  it(&amp;#39;responds with matching records&amp;#39;, async function() &amp;#123;
    const users = await db.find(&amp;#123;type: &amp;#39;User&amp;#39;&amp;#125;);
    users.should.have.length(3);
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要Babel支持~~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;示例项目&#34;&gt;&lt;a href=&#34;#示例项目&#34; class=&#34;headerlink&#34; title=&#34;示例项目&#34;&gt;&lt;/a&gt;示例项目&lt;/h3&gt;&lt;h4 id=&#34;创建项目-amp-安装依赖&#34;&gt;&lt;a href=&#34;#创建项目-amp-安装依赖&#34; class=&#34;headerlink&#34; title=&#34;创建项目&amp;amp;安装依赖&#34;&gt;&lt;/a&gt;创建项目&amp;amp;安装依赖&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;// 初始化一个nodejs项目
npm init -y

// 安装依赖
npm install --save-dev @babel/cli @babel/core @babel/node @babel/register @babel/preset-env chai mocha nodemon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;形成package.json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
  &amp;quot;name&amp;quot;: &amp;quot;projects&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;scripts&amp;quot;: &amp;#123;
  &amp;#125;,
  &amp;quot;keywords&amp;quot;: [],
  &amp;quot;author&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;,
  &amp;quot;devDependencies&amp;quot;: &amp;#123;
    &amp;quot;@babel/cli&amp;quot;: &amp;quot;^7.5.0&amp;quot;,
    &amp;quot;@babel/core&amp;quot;: &amp;quot;^7.5.0&amp;quot;,
    &amp;quot;@babel/node&amp;quot;: &amp;quot;^7.5.0&amp;quot;,
    &amp;quot;@babel/preset-env&amp;quot;: &amp;quot;^7.5.0&amp;quot;,
    &amp;quot;@babel/register&amp;quot;: &amp;quot;^7.4.4&amp;quot;,
    &amp;quot;chai&amp;quot;: &amp;quot;^4.2.0&amp;quot;,
    &amp;quot;mocha&amp;quot;: &amp;quot;^6.1.4&amp;quot;,
    &amp;quot;nodemon&amp;quot;: &amp;quot;^1.19.1&amp;quot;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;测试过程&#34;&gt;&lt;a href=&#34;#测试过程&#34; class=&#34;headerlink&#34; title=&#34;测试过程&#34;&gt;&lt;/a&gt;测试过程&lt;/h4&gt;&lt;p&gt;新建一个待测试的方法&lt;code&gt;./src/index.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const sayHello = () =&amp;gt; &amp;quot;Hello world!!!&amp;quot;

console.log(sayHello())

// ES6语法
export default sayHello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试脚本&lt;code&gt;./test/index.spec.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; expect &amp;#125; from &amp;quot;chai&amp;quot;
import sayHello from &amp;quot;../src/index&amp;quot;

describe(&amp;quot;index test&amp;quot;, () =&amp;gt; &amp;#123;
  describe(&amp;quot;sayHello function&amp;quot;, () =&amp;gt; &amp;#123;
    it(&amp;quot;should say Hello guys!&amp;quot;, () =&amp;gt; &amp;#123;

      const str = sayHello();
      expect(str).to.equal(&amp;quot;Hello guys!&amp;quot;)
    &amp;#125;)
  &amp;#125;)
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;中的脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;  &amp;quot;scripts&amp;quot;: &amp;#123;
    // &amp;quot;start&amp;quot;: &amp;quot;nodemon ./src/index.js&amp;quot;,  // 针对ES5语法
    &amp;quot;start:babel&amp;quot;: &amp;quot;nodemon --exec babel-node ./src/index.js&amp;quot;,
    &amp;quot;test:watch&amp;quot;: &amp;quot;mocha --require @babel/register --watch&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;mocha --require @babel/register&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;babel src --out-dir ./dist --source-maps&amp;quot;,
    &amp;quot;serve&amp;quot;: &amp;quot;node ./dist/index.js&amp;quot;,
    &amp;quot;debug&amp;quot;: &amp;quot;node --inspect-brk ./dist/index.js&amp;quot;
  &amp;#125;,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开始测试：&lt;code&gt;npm run test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;报错了，因为期望的值与实际值不一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Hello world!!!


  index test
    sayHello function
      1) should say Hello guys!


  0 passing (9ms)
  1 failing

  1) index test
       sayHello function
         should say Hello guys!:

      AssertionError: expected &amp;#39;Hello world!!!&amp;#39; to equal &amp;#39;Hello guys!&amp;#39;
      + expected - actual

      -Hello world!!!
      +Hello guys!
      
      at Context.equal (test/index.spec.js:9:22)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改测试脚本，或者修改index.js文件：&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;./test/index.spec.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; expect &amp;#125; from &amp;quot;chai&amp;quot;
import sayHello from &amp;quot;../src/index&amp;quot;

describe(&amp;quot;index test&amp;quot;, () =&amp;gt; &amp;#123;
  describe(&amp;quot;sayHello function&amp;quot;, () =&amp;gt; &amp;#123;
    it(&amp;quot;should say Hello world!!!&amp;quot;, () =&amp;gt; &amp;#123;

      const str = sayHello();
      expect(str).to.equal(&amp;quot;Hello world!!!&amp;quot;)
    &amp;#125;)
  &amp;#125;)
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;&amp;gt; mocha --require @babel/register

Hello world!!!


  index test
    sayHello function
      ✓ should say Hello world!!!


  1 passing (6ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;mochawesome&lt;/code&gt;展示你的测试结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install --save-dev mochawesome
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;中添加如下内容，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
    &amp;quot;report&amp;quot;: &amp;quot;mocha --require @babel/register --reporter mochawesome&amp;quot;,
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm run report
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;形成出来的报告在浏览器中打开：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/image-20190707212821248.png&#34; alt=&#34;/images/image-20190707212821248&#34;&gt;&lt;/p&gt;
&lt;p&gt;在Vscode中可以安装Live Server这个插件快速打开：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/image-20190707212923919.png&#34; alt=&#34;/images/image-20190707212923919&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;开箱即用Jest&#34;&gt;&lt;a href=&#34;#开箱即用Jest&#34; class=&#34;headerlink&#34; title=&#34;开箱即用Jest&#34;&gt;&lt;/a&gt;开箱即用Jest&lt;/h2&gt;&lt;p&gt;Jest是由Facebook发布的开源的、基于&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==&#34;&gt;Jasmine&lt;/span&gt;的JavaScript单元测试框架。Jest源于Facebook的构想，用于快速、可靠地测试Web聊天应用。它吸引了公司内部的兴趣，Facebook的一名软件工程师Jeff Morrison半年前又重拾这个项目，改善它的性能，并将其开源。Jest的目标是减少开始测试一个项目所要花费的时间和认知负荷，因此它提供了大部分你需要的现成工具：快速的命令行接口、Mock工具集以及它的自动模块Mock系统。此外，如果你在寻找隔离工具例如Mock库，大部分其它工具将让你在测试中（甚至经常在你的主代码中）写一些不尽如人意的样板代码，以使其生效。Jest与Jasmine框架的区别是在后者之上增加了一些层。最值得注意的是，运行测试时，Jest会自动模拟依赖。Jest自动为每个依赖的模块生成Mock，并默认提供这些Mock，这样就可以很容易地隔离模块的依赖。&lt;/p&gt;
&lt;p&gt;Jest支持Babel，我们将很轻松的使用ES6的高级语法&lt;/p&gt;
&lt;p&gt;Jest支持webpack，非常方便的使用它来管理我们的项目&lt;/p&gt;
&lt;p&gt;Jest支持TypeScript，书写测试用例更加严谨&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简化API&lt;/p&gt;
&lt;p&gt;Jest既简单又强大，内置支持以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灵活的配置：比如，可以用文件名通配符来检测测试文件。&lt;/li&gt;
&lt;li&gt;测试的事前步骤(Setup)和事后步骤(Teardown)，同时也包括测试范围。&lt;/li&gt;
&lt;li&gt;匹配表达式(Matchers)：能使用期望&lt;code&gt;expect&lt;/code&gt;句法来验证不同的内容。&lt;/li&gt;
&lt;li&gt;测试异步代码：支持承诺(promise)数据类型和异步等待&lt;code&gt;async&lt;/code&gt; &amp;#x2F; &lt;code&gt;await&lt;/code&gt;功能。&lt;/li&gt;
&lt;li&gt;模拟函数：可以修改或监查某个函数的行为。&lt;/li&gt;
&lt;li&gt;手动模拟：测试代码时可以忽略模块的依存关系。&lt;/li&gt;
&lt;li&gt;虚拟计时：帮助控制时间推移。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;性能与隔离&lt;/p&gt;
&lt;p&gt;Jest文档里写道：&lt;/p&gt;
&lt;p&gt;Jest能运用所有的工作部分，并列运行测试，使性能最大化。终端上的信息经过缓冲，最后与测试结果一起打印出来。沙盒中生成的测试文件，以及自动全局状态在每个测试里都会得到重置，这样就不会出现两个测试冲突的情况。&lt;/p&gt;
&lt;p&gt;Mocha用一个进程运行所有的测试，和它比较起来，Jest则完全不同。要在测试之间模拟出隔离效果，我们必须要引入几个测试辅助函数来妥善管理清除工作。这种做法虽然不怎么理想，但99%的情况都可以用，因为测试是按顺序进行的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;沉浸式监控模式&lt;/p&gt;
&lt;p&gt;快速互动式监控模式可以监控到哪些测试文件有过改动，只运行与改动过的文件相关的测试，并且由于优化作用，能迅速放出监控信号。设置起来非常简单，而且还有一些别的选项，可以用文件名或测试名来过滤测试。我们用Mocha时也有监控模式，不过没有那么强大，要运行某个特定的测试文件夹或文件，就不得不自己创造解决方法，而这些功能Jest本身就已经提供了，不用花力气。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码覆盖率&amp;amp;测试报告&lt;/p&gt;
&lt;p&gt;Jest内置有代码覆盖率报告功能，设置起来易如反掌。可以在整个项目范围里收集代码覆盖率信息，包括未经受测试的文件。&lt;/p&gt;
&lt;p&gt;要使完善Circle CI整合，只需要一个自定义报告功能。有了Jest，用&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWxsZWVhbGxlbi9qZXN0LWp1bml0LXJlcG9ydGVy&#34;&gt;jest-junit-reporter&lt;/span&gt;就可以做到，其用法和Mocha几乎相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;快照功能&lt;/p&gt;
&lt;p&gt;快照测试的目的不是要替换现有的单元测试，而是要使之更有价值，让测试更轻松。在某些情况下，某些功能比如React组件功能，有了快照测试意味着无需再做单元测试，但同样这两者不是非此即彼。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;安装-1&#34;&gt;&lt;a href=&#34;#安装-1&#34; class=&#34;headerlink&#34; title=&#34;安装&#34;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;新建文件夹然后通过npm 命令安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install --save-dev jest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者通过yarn来安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;yarn add --dev jest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以开始测试了&lt;/p&gt;
&lt;p&gt;也可用&lt;code&gt;npm install -g jest&lt;/code&gt;进行全局安装；并在 package.json 中指定 test 脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
  &amp;quot;scripts&amp;quot;: &amp;#123;
    &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Jest 的测试脚本名形如&lt;code&gt;.test.js&lt;/code&gt;，不论 Jest 是全局运行还是通过&lt;code&gt;npm test&lt;/code&gt;运行，它都会执行当前目录下所有的&lt;code&gt;*.test.js&lt;/code&gt; 或 &lt;code&gt;*.spec.js&lt;/code&gt; 文件、完成测试。&lt;/p&gt;
&lt;p&gt;ES6语法支持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;yarn add --dev babel-jest @babel/core @babel/preset-env
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;配置&lt;code&gt;.babelrc&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
  &amp;quot;presets&amp;quot;: [
    [
      &amp;quot;@babel/preset-env&amp;quot;,
      &amp;#123;
        &amp;quot;targets&amp;quot;: &amp;#123;
          &amp;quot;node&amp;quot;: &amp;quot;current&amp;quot;
        &amp;#125;
      &amp;#125;
    ]
  ]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来就可以使用ES6的语法了~~~&lt;/p&gt;
&lt;p&gt;更多高阶的ES6&amp;#x2F;7&amp;#x2F;8…语法，可以参见：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWJlbGpzLmlvLw==&#34;&gt;babel官网&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于Typescript的支持，可以参见 ：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9nZXR0aW5nLXN0YXJ0ZWQjdXNpbmctdHlwZXNjcmlwdA==&#34;&gt;Using Typescript&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;举个例子&#34;&gt;&lt;a href=&#34;#举个例子&#34; class=&#34;headerlink&#34; title=&#34;举个例子&#34;&gt;&lt;/a&gt;举个例子&lt;/h3&gt;&lt;p&gt;关于test suite与test case：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/w80140jb42.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;describe属于 test suite 的描述，而每个 test 或者 it 则描述了每个 test case。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;math.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;export const add = (a, b) =&amp;gt; a + b;

export const multiple = (a, b) =&amp;gt; a * b;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试脚本：&lt;code&gt;math.test.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const math = require(&amp;#39;./src/math&amp;#39;)

describe(&amp;quot;math&amp;quot;, () =&amp;gt; &amp;#123;
  let a
  let b

  beforeEach(function () &amp;#123;
    a = 2;
    b = 3;
  &amp;#125;);

  test(&amp;quot;#should return result as a+b&amp;quot;, () =&amp;gt; &amp;#123;
    // test code
    const result = math.add(a, b)
    expect(result).toEqual(5)
  &amp;#125;);

  it(&amp;quot;#should return result as a*b&amp;quot;, () =&amp;gt; &amp;#123;
    //test code
    const result = math.multiple(a, b)
    expect(result).toEqual(6)
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; test suite 可以进行嵌套：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;describe(&amp;quot;foo&amp;quot;, () =&amp;gt; &amp;#123;
  describe(&amp;quot;bar&amp;quot;, () =&amp;gt; &amp;#123;
    it(&amp;quot;foo bar&amp;quot;, () =&amp;gt; &amp;#123;
      //test code
    &amp;#125;);
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test case 也可以脱离 test suite 独立运行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// hello.js
module.exports = () =&amp;gt; &amp;#39;Hello world&amp;#39;

// hello.test.js
let hello = require(&amp;#39;hello.js&amp;#39;)

test(&amp;#39;should get &amp;quot;Hello world&amp;quot;&amp;#39;, () =&amp;gt; &amp;#123;
    expect(hello()).toBe(&amp;#39;Hello world&amp;#39;) // 测试成功
// expect(hello()).toBe(&amp;#39;Hello&amp;#39;) // 测试失败
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Mock与Spy&#34;&gt;&lt;a href=&#34;#Mock与Spy&#34; class=&#34;headerlink&#34; title=&#34;Mock与Spy&#34;&gt;&lt;/a&gt;Mock与Spy&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;mock&lt;/strong&gt;测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。&lt;/p&gt;
&lt;p&gt;Mock 是单元测试中经常使用的一种技术。单元测试，顾名思义测试的重点是某个具体单元。但是在实际代码中，代码与代码之间，模块与模块之间总是会存在着相互引用。这个时候，剥离出这种单元的依赖，让测试更加独立，使用到的技术就是 Mock。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要使用Mock函数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目中，一个模块的方法内常常会去调用另外一个模块的方法。在单元测试中，我们可能并不需要关心内部调用的方法的执行过程和结果，只想知道它是否被正确调用即可，甚至会指定该函数的返回值。此时，使用Mock函数是十分有必要。&lt;/p&gt;
&lt;p&gt;Mock函数提供的以下三种特性，在我们写测试代码时十分有用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捕获函数调用情况&lt;/li&gt;
&lt;li&gt;设置函数返回值&lt;/li&gt;
&lt;li&gt;改变函数的内部实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/8u3cp5kz2s.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// math.js
export const getFooResult = () =&amp;gt; &amp;#123;
  // foo logic here
&amp;#125;;
export const getBarResult = () =&amp;gt; &amp;#123;
  // bar logic here
&amp;#125;;

// caculate.js
import &amp;#123; getFooResult, getBarResult &amp;#125; from &amp;quot;./math&amp;quot;;

export const getFooBarResult = () =&amp;gt; getFooResult() + getBarResult();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，getFooResult() 和 getBarResult() 就是 getFooBarResult 这个函数的依赖。如果我们关注的点是 getFooBarResult 这个函数，我们就应该把 getFooResult 和 getBarResult Mock 掉，剥离这种依赖。下面是一个使用 Jest 进行 Mock 的例子。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jest.fn()&lt;/code&gt;是创建Mock函数最简单的方式，如果没有定义函数内部的实现，&lt;code&gt;jest.fn()&lt;/code&gt;会返回&lt;code&gt;undefined&lt;/code&gt;作为返回值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;test(&amp;#39;测试jest.fn()调用&amp;#39;, () =&amp;gt; &amp;#123;
  let mockFn = jest.fn();
  let result = mockFn(1, 2, 3);

  // 断言mockFn的执行后返回undefined
  expect(result).toBeUndefined();
  // 断言mockFn被调用
  expect(mockFn).toBeCalled();
  // 断言mockFn被调用了一次
  expect(mockFn).toBeCalledTimes(1);
  // 断言mockFn传入的参数为1, 2, 3
  expect(mockFn).toHaveBeenCalledWith(1, 2, 3);
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;情景一：设置函数 的返回值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// calculate.test.js
import &amp;#123; getFooBarResult &amp;#125; from &amp;quot;./calculate&amp;quot;;
import * as fooBar from &amp;#39;./math&amp;#39;;

test(&amp;#39;getResult should return result getFooResult() + getBarResult()&amp;#39;, () =&amp;gt; &amp;#123;
  // mock add方法和multiple方法
  fooBar.getFooBarResult = jest.fn(() =&amp;gt; 10);
  fooBar.getBarResult = jest.fn(() =&amp;gt; 5);

  const result = getFooBarResult();

  expect(result).toEqual(15);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mock其实就是一种Spies，在Jest中使用spies来“spy”(窥探)一个函数的行为。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9tb2NrLWZ1bmN0aW9uLWFwaS5odG1sI2NvbnRlbnQ=&#34;&gt;Jest文档&lt;/span&gt;对于spies的解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mock函数也称为“spies”，因为它们让你窥探一些由其他代码间接调用的函数的行为，而不仅仅是测试输出。你可以通过使用 &lt;code&gt;jest.fn()&lt;/code&gt; 创建一个mock函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，一个spy是另一个内置的能够记录对其调用细节的函数：调用它的次数，使用什么参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// calculate.test.js
import &amp;#123; getFooBarResult &amp;#125; from &amp;quot;./calculate&amp;quot;;
import * as fooBar from &amp;#39;./math&amp;#39;;

test(&amp;#39;getResult should return result getFooResult() + getBarResult()&amp;#39;, () =&amp;gt; &amp;#123;
  // mock add方法和multiple方法
  fooBar.getFooResult = jest.fn(() =&amp;gt; 10);
  fooBar.getBarResult = jest.fn(() =&amp;gt; 5);

  const result = getFooBarResult();

  // 监控getFooResult和getBarResult的调用情况.
  expect(fooBar.getFooResult).toHaveBeenCalled();
  expect(fooBar.getBarResult).toHaveBeenCalled();
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;情景二：捕获函数调用情况&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// bot method
const bot = &amp;#123;
  sayHello: name =&amp;gt; &amp;#123;
    console.log(`Hello $&amp;#123;name&amp;#125;!`);
  &amp;#125;
&amp;#125;;

// test.js
describe(&amp;quot;bot&amp;quot;, () =&amp;gt; &amp;#123;
  it(&amp;quot;should say hello&amp;quot;, () =&amp;gt; &amp;#123;
    const spy = jest.spyOn(bot, &amp;quot;sayHello&amp;quot;);

    bot.sayHello(&amp;quot;Michael&amp;quot;);

    expect(spy).toHaveBeenCalledWith(&amp;quot;Michael&amp;quot;);

    spy.mockRestore();
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们通过 &lt;code&gt;jest.spyOn&lt;/code&gt; 创建了一个监听 &lt;code&gt;bot&lt;/code&gt; 对象的 &lt;code&gt;sayHello&lt;/code&gt; 方法的 spy。它就像间谍一样监听了所有对 &lt;code&gt;bot#sayHello&lt;/code&gt; 方法的调用。由于创建 spy 时，Jest 实际上修改了 &lt;code&gt;bot&lt;/code&gt; 对象的 &lt;code&gt;sayHello&lt;/code&gt; 属性，所以在断言完成后，我们还要通过 &lt;code&gt;mockRestore&lt;/code&gt; 来恢复 &lt;code&gt;bot&lt;/code&gt; 对象原本的 &lt;code&gt;sayHello&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;Jest的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9qZXN0LW9iamVjdCNqZXN0c3B5b25vYmplY3QtbWV0aG9kbmFtZQ==&#34;&gt;spyOn介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情景三：修改函数的内容实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const bot = &amp;#123;
  sayHello: name =&amp;gt; &amp;#123;
    console.log(`Hello $&amp;#123;name&amp;#125;!`);
  &amp;#125;
&amp;#125;;

describe(&amp;quot;bot&amp;quot;, () =&amp;gt; &amp;#123;
  it(&amp;quot;should say hello&amp;quot;, () =&amp;gt; &amp;#123;
    const spy = jest.spyOn(bot, &amp;quot;sayHello&amp;quot;).mockImplementation(name =&amp;gt; &amp;#123;
      console.log(`Hello mix $&amp;#123;name&amp;#125;`)
    &amp;#125;);

    bot.sayHello(&amp;quot;Michael&amp;quot;);

    expect(spy).toHaveBeenCalledWith(&amp;quot;Michael&amp;quot;);

    spy.mockRestore();
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用spyOn方法，还可以去修改Math.random这样的函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;jest.spyOn(Math, &amp;quot;random&amp;quot;).mockImplementation(() =&amp;gt; 0.9);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// getNum.js
const arr = [1,2,3,4,5,6];

const getNum = index =&amp;gt; &amp;#123;
  if (index) &amp;#123;
    return arr[index % 6];
  &amp;#125; else &amp;#123;
    return arr[Math.floor(Math.random() * 6)];
  &amp;#125;
&amp;#125;;

// num.test.js
import &amp;#123; getNum &amp;#125; from &amp;#39;../src/getNum&amp;#39;

describe(&amp;quot;getNum&amp;quot;, () =&amp;gt; &amp;#123;
  it(&amp;quot;should select numbber based on index if provided&amp;quot;, () =&amp;gt; &amp;#123;
    expect(getNum(1)).toBe(2);
  &amp;#125;);

  it(&amp;quot;should select a random number based on Math.random if skuId not available&amp;quot;, () =&amp;gt; &amp;#123;
    const spy = jest.spyOn(Math, &amp;quot;random&amp;quot;).mockImplementation(() =&amp;gt; 0.9);

    expect(getNum()).toBe(6);
    expect(spy).toHaveBeenCalled();

    spy.mockRestore();
  &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;CLI命令&#34;&gt;&lt;a href=&#34;#CLI命令&#34; class=&#34;headerlink&#34; title=&#34;CLI命令&#34;&gt;&lt;/a&gt;CLI命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;➜ npx jest --help
Usage: jest [--config=&amp;lt;pathToConfigFile&amp;gt;] [TestPathPattern]

选项：
  --help, -h                    显示帮助信息                              [布尔]
  --version, -v                 Print the version and exit                [布尔]
  --config, -c                  The path to a jest config file specifying how to
                                find and execute tests. If no rootDir is set in
                                the config, the directory containing the config
                                file is assumed to be the rootDir for the
                                project.This can also be a JSON encoded value
                                which Jest will use as configuration.   [字符串]
  --coverage                    Indicates that test coverage information should
                                be collected and reported in the output.  [布尔] 
  --timers                      Setting this value to fake allows the use of
                                fake timers for functions such as setTimeout.
                                                                        [字符串]
  --verbose                     Display individual test results with the test
                                suite hierarchy.                          [布尔]
  --watch                       Watch files for changes and rerun tests related
                                to changed files. If you want to re-run all
                                tests when a file has changed, use the
                                `--watchAll` option.                      [布尔]
  --watchAll                    Watch files for changes and rerun all tests. If
                                you want to re-run only the tests related to the
                                changed files, use the `--watch` option.  [布尔]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见使用：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--verbose&lt;/code&gt;显示详细的测试信息，包括测试suite和case：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;➜ npx jest --verbose
 PASS  test/mock.test.js
  bot
    ✓ should say hello (7ms)

  console.log test/mock.test.js:10
    Hello mix Michael

 PASS  test/domain.test.js
  getImageDomain
    ✓ should select domain based on skuId if provided (1ms)
    ✓ should select a random domain based on Math.random if skuId not available (1ms)

  console.log test/sayhello.test.js:3
    Hello Michael!

 PASS  test/sayhello.test.js
  bot
    ✓ should say hello (6ms)

 PASS  test/num.test.js
  getNum
    ✓ should select numbber based on index if provided (1ms)
    ✓ should select a random number based on Math.random if skuId not available

 PASS  test/math.test.js
  math
    ✓ #should return result as a+b (1ms)
    ✓ #should return result as a*b (4ms)

Test Suites: 5 passed, 5 total
Tests:       8 passed, 8 total
Snapshots:   0 total
Time:        1.075s
Ran all test suites.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--watch&lt;/code&gt;和&lt;code&gt;--watchAll&lt;/code&gt;用来监听测试文件的变化 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Ran all test suites.

Watch Usage
 › Press f to run only failed tests.
 › Press o to only run tests related to changed files.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--coverage&lt;/code&gt;用来形成测试覆盖率报告&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;-----------|----------|----------|----------|----------|-------------------|
File       |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
-----------|----------|----------|----------|----------|-------------------|
All files  |      100 |      100 |      100 |      100 |                   |
 getNum.js |      100 |      100 |      100 |      100 |                   |
 math.js   |      100 |      100 |      100 |      100 |                   |
-----------|----------|----------|----------|----------|-------------------|

Test Suites: 5 passed, 5 total
Tests:       8 passed, 8 total
Snapshots:   0 total
Time:        1.497s
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Jest在React、Vue项目中的应用&#34;&gt;&lt;a href=&#34;#Jest在React、Vue项目中的应用&#34; class=&#34;headerlink&#34; title=&#34;Jest在React、Vue项目中的应用&#34;&gt;&lt;/a&gt;Jest在React、Vue项目中的应用&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;create-react-app&lt;/code&gt;中的应用：&lt;/p&gt;
&lt;p&gt;安装对应的依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install react-test-renderer enzyme enzyme-adapter-react-16 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9lbnp5bWU=&#34;&gt;Enzyme&lt;/span&gt;是一个非常棒的React组件测试测试库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Enzyme is a JavaScript Testing utility for React that makes it easier to test your React Components’ output. You can also manipulate, traverse, and in some ways simulate runtime given the output.&lt;/p&gt;
&lt;p&gt;Enzyme’s API is meant to be intuitive and flexible by mimicking jQuery’s API for DOM manipulation and traversal&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的两点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要配置Adapter，不同的React的Adapter不同&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Enzyme Adapter Package&lt;/th&gt;
&lt;th&gt;React semver compatibility&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enzyme-adapter-react-16&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^16.4.0-0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enzyme-adapter-react-16.3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~16.3.0-0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enzyme-adapter-react-16.2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~16.2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enzyme-adapter-react-16.1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;#96;~16.0.0-0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enzyme-adapter-react-15&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^15.5.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enzyme-adapter-react-15.4&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;15.0.0-0 - 15.4.x&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enzyme-adapter-react-14&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^0.14.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enzyme-adapter-react-13&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^0.13.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要初始化配置&lt;code&gt;setUpTests.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;官方文档在Package.json中设置jest配置，已经过时，Jest框架最新会默认加载文件&lt;code&gt;src/setUpTests.js&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code class=&#34;react&#34;&gt;import &amp;#123; configure &amp;#125; from &amp;#39;enzyme&amp;#39;;
import Adapter from &amp;#39;enzyme-adapter-react-16&amp;#39;

configure(&amp;#123; adapter: new Adapter() &amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在vue工程化项目中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;quot;devDependencies&amp;quot;: &amp;#123;
  &amp;quot;@vue/cli-plugin-unit-jest&amp;quot;: &amp;quot;^3.9.0&amp;quot;,
  &amp;quot;@vue/test-utils&amp;quot;: &amp;quot;1.0.0-beta.29&amp;quot;,
  &amp;quot;babel-core&amp;quot;: &amp;quot;7.0.0-bridge.0&amp;quot;,
  &amp;quot;babel-eslint&amp;quot;: &amp;quot;^10.0.1&amp;quot;,
  &amp;quot;babel-jest&amp;quot;: &amp;quot;^23.6.0&amp;quot;,
  &amp;quot;babel-preset-env&amp;quot;: &amp;quot;^1.7.0&amp;quot;,
&amp;#125;,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加如上依赖，&lt;/p&gt;
&lt;p&gt;配置scripts:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;quot;scripts&amp;quot;: &amp;#123;
  &amp;quot;test&amp;quot;: &amp;quot;vue-cli-service test:unit&amp;quot;
&amp;#125;,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置&lt;code&gt;jest.config.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;module.exports = &amp;#123;
  // 处理vue结尾的文件
  moduleFileExtensions: [
    &amp;#39;js&amp;#39;,
    &amp;#39;jsx&amp;#39;,
    &amp;#39;json&amp;#39;,
    &amp;#39;vue&amp;#39;
  ],
  // es6转义
  transform: &amp;#123;
    &amp;#39;^.+\\.vue$&amp;#39;: &amp;#39;vue-jest&amp;#39;,
    &amp;#39;.+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$&amp;#39;: &amp;#39;jest-transform-stub&amp;#39;,
    &amp;#39;^.+\\.jsx?$&amp;#39;: &amp;#39;babel-jest&amp;#39;
  &amp;#125;,
  transformIgnorePatterns: [
    &amp;#39;/node_modules/&amp;#39;
  ],
  // cli配置了webpack别名
  moduleNameMapper: &amp;#123;
    &amp;#39;^@/(.*)$&amp;#39;: &amp;#39;&amp;lt;rootDir&amp;gt;/src/$1&amp;#39;
  &amp;#125;,
  snapshotSerializers: [
    &amp;#39;jest-serializer-vue&amp;#39;
  ],
  testMatch: [
    &amp;#39;**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)&amp;#39;
  ],
  testURL: &amp;#39;http://localhost/&amp;#39;,
  watchPlugins: [
    &amp;#39;jest-watch-typeahead/filename&amp;#39;,
    &amp;#39;jest-watch-typeahead/testname&amp;#39;
  ]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写一个测试用例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;简约之美AVA&#34;&gt;&lt;a href=&#34;#简约之美AVA&#34; class=&#34;headerlink&#34; title=&#34;简约之美AVA&#34;&gt;&lt;/a&gt;简约之美AVA&lt;/h2&gt;&lt;p&gt;简单的说ava是mocha的替代品：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;es6语法支持更好，对aysnc&amp;#x2F;await有支持&lt;/li&gt;
&lt;li&gt;执行效率更高，使用io并发，就必须保证测试的原子性&lt;/li&gt;
&lt;li&gt;语义上更简单，集众家之长&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然 JavaScript 是单线程，但在 Node.js 里由于其异步的特性使得 IO 可以并行。AVA 利用这个优点让你的测试可以并发执行，这对于 IO 繁重的测试特别有用。另外，测试文件可以在不同的进程里并行运行，让每一个测试文件可以获得更好的性能和独立的环境。&lt;/p&gt;
&lt;h3 id=&#34;AVA特点&#34;&gt;&lt;a href=&#34;#AVA特点&#34; class=&#34;headerlink&#34; title=&#34;AVA特点&#34;&gt;&lt;/a&gt;AVA特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;轻量和高效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简单的测试语法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并发运行测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;强制编写&lt;strong&gt;原子测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦开始，就一直运行到结束，中间不会切换到另一个测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;没有隐藏的全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为每个测试文件隔离环境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;用 ES2015 编写测试&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持 Promise&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持 Generator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持 Async&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持 Observable&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;强化断言信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可选的 TAP 输出显示&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/tap-reporter.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简明的堆栈跟踪&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装-amp-开始&#34;&gt;&lt;a href=&#34;#安装-amp-开始&#34; class=&#34;headerlink&#34; title=&#34;安装&amp;amp;开始&#34;&gt;&lt;/a&gt;安装&amp;amp;开始&lt;/h3&gt;&lt;p&gt;情景一：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;// 创建一个ava项目
npm init ava
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;形成package.json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
    &amp;quot;name&amp;quot;: &amp;quot;awesome-package&amp;quot;, 
    &amp;quot;scripts&amp;quot;: &amp;#123;
        &amp;quot;test&amp;quot;: &amp;quot;ava&amp;quot;
    &amp;#125;,
    &amp;quot;devDependencies&amp;quot;: &amp;#123;
        &amp;quot;ava&amp;quot;: &amp;quot;^1.0.0&amp;quot;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;情景二：（推荐）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm init -y

// npm &amp;amp; cnpm
npm install -D ava

// yarn 
yarn add ava -D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试ava正常安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;➜ npx ava --version
2.2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;第一个ava测试例子&#34;&gt;&lt;a href=&#34;#第一个ava测试例子&#34; class=&#34;headerlink&#34; title=&#34;第一个ava测试例子&#34;&gt;&lt;/a&gt;第一个ava测试例子&lt;/h3&gt;&lt;p&gt;流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引用ava的测试API&lt;/li&gt;
&lt;li&gt;执行测试&lt;/li&gt;
&lt;li&gt;使用断言&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;创建&lt;code&gt;test.js&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import test from &amp;#39;ava&amp;#39;;

const testfn = (a, b) =&amp;gt; a + b

test(&amp;#39;hello ava&amp;#39;, t =&amp;gt; &amp;#123;
  t.pass();
&amp;#125;);

test(&amp;#39;my first test&amp;#39;, async t =&amp;gt; &amp;#123;
  const str = &amp;#39;hello ava!!!!&amp;#39;
  t.is(str, &amp;#39;hello ava!!!!&amp;#39;)
&amp;#125;);

test(&amp;#39;add method&amp;#39;, async t =&amp;gt; &amp;#123;
  const result = testfn(3, 4)
  t.is(result, 7)
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ava自动搜索如下文件结尾的文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;**/test.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**/test-*.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**/*.spec.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**/*.test.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**/test/**/*.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**/tests/**/*.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**/__tests__/**/*.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ava中的断言：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;.pass([message])
.fail([message])
.assert(value, [message])
.truthy(value, [message])
.falsy(value, [message])
.true(value, [message])
.false(value, [message])
.is(value, expected, [message])
.not(value, expected, [message])
.deepEqual(value, expected, [message])
.notDeepEqual(value, expected, [message])
.deepEqual()。
.throws(fn, [expected, [message]])
.throwsAsync(thrower, [expected, [message]])
.notThrows(fn, [message])
.notThrowsAsync(nonThrower, [message])
.regex(contents, regex, [message])
.notRegex(contents, regex, [message])
.snapshot(expected, [message])
.snapshot(expected, [options], [message])
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;CLI命令-1&#34;&gt;&lt;a href=&#34;#CLI命令-1&#34; class=&#34;headerlink&#34; title=&#34;CLI命令&#34;&gt;&lt;/a&gt;CLI命令&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;--help&lt;/code&gt;命令去查看ava支持的cli参数 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;➜ npx ava --help

  Testing can be a drag. AVA helps you get it done.

  Usage
    ava [&amp;lt;file&amp;gt; ...]

  Options
    --watch, -w             Re-run tests when tests and source files change
    --match, -m             Only run tests with matching title (Can be repeated)
    --update-snapshots, -u  Update snapshots
    --fail-fast             Stop after first test failure
    --timeout, -T           Set global timeout (milliseconds or human-readable, e.g. 10s, 2m)
    --serial, -s            Run tests serially
    --concurrency, -c       Max number of test files running at the same time (Default: CPU cores)
    --verbose, -v           Enable verbose output
    --tap, -t               Generate TAP output
    --color                 Force color output
    --no-color              Disable color output
    --reset-cache           Reset AVA&amp;#39;s compilation cache and exit
    --config                JavaScript file for AVA to read its config from, instead of using package.json
                            or ava.config.js files

  Examples
    ava
    ava test.js test2.js
    ava test-*.js
    ava test

  The above relies on your shell expanding the glob patterns.
  Without arguments, AVA uses the following patterns:
    **/test.js **/test-*.js **/*.spec.js **/*.test.js **/test/**/*.js **/tests/**/*.js **/__tests__/**/*.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;文件匹配&#34;&gt;&lt;a href=&#34;#文件匹配&#34; class=&#34;headerlink&#34; title=&#34;文件匹配&#34;&gt;&lt;/a&gt;文件匹配&lt;/h4&gt;&lt;p&gt;使用&lt;code&gt;match&lt;/code&gt;指令，匹配对应需要测试的文件：&lt;/p&gt;
&lt;p&gt;匹配标题以&lt;code&gt;foo&lt;/code&gt;：结尾&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npx ava --match =&amp;#39;* foo&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配标题以&lt;code&gt;foo&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npx ava --match =&amp;#39;foo *&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配标题包含&lt;code&gt;foo&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npx ava --match =&amp;#39;* foo *&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配是完全相同 &lt;code&gt;foo&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npx ava --match =&amp;#39;foo&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配标题不包含&lt;code&gt;foo&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npx ava --match =&amp;#39;！* foo *&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配以下&lt;code&gt;foo&lt;/code&gt;结尾的标题&lt;code&gt;bar&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npx ava --match =&amp;#39;foo * bar&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配&lt;code&gt;foo&lt;/code&gt;以&lt;code&gt;bar&lt;/code&gt;：开头或结尾的标题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npx ava --match =&amp;#39;foo *&amp;#39; -  match =&amp;#39;* bar&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;关于reporter&#34;&gt;&lt;a href=&#34;#关于reporter&#34; class=&#34;headerlink&#34; title=&#34;关于reporter&#34;&gt;&lt;/a&gt;关于reporter&lt;/h4&gt;&lt;p&gt;默认情况下，AVA使用最小的报告：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/avajs/ava/blob/master/media/mini-reporter.gif&#34;&gt;&lt;img data-src=&#34;/assets/mini-reporter.gif&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用该&lt;code&gt;--verbose&lt;/code&gt;标志启用详细的报告者。除非启用TAP报告，否则始终在CI环境中使用此选项。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/avajs/ava/blob/master/media/verbose-reporter.png&#34;&gt;&lt;img data-src=&#34;/assets/verbose-reporter.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TAP报告（推荐）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AVA支持TAP格式，因此与任何TAP报告器兼容。使用该&lt;code&gt;--tap&lt;/code&gt;标志启用TAP输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ npx ava --tap | npx tap-nyan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/avajs/ava/blob/master/media/tap-reporter.png&#34;&gt;&lt;img data-src=&#34;/assets/tap-reporter-20190709154342692.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有一些格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RhcC1kb3Q=&#34;&gt;tap-dot&lt;/span&gt; - Dotted output.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RhcC1zcGVj&#34;&gt;tap-spec&lt;/span&gt; - Mocha-like spec reporter.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2NhbHZpbm1ldGNhbGYvdGFwLW55YW4=&#34;&gt;tap-nyan&lt;/span&gt; - Nyan cat.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2d1bW1lc3Nvbi90YXAtbWlu&#34;&gt;tap-min&lt;/span&gt; - Minimal output.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL25hbXVvbC90YXAtZGlmZmxldA==&#34;&gt;tap-difflet&lt;/span&gt; - Minimal output with diffing.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2F4cm9zcy90YXAtZGlmZg==&#34;&gt;tap-diff&lt;/span&gt; - Human-friendly output with diffing.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2pvZXliYWtlci90YXAtc2ltcGxl&#34;&gt;tap-simple&lt;/span&gt; - Simple output.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2ZhdWNldA==&#34;&gt;faucet&lt;/span&gt; - Human-readable summarizer.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy90YXAtbW9jaGEtcmVwb3J0ZXI=&#34;&gt;tap-mocha-reporter&lt;/span&gt; - Use any of the &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy90YXAtbW9jaGEtcmVwb3J0ZXIvdHJlZS9tYXN0ZXIvbGliL3JlcG9ydGVycw==&#34;&gt;Mocha reporters&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3pvdWJpbi90YXAtc3VtbWFyeQ==&#34;&gt;tap-summary&lt;/span&gt; - Summarized output.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2NsdXgvdGFwLXBlc3NpbWlzdA==&#34;&gt;tap-pessimist&lt;/span&gt; - Only shows failed tests.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3Rvb2xuZXNzL3RhcC1wcmV0dGlmeQ==&#34;&gt;tap-prettify&lt;/span&gt; - Nice readable output with diffing.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL3RhcC1jb2xvcml6ZQ==&#34;&gt;tap-colorize&lt;/span&gt; - Colorize the output while preserving machine-readability.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbmdydWJlci90YXAtYmFpbA==&#34;&gt;tap-bail&lt;/span&gt; - Bail out when the first test fails.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2F4cm9zcy90YXAtbm90aWZ5&#34;&gt;tap-notify&lt;/span&gt; - Notifier for macOS, Linux and Windows.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2d1bW1lc3Nvbi90YXAtanNvbg==&#34;&gt;tap-json&lt;/span&gt; - JSON output.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3lvdmFzeDIvYXZhLXRhcC1qc29u&#34;&gt;ava-tap-json&lt;/span&gt; - JSON output with AVA compatibility.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2FnaGFzc2VtaS90YXAteHVuaXQ=&#34;&gt;tap-xunit&lt;/span&gt; - xUnit output.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3Ntb2NrbGUvdGFwLXRlYW1jaXR5&#34;&gt;tap-teamcity&lt;/span&gt; - Output for TeamCity.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;快照功能&#34;&gt;&lt;a href=&#34;#快照功能&#34; class=&#34;headerlink&#34; title=&#34;快照功能&#34;&gt;&lt;/a&gt;快照功能&lt;/h4&gt;&lt;p&gt;ava自动进行项目测试快照，如果文件放置在&lt;code&gt;test&lt;/code&gt;或者&lt;code&gt;tests&lt;/code&gt;目录，则快照会放置在&lt;code&gt;snapshots&lt;/code&gt;目录。如果测试放置在&lt;code&gt;__test__&lt;/code&gt;目录，则快照放置在&lt;code&gt;__snapshots__&lt;/code&gt;目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;ava --update-snapshots
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以指定一个固定位置，以便在AVA的&lt;code&gt;package.json&lt;/code&gt;配置中存储快照文件：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;package.json：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
     &amp;quot;ava&amp;quot;：&amp;#123;
         &amp;quot;snapshotDir&amp;quot;：&amp;quot;自定义目录&amp;quot;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;设置超时&#34;&gt;&lt;a href=&#34;#设置超时&#34; class=&#34;headerlink&#34; title=&#34;设置超时&#34;&gt;&lt;/a&gt;设置超时&lt;/h4&gt;&lt;p&gt;AVA中的超时行为与其他测试框架中的行为不同。AVA在每次测试后重置计时器，如果在指定的超时内没有收到新的测试结果，则强制测试退出。这可用于处理停滞的测试。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;没有默认超时。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;您可以配置使用超时&lt;code&gt;--timeout&lt;/code&gt; 命令行选项，或配置文件中设置。它们可以以人类可读的方式设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 10秒
npx ava --timeout = 10s 

# 2分钟
npx ava --timeout = 2m 

# 100毫秒
npx ava --timeout = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以为每个测试单独设置超时。每次进行断言时都会重置这些超时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;test(&amp;#39;foo&amp;#39;, t =&amp;gt; &amp;#123;
    t.timeout(100); // 100 milliseconds
    // Write your assertions here
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他ava设置相关&#34;&gt;&lt;a href=&#34;#其他ava设置相关&#34; class=&#34;headerlink&#34; title=&#34;其他ava设置相关&#34;&gt;&lt;/a&gt;其他ava设置相关&lt;/h3&gt;&lt;h4 id=&#34;ESLint&#34;&gt;&lt;a href=&#34;#ESLint&#34; class=&#34;headerlink&#34; title=&#34;ESLint&#34;&gt;&lt;/a&gt;ESLint&lt;/h4&gt;&lt;p&gt;如果使用了ESLint，请添加&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2VzbGludC1wbHVnaW4tYXZh&#34;&gt;eslint-plugin-ava&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
    plugins: [
        &amp;quot;ava&amp;quot;
    ]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;异步相关&#34;&gt;&lt;a href=&#34;#异步相关&#34; class=&#34;headerlink&#34; title=&#34;异步相关&#34;&gt;&lt;/a&gt;异步相关&lt;/h4&gt;&lt;p&gt;如果异步操作使用promises，则应返回promise：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;test(&amp;#39;fetches foo&amp;#39;, t =&amp;gt; &amp;#123;
    return fetch().then(data =&amp;gt; &amp;#123;
        t.is(data, &amp;#39;foo&amp;#39;);
    &amp;#125;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更好的是，使用&lt;code&gt;async&lt;/code&gt;&amp;#x2F; &lt;code&gt;await&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;test(&amp;#39;fetches foo&amp;#39;, async t =&amp;gt; &amp;#123;
    const data = await fetch();
    t.is(data, &amp;#39;foo&amp;#39;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试环境-amp-帮手Karma&#34;&gt;&lt;a href=&#34;#测试环境-amp-帮手Karma&#34; class=&#34;headerlink&#34; title=&#34;测试环境&amp;amp;帮手Karma&#34;&gt;&lt;/a&gt;测试环境&amp;amp;帮手Karma&lt;/h2&gt;&lt;p&gt;Karma 是一个基于 Node.js 的 JavaScript 测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流 Web 浏览器，也可以集成到 CI（Continuous integration）工具，还可以和其他代码编辑器一起使用。&lt;/p&gt;
&lt;p&gt;Karma 会监控配置文件中所指定的每一个文件，每当文件发生改变，它都会向测试服务器发送信号，来通知所有的浏览器再次运行测试代码。此时，浏览器会重新加载源文件，并执行测试代码。其结果会传递回服务器，并以某种形式显示给开发者。&lt;/p&gt;
&lt;p&gt;访问浏览器执行结果，可通过以下的方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手工方式 - 通过浏览器&lt;/li&gt;
&lt;li&gt;自动方式 - 让 karma 来启动对应的浏览器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工作原理简介&#34;&gt;&lt;a href=&#34;#工作原理简介&#34; class=&#34;headerlink&#34; title=&#34;工作原理简介&#34;&gt;&lt;/a&gt;工作原理简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;karma&lt;/code&gt; 是一个典型的 &lt;code&gt;C/S&lt;/code&gt; 程序，包含 client 和 server ，通讯方式基于 &lt;code&gt;Http&lt;/code&gt; ，通常情况下，客户端和服务端基本都运行在开发者本地机器上。&lt;/p&gt;
&lt;p&gt;一个服务端实例对应一个项目，假如想同时运行多个项目，得同时开启多个服务端实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Server&lt;/code&gt; 是框架的主要组成部分之一，它内部保存了所有的程序运行状态，比如 client 连接，当前运行的单测文件，根据这些数据状态，它提供了下面几个功能， 下图是 server 的结构&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/TB13X9xLXXXXXXoaXXXDUoU9pXX-902-329.png&#34; alt=&#34;karma_server&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监听文件&lt;/li&gt;
&lt;li&gt;与 client 进行通讯&lt;/li&gt;
&lt;li&gt;向开发者输出测试结果&lt;/li&gt;
&lt;li&gt;提供 client 端所需的资源文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Client&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;client 是单测最终运行的地方，类似一个 web app ， 跟 server 端通讯利用 &lt;code&gt;socket.io&lt;/code&gt;， 执行单测在一个独立的 &lt;code&gt;iframe&lt;/code&gt; 中。下面是它的结构图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/TB1jTKwLXXXXXX.aXXX0KhCSFXX-619-472.png&#34; alt=&#34;karma_impl_client&#34;&gt;&lt;/p&gt;
&lt;p&gt;client 和 server 端通讯采用 &lt;code&gt;socket.io&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;client 端会发送这些消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/TB1XXuILXXXXXcAXFXX.hdJKpXX-918-179.png&#34; alt=&#34;karma_impl_client_message_c&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server 端会发送这些消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/assets/TB1PvisLXXXXXcqaXXXEHlCNpXX-896-103.png&#34; alt=&#34;karma_impl_client_message_s&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;安装Karma&#34;&gt;&lt;a href=&#34;#安装Karma&#34; class=&#34;headerlink&#34; title=&#34;安装Karma&#34;&gt;&lt;/a&gt;安装Karma&lt;/h3&gt;&lt;p&gt;对于Nodejs版本的要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Karma currently works on Node.js &lt;strong&gt;6.x&lt;/strong&gt;, &lt;strong&gt;8.x&lt;/strong&gt;, and &lt;strong&gt;10.x&lt;/strong&gt;. See &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLzQuMC9pbnRyby9mYXEuaHRtbA==&#34;&gt;FAQ&lt;/span&gt; for more info.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;全局安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$npm install -g karma
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装 Karma 命令会到全局的 &lt;code&gt;node_modules&lt;/code&gt; 目录下，我们可以在任何位置直接运行 karma 命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g karma-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此命令用来安装 &lt;code&gt;karma-cli&lt;/code&gt;，它会在当前目录下寻找 karma 的可执行文件。这样我们就可以在一个系统内运行多个版本的 Karma。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install karma --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装 Karma 命令到当前 &lt;code&gt;node_modules&lt;/code&gt; 目录下，此时，如果需要执行 karma 命令，就需要这样 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./node_modules/.bin/karma

npx karma --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置Karma&#34;&gt;&lt;a href=&#34;#配置Karma&#34; class=&#34;headerlink&#34; title=&#34;配置Karma&#34;&gt;&lt;/a&gt;配置Karma&lt;/h3&gt;&lt;p&gt;karma配置文件可以用JavaScript，CoffeeScript或TypeScript编写，并作为常规Node.js模块加载。&lt;/p&gt;
&lt;p&gt;除非作为参数提供，否则Karma CLI将在以下位置以该顺序(从上至下)查找配置文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./karma.conf.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./karma.conf.coffee&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./karma.conf.ts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./.config/karma.conf.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./.config/karma.conf.coffee&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./.config/karma.conf.ts&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在配置文件中，配置代码通过设置&lt;code&gt;module.exports&lt;/code&gt;指向一个接受一个参数的函数：配置对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;// karma.conf.js
module.exports = function(config) &amp;#123;
  config.set(&amp;#123;
    basePath: &amp;#39;../..&amp;#39;,
    frameworks: [&amp;#39;jasmine&amp;#39;],
    //...
  &amp;#125;);
&amp;#125;;
# karma.conf.coffee
module.exports = (config) -&amp;gt;
  config.set
    basePath: &amp;#39;../..&amp;#39;
    frameworks: [&amp;#39;jasmine&amp;#39;]
    # ...
// karma.conf.ts
module.exports = (config) =&amp;gt; &amp;#123;
  config.set(&amp;#123;
    basePath: &amp;#39;../..&amp;#39;,
    frameworks: [&amp;#39;jasmine&amp;#39;],
    //...
  &amp;#125;);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;关于typescript的支持，需要使用到&lt;code&gt;ts-node&lt;/code&gt;，配置ts-node以使用&lt;code&gt;commonjs&lt;/code&gt;模块格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置文件中的基本的属性介绍：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLzQuMC9jb25maWcvY29uZmlndXJhdGlvbi1maWxlLmh0bWw=&#34;&gt;Overview&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用CLI工具，快速创建配置&lt;/p&gt;
&lt;p&gt;开始配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;~/Downloads/Demo is 📦 v1.0.0 via ⬢ v10.16.0 
➜ npx karma init

# 如果在应用中用到了其它的测试框架，那就需要我们安装它们所对应的插件，并在配置文件中标注它们（详见 karma.conf.js 中的 plugins 项）
Which testing framework do you want to use ?
Press tab to list possible options. Enter to move to the next question.
&amp;gt; jasmine
# mocha
# qunit
# nodeunit
# nunit

# Require.js 是异步加载规范（AMD）的实现。常被作为基础代码库，应用在了很多的项目与框架之中，例如 Dojo, AngularJs 等
Do you want to use Require.js ?
This will add Require.js plugin.
Press tab to list possible options. Enter to move to the next question.
&amp;gt; no
# yes

# 选择需要运行测试用例的浏览器。需要注意的就是，必须保证所对应的浏览器插件已经安装成功。
Do you want to capture any browsers automatically ?
Press tab to list possible options. Enter empty string to move to the next question.
&amp;gt; Chrome
# ChromeHeadless
# ChromeCanary
# Firefox
# Safari
# PhantomJS
# Opera
# IE

# 选择测试用例所在的目录位置。Karma 支持通配符的方式配置文件或目录，例如 *.js, test/**/*.js 等。如果目录或文件使用相对位置，要清楚地是，此时的路径是相对于当前运行 karma 命令时所在的目录。
What is the location of your source and test files ?
You can use glob patterns, eg. &amp;quot;js/*.js&amp;quot; or &amp;quot;test/**/*Spec.js&amp;quot;.
Enter empty string to move to the next question.
&amp;gt; src/*js

# 目录中不包括的那些文件。
Should any of the files included by the previous patterns be excluded ?
You can use glob patterns, eg. &amp;quot;**/*.swp&amp;quot;.
Enter empty string to move to the next question.

# 是否需要 Karma 自动监听文件？并且文件一旦被修改，就重新运行测试用例？
Do you want Karma to watch all the files and run the tests on change ?
Press tab to list possible options.
&amp;gt; yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成了一个&lt;code&gt;karma.conf.js&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// Karma configuration
// Generated on Wed Jul 10 2019 22:46:32 GMT+0800 (GMT+08:00)

module.exports = function(config) &amp;#123;
  config.set(&amp;#123;

    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: &amp;#39;&amp;#39;,


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    frameworks: [&amp;#39;mocha&amp;#39;],


    // list of files / patterns to load in the browser
    files: [
      &amp;#39;src/*js&amp;#39;
    ],


    // list of files / patterns to exclude
    exclude: [
    ],


    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    preprocessors: &amp;#123;
    &amp;#125;,


    // test results reporter to use
    // possible values: &amp;#39;dots&amp;#39;, &amp;#39;progress&amp;#39;
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    reporters: [&amp;#39;progress&amp;#39;],


    // web server port
    port: 9876,


    // enable / disable colors in the output (reporters and logs)
    colors: true,


    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,


    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: [&amp;#39;Chrome&amp;#39;],


    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: false,

    // Concurrency level
    // how many browser should be started simultaneous
    concurrency: Infinity
  &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;karma示例&#34;&gt;&lt;a href=&#34;#karma示例&#34; class=&#34;headerlink&#34; title=&#34;karma示例&#34;&gt;&lt;/a&gt;karma示例&lt;/h3&gt;&lt;p&gt;目标 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;babel支持，ES6语法支持&lt;/li&gt;
&lt;li&gt;mocha与chai支持&lt;/li&gt;
&lt;li&gt;karma与chrome、webpack对接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;Karma对babel支持的，一个可选项：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2thcm1hLWJhYmVsLXByZXByb2Nlc3Nvcg==&#34;&gt;karma-babel-preprocessor&lt;/span&gt;，但是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;babel and karma-babel-preprocessor only convert ES6 modules to CommonJS&amp;#x2F;AMD&amp;#x2F;SystemJS&amp;#x2F;UMD**. If you choose CommonJS, you still need to resolve and concatenate CommonJS modules on your own**. We recommend &lt;strong&gt;karma-browserify + babelify&lt;/strong&gt; or &lt;strong&gt;webpack + babel-loader&lt;/strong&gt; in such cases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，我们选择了webpack&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install @babel/core @babel/preset-env chai mocha webpack webpack-cli babel-loader -D
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装karma的适配器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install karma-webpack karma-chrome-launcher karma-mocha karma-chai -D
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置&lt;code&gt;karma.config.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// Karma configuration
// Generated on Thu Jul 11 2019 23:23:44 GMT+0800 (GMT+08:00)

module.exports = function (config) &amp;#123;
  config.set(&amp;#123;

    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: &amp;#39;&amp;#39;,


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    frameworks: [&amp;#39;mocha&amp;#39;],


    // list of files / patterns to load in the browser
    files: [
      &amp;#39;src/**/*.js&amp;#39;,
      &amp;#39;test/**/*.js&amp;#39;
    ],

 
    // ....
    

    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    preprocessors: &amp;#123;
      &amp;#39;src/**/*.js&amp;#39;: [&amp;#39;webpack&amp;#39;],
      &amp;#39;test/**/*.js&amp;#39;: [&amp;#39;webpack&amp;#39;]
    &amp;#125;,

    webpack: &amp;#123;
      mode: &amp;quot;none&amp;quot;,
      node: &amp;#123;
        fs: &amp;#39;empty&amp;#39;
      &amp;#125;,
      module: &amp;#123;
        rules: [
          &amp;#123; test: /\.js?$/, loader: &amp;quot;babel-loader&amp;quot;, options: &amp;#123; presets: [&amp;quot;@babel/env&amp;quot;] &amp;#125;, &amp;#125;
        ]
      &amp;#125;
    &amp;#125;,
 
    // ....
    
    plugins: [
      &amp;#39;karma-mocha&amp;#39;,
      &amp;#39;karma-chai&amp;#39;,
      &amp;#39;karma-chrome-launcher&amp;#39;,
      &amp;#39;karma-webpack&amp;#39;
    ]
  &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;书写测试用例&lt;code&gt;test.js&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; describe &amp;#125; from &amp;quot;mocha&amp;quot;;
import &amp;#123; expect &amp;#125; from &amp;#39;chai&amp;#39;

describe(&amp;#39;first test&amp;#39;, () =&amp;gt; &amp;#123;
  it(&amp;#39;hello mocha and karma&amp;#39;, () =&amp;gt; &amp;#123;
    console.log(&amp;#39;hello mocha&amp;#39;)
    expect(true).to.be.equal(true)
  &amp;#125;)
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开始测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npx karma start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加到&lt;code&gt;package.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;quot;scripts&amp;quot;: &amp;#123;
  &amp;quot;karma&amp;quot;: &amp;quot;karma start&amp;quot;
&amp;#125;,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用，&lt;code&gt;npm run karma&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;➜ npx karma start
ℹ ｢wdm｣: Hash: 9d2c943b68425fd58dd0
Version: webpack 4.35.3
Time: 53ms
Built at: 2019-07-12 5:07:49 PM
ℹ ｢wdm｣: Compiled successfully.
ℹ ｢wdm｣: Compiling...
⚠ ｢wdm｣: Hash: cca8316f4bd5855fc4de
Version: webpack 4.35.3
Time: 2414ms
Built at: 2019-07-12 5:07:52 PM
       Asset      Size  Chunks             Chunk Names
src/index.js  3.62 KiB       0  [emitted]  src/index
test/test.js  1010 KiB       1  [emitted]  test/test
Entrypoint src/index = src/index.js
Entrypoint test/test = test/test.js
  [0] ./src/index.js 27 bytes &amp;#123;0&amp;#125; [built]
  [1] ./test/test.js 223 bytes &amp;#123;1&amp;#125; [built]
  [2] ./node_modules/mocha/browser-entry.js 4.19 KiB &amp;#123;1&amp;#125; [built]
  [3] ./node_modules/process/browser.js 4.96 KiB &amp;#123;1&amp;#125; [built]
  [4] (webpack)/buildin/global.js 878 bytes &amp;#123;1&amp;#125; [built]
  [5] ./node_modules/browser-stdout/index.js 662 bytes &amp;#123;1&amp;#125; [built]
  [6] ./node_modules/stream-browserify/index.js 3.53 KiB &amp;#123;1&amp;#125; [built]
 [36] ./node_modules/util/util.js 19 KiB &amp;#123;1&amp;#125; [built]
 [38] ./node_modules/mocha/lib/mocha.js 21.8 KiB &amp;#123;1&amp;#125; [built]
 [39] (webpack)/buildin/module.js 552 bytes &amp;#123;1&amp;#125; [built]
 [40] ./node_modules/escape-string-regexp/index.js 230 bytes &amp;#123;1&amp;#125; [built]
 [41] path (ignored) 15 bytes &amp;#123;1&amp;#125; [built]
 [42] ./node_modules/mocha/lib/reporters/index.js 945 bytes &amp;#123;1&amp;#125; [built]
[105] ./node_modules/chai/index.js 39 bytes &amp;#123;1&amp;#125; [built]
[106] ./node_modules/chai/lib/chai.js 1.22 KiB &amp;#123;1&amp;#125; [built]
    + 128 hidden modules

WARNING in ./node_modules/mocha/lib/mocha.js 217:20-37
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js

WARNING in ./node_modules/mocha/lib/mocha.js 222:24-70
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js

WARNING in ./node_modules/mocha/lib/mocha.js 266:24-35
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js

WARNING in ./node_modules/mocha/lib/mocha.js 313:35-48
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js

WARNING in ./node_modules/mocha/lib/mocha.js 329:23-44
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js
ℹ ｢wdm｣: Compiled with warnings.
12 07 2019 17:07:52.761:WARN [karma]: No captured browser, open http://localhost:9876/
12 07 2019 17:07:52.770:INFO [karma-server]: Karma v4.1.0 server started at http://0.0.0.0:9876/
12 07 2019 17:07:52.770:INFO [launcher]: Launching browsers Chrome with concurrency unlimited
12 07 2019 17:07:52.773:INFO [launcher]: Starting browser Chrome
12 07 2019 17:07:54.135:INFO [Chrome 75.0.3770 (Mac OS X 10.14.5)]: Connected on socket R9R31QB1GtR_kayNAAAA with id 55412577
Chrome 75.0.3770 (Mac OS X 10.14.5) LOG: &amp;#39;hello karma&amp;#39;

LOG: &amp;#39;hello mocha&amp;#39;
Chrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0 secs / 0.001 secs
~/Downloads/karma-demo is 📦 v1.0.0 via ⬢ v10.16.0 
➜ npm run karma

&amp;gt; karma-demo@1.0.0 karma /Users/itheima/Downloads/karma-demo
&amp;gt; karma start

ℹ ｢wdm｣: Hash: 9d2c943b68425fd58dd0
Version: webpack 4.35.3
Time: 48ms
Built at: 2019-07-12 5:24:02 PM
ℹ ｢wdm｣: Compiled successfully.
ℹ ｢wdm｣: Compiling...
⚠ ｢wdm｣: Hash: cca8316f4bd5855fc4de
Version: webpack 4.35.3
Time: 2307ms
Built at: 2019-07-12 5:24:04 PM
       Asset      Size  Chunks             Chunk Names
src/index.js  3.62 KiB       0  [emitted]  src/index
test/test.js  1010 KiB       1  [emitted]  test/test
Entrypoint src/index = src/index.js
Entrypoint test/test = test/test.js
  [0] ./src/index.js 27 bytes &amp;#123;0&amp;#125; [built]
  [1] ./test/test.js 223 bytes &amp;#123;1&amp;#125; [built]
  [2] ./node_modules/mocha/browser-entry.js 4.19 KiB &amp;#123;1&amp;#125; [built]
  [3] ./node_modules/process/browser.js 4.96 KiB &amp;#123;1&amp;#125; [built]
  [4] (webpack)/buildin/global.js 878 bytes &amp;#123;1&amp;#125; [built]
  [5] ./node_modules/browser-stdout/index.js 662 bytes &amp;#123;1&amp;#125; [built]
  [6] ./node_modules/stream-browserify/index.js 3.53 KiB &amp;#123;1&amp;#125; [built]
 [36] ./node_modules/util/util.js 19 KiB &amp;#123;1&amp;#125; [built]
 [38] ./node_modules/mocha/lib/mocha.js 21.8 KiB &amp;#123;1&amp;#125; [built]
 [39] (webpack)/buildin/module.js 552 bytes &amp;#123;1&amp;#125; [built]
 [40] ./node_modules/escape-string-regexp/index.js 230 bytes &amp;#123;1&amp;#125; [built]
 [41] path (ignored) 15 bytes &amp;#123;1&amp;#125; [built]
 [42] ./node_modules/mocha/lib/reporters/index.js 945 bytes &amp;#123;1&amp;#125; [built]
[105] ./node_modules/chai/index.js 39 bytes &amp;#123;1&amp;#125; [built]
[106] ./node_modules/chai/lib/chai.js 1.22 KiB &amp;#123;1&amp;#125; [built]
    + 128 hidden modules

WARNING in ./node_modules/mocha/lib/mocha.js 217:20-37
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js

WARNING in ./node_modules/mocha/lib/mocha.js 222:24-70
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js

WARNING in ./node_modules/mocha/lib/mocha.js 266:24-35
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js

WARNING in ./node_modules/mocha/lib/mocha.js 313:35-48
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js

WARNING in ./node_modules/mocha/lib/mocha.js 329:23-44
Critical dependency: the request of a dependency is an expression
 @ ./node_modules/mocha/browser-entry.js
 @ ./test/test.js
ℹ ｢wdm｣: Compiled with warnings.
12 07 2019 17:24:04.905:WARN [karma]: No captured browser, open http://localhost:9876/
12 07 2019 17:24:04.914:INFO [karma-server]: Karma v4.1.0 server started at http://0.0.0.0:9876/
12 07 2019 17:24:04.914:INFO [launcher]: Launching browsers Chrome with concurrency unlimited
12 07 2019 17:24:04.922:INFO [launcher]: Starting browser Chrome
12 07 2019 17:24:06.289:INFO [Chrome 75.0.3770 (Mac OS X 10.14.5)]: Connected on socket EbCCSbQRPbxHbq3OAAAA with id 92342032
Chrome 75.0.3770 (Mac OS X 10.14.5) LOG: &amp;#39;hello karma&amp;#39;

LOG: &amp;#39;hello mocha&amp;#39;
Chrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0 secs / 0.001 secs
Chrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0.006 secs / 0.001 
secs)
TOTAL: 1 SUCCESS
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;UI测试利器Nightmare&#34;&gt;&lt;a href=&#34;#UI测试利器Nightmare&#34; class=&#34;headerlink&#34; title=&#34;UI测试利器Nightmare&#34;&gt;&lt;/a&gt;UI测试利器Nightmare&lt;/h2&gt;&lt;p&gt;Nightmare是&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zZWdtZW50LmNvbS8=&#34;&gt;Segment&lt;/span&gt;的高级浏览器自动化库。&lt;/p&gt;
&lt;p&gt;目标是公开一些模仿用户操作（例如&lt;code&gt;goto&lt;/code&gt;，&lt;code&gt;type&lt;/code&gt;和&lt;code&gt;click&lt;/code&gt;）的简单方法，使用对每个脚本块感觉同步的API，而不是深层嵌套的回调。它最初设计用于在没有API的站点之间自动执行任务，但最常用于UI测试和爬网。&lt;/p&gt;
&lt;p&gt;它使用&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2VsZWN0cm9uLmF0b20uaW8v&#34;&gt;Electron&lt;/span&gt;，它与&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3BoYW50b21qcy5vcmcv&#34;&gt;PhantomJS&lt;/span&gt;类似，但大约&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUvaXNzdWVzLzQ4NCNpc3N1ZWNvbW1lbnQtMTg0NTE5NTkx&#34;&gt;快两倍&lt;/span&gt;，更现代。&lt;/p&gt;
&lt;h3 id=&#34;安装与起步&#34;&gt;&lt;a href=&#34;#安装与起步&#34; class=&#34;headerlink&#34; title=&#34;安装与起步&#34;&gt;&lt;/a&gt;安装与起步&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装&lt;code&gt;nightmare&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;// 初始化项目
npm init -y

npm install --save-dev nightmare
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;npm install –save-dev mocha&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
2. 淘宝源加速
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;   &amp;#x2F;&amp;#x2F; 使用淘宝源加速electron的安装&lt;br&gt;   export ELECTRON_MIRROR&amp;#x3D;”&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ucG0udGFvYmFvLm9yZy9taXJyb3JzL2VsZWN0cm9uLw==&#34;&gt;https://npm.taobao.org/mirrors/electron/&lt;/span&gt;“&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
3. 起步测试：

```js
const Nightmare = require(&amp;#39;nightmare&amp;#39;)
const assert = require(&amp;#39;assert&amp;#39;)

describe(&amp;#39;Load a Page&amp;#39;, function () &amp;#123;
  // Recommended: 5s locally, 10s to remote server, 30s from airplane ¯\_(ツ)_/¯
  this.timeout(&amp;#39;30s&amp;#39;)

  let nightmare = null
  beforeEach(() =&amp;gt; &amp;#123;
    nightmare = new Nightmare()
  &amp;#125;)

  describe(&amp;#39;/ (Home Page)&amp;#39;, () =&amp;gt; &amp;#123;
    it(&amp;#39;should load without error&amp;#39;, done =&amp;gt; &amp;#123;
      // your actual testing urls will likely be `http://localhost:port/path`
      nightmare.goto(&amp;#39;https://www.baidu.com&amp;#39;)
        .end()
        .then(function (result) &amp;#123;
          done()
        &amp;#125;)
        .catch(done)
    &amp;#125;)
  &amp;#125;)
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nightmare配合mocha测试&#34;&gt;&lt;a href=&#34;#nightmare配合mocha测试&#34; class=&#34;headerlink&#34; title=&#34;nightmare配合mocha测试&#34;&gt;&lt;/a&gt;nightmare配合mocha测试&lt;/h3&gt;&lt;p&gt;nightmare可以进行网页的抓取，配合mocha进行页面的测试：&lt;/p&gt;
&lt;p&gt;安装&lt;code&gt;mocha&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install --save-dev mocha
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;还可以安装一些断言库，如：&lt;code&gt;chai&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const Nightmare = require(&amp;#39;nightmare&amp;#39;)
const assert = require(&amp;#39;assert&amp;#39;)

describe(&amp;#39;Search nightmare&amp;#39;, () =&amp;gt; &amp;#123;
  this.timeout(&amp;#39;30s&amp;#39;)

  let nightmare = null
  
  beforeEach(() =&amp;gt; &amp;#123;
    nightmare = new Nightmare()
  &amp;#125;)

  it(&amp;#39;should load with result nightmare&amp;#39;, done =&amp;gt; &amp;#123;
    const selector = &amp;#39;em&amp;#39;
    nightmare.goto(&amp;#39;https://www.baidu.com&amp;#39;)
      .type(&amp;#39;#kw&amp;#39;, &amp;#39;nightmare&amp;#39;)
      .click(&amp;#39;#su&amp;#39;)
      .wait(&amp;#39;em&amp;#39;)
      .evaluate(selector =&amp;gt; &amp;#123;
      // now we&amp;#39;re executing inside the browser scope.
      return document.querySelector(selector).innerText
    &amp;#125;, selector) // &amp;lt;-- that&amp;#39;s how you pass parameters from Node scope to browser scope
      .end()
      .then(function (result) &amp;#123;
      console.log(result)
      assert.equal(result, &amp;#39;nightmare&amp;#39;)
      done()
    &amp;#125;)
      .catch(done)
  &amp;#125;)
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将mocha作为测试脚本添加到您的  &lt;code&gt;package.json&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;quot;scripts&amp;quot;: &amp;#123;
  &amp;quot;test&amp;quot;: &amp;quot;mocha&amp;quot;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;API介绍&#34;&gt;&lt;a href=&#34;#API介绍&#34; class=&#34;headerlink&#34; title=&#34;API介绍&#34;&gt;&lt;/a&gt;API介绍&lt;/h3&gt;&lt;h4 id=&#34;nightmare的配置项&#34;&gt;&lt;a href=&#34;#nightmare的配置项&#34; class=&#34;headerlink&#34; title=&#34;nightmare的配置项&#34;&gt;&lt;/a&gt;nightmare的配置项&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;waitTimeout (default: 30s)
gotoTimeout (default: 30s)
loadTimeout (default: infinite)
executionTimeout (default: 30s)
paths
switches
electronPath
dock
openDevTools
typeInterval (default: 100ms)
pollInterval (default: 250ms)
maxAuthRetries (default: 3)
certificateSubjectName
.engineVersions()
.useragent(useragent)
.authentication(user, password)
.authentication(user, password)
.halt(error, done)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjbmlnaHRtYXJlb3B0aW9ucw==&#34;&gt;https://github.com/segmentio/nightmare#nightmareoptions&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;页面交互相关&#34;&gt;&lt;a href=&#34;#页面交互相关&#34; class=&#34;headerlink&#34; title=&#34;页面交互相关&#34;&gt;&lt;/a&gt;页面交互相关&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;.back()
.forward()
.refresh()
.click(selector)
.mousedown(selector)
.mouseup(selector)
.mouseover(selector)
.mouseout(selector)
.type(selector[, text])
.insert(selector[, text])
.check(selector)
.uncheck(selector)
.select(selector, option)
.scrollTo(top, left)
.viewport(width, height)
.inject(type, file)
.evaluate(fn[, arg1, arg2,...])
.wait(ms)
.wait(selector)
.wait(fn[, arg1, arg2,...])
.header(header, value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjaW50ZXJhY3Qtd2l0aC10aGUtcGFnZQ==&#34;&gt;配置参考链接&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;页面提取&#34;&gt;&lt;a href=&#34;#页面提取&#34; class=&#34;headerlink&#34; title=&#34;页面提取&#34;&gt;&lt;/a&gt;页面提取&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;.exists(selector)
.visible(selector)
.on(event, callback)
.once(event, callback)
.removeListener(event, callback)
.screenshot([path][, clip])
.html(path, saveType)
.pdf(path, options)
.title()
.url()
.path()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjZXh0cmFjdC1mcm9tLXRoZS1wYWdl&#34;&gt;配置参考链接&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;补充学习&#34;&gt;&lt;a href=&#34;#补充学习&#34; class=&#34;headerlink&#34; title=&#34;补充学习&#34;&gt;&lt;/a&gt;补充学习&lt;/h2&gt;&lt;h3 id=&#34;补充资料&#34;&gt;&lt;a href=&#34;#补充资料&#34; class=&#34;headerlink&#34; title=&#34;补充资料&#34;&gt;&lt;/a&gt;补充资料&lt;/h3&gt;&lt;h4 id=&#34;软件测试的分类&#34;&gt;&lt;a href=&#34;#软件测试的分类&#34; class=&#34;headerlink&#34; title=&#34;软件测试的分类&#34;&gt;&lt;/a&gt;软件测试的分类&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;第一部分：软件测试的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;按测试执行阶段划分&lt;/p&gt;
&lt;p&gt;单元测试、集成测试、系统测试、验收测试（正式验收测试、Alpha测试、Beta测试）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按测试技术划分&lt;/p&gt;
&lt;p&gt;白盒测试、黑盒测试、灰盒测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;被测试对象是否运行划分&lt;/p&gt;
&lt;p&gt;动态测试、静态测试（文档检查、代码走查、界面检查）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按不同的测试手段划分&lt;/p&gt;
&lt;p&gt;手工测试、自动化测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按测试包含的内容划分&lt;/p&gt;
&lt;p&gt;功能测试、界面测试、安全测试、兼容性测试、易用性测试、性能测试、压力测试、负载测试、恢复测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他测试&lt;/p&gt;
&lt;p&gt;冒烟测试、回归测试、探索性测试&amp;#x2F;自由测试（测试思维）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第二部分：接下来对软件测试分类进行一个说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg&#34; alt=&#34;img&#34;&gt;&lt;img data-src=&#34;/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-f831b8041976b50aad7c2425aada44e2_hd-1561454378198.jpg&#34; alt=&#34;img&#34;&gt;&lt;img data-src=&#34;/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-f831b8041976b50aad7c2425aada44e2_hd.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三部分：测试工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SVN，Git——&amp;gt;版本控制管理工具&lt;/p&gt;
&lt;p&gt;禅道——&amp;gt;Bug管理工具&lt;/p&gt;
&lt;p&gt;Fiddler——&amp;gt;抓包，定位问题你&lt;/p&gt;
&lt;p&gt;postman，jmeter，soapui——&amp;gt;接口测试&lt;/p&gt;
&lt;p&gt;Loadrunner，Jmeter——&amp;gt;性能，压力测试&lt;/p&gt;
&lt;h4 id=&#34;2019年Javascript测试概览&#34;&gt;&lt;a href=&#34;#2019年Javascript测试概览&#34; class=&#34;headerlink&#34; title=&#34;2019年Javascript测试概览&#34;&gt;&lt;/a&gt;2019年Javascript测试概览&lt;/h4&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tZWRpdW0uY29tL3dlbGxkb25lLXNvZnR3YXJlL2FuLW92ZXJ2aWV3LW9mLWphdmFzY3JpcHQtdGVzdGluZy1pbi0yMDE5LTI2NGUxOTUxNGQwYQ==&#34;&gt;https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2019-264e19514d0a&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是一篇非常好的国外的博文，同时也是2018年Javascript测试概览的作者。这里有2018年的译文：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjcwMjQyMQ==&#34;&gt;展望 2018 年 JavaScript Testing&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在文中很好介绍到了测试类型，并举了大量的例子，非常全面。&lt;/p&gt;
&lt;h4 id=&#34;什么是TDD？&#34;&gt;&lt;a href=&#34;#什么是TDD？&#34; class=&#34;headerlink&#34; title=&#34;什么是TDD？&#34;&gt;&lt;/a&gt;什么是TDD？&lt;/h4&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzNlNzM4NzZmYjlhMDQ5ZDM3ZjVkYjE=&#34;&gt;测试驱动开发（TDD）总结——原理篇&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TDD （Test Driven Development） 在不同的圈子、不同的角色的认知中可能会有不同的理解，有人可能会理解成 ATDD（Acceptance Test Driven Development），也有人可能会理解成 UTDD（Unit Test Driven Development），为了避免产生歧义，&lt;strong&gt;文章涉及到 TDD 专指 UTDD（Unit Test Driven Development），即 「单元测试驱动开发」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TDD 的目标&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kent Beck 在他的著作《Test-Driven Development》一书中提到：“&lt;strong&gt;代码简洁可用&lt;/strong&gt;这句言简意赅的话，正是 TDD 所追求的目标”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对于如何保证“代码简洁可用”可以使用分而治之的方法，先达到“可用”目标，再追求“简洁”目标。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用：&lt;/strong&gt; 保证代码通过自动化测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码简洁：&lt;/strong&gt; 在不同阶段人们对简洁的理解程度也不一样，不过遵循的原则差不多，例如 OOD 的 SOLID 原则，Kent Beck 的 Simple Design 原则等。&lt;/p&gt;
&lt;p&gt;虽然有很多因素妨碍我们得到整洁的代码，甚至可用的代码，无需征求太多意见，只需要采用 TDD 的开发方式来驱动出简洁可用的代码。&lt;/p&gt;
&lt;h4 id=&#34;Karma的前世今生&#34;&gt;&lt;a href=&#34;#Karma的前世今生&#34; class=&#34;headerlink&#34; title=&#34;Karma的前世今生&#34;&gt;&lt;/a&gt;Karma的前世今生&lt;/h4&gt;&lt;p&gt;2016年的文章，由淘宝前端团队书写：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3Rhb2Jhb2ZlZC5vcmcvYmxvZy8yMDE2LzAxLzA4L2thcm1hLW9yaWdpbi8=&#34;&gt;http://taobaofed.org/blog/2016/01/08/karma-origin/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通篇介绍了karma的工作原理及实现原理，非常有价值的文章。&lt;/p&gt;
&lt;h3 id=&#34;ava框架的配置文件&#34;&gt;&lt;a href=&#34;#ava框架的配置文件&#34; class=&#34;headerlink&#34; title=&#34;ava框架的配置文件&#34;&gt;&lt;/a&gt;ava框架的配置文件&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;&amp;#123;
    &amp;quot;ava&amp;quot;: &amp;#123;
        &amp;quot;files&amp;quot;: [
            &amp;quot;test/**/*&amp;quot;,
            &amp;quot;!test/exclude-files-in-this-directory&amp;quot;,
            &amp;quot;!**/exclude-files-with-this-name.*&amp;quot;
        ],
        &amp;quot;helpers&amp;quot;: [
            &amp;quot;**/helpers/**/*&amp;quot;
        ],
        &amp;quot;sources&amp;quot;: [
            &amp;quot;src/**/*&amp;quot;
        ],
        &amp;quot;match&amp;quot;: [
            &amp;quot;*oo&amp;quot;,
            &amp;quot;!foo&amp;quot;
        ],
        &amp;quot;cache&amp;quot;: true,
        &amp;quot;concurrency&amp;quot;: 5,
        &amp;quot;failFast&amp;quot;: true,
        &amp;quot;failWithoutAssertions&amp;quot;: false,
        &amp;quot;environmentVariables&amp;quot;: &amp;#123;
            &amp;quot;MY_ENVIRONMENT_VARIABLE&amp;quot;: &amp;quot;some value&amp;quot;
        &amp;#125;,
        &amp;quot;tap&amp;quot;: true,
        &amp;quot;verbose&amp;quot;: true,
        &amp;quot;compileEnhancements&amp;quot;: false,
        &amp;quot;require&amp;quot;: [
            &amp;quot;@babel/register&amp;quot;
        ],
        &amp;quot;babel&amp;quot;: &amp;#123;
            &amp;quot;extensions&amp;quot;: [&amp;quot;js&amp;quot;, &amp;quot;jsx&amp;quot;],
            &amp;quot;testOptions&amp;quot;: &amp;#123;
                &amp;quot;babelrc&amp;quot;: false
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;files&lt;/code&gt;：用于选择测试文件的glob模式数组。带有下划线前缀的文件将被忽略。默认情况下，仅选择具有&lt;code&gt;js&lt;/code&gt;扩展名的文件，即使该模式与其他文件匹配。指定&lt;code&gt;extensions&lt;/code&gt;并&lt;code&gt;babel.extensions&lt;/code&gt;允许其他文件扩展名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;helpers&lt;/code&gt;：用于选择帮助文件的glob模式数组。这里匹配的文件永远不会被视为测试。默认情况下，仅选择具有&lt;code&gt;js&lt;/code&gt;扩展名的文件，即使该模式与其他文件匹配。指定&lt;code&gt;extensions&lt;/code&gt;并&lt;code&gt;babel.extensions&lt;/code&gt;允许其他文件扩展名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sources&lt;/code&gt;：一组glob模式，用于匹配文件，这些文件在更改时会导致重新运行测试（在监视模式下）。有关详细信息，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzL3JlY2lwZXMvd2F0Y2gtbW9kZS5tZCNzb3VyY2UtZmlsZXMtYW5kLXRlc3QtZmlsZXM=&#34;&gt;请参阅&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt;：通常在&lt;code&gt;package.json&lt;/code&gt;配置中没用，但等同于在CLI上指定&lt;code&gt;--match&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cache&lt;/code&gt;：缓存编译的测试和帮助文件&lt;code&gt;node_modules/.cache/ava&lt;/code&gt;。如果&lt;code&gt;false&lt;/code&gt;，文件缓存在临时目录中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;failFast&lt;/code&gt;：一旦测试失败，停止运行进一步的测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;failWithoutAssertions&lt;/code&gt;：如果设置成&lt;code&gt;false&lt;/code&gt;，那么如果没有运行断言，则测试失败&lt;/li&gt;
&lt;li&gt;&lt;code&gt;environmentVariables&lt;/code&gt;：指定要供测试使用的环境变量。此处定义的环境变量会覆盖其中的环境变量&lt;code&gt;process.env&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tap&lt;/code&gt;：设置成 &lt;code&gt;true&lt;/code&gt;，启用TAP报告&lt;/li&gt;
&lt;li&gt;&lt;code&gt;verbose&lt;/code&gt;：设置成 &lt;code&gt;true&lt;/code&gt;，启用详细输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snapshotDir&lt;/code&gt;：指定用于存储快照文件的固定位置。如果快照最终位于错误的位置，请使用此选项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileEnhancements&lt;/code&gt;：设置成 &lt;code&gt;false&lt;/code&gt;，禁用了 &lt;a href=&#34;https://github.com/avajs/ava/blob/master/docs/03-assertions.md#enhanced-assertion-messages&#34;&gt;&lt;code&gt;power-assert&lt;/code&gt;&lt;/a&gt;，否则有助于提供更具描述性的错误消息， 并检测&lt;code&gt;t.throws()&lt;/code&gt;断言的不当使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extensions&lt;/code&gt;：未使用AVA的Babel预设进行预编译的测试文件的扩展名。请注意，文件仍然会被编译为启用&lt;code&gt;power-assert&lt;/code&gt;和其他功能，因此您可能还需要设置&lt;code&gt;compileEnhancements&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;文件是否为有效的JavaScript。设置此&lt;code&gt;&amp;quot;js&amp;quot;&lt;/code&gt;值会覆盖默认值，因此请确保在列表中包含该扩展名，只要它不包含在内&lt;code&gt;babel.extensions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt;：在运行测试之前需要额外的模块。工作进程中需要模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;babel&lt;/code&gt;：测试文件特定的Babel选项。有关详细信息，请参阅&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzL3JlY2lwZXMvYmFiZWwubWQjY29uZmlndXJpbmctYmFiZWw=&#34;&gt;Babel配置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;babel.extensions&lt;/code&gt;：将使用AVA的Babel预设进行预编译的测试文件的扩展。设置此选项会覆盖默认&lt;code&gt;&amp;quot;js&amp;quot;&lt;/code&gt;值，因此请确保在列表中包含该扩展名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeout&lt;/code&gt;：AVA中的超时行为与其他测试框架中的行为不同。AVA在每次测试后重置计时器，如果在指定的超时内没有收到新的测试结果，则强制测试退出。这可用于处理停滞的测试。请参阅我们的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzLzA3LXRlc3QtdGltZW91dHMubWQ=&#34;&gt;超时文档&lt;/span&gt;以获取更多选&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，在CLI上提供文件会覆盖该&lt;code&gt;files&lt;/code&gt;选项。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzAwOTY2NA==&#34;&gt;使用Jest测试JavaScript(Mock篇)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/03/02/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
            <title>设计模式</title>
            <link>https://dmqweb.cn/2024/03/02/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
            <category term="设计模式" scheme="https://dmqweb.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
            <category term="设计模式" scheme="https://dmqweb.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
            <pubDate>Sat, 02 Mar 2024 08:24:04 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;设计模式&#34;&gt;&lt;a href=&#34;#设计模式&#34; class=&#34;headerlink&#34; title=&#34;设计模式&#34;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思&lt;/p&gt;
&lt;p&gt;每个代理模式的代码都必须自己手动完成一遍。&lt;/p&gt;
&lt;h2 id=&#34;创建型模式&#34;&gt;&lt;a href=&#34;#创建型模式&#34; class=&#34;headerlink&#34; title=&#34;创建型模式&#34;&gt;&lt;/a&gt;创建型模式&lt;/h2&gt;&lt;p&gt;创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。&lt;/p&gt;
&lt;p&gt;工厂模式分为简单工厂模式，工厂模式，抽象工厂模式&lt;/p&gt;
&lt;p&gt;在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。&lt;strong&gt;本质就是使用工厂方法代替new操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;简单工厂模式&#34;&gt;&lt;a href=&#34;#简单工厂模式&#34; class=&#34;headerlink&#34; title=&#34;简单工厂模式&#34;&gt;&lt;/a&gt;简单工厂模式&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class FoodFactory &amp;#123;
    public static Food makeFood(String name) &amp;#123;
        if (name.equals(&amp;quot;兰州拉面&amp;quot;)) &amp;#123;
            Food noodle = new LanZhouNoodle();
            System.out.println(&amp;quot;兰州拉面&amp;quot;+noodle+&amp;quot;出锅啦&amp;quot;);
            return noodle;
        &amp;#125; else if (name.equals(&amp;quot;黄焖鸡&amp;quot;)) &amp;#123;
            Food chicken = new HuangMenChicken();
            System.out.println(&amp;quot;黄焖鸡&amp;quot;+ chicken +&amp;quot;出锅啦&amp;quot;);
            return chicken;
        &amp;#125; else &amp;#123;
            System.out.println(&amp;quot;不知道你做的什么哦~&amp;quot;);
            return null;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Cook &amp;#123;
    public static void main(String[] args) &amp;#123;
        Food food = FoodFactory.makeFood(&amp;quot;黄焖鸡&amp;quot;);
        FoodFactory.makeFood(&amp;quot;jaja&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单地说，&lt;strong&gt;简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们强调&lt;strong&gt;职责单一&lt;/strong&gt;原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在此例中可以看出，Cook 类在使用 FoodFactory 时就不需要 new 任何一个对象，这就是简单工厂模式的好处，封装了 new 的部分，做到的代码易用性。&lt;/p&gt;
&lt;h3 id=&#34;工厂模式&#34;&gt;&lt;a href=&#34;#工厂模式&#34; class=&#34;headerlink&#34; title=&#34;工厂模式&#34;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface FoodFactory &amp;#123;
    Food makeFood(String name);
&amp;#125;
public class ChineseFoodFactory implements FoodFactory &amp;#123;

    @Override
    public Food makeFood(String name) &amp;#123;
        if (name.equals(&amp;quot;A&amp;quot;)) &amp;#123;
            return new ChineseFoodA();
        &amp;#125; else if (name.equals(&amp;quot;B&amp;quot;)) &amp;#123;
            return new ChineseFoodB();
        &amp;#125; else &amp;#123;
            return null;
        &amp;#125;
    &amp;#125;
&amp;#125;
public class AmericanFoodFactory implements FoodFactory &amp;#123;

    @Override
    public Food makeFood(String name) &amp;#123;
        if (name.equals(&amp;quot;A&amp;quot;)) &amp;#123;
            return new AmericanFoodA();
        &amp;#125; else if (name.equals(&amp;quot;B&amp;quot;)) &amp;#123;
            return new AmericanFoodB();
        &amp;#125; else &amp;#123;
            return null;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。&lt;/p&gt;
&lt;p&gt;客户端调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class APP &amp;#123;
    public static void main(String[] args) &amp;#123;
        // 先选择一个具体的工厂
        FoodFactory factory = new ChineseFoodFactory();
        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象
        Food food = factory.makeFood(&amp;quot;A&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然都是调用 makeFood(“A”) 制作 A 类食物，但是，不同的工厂生产出来的完全不一样。&lt;/p&gt;
&lt;p&gt;第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心在于，我们需要在第一步选好我们需要的工厂&lt;/strong&gt;。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。&lt;/p&gt;
&lt;h3 id=&#34;抽象工厂模式&#34;&gt;&lt;a href=&#34;#抽象工厂模式&#34; class=&#34;headerlink&#34; title=&#34;抽象工厂模式&#34;&gt;&lt;/a&gt;抽象工厂模式&lt;/h3&gt;&lt;p&gt;当涉及到&lt;strong&gt;产品族&lt;/strong&gt;的时候，就需要引入抽象工厂模式了。 一个经典的例子是造一台电脑 。&lt;/p&gt;
&lt;p&gt;当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。&lt;/p&gt;
&lt;p&gt;当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了&lt;strong&gt;对修改关闭，对扩展开放&lt;/strong&gt;这个设计原则。&lt;/p&gt;
&lt;p&gt;本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/3-1Q1141559151S.gif&#34; alt=&#34;3-1Q1141559151S&#34;&gt;&lt;/p&gt;
&lt;p&gt;抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。&lt;/p&gt;
&lt;p&gt;抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。&lt;/p&gt;
&lt;p&gt;使用抽象工厂模式一般要满足以下条件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。&lt;/li&gt;
&lt;li&gt;系统一次只可能消费其中某一族产品，即同族的产品一起使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。&lt;/li&gt;
&lt;li&gt;当增加一个新的产品族时不需要修改原代码，满足开闭原则。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。&lt;/p&gt;
&lt;h3 id=&#34;单例模式&#34;&gt;&lt;a href=&#34;#单例模式&#34; class=&#34;headerlink&#34; title=&#34;单例模式&#34;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;p&gt;简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。&lt;/p&gt;
&lt;p&gt;getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类构造器私有&lt;/li&gt;
&lt;li&gt;持有自己类型的属性&lt;/li&gt;
&lt;li&gt;对外提供获取实例的静态方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;饿汉式写法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Singleton &amp;#123;  
   private static Singleton instance = new Singleton();  
   private Singleton ()&amp;#123;&amp;#125;  
   public static Singleton getInstance() &amp;#123;  
   return instance;  
   &amp;#125;  
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;弊端：因为类加载的时候就会创建对象，所以有的时候还不需要使用对象，就会创建对象，造成内存的浪费；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饱汉模式最容易出错：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Singleton &amp;#123;
    // 首先，也是先堵死 new Singleton() 这条路
    private Singleton() &amp;#123;&amp;#125;
    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的
    private static volatile Singleton instance = null;

    public static Singleton getInstance() &amp;#123;
        if (instance == null) &amp;#123;
            // 加锁
            synchronized (Singleton.class) &amp;#123;
                // 这一次判断也是必须的，不然会有并发问题
                if (instance == null) &amp;#123;
                    instance = new Singleton();
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return instance;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;双重检查，指的是两次检查 instance 是否为 null。&lt;/p&gt;
&lt;p&gt;volatile 在这里是需要的，希望能引起读者的关注。&lt;/p&gt;
&lt;p&gt;很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嵌套类最经典，以后大家就用它吧：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Singleton &amp;#123;

    private Singleton() &amp;#123;&amp;#125;
    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性
    private static class Holder &amp;#123;
        private static Singleton instance = new Singleton();
    &amp;#125;
    public static Singleton getInstance() &amp;#123;
        return Holder.instance;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，很多人都会把这个&lt;strong&gt;嵌套类&lt;/strong&gt;说成是&lt;strong&gt;静态内部类&lt;/strong&gt;，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TODO:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建造者模式&lt;/p&gt;
&lt;p&gt;原型模式&lt;/p&gt;
&lt;h2 id=&#34;结构型模式&#34;&gt;&lt;a href=&#34;#结构型模式&#34; class=&#34;headerlink&#34; title=&#34;结构型模式&#34;&gt;&lt;/a&gt;结构型模式&lt;/h2&gt;&lt;p&gt;前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。&lt;/p&gt;
&lt;h3 id=&#34;代理模式&#34;&gt;&lt;a href=&#34;#代理模式&#34; class=&#34;headerlink&#34; title=&#34;代理模式&#34;&gt;&lt;/a&gt;代理模式&lt;/h3&gt;&lt;p&gt;第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。&lt;/p&gt;
&lt;p&gt;既然说是&lt;strong&gt;代理&lt;/strong&gt;，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。&lt;/p&gt;
&lt;p&gt;理解&lt;strong&gt;代理&lt;/strong&gt;这个词，这个模式其实就简单了。 下面上代码理解。 代理接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;//要有一个代理接口让实现类和代理实现类来实现。
public interface FoodService &amp;#123;
    Food makeChicken();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;被代理的实现类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class FoodServiceImpl implements FoodService &amp;#123;
    @Override
    public Food makeChicken() &amp;#123;
        Food f = new Chicken();
        f.setChicken(&amp;quot;1kg&amp;quot;);
        f.setSpicy(&amp;quot;1g&amp;quot;);
        f.setSalt(&amp;quot;3g&amp;quot;);
        System.out.println(&amp;quot;鸡肉加好佐料了&amp;quot;);
        return f;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;被代理实现类就只需要做自己该做的事情就好了，不需要管别的。&lt;/p&gt;
&lt;p&gt;代理实现类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class FoodServiceProxy implements FoodService &amp;#123;
    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入
    private FoodService foodService = new FoodServiceImpl();
    
    @Override
    public Food makeChicken() &amp;#123;
        System.out.println(&amp;quot;开始制作鸡肉&amp;quot;);
        
        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，
        // 代理只是在核心代码前后做些“无足轻重”的事情
        Food food = foodService.makeChicken();
        
        System.out.println(&amp;quot;鸡肉制作完成啦，加点胡椒粉&amp;quot;);
        food.addCondiment(&amp;quot;pepper&amp;quot;);
        System.out.println(&amp;quot;上锅咯&amp;quot;);
        return food;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端调用，注意，我们要用代理来实例化接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;// 这里用代理类来实例化
FoodService foodService = new FoodServiceProxy();
foodService.makeChicken();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所谓代理模式，&lt;strong&gt;就是对被代理方法包装或者叫增强， 在面向切面编程（AOP）中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;待续。。。&lt;/p&gt;
&lt;h2 id=&#34;行为型模式&#34;&gt;&lt;a href=&#34;#行为型模式&#34; class=&#34;headerlink&#34; title=&#34;行为型模式&#34;&gt;&lt;/a&gt;行为型模式&lt;/h2&gt;&lt;h3 id=&#34;模板模式&#34;&gt;&lt;a href=&#34;#模板模式&#34; class=&#34;headerlink&#34; title=&#34;模板模式&#34;&gt;&lt;/a&gt;模板模式&lt;/h3&gt;&lt;p&gt;在含有继承结构的代码中，模板方法模式是非常常用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。&lt;/p&gt;
&lt;p&gt;好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好&lt;/p&gt;
&lt;p&gt;缺点： 每一个不同的实现都需要一个子类来实现，导致类个数增加，使系统更加庞大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板模式的关键点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、使用抽象类定义模板类，并在其中定义所有的基本方法、模板方法，钩子方法，不限数量，以实现功能逻辑为主。其中基本方法使用final修饰，其中要调用基本方法和钩子方法，基本方法和钩子方法可以使用protected修饰，表明可被子类修改。&lt;/p&gt;
&lt;p&gt;　　　　2、定义实现抽象类的子类，重写其中的模板方法，甚至钩子方法，完善具体的逻辑。&lt;/p&gt;
&lt;p&gt;　　使用场景：&lt;/p&gt;
&lt;p&gt;　　　　1、在多个子类中拥有相同的方法，而且逻辑相同时，可以将这些方法抽出来放到一个模板抽象类中。&lt;/p&gt;
&lt;p&gt;　　　　2、程序主框架相同，细节不同的情况下，也可以使用模板方法。&lt;/p&gt;
&lt;h4 id=&#34;架构方法介绍&#34;&gt;&lt;a href=&#34;#架构方法介绍&#34; class=&#34;headerlink&#34; title=&#34;架构方法介绍&#34;&gt;&lt;/a&gt;架构方法介绍&lt;/h4&gt;&lt;p&gt;模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。其主要分为两大类：模版方法和基本方法，而基本方法又分为：抽象方法（Abstract Method），具体方法（Concrete Method），钩子方法（Hook Method）。&lt;/p&gt;
&lt;p&gt;四种方法的基本定义（前提：在抽象类中定义）：&lt;/p&gt;
&lt;p&gt;（1）抽象方法：由抽象类声明，由具体子类实现，并以abstract关键字进行标识。&lt;/p&gt;
&lt;p&gt;（2）具体方法：由抽象类声明并且实现，子类并不实现或者做覆盖操作。其实质就是普遍适用的方法，不需要子类来实现。&lt;/p&gt;
&lt;p&gt;（3）钩子方法：由抽象类声明并且实现，子类也可以选择加以扩展。通常抽象类会给出一个空的钩子方法，也就是没有实现的扩展。&lt;strong&gt;它和具体方法在代码上没有区别，不过是一种意识的区别&lt;/strong&gt;；而它和抽象方法有时候也是没有区别的，就是在子类都需要将其实现的时候。而不同的是抽象方法必须实现，而钩子方法可以不实现。也就是说钩子方法为你在实现某一个抽象类的时候提供了可选项，&lt;strong&gt;相当于预先提供了一个默认配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（4）模板方法：定义了一个方法，其中定义了整个逻辑的基本骨架。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;public abstract class AbstractTemplate &amp;#123;
    // 这就是模板方法
    public void templateMethod() &amp;#123;
        init();
        apply(); // 这个是重点
        end(); // 可以作为钩子方法
    &amp;#125;
    //这是具体方法
    protected void init() &amp;#123;
        System.out.println(&amp;quot;init 抽象层已经实现，子类也可以选择覆写&amp;quot;);
    &amp;#125;

    // 这是抽象方法，留给子类实现
    protected abstract void apply();
    //这是钩子方法，可定义一个默认操作，或者为空
    protected void end() &amp;#123;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/02/03/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/</guid>
            <title>持续集成与持续部署</title>
            <link>https://dmqweb.cn/2024/02/03/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/</link>
            <category term="持续集成与部署" scheme="https://dmqweb.cn/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E9%83%A8%E7%BD%B2/" />
            <category term="持续集成" scheme="https://dmqweb.cn/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/" />
            <category term="持续部署" scheme="https://dmqweb.cn/tags/%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/" />
            <pubDate>Sat, 03 Feb 2024 14:04:09 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;5-4-持续集成与持续部署&#34;&gt;&lt;a href=&#34;#5-4-持续集成与持续部署&#34; class=&#34;headerlink&#34; title=&#34;5-4 持续集成与持续部署&#34;&gt;&lt;/a&gt;5-4 持续集成与持续部署&lt;/h1&gt;&lt;h2 id=&#34;课程介绍&#34;&gt;&lt;a href=&#34;#课程介绍&#34; class=&#34;headerlink&#34; title=&#34;课程介绍&#34;&gt;&lt;/a&gt;课程介绍&lt;/h2&gt;&lt;p&gt;那些大厂们，天天DevOps、持续集成的？到底在讲些什么？这堂课来给你揭开持续集成与持续部署的面纱！！没有什么难的，盘它！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的开发过程中的坑：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUG总是在最后才发现&lt;/li&gt;
&lt;li&gt;越到项目后期，加班越严重&lt;/li&gt;
&lt;li&gt;交付无法保障&lt;/li&gt;
&lt;li&gt;变更频繁导致效率低下&lt;/li&gt;
&lt;li&gt;无效的等待多，用户满足度低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/1460000014924499.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你有没有想过&amp;#x2F;用过？当你哪一天…&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不用为开发&amp;#x2F;测试环境不一致而苦恼&lt;/li&gt;
&lt;li&gt;不用麻烦运维人员帮忙调试环境&lt;/li&gt;
&lt;li&gt;不用手动进行测试，模拟环境中进行自测&lt;/li&gt;
&lt;li&gt;不用手动发布、部署，自动化实现发布部署&lt;/li&gt;
&lt;li&gt;不用管开发&amp;#x2F;测试环境，只用专注代码的开发？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;持续集成解决了什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高软件质量&lt;/li&gt;
&lt;li&gt;效率迭代&lt;/li&gt;
&lt;li&gt;便捷部署&lt;/li&gt;
&lt;li&gt;快速交付、便于管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;课程的主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是CI&amp;#x2F;CD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;介绍CI&amp;#x2F;CD流程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端项目：结合CI&amp;#x2F;CD流程，实现快速迭代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Docker的使用，Jenkins+gitlab+nodejs自动化项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持续集成工具介绍：Jenkins、Travis CI、Circle CI&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;环境准备：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux服务器(Centos 7.6&amp;#x2F;Ubuntu 16.04LTS)&lt;/li&gt;
&lt;li&gt;VSCode+插件 Dockerfile&lt;/li&gt;
&lt;li&gt;注册github账号&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;持续集成&#34;&gt;&lt;a href=&#34;#持续集成&#34; class=&#34;headerlink&#34; title=&#34;持续集成&#34;&gt;&lt;/a&gt;持续集成&lt;/h2&gt;&lt;h3 id=&#34;核心概念&#34;&gt;&lt;a href=&#34;#核心概念&#34; class=&#34;headerlink&#34; title=&#34;核心概念&#34;&gt;&lt;/a&gt;核心概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;集成，就是一些孤立的事物或元素通过某种方式集中在一起，产生联系，从而构成一个有机整体的过程&lt;/strong&gt;。知识经济的社会，集成已经成了很重要的一个名词。各行各业基本都会用到集成。比如汽车行业，那么复杂的一台跑车愣是通过一大堆零件组装起来。对于这些传统行业，它们在研发成功以后，可以通过流水线的方法批量生产进行集成。而在软件行业中，集成并不是一个简单的“搬箱子”的过程。因为软件工业是一个知识生产活动，其内在逻辑非常复杂，需求又很难一次性确定，完成的产品与最初的设计往往相差很远。敏捷宣言中就有一条是说响应变化重于遵循计划。而且由于软件行业的迅猛发展，软件变的越来越复杂，单靠个人是根本无法完成。大型软件为了重用及解耦，往往还需要分成好几个模块，这样集成就成了软件开发中不可或缺的一部分。&lt;/p&gt;
&lt;p&gt;持续，不言而喻，就是指&lt;strong&gt;长期的对项目代码进行集成。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;持续集成-1&#34;&gt;&lt;a href=&#34;#持续集成-1&#34; class=&#34;headerlink&#34; title=&#34;持续集成&#34;&gt;&lt;/a&gt;持续集成&lt;/h4&gt;&lt;p&gt;持续集成（英文：Continuous Integration，简称CI）&lt;/p&gt;
&lt;p&gt;在软件工程中，持续集成是指将所有开发者工作副本每天多次合并到主干的做法。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Grady Booch 在1991年的 Booch method 中首次命名并提出了 CI 的概念，尽管在当时他并不主张每天多次集成。而 XP（Extreme programming，极限编程）采用了 CI 的概念，并提倡每天不止一次集成。&lt;/p&gt;
&lt;p&gt;在《持续集成》一书中，对持续集成的定义如下：&lt;code&gt;持续集成&lt;/code&gt;是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，一般每人每天至少集成一次,也可以多次。每次集成会经过自动构建(包括自动测试)的检验，以尽快发现集成错误。自从在团队中引入这样的实践之后，&lt;code&gt;Martin Fowler&lt;/code&gt;发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/c5c8e6f40c7c133e22402c00bb7e1a25_hd.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。&lt;/p&gt;
&lt;p&gt;对于一天需要集成多少次数，并没有一个明确的定义。一般就是按照自己项目的实际需要来设置一定的频率，少则可能几次，多则可能达几十次。可以设置按照代码的变更来触发集成，或者设置一个固定时间周期来集成，也可以手工点击集成的按钮来“一键集成”。&lt;/p&gt;
&lt;h4 id=&#34;持续交付&#34;&gt;&lt;a href=&#34;#持续交付&#34; class=&#34;headerlink&#34; title=&#34;持续交付&#34;&gt;&lt;/a&gt;持续交付&lt;/h4&gt;&lt;p&gt;持续交付（英文：Continuous Delivery，简称CD）&lt;/p&gt;
&lt;p&gt;完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/db7198e3c39e4656e18efcb4bd1b20b1_hd.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。&lt;/p&gt;
&lt;p&gt;比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续&lt;code&gt;手动&lt;/code&gt;部署到生产环境中。&lt;/p&gt;
&lt;h4 id=&#34;持续部署&#34;&gt;&lt;a href=&#34;#持续部署&#34; class=&#34;headerlink&#34; title=&#34;持续部署&#34;&gt;&lt;/a&gt;持续部署&lt;/h4&gt;&lt;p&gt;持续部署（英文：Continuous Deployment，简称CD）&lt;/p&gt;
&lt;p&gt;对于一个成熟的 CI&amp;#x2F;CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/f96f19e4d567aad5006d841963a86e41_hd.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI&amp;#x2F;CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI&amp;#x2F;CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。&lt;/p&gt;
&lt;p&gt;持续部署则是在持续交付的基础上，把部署到生产环境的过程&lt;code&gt;自动化&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;持续集成组成要素&#34;&gt;&lt;a href=&#34;#持续集成组成要素&#34; class=&#34;headerlink&#34; title=&#34;持续集成组成要素&#34;&gt;&lt;/a&gt;持续集成组成要素&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一个最小化的持续集成系统需要包含以下几个要素：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;版本管理系统：&lt;/strong&gt;项目的源代码需要托管到适合的版本管理系统中，一般我们使用git作为版本控制库，版本管理软件可以使用github、&lt;code&gt;gitlab&lt;/code&gt;、stash等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构建脚本&amp;amp;工具：&lt;/strong&gt;每个项目都需要有构建脚本来实现对整个项目的自动化构建。比如Java的项目就可以使用gradle作为构建工具。通过构建工具实现对编译、静态扫描、运行测试、样式检查、打包、发布等活动串起来，可以通过命令行自动执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CI服务器：&lt;/strong&gt;CI服务器可以检测项目中的代码变动，并及时的通过构建机器运行构建脚本，并将集成结果通过某种方式反馈给团队成员。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;&lt;a href=&#34;#应用场景&#34; class=&#34;headerlink&#34; title=&#34;应用场景&#34;&gt;&lt;/a&gt;应用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打包平台&lt;/p&gt;
&lt;p&gt;常见的打包，Java应用（Gradle&amp;#x2F;Maven）、Nodejs前端应用(npm&amp;#x2F;yarn)&lt;/p&gt;
&lt;p&gt;移动端打包：Android&amp;#x2F;iOS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试平台&lt;/p&gt;
&lt;p&gt;接口测试&lt;/p&gt;
&lt;p&gt;自动化测试Robotium、Testlink&lt;/p&gt;
&lt;p&gt;单元测试junit&lt;/p&gt;
&lt;p&gt;性能测试Jmeter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动部署&lt;/p&gt;
&lt;p&gt;FTP&lt;/p&gt;
&lt;p&gt;Shell&lt;/p&gt;
&lt;p&gt;Tomcat&amp;#x2F;Dokcer&lt;/p&gt;
&lt;p&gt;Kubernetes&amp;#x2F;Rancher&amp;#x2F;Cluster&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持续集成&lt;/p&gt;
&lt;p&gt;Git: gitlab github gitee等&lt;/p&gt;
&lt;p&gt;Jenkins&amp;#x2F;TravisCi&amp;#x2F;CircleCI&lt;/p&gt;
&lt;p&gt;Docker&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工作流&#34;&gt;&lt;a href=&#34;#工作流&#34; class=&#34;headerlink&#34; title=&#34;工作流&#34;&gt;&lt;/a&gt;工作流&lt;/h3&gt;&lt;h4 id=&#34;传统的工作流&#34;&gt;&lt;a href=&#34;#传统的工作流&#34; class=&#34;headerlink&#34; title=&#34;传统的工作流&#34;&gt;&lt;/a&gt;传统的工作流&lt;/h4&gt;&lt;p&gt;参与人员：开发、项目经理、测试&lt;/p&gt;
&lt;p&gt;主要流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目一开始是先划分好模块，&lt;code&gt;分配模块&lt;/code&gt;给相应的开发人员；&lt;/li&gt;
&lt;li&gt;开发人员&lt;code&gt;开发好&lt;/code&gt;一个模块就进行&lt;code&gt;单元测试&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;等所有的模块都开发完成之后，由项目经理对&lt;code&gt;所有代码进行集成&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;集成后的项目由项目经理&lt;code&gt;部署到测试服务器&lt;/code&gt;上，被交由测试人员进行集成测试；&lt;/li&gt;
&lt;li&gt;测试过程中出现 Bug 就提把问题&lt;code&gt;记录&lt;/code&gt;进行 &lt;code&gt;Bug&lt;/code&gt; 列表中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;项目经理分配 Bug&lt;/code&gt; 给相应的责任人进行修改；&lt;/li&gt;
&lt;li&gt;修改完成后，项目经理&lt;code&gt;再次&lt;/code&gt;对项目进行集成，并&lt;code&gt;部署&lt;/code&gt;到测试服务器上；&lt;/li&gt;
&lt;li&gt;测试人员在下一次的集成测试中进行&lt;code&gt;回归测试&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;通过通过之后就&lt;code&gt;部署到生产环境&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;如果测试不通过，则重复上述“分配 Bug -&amp;gt; 修改 Bug -&amp;gt; 集成代码 -&amp;gt; 部署到测试服务器上 -&amp;gt; 集成测试”工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这也是传统的瀑布式开发模型，请参考：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vLU9ZSy9hcmNoaXZlLzIwMTIvMTAvMDgvMjcxNDY2OS5odG1s&#34;&gt;软件开发模式对比(瀑布、迭代、螺旋、敏捷)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;带来的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;重复性劳动，无效的等待变多&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重复的进行发布部署。&lt;/p&gt;
&lt;p&gt;流程上：有可能开发在等集成其他人的模块；测试人员在等待开发人员修复 Bug；产品经理在等待新版本上线好给客户做演示；项目经理在等待其他人提交代码。不管怎么样，等待意味低效。&lt;/p&gt;
&lt;p&gt;自动化部署工作可以解放了集成、测试、部署等重复性劳动，而且机器集成的频率明显可以比手工的高很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;很晚才发现缺陷，并且难以修复&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实践证明，缺陷发现的越晚，需要修复的时间和精力也就越大。从上一个可工作的软件到发现缺陷之间可能存在很多次提交，而要从这些提交中找出问题并修复的成本会很大，因为开发人员需要回忆每个提交的上下文来评估影响点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;低品质的软件，软件交付时机无法保障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于集成时每次包含的代码很多，所以大家的关注点主要都是如何保证编译通过、自动化测试通过，而往往很容易忽略代码是否遵守了编码规范、是否包含有重复代码、是否有重构的空间等问题。而这些问题又反过来会影响今后的开发和集成，久而久之集成变得越来越困难，软件的质量可想而知。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;项目缺少可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某些项目，程序会经常需要变更，特别是敏捷开发的实践者。由于产品经理在与客户交流过程中，往往实际的软件就是最好的原型，所以软件会被当作原型作为跟客户交流的工具。当然，客户最希望的当然是客户的想法能够马上反映到原型上，这会导致程序会经常被修改的。那么也就意味着“分配 Bug -&amp;gt; 修改 Bug -&amp;gt; 集成代码 -&amp;gt; 部署到测试服务器上 -&amp;gt; 集成测试”工作无形又爆增了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;常见的工作流&#34;&gt;&lt;a href=&#34;#常见的工作流&#34; class=&#34;headerlink&#34; title=&#34;常见的工作流&#34;&gt;&lt;/a&gt;常见的工作流&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&#34;/./assets/DevOps.png&#34; alt=&#34;DevOps&#34;&gt;&lt;/p&gt;
&lt;p&gt;该系统的各个组成部分是按如下顺序来发挥作用的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开发者检入代码到源代码仓库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CI系统会为每一个项目创建了一个单独的工作区。当预设或请求一次新的构建时，它将把源代码仓库的源码存放到对应的工作区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CI系统会在对应的工作区内执行构建过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置如果存在）构建完成后，CI系统会在一个新的构件中执行定义的一套测试。完成后触发通知(Email,RSS等等)给相关的当事人。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置如果存在）如果构建成功，这个构件会被打包并转移到一个部署目标(如应用服务器)或存储为软件仓库中的一个新版本。软件仓库可以是CI系统的一部分，也可以是一个外部的仓库，诸如一个文件服务器或者像Java.net、SourceForge之类的网站。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CI系统通常会根据请求发起相应的操作，诸如即时构建、生成报告，或者检索一些构建好的构件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;“You build it, you run it”，这是 Amazon 一年可以完成 5000 万次部署，平均每个工程师每天部署超过 50 次的核心秘籍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;解决的问题&#34;&gt;&lt;a href=&#34;#解决的问题&#34; class=&#34;headerlink&#34; title=&#34;解决的问题&#34;&gt;&lt;/a&gt;解决的问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;高效率&lt;/p&gt;
&lt;p&gt;高效率的发布，避免了重复性的劳动；&lt;/p&gt;
&lt;p&gt;更快的修复BUG，更快的交付成果，减少了等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;高质量&lt;/p&gt;
&lt;p&gt;只有在完成集成测试、系统测试后，才能得到可用的软件，整个过程中只有最后时刻才能拿到可运行软件。集成活动不一定在一个标准的构建机器上生成，而是在某个开发人员的机器上构建的，那么可能存在在其他机器上无法运行的问题。&lt;/p&gt;
&lt;p&gt;人与机器的一个最大的区别是，在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。所以，当我们搭建完成集成服务器后，以后的事就交给集成服务器来打理吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;高产出&lt;/p&gt;
&lt;p&gt;快速开发和上市一个新产品，并快速取得预期的投资回报是每个企业孜孜以求的目标。&lt;/p&gt;
&lt;p&gt;便捷的部署+项目的可预期，使得团队的开发变成了一种开心的事情。&lt;/p&gt;
&lt;p&gt;持续集成可以让你在任何时间发布可以部署的软件。在外界看来，这是持续集成最明显的好处，对客户来说，可以部署的软件产品是最实际的资产。利用持续集成，你可以经常对源代码进行一些小改动，并将这些改动和其他代码进行集成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常见问题&#34;&gt;&lt;a href=&#34;#常见问题&#34; class=&#34;headerlink&#34; title=&#34;常见问题&#34;&gt;&lt;/a&gt;常见问题&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;思维转变后，新技术抵触&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法接受新事物：不管怎么样，求稳心态的人还是多。总是有人认为老的技术代表稳定，新的事物往往会带来问题。&lt;/li&gt;
&lt;li&gt;认为手工集成也没有多少工作量：不是所有的人都参与到了整个持续集成的环节，所以没有办法认识到问题全貌。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;针对这个问题，可以通过设置一定的持续集成技术培训、宣讲得到改观&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;管理层的抵触&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;培训持续集成需要投入资金啊，没钱。&lt;/li&gt;
&lt;li&gt;持续集成服务器要增加软硬件成本啊，没钱。&lt;/li&gt;
&lt;li&gt;开发人员领了那么高的工资，多干活多加班应该啊。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;针对这一点，可以从开发人员的成本和持续集成的投入（软硬件）的成本上两者做下估算。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;硬件参考：&lt;/p&gt;
&lt;p&gt;Jenkins主服务器一般2C4G，slave服务器根据生产需要进行选购。&lt;/p&gt;
&lt;p&gt;git服务器一般2C4G(10人团队)&lt;/p&gt;
&lt;p&gt;Docker服务器8C32G(Rancher + harbor)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生产环境的复杂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如部署的生成环境是在政务外网，无法从互联网直接访问等。&lt;/li&gt;
&lt;li&gt;构建效率低下，任务多&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前，这个是最麻烦的，还在研究中。初步设想是让政务外网开辟一个白名单，给持续集成服务器设置一个单独的通道。只是思路，未验证。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;最佳实践&#34;&gt;&lt;a href=&#34;#最佳实践&#34; class=&#34;headerlink&#34; title=&#34;最佳实践&#34;&gt;&lt;/a&gt;最佳实践&lt;/h4&gt;&lt;p&gt;实施持续集成的开发人员可以尽早并经常提交。这允许他们尽早发现冲突。并且，如果存在任何问题，则使用较小的提交可以更轻松地对代码进行故障排除。每天或甚至更频繁地提交软件对于持续集成是必要的，但还不够。&lt;/p&gt;
&lt;p&gt;要成功使用持续集成，团队必须：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使测试成为开发过程中不可或缺的一部分。应该在创建代码时编写测试。&lt;/p&gt;
&lt;p&gt;公司成功持续整合所需的最重要因素是严格的测试文化。为了将新代码自信地集成到主线中，团队需要确信代码是健全的。这是通过测试来实现的，这应该定期进行。工程师应该在开发每个功能时编写测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;确保测试环境反映生产一致。&lt;/p&gt;
&lt;p&gt;为了支持您严格的测试文化，测试环境必须反映生产环境。否则，您无法保证您正在测试的内容将在生产中起作用。这意味着测试环境应使用相同版本的数据库，Web服务器配置，工件等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用编码最佳实践，例如结对编程。&lt;/p&gt;
&lt;p&gt;软件开发的另一个最佳实践是在编码期间进行配对。对于更复杂的功能，团队在编写单行代码之前讨论体系结构方法。在将任何代码合并到生产环境之前，其他开发人员始终会检查代码。这有助于确保使用编码最佳实践，代码不会与其他开发人员正在处理的现有代码或代码冲突，并且新功能是可扩展的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Pair programming&lt;/strong&gt; is an &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWdpbGVfc29mdHdhcmVfZGV2ZWxvcG1lbnQ=&#34;&gt;agile software development&lt;/span&gt; technique in which two &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcHV0ZXJfcHJvZ3JhbW1lcg==&#34;&gt;programmers&lt;/span&gt; work together at one workstation. One, the &lt;em&gt;driver&lt;/em&gt;, writes &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU291cmNlX2NvZGU=&#34;&gt;code&lt;/span&gt; while the other, the &lt;em&gt;observer&lt;/em&gt; or &lt;em&gt;navigator&lt;/em&gt;,[&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFpcl9wcm9ncmFtbWluZyNjaXRlX25vdGUtMQ==&#34;&gt;1]&lt;/span&gt; &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29kZV9yZXZpZXc=&#34;&gt;reviews&lt;/span&gt; each line of code as it is typed in. The two programmers switch roles frequently.&lt;/p&gt;
&lt;p&gt;While reviewing, the observer also considers the “strategic” direction of the work, coming up with ideas for improvements and likely future problems to address. This is intended to free the driver to focus all of their attention on the “tactical” aspects of completing the current task, using the observer as a safety net and guide.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动化部署工作流程。&lt;/p&gt;
&lt;p&gt;最后，为确保整个软件开发流程快速高效，构建需要快速，部署工作流程应自动化。代码构建的每一分钟都浪费了一分钟。通过自动化部署工作流程，团队可以更快地将完成的代码生成。因为，毕竟，如果没有接触到客户，那么快速开发软件有什么意义呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;效率工具对比&#34;&gt;&lt;a href=&#34;#效率工具对比&#34; class=&#34;headerlink&#34; title=&#34;效率工具对比&#34;&gt;&lt;/a&gt;效率工具对比&lt;/h3&gt;&lt;p&gt;![img](&amp;#x2F;Users&amp;#x2F;Shared&amp;#x2F;Target&amp;#x2F;5-4 持续集成与持续部署&amp;#x2F;resource&amp;#x2F;assets&amp;#x2F;CICD-resource.png)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#%E5%A4%8D%E6%9D%82%E7%9A%84DevOps%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7&#34;&gt;点击查看&lt;/a&gt;效率工具&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Jenkins&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Jenkins，原名Hudson，2011年改为现在的名字，它 是一个开源的实现持续集成的软件工具。官方网站：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2plbmtpbnMtY2kub3JnLw==&#34;&gt;http://jenkins-ci.org/&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Jenkins 能实时&lt;strong&gt;监控集成中存在的错误&lt;/strong&gt;，提供&lt;strong&gt;详细的日志文件和提醒&lt;/strong&gt;功能，还能用图表的形式形象地展示&lt;strong&gt;项目构建的趋势和稳定性&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Jenkins特点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;易安装&lt;/strong&gt;：Jenkins是一个独立的基于Java的程序，随时可以运行，包含Windows，Mac OS X和其他类Unix操作系统的软件包。仅仅一个 java -jar jenkins.war，从官网下载该文件后，直接运行，无需额外的安装，更无需安装数据库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易配置&lt;/strong&gt;：提供友好的GUI配置界面；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变更支持&lt;/strong&gt;：Jenkins能从代码仓库（Subversion&amp;#x2F;CVS）中获取并产生代码更新列表并输出到编译输出信息中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持永久链接&lt;/strong&gt;：用户是通过web来访问Jenkins的，而这些web页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成E-Mail&amp;#x2F;RSS&amp;#x2F;IM：&lt;/strong&gt;当完成一次集成时，可通过这些工具实时告诉你集成结果（据我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程中，干别的事情）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JUnit&amp;#x2F;TestNG测试报告&lt;/strong&gt;：也就是用以图表等形式提供详细的测试报表功能；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持分布式构建&lt;/strong&gt;：Jenkins可以把&lt;strong&gt;集成构建等工作分发到多台计算机中完成&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件指纹信息&lt;/strong&gt;：Jenkins会保存哪次集成构建产生了哪些jars文件，哪一次集成构建使用了哪个版本的jars文件等构建记录；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持第三方插件&lt;/strong&gt;：使得 Jenkins 变得越来越强大；凭借更新中心中的数百个插件，Jenkins几乎集成了持续集成和持续交付工具链中的所有工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rest API&lt;/strong&gt; - 可以访问控制您获取的数据量，获取&amp;#x2F;更新config.xml，删除作业，检索所有构建，获取&amp;#x2F;更新作业说明，执行构建，禁用&amp;#x2F;启用作业&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Jenkins优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;价格（免费）&lt;/li&gt;
&lt;li&gt;定制&lt;/li&gt;
&lt;li&gt;插件系统&lt;/li&gt;
&lt;li&gt;完全控制系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Jenkins缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要专用服务器（或多个服务器）。这导致额外的费用。对于服务器本身，DevOps等…&lt;/li&gt;
&lt;li&gt;配置&amp;#x2F;定制所需的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. Travis CI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Travis CI&lt;/strong&gt;是一个托管的持续集成服务，用于构建和测试在GitHub上托管的软件项目。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Travis CI&lt;/strong&gt; is a hosted continuous integration service used to build and test software projects hosted at GitHub&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Travis CI的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于云：TravisCI是一个&lt;strong&gt;基于云&lt;/strong&gt;的系统 - 不需要专用服务器，您无需管理它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持Docker运行测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用YAML文件进行配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可选择Linux和Mac OSX上同时运行测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开箱即用的支持的语言&lt;/p&gt;
&lt;p&gt;Android，C，C＃，C ++，Clojure，Crystal，D，Dart，Erlang，Elixir，F＃，Go，Groovy，Haskell，Haxe，Java，JavaScript（使用Node.js），Julia，Objective-C，Perl，Perl6， PHP，Python，R，Ruby，Rust，Scala，Smalltalk，Visual Basic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;支持多环境构建矩阵&lt;/strong&gt;：如Python 2.7 , 3.4, 3.5 +  Django 1.8, 1.9, 1.10&lt;/p&gt;
&lt;p&gt;构建矩阵是一种工具，可以使用不同版本的语言和包运行测试。您可以以不同的方式自定义它。例如，某些环境的失败可以触发通知但不会使所有构建失败（这对包的开发版本有帮助）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Travis CI优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开箱即用构建矩阵&lt;/li&gt;
&lt;li&gt;快速启动&lt;/li&gt;
&lt;li&gt;轻量级YAML配置&lt;/li&gt;
&lt;li&gt;开源项目的免费计划&lt;/li&gt;
&lt;li&gt;无需专用服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Travis CI缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与CircleCI相比，价格更高，没有免费的企业计划&lt;/li&gt;
&lt;li&gt;定制（对于某些你需要第三方的东西）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. Circle CI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在GitHub或Bitbucket上的软件存储库被授权并作为项目添加到&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jaXJjbGVjaS5jb20v&#34;&gt;circleci.com之后&lt;/span&gt;，每个代码更改都会在干净的容器或VM中触发自动化测试。&lt;/p&gt;
&lt;p&gt;CircleCI在2017年被Forrester评为持续集成领导者，并被命名为多个最佳DevOps工具列表。CircleCI成立于2011年，总部位于旧金山，拥有全球性的远程员工队伍，由Scale Venture Partners，DFJ，Baseline Ventures，Top Tier Capital，Industry Ventures，Heavybit和Harrison Metal Capital提供风险投资。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Circle CI的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;云&amp;amp;本地化&lt;/strong&gt;：CircleCI是一个&lt;strong&gt;基于云&lt;/strong&gt;的系统 - 不需要专用服务器，您无需管理它。 但是，它还&lt;strong&gt;提供了一个本地解决方案&lt;/strong&gt;，允许您在私有云或数据中心中运行它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;商业&amp;amp;免费&lt;/strong&gt;：即使是商业帐户，它也&lt;strong&gt;有免费计划&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rest API&lt;/strong&gt; - 您可以访问项目，构建和工件（artifacts）。构建的结果将是工件或工件组。 工件可以是已编译的应用程序或可执行文件（例如，android APK）或元数据（例如，关于测试&amp;#96;成功的信息）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按需安装&lt;/strong&gt;：CircleCI 缓存&lt;strong&gt;必要的安装&lt;/strong&gt;（requirements installation）。 它会检查第三方依赖项，而不是持续安装所需的环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH模式&lt;/strong&gt;：您可以触发&lt;strong&gt;SSH模式&lt;/strong&gt;访问容器并进行自己的调查（如果出现任何问题）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小化配置&lt;/strong&gt;：这是一个完整的开箱即用解决方案，需要&lt;strong&gt;最少的配置\调整&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CircleCI优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速启动&lt;/li&gt;
&lt;li&gt;CircleCI有一个免费的企业项目计划&lt;/li&gt;
&lt;li&gt;这很容易，也很快开始&lt;/li&gt;
&lt;li&gt;轻量级，易读的YAML配置&lt;/li&gt;
&lt;li&gt;您不需要任何专用服务器来运行CircleCI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CircleCI缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CircleCI仅支持2个版本的Ubuntu免费（12.04和14.04）和MacOS作为付费部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽管CircleCI可以使用并运行所有语言，但tt仅支持“开箱即用”的以下编程语言：Go（Golang），Haskell，Java，PHP，Python，Ruby &amp;#x2F; Rails，Scala&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果您想进行自定义，可能会出现一些问题：您可能需要一些第三方软件来进行这些调整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;此外，虽然作为基于云的系统是一方的优势，它也可以停止支持任何软件，你将无法阻止&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;Jenkins&lt;/th&gt;
&lt;th&gt;Travis CI&lt;/th&gt;
&lt;th&gt;Circle CI&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;本地部署&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REST API&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;配置&lt;/td&gt;
&lt;td&gt;复杂，高度可配置&lt;/td&gt;
&lt;td&gt;YAML文件&lt;/td&gt;
&lt;td&gt;YAML文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;按需安装&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跨平台支持&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Linux + MacOS&lt;/td&gt;
&lt;td&gt;Linux + MacOS(付费)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多服务器&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;按需&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;快速构建&lt;/td&gt;
&lt;td&gt;手动配置复杂&lt;/td&gt;
&lt;td&gt;快(需要写配置文件)&lt;/td&gt;
&lt;td&gt;最快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基本环境&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;云环境&lt;/td&gt;
&lt;td&gt;云环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;费用&lt;/td&gt;
&lt;td&gt;免费&lt;/td&gt;
&lt;td&gt;特定免费(69$&amp;#x2F;c)&lt;/td&gt;
&lt;td&gt;特定免费(50$&amp;#x2F;c)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Travis CI的价格（非常感人）：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190611100501785.png&#34; alt=&#34;/images/image-20190611100501785&#34;&gt;&lt;/p&gt;
&lt;p&gt;CirCle CI的价格：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190611100534676.png&#34; alt=&#34;/images/image-20190611100534676&#34;&gt;&lt;/p&gt;
&lt;p&gt;其他的一些持续集成的工具：CruiseControl，TeamCity，Continuum等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AnthillPro：商业的构建管理服务器，提供C功能&lt;/li&gt;
&lt;li&gt;Bamboo：商业的CI服务器，对于开源项目免费&lt;/li&gt;
&lt;li&gt;Build Forge：多功能商业构建管理工具，特点：高性能、分布式构建&lt;/li&gt;
&lt;li&gt;Cruise Control：基于java实现的持续集成构建工具&lt;/li&gt;
&lt;li&gt;CruiseControl.NET：基于C#实现的持续集成构建工具&lt;/li&gt;
&lt;li&gt;Lunt build：开源的自动化构建工具&lt;/li&gt;
&lt;li&gt;Para Build：商业的自动化软件构建管理服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Jenkins&#34;&gt;&lt;a href=&#34;#Jenkins&#34; class=&#34;headerlink&#34; title=&#34;Jenkins&#34;&gt;&lt;/a&gt;Jenkins&lt;/h2&gt;&lt;h3 id=&#34;使用简介&#34;&gt;&lt;a href=&#34;#使用简介&#34; class=&#34;headerlink&#34; title=&#34;使用简介&#34;&gt;&lt;/a&gt;使用简介&lt;/h3&gt;&lt;p&gt;Jenkins是开源CI&amp;amp;CD软件领导者， 提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190611103941326.png&#34; alt=&#34;/images/image-20190611103941326&#34;&gt;&lt;/p&gt;
&lt;p&gt;相关概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;流水线：&lt;strong&gt;Jenkins Pipeline&lt;/strong&gt;（或简称为 “Pipeline”）是一套插件，将持续交付的实现和实施集成到 Jenkins 中。&lt;/p&gt;
&lt;p&gt;Jenkins Pipeline 提供了一套可扩展的工具，用于将“简单到复杂”的交付流程实现为“持续交付即代码”。Jenkins Pipeline 的定义通常被写入到一个文本文件（称为 &lt;code&gt;Jenkinsfile&lt;/code&gt; ）中，该文件可以被放入项目的源代码控制库中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;节点：节点是一个机器，主要用于执行jenkins任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;阶段：定义不同的执行任务，比如：构建、测试、发布(部署)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;步骤：相当于告诉Jenkins现在要做些什么，比如shell命令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190611163108298.png&#34; alt=&#34;/images/image-20190611163108298&#34;&gt;&lt;/p&gt;
&lt;p&gt;Jenkins的界面&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190611163727975.png&#34; alt=&#34;/images/image-20190611163727975&#34;&gt;&lt;/p&gt;
&lt;p&gt;任务详情页面&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190611163855257.png&#34; alt=&#34;/images/image-20190611163855257&#34;&gt;&lt;/p&gt;
&lt;p&gt;Jenkins任务日志&lt;/p&gt;
&lt;h3 id=&#34;安装方式&#34;&gt;&lt;a href=&#34;#安装方式&#34; class=&#34;headerlink&#34; title=&#34;安装方式&#34;&gt;&lt;/a&gt;安装方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;环境要求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器要求：&lt;ul&gt;
&lt;li&gt;256 MB 内存，建议大于 512 MB&lt;/li&gt;
&lt;li&gt;10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要安装以下软件：&lt;ul&gt;
&lt;li&gt;Java 8 ( JRE 或者 JDK 都可以)&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=&#34;&gt;Docker&lt;/span&gt; （导航到网站顶部的Get Docker链接以访问适合您平台的Docker下载）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常规安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装JDK&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9qYXZhL2phdmFzZS9kb3dubG9hZHMvamRrOC1kb3dubG9hZHMtMjEzMzE1MS5odG1s&#34;&gt;官方地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下载对应的操作系统的JDK，然后解压进行安装。以Linux为例：&lt;/p&gt;
&lt;p&gt;下载最新版本，上传到Linux服务器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 上传到 /opt/jdk8目录下

# tar解压JDK安装包
mkdir -p /opt/jdk8
tar zxvf jdk-8u211-linux-x64.tar.gz -C /opt/jdk8 --strip-components 1

# vi /etc/profile
export JAVA_HOME=/opt/jdk8
export JRE_HOME=$&amp;#123;JAVA_HOME&amp;#125;/jre
export CLASSPATH=.:$&amp;#123;JAVA_HOME&amp;#125;/lib:$&amp;#123;JRE_HOME&amp;#125;/lib
export PATH=$&amp;#123;JAVA_HOME&amp;#125;/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Jenkins&lt;/p&gt;
&lt;p&gt;下载Jenkins最新的war包：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL21pcnJvcnMuamVua2lucy5pby93YXItc3RhYmxlL2xhdGVzdC9qZW5raW5zLndhcg==&#34;&gt;Latest&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mkdir -p /opt/jenkins &amp;amp;&amp;amp; cd /opt/jenkins

wget -O /opt/jenkins/jenkins.war http://mirrors.jenkins.io/war-stable/latest/jenkins.war

java -jar jenkins.war --httpPort=8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就嗯可以打开，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xvY2FsaG9zdDo4MDgw5LqG&#34;&gt;http://localhost:8080了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意一段这样的话：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;*************************************************************
*************************************************************
*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

63196690ae7d47c49506480ee0e1af4a

This may also be found at: /root/.jenkins/secrets/initialAdminPassword

*************************************************************
*************************************************************
*************************************************************
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;63196690ae7d47c49506480ee0e1af4a&lt;/code&gt;就是初始的安装的管理员密码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Docker安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装Docker&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# From https://get.docker.com:
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh

#From https://test.docker.com:
curl -fsSL https://test.docker.com -o test-docker.sh
sh test-docker.sh

# From the source repo (This will install latest from the test channel):
sh install.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置Docker镜像加速，使用阿里云&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20vP3NwbT1hMmM0ZS4xMTE1Mzk0MC5ibG9nY29udDI5OTQxLjkuNTIwMjdlMjl3Mmp2OVA=&#34;&gt;容器加速服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;左侧的加速器帮助页面就会显示为你独立分配的加速地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;例如：
公网Mirror：[系统分配前缀].mirror.aliyuncs.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用配置文件 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;（没有时新建该文件）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;&amp;#123;
    &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;&amp;lt;your accelerate address&amp;gt;&amp;quot;]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启Docker Daemon就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;systemctl daemon-reload
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker ps&lt;/code&gt; 查看容器运行状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker logs 容器ID/容器名称&lt;/code&gt; 查看管理员初始密码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Docker-compose.yml文件(可选)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装方法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;#下载
sudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
#安装
chmod +x /usr/local/bin/docker-compose
#查看版本
docker-compose --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Jenkins&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本选择：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jenkins: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2plbmtpbnMvamVua2lucy8=&#34;&gt;https://hub.docker.com/r/jenkins/jenkins/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Jenkins with Blue Ocean: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2plbmtpbnNjaS9ibHVlb2NlYW4=&#34;&gt;https://hub.docker.com/r/jenkinsci/blueocean&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blue Ocean 重新思考Jenkins的用户体验，从头开始设计&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9qZW5raW5zLmlvL3poL2RvYy9ib29rL3BpcGVsaW5lLw==&#34;&gt;Jenkins Pipeline&lt;/span&gt;, 但仍然与自由式作业兼容，Blue Ocean减少了混乱而且进一步明确了团队中每个成员 Blue Ocean 的主要特性包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持续交付(CD)Pipeline的 &lt;strong&gt;复杂可视化&lt;/strong&gt; ，可以让您快速直观地理解管道状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pipeline 编辑器&lt;/strong&gt; - 引导用户通过直观的、可视化的过程来创建Pipeline，从而使Pipeline的创建变得平易近人。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;个性化&lt;/strong&gt; 以适应团队中每个成员不同角色的需求。&lt;/li&gt;
&lt;li&gt;在需要干预和&amp;#x2F;或出现问题时 &lt;strong&gt;精确定位&lt;/strong&gt; 。 Blue Ocean 展示 Pipeline中需要关注的地方， 简化异常处理，提高生产力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地集成分支和合并请求&lt;/strong&gt;, 在与GitHub 和 Bitbucket中的其他人协作编码时实现最大程度的开发人员生产力。****&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;安装命令：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# Jenkins
docker run \
  -itd \
  -u root \
  -p 8080:8080 \
  -v jenkins-data:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v /usr/bin/docker:/usr/bin/docker \
  --name jenkins-master \
  jenkins/jenkins
  
# Jenkins blueocean
docker run \
  -itd \
  -u root \
  -p 8080:8080 \
  -v jenkins-data:/var/jenkins_home \ 
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v /usr/bin/docker:/usr/bin/docker \
  --name jenkins-master \
  jenkinsci/blueocean
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置Jenkins插件加速&lt;/p&gt;
&lt;p&gt;进入jenkins系统管理-&amp;gt;插件管理中-&amp;gt;高级选项卡-&amp;gt;升级站点，使用清华源：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/current/update-center.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/70.png&#34; alt=&#34;ç³»ç»ç®¡ç&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/70-20190611152837311.png&#34; alt=&#34;æä»¶ç®¡ç&#34;&gt;&lt;/p&gt;
&lt;p&gt;关于官方所有的镜像列表：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL21pcnJvcnMuamVua2lucy1jaS5vcmcvc3RhdHVzLmh0bWw=&#34;&gt;http://mirrors.jenkins-ci.org/status.html&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;环境配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jenkins 的URL路径&lt;/li&gt;
&lt;li&gt;全局工具的配置：Docker, JDK(JAVA)…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户权限配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;矩阵权限的配置&lt;/li&gt;
&lt;li&gt;添加管理员用户所有的权限&lt;/li&gt;
&lt;li&gt;添加&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93aWtpLmplbmtpbnMtY2kub3JnL2Rpc3BsYXkvSkVOS0lOUy9BdXRob3JpemUrUHJvamVjdCtwbHVnaW4=&#34;&gt;Authorize Project&lt;/span&gt;插件，并且在系统管理中进行配置。配置逻辑，就给用户当前项目的矩阵权限！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;与gitlab进行联接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置一个SSH Key，方便Jenkins去拉取Gitlab中的项目&lt;/li&gt;
&lt;li&gt;GItlab项目中去配置SSH Key的Deploy权限。&lt;code&gt;Settings -&amp;gt; Repository -&amp;gt; Deploy keys -&amp;gt; Public Deploy Keys&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Jenkins添加SSH的私钥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就完成了Jenkins可以访问gitlab的联接的过程。&lt;/p&gt;
&lt;p&gt;Jenkins层面，需要去安装Gitlab相关插件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;插件介绍&#34;&gt;&lt;a href=&#34;#插件介绍&#34; class=&#34;headerlink&#34; title=&#34;插件介绍&#34;&gt;&lt;/a&gt;插件介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Publish over SSH&lt;/p&gt;
&lt;p&gt;这个是一个远程Shell工具，可以远程去执行一些shell命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTP Request Plugin&lt;/p&gt;
&lt;p&gt;跨平台调用，在构建前后可以通过该插件以http形式调用各种api接口实现和内部系统的联动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Publish Over FTP&lt;/p&gt;
&lt;p&gt;用于远程使用FTP发布，比较合适于静态资源的发布。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/20181225153134962.jpeg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Performance Plugin&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​        该插件可以读取和解析测试框架输出的报告，并且在 Jenkins 上绘制性能和稳定性相关的图表。Performance Plugin 支持的测试框架有 JUnit、JMeter, Twitter 的 Lago 和 Taurus。下图是该插件输出的示例图：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/3dee2f58ccdf7cf25fa86074c5485184a9f.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;​        &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wbHVnaW5zLmplbmtpbnMuaW8vcGVyZm9ybWFuY2U=&#34;&gt;https://plugins.jenkins.io/performance&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gitlab Merge Request Builder Plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​        Gitlab Merge Request Builder Plugin 可以方便的自动发起代码审查，它在创建 pull request 的时候，会自动带上关联任务的运行结果，以方便代码审查着确认改动的正确性。&lt;/p&gt;
&lt;p&gt;​        同时，这款插件还支持自动合并，既在代码审查通过后自动合并该 pull request 内容。&lt;/p&gt;
&lt;p&gt;​        &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3RpbW9scy9qZW5raW5zLWdpdGxhYi1tZXJnZS1yZXF1ZXN0LWJ1aWxkZXItcGx1Z2lu&#34;&gt;https://github.com/timols/jenkins-gitlab-merge-request-builder-plugin&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JIRA Plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​        JIRA Plugin 可以让 Jenkins 任务和 JIRA 集成起来，这样项目管理者可以通过 JIRA 了解项目进度，开发者也可以通过该插件直接更改 JIRA 上的 issue 状态。&lt;/p&gt;
&lt;p&gt;​        &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wbHVnaW5zLmplbmtpbnMuaW8vamlyYQ==&#34;&gt;https://plugins.jenkins.io/jira&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes Plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​        和最近大热的容器编排框架 Kubernetes 集成当然不能落下了。另外，Jenkins 对执行机的管理一直比较弱，无法做到快速的扩容和缩容。Kubernetes Plugin 通过引入 Kubernetes 的容器编排能力，让 Jenkins 执行机运行在 Kubernetes 环境中。&lt;/p&gt;
&lt;p&gt;​        &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2plbmtpbnNjaS9rdWJlcm5ldGVzLXBsdWdpbg==&#34;&gt;https://github.com/jenkinsci/kubernetes-plugin&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build Pipeline plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​        对一个系统的持续集成会包含很多个方面，如果将它们都杂糅在一个 Jenkins 任务中，会提高排查成本，也不利于整个持续集成的运作。Build Pipeline plugin 可以让项目管理员针对系统持续集成步骤设置一系列关联的任务，任务之间可以设置不同的触发条件，以确认何时需要人工介入。该插件可以让整个持续集成流程变得非常直观：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://oscimg.oschina.net/oscnet/abf7ec185c847b72cd61181562f940557a2.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;​        &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2plbmtpbnNjaS9idWlsZC1waXBlbGluZS1wbHVnaW4=&#34;&gt;https://github.com/jenkinsci/build-pipeline-plugin&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置自动化任务&#34;&gt;&lt;a href=&#34;#配置自动化任务&#34; class=&#34;headerlink&#34; title=&#34;配置自动化任务&#34;&gt;&lt;/a&gt;配置自动化任务&lt;/h3&gt;&lt;p&gt;两种执行方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置自由风格的项目&lt;/li&gt;
&lt;li&gt;配置Pipeline使用Jenkinsfile&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的地方&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SSH插件：&lt;/p&gt;
&lt;p&gt;SSH&lt;/p&gt;
&lt;p&gt;SSH Agent&lt;/p&gt;
&lt;p&gt;SSH Pipeline Steps&lt;/p&gt;
&lt;p&gt;Publish Over SSH&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git相关插件：&lt;/p&gt;
&lt;p&gt;Gitlab&lt;/p&gt;
&lt;p&gt;Github&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;管理员界面配置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Settings -&amp;gt; network -&amp;gt; Outbound requests&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Allow requests to the local network from hooks and services 进行勾选&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他的一些用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Jenkins配合Docker Hub，把前端代码打包成镜像，再远程部署&lt;/li&gt;
&lt;li&gt;Jenkins配合自建Docker容器服务，把前端代码打包，使用Kubernetes进行发布。&lt;/li&gt;
&lt;li&gt;使用Docker进行远程发布(远程服务器上有Docker服务，并且设置了远程连接)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;TravisCI&#34;&gt;&lt;a href=&#34;#TravisCI&#34; class=&#34;headerlink&#34; title=&#34;TravisCI&#34;&gt;&lt;/a&gt;TravisCI&lt;/h2&gt;&lt;h3 id=&#34;使用简介-1&#34;&gt;&lt;a href=&#34;#使用简介-1&#34; class=&#34;headerlink&#34; title=&#34;使用简介&#34;&gt;&lt;/a&gt;使用简介&lt;/h3&gt;&lt;p&gt;Travis CI 只支持 Github，不支持其他代码托管服务。这意味着，你必须满足以下条件，才能使用 Travis CI。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;拥有 GitHub 帐号&lt;/li&gt;
&lt;li&gt;该帐号下面有一个项目&lt;/li&gt;
&lt;li&gt;该项目里面有可运行的代码&lt;/li&gt;
&lt;li&gt;该项目还包含构建或测试脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Travis简单的使用步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github授权及面板&lt;/li&gt;
&lt;li&gt;获取github的Tokens&lt;/li&gt;
&lt;li&gt;配置项目.travis.yml&lt;ul&gt;
&lt;li&gt;Node项目&lt;/li&gt;
&lt;li&gt;Script脚本&lt;/li&gt;
&lt;li&gt;部署到github pages&lt;/li&gt;
&lt;li&gt;钩子用法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;github授权及面板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，访问官方网站 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90cmF2aXMtY2kub3JnLw==&#34;&gt;travis-ci.org&lt;/span&gt;，点击右上角的个人头像，使用 Github 账户登入 Travis CI。&lt;/p&gt;
&lt;p&gt;会进入到授权页面，这里跟微博、QQ是一回事，主要是读取你的用户信息。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190612205411602.png&#34; alt=&#34;/images/image-20190612205411602&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里第二步在，&lt;code&gt;Dashboard&lt;/code&gt;这个选项卡中，点击&lt;code&gt;Activate&lt;/code&gt;这个按钮&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190612212459194.png&#34; alt=&#34;/images/image-20190612212459194&#34;&gt;&lt;/p&gt;
&lt;p&gt;完了之后，Dashboard会列出所有Github中有&lt;code&gt;.travis.yml&lt;/code&gt;配置文件的仓库：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190612212731186.png&#34; alt=&#34;/images/image-20190612212731186&#34;&gt;&lt;/p&gt;
&lt;p&gt;Travis 会列出 Github 上面你的所有仓库，以及你所属于的组织。此时，选择你需要 Travis 帮你构建的仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190612213022380.png&#34; alt=&#34;/images/image-20190612213022380&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Settings&lt;/code&gt;中用于配置项目的构建条件&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190612214434173.png&#34; alt=&#34;/images/image-20190612214434173&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Requests&lt;/code&gt;可以查看构建记录&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190612214519926.png&#34; alt=&#34;/images/image-20190612214519926&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Caches&lt;/code&gt;主要是缓存文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Trigger build&lt;/code&gt;手动触发构建&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;获取github的token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在settings-&amp;gt;Developer settings-&amp;gt;Personal access tokens-&amp;gt;Generate new token&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190612225000955.png&#34; alt=&#34;/images/image-20190612225000955&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置项目的.travis.yml文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置项目语言&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;language: node_js
node_js:
  - &amp;quot;10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Script脚本&lt;/p&gt;
&lt;p&gt;Travis 的运行流程很简单，任何项目都会经过两个阶段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;install 阶段：安装依赖&lt;/li&gt;
&lt;li&gt;script 阶段：运行脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;# S: Build Lifecycle
install:
  - yarn install

// 钩子方法
before_script:

# 无其他依赖项所以执行npm run build 构建就行了
script:
  - npm run build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不需要安装，即跳过安装阶段，就直接设为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;install: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;script&lt;/code&gt;字段用来指定构建或测试脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;script: bundle exec thor build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有多个脚本，可以写成下面的形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;script:
  - command1
  - command2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;部署到github pages&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;deploy:
    # 其他的一些配置项，可以参考：https://docs.travis-ci.com/user/deployment/pages/
  provider: pages
  skip_cleanup: true
  local_dir: dist/
  github_token: $GITHUB_TOKEN # Set in the settings page of your repository, as a secure variable
  keep_history: false
  on:
    branch: master
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;钩子用法&lt;/p&gt;
&lt;p&gt;Travis 为上面这些阶段提供了7个钩子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;before_install：install 阶段之前执行&lt;/li&gt;
&lt;li&gt;before_script：script 阶段之前执行&lt;/li&gt;
&lt;li&gt;after_failure：script 阶段失败时执行&lt;/li&gt;
&lt;li&gt;after_success：script 阶段成功时执行&lt;/li&gt;
&lt;li&gt;before_deploy：deploy 步骤之前执行&lt;/li&gt;
&lt;li&gt;after_deploy：deploy 步骤之后执行&lt;/li&gt;
&lt;li&gt;after_script：script 阶段之后执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的生命周期，从开始到结束是下面的流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;before_install&lt;/li&gt;
&lt;li&gt;install&lt;/li&gt;
&lt;li&gt;before_script&lt;/li&gt;
&lt;li&gt;script&lt;/li&gt;
&lt;li&gt;after&lt;em&gt;success or after&lt;/em&gt;failure&lt;/li&gt;
&lt;li&gt;[OPTIONAL] before_deploy&lt;/li&gt;
&lt;li&gt;[OPTIONAL] deploy&lt;/li&gt;
&lt;li&gt;[OPTIONAL] after_deploy&lt;/li&gt;
&lt;li&gt;after_script&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZG9tZW5pYy9lYzhiMGZjOGFiNDVmMzk0MDNkZA==&#34;&gt;Auto-deploying built products to gh-pages with Travis&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9vbmNsZXRvbS5pby8yMDE2L3RyYXZpcy1zc2gtZGVwbG95Lw==&#34;&gt;SSH deploys with Travis CI&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMTIvdHJhdmlzX2NpX3R1dG9yaWFsLmh0bWw=&#34;&gt;持续集成服务 Travis CI 教程&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置Node-js应用&#34;&gt;&lt;a href=&#34;#配置Node-js应用&#34; class=&#34;headerlink&#34; title=&#34;配置Node.js应用&#34;&gt;&lt;/a&gt;配置Node.js应用&lt;/h3&gt;&lt;p&gt;配置一个Vue实例并发布到github pages&lt;/p&gt;
&lt;p&gt;.travis.yml文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;language: node_js
node_js:
  - &amp;quot;10&amp;quot;

# Travis-CI Caching
cache:
  directories:
    - node_modules

# S: Build Lifecycle
install:
  - yarn install

before_script:

# 无其他依赖项所以执行npm run build 构建就行了
script:
  - npm run build

deploy:
    # 其他的一些配置项，可以参考：https://docs.travis-ci.com/user/deployment/pages/
  provider: pages
  skip_cleanup: true
  local_dir: dist/
  github_token: $GITHUB_TOKEN # Set in the settings page of your repository, as a secure variable
  keep_history: false
  on:
    branch: master
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;CircleCI&#34;&gt;&lt;a href=&#34;#CircleCI&#34; class=&#34;headerlink&#34; title=&#34;CircleCI&#34;&gt;&lt;/a&gt;CircleCI&lt;/h2&gt;&lt;h3 id=&#34;使用简介-2&#34;&gt;&lt;a href=&#34;#使用简介-2&#34; class=&#34;headerlink&#34; title=&#34;使用简介&#34;&gt;&lt;/a&gt;使用简介&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注册 CircleCI&lt;/p&gt;
&lt;p&gt;打开 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jaXJjbGVjaS5jb20v&#34;&gt;CircleCI&lt;/span&gt; 官方网站，使用您的GitHub帐户登录。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190613093550553.png&#34; alt=&#34;/images/image-20190613093550553&#34;&gt;&lt;/p&gt;
&lt;p&gt;进行授权：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190613093732415.png&#34; alt=&#34;/images/image-20190613093732415&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动存储库&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;检查要在 CircleCI 上管理的存储库的开关按钮。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190613094115350.png&#34; alt=&#34;/images/image-20190613094115350&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;p&gt;编写 config.yml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: 2
jobs:
  build:
    docker:
      ...
    branches:
      ...
    steps:
      ...
        environment:
            ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方参考文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jaXJjbGVjaS5jb20vZG9jcy8yLjAvY29uZmlndXJhdGlvbi1yZWZlcmVuY2UvI3ZlcnNpb24=&#34;&gt;https://circleci.com/docs/2.0/configuration-reference/#version&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来看一个完事版的配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: 2
jobs:
  build:
    docker:
      - image: ubuntu:14.04

      - image: mongo:2.6.8
        command: [mongod, --smallfiles]

      - image: postgres:9.4.1
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: root

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.5.4

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc &amp;#39;|&amp;#39; for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &amp;amp;&amp;amp;
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-&amp;#123;&amp;#123; checksum &#34;project.clj&#34; &amp;#125;&amp;#125;
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: &amp;quot;localhost&amp;quot;
            TEST_ENV: &amp;quot;linux&amp;quot;
          command: |
            set -xu
            mkdir -p $&amp;#123;TEST_REPORTS&amp;#125;
            run-tests.sh
            cp out/tests/*.xml $&amp;#123;TEST_REPORTS&amp;#125;

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh $&amp;#123;CIRCLE_BUILD_NUM&amp;#125;
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-&amp;#123;&amp;#123; checksum &#34;project.clj&#34; &amp;#125;&amp;#125;
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:14.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:14.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Master
          command: ansible-playbook site.yml -i production

workflows:
  version: 2
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置&amp;#x2F;查看任务&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190613093327981.png&#34; alt=&#34;/images/image-20190613093327981&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置Node-js应用-1&#34;&gt;&lt;a href=&#34;#配置Node-js应用-1&#34; class=&#34;headerlink&#34; title=&#34;配置Node.js应用&#34;&gt;&lt;/a&gt;配置Node.js应用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;.circleci/config.yml&lt;/code&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: 2
jobs:
  build:
    docker:
      - image: circleci/node:10
    branches:
      only:
        - master
    steps:
      - add_ssh_keys:
          fingerprints:
            - &amp;quot;c5:20:8e:79:81:19:fd:c1:6c:c4:fb:41:58:92:9d:4f&amp;quot;
      - checkout
      - restore_cache:
          keys:
            # fallback to using the latest cache if no exact match is found
            - dependencies-
      - run:
          name: Install
          command: yarn install
      - save_cache:
          paths:
            - node_modules
          key: dependencies-
      - run:
          name: build github pages
          command: yarn build
      - run:
          name: Prepare shell commands
          command: chmod +x scripts/deploy.sh
      - run:
          name: Run deploy scripts
          command: ./scripts/deploy.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里以发布到github page为示例：&lt;/p&gt;
&lt;p&gt;deploy.sh文件的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;#!/bin/sh
# ideas used from https://gist.github.com/motemen/8595451

# Based on https://github.com/eldarlabs/ghpages-deploy-script/blob/master/scripts/deploy-ghpages.sh
# Used with their MIT license https://github.com/eldarlabs/ghpages-deploy-script/blob/master/LICENSE

# abort the script if there is a non-zero error
set -e

# show where we are on the machine
pwd
remote=$(git config remote.origin.url)

echo &amp;#39;remote is: &amp;#39;$remote

# make a directory to put the gp-pages branch
mkdir gh-pages-branch
cd gh-pages-branch
# now lets setup a new repo so we can update the gh-pages branch
git config --global user.email &amp;quot;$GH_EMAIL&amp;quot; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
git config --global user.name &amp;quot;$GH_NAME&amp;quot; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
git init
git remote add --fetch origin &amp;quot;$remote&amp;quot;

echo &amp;#39;email is: &amp;#39;$GH_EMAIL
echo &amp;#39;name is: &amp;#39;$GH_NAME
echo &amp;#39;sitesource is: &amp;#39;$siteSource

# switch into the the gh-pages branch
if git rev-parse --verify origin/gh-pages &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
then
    git checkout gh-pages
    # delete any old site as we are going to replace it
    # Note: this explodes if there aren&amp;#39;t any, so moving it here for now
    git rm -rf .
else
    git checkout --orphan gh-pages
fi

# copy over or recompile the new site
cp -a &amp;quot;../$&amp;#123;siteSource&amp;#125;/.&amp;quot; .

ls -la

# stage any changes and new files
git add -A
# now commit, ignoring branch gh-pages doesn&amp;#39;t seem to work, so trying skip
git commit --allow-empty -m &amp;quot;Deploy to GitHub pages [ci skip]&amp;quot;
# and push, but send any output to /dev/null to hide anything sensitive
git push --force --quiet origin gh-pages
# go back to where we started and remove the gh-pages git repo we made and used
# for deployment
cd ..
rm -rf gh-pages-branch

echo &amp;quot;Finished Deployment!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;gt;&amp;#x2F;dev&amp;#x2F;null 2&amp;gt;&amp;amp;1的含义&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;文件描述符&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;默认情况&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;对应文件句柄位置&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;标准输入（standard input）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从键盘获得输入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;#x2F;proc&amp;#x2F;slef&amp;#x2F;fd&amp;#x2F;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;标准输出（standard output）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出到屏幕（即控制台）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;#x2F;proc&amp;#x2F;slef&amp;#x2F;fd&amp;#x2F;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;错误输出（error output）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出到屏幕（即控制台）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;#x2F;proc&amp;#x2F;slef&amp;#x2F;fd&amp;#x2F;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 代表重定向到哪里?&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;echo &amp;quot;123&amp;quot; &amp;gt; /home/123.txt&lt;/code&gt;&lt;br&gt;&lt;code&gt;1&lt;/code&gt; 表示&lt;code&gt;stdout&lt;/code&gt;标准输出，系统默认值是&lt;code&gt;1&lt;/code&gt;，所以&lt;code&gt;&amp;gt;/dev/null&lt;/code&gt;等同于&lt;code&gt;1&amp;gt;/dev/null&lt;/code&gt;&lt;br&gt;&lt;code&gt;2&lt;/code&gt; 表示&lt;code&gt;stderr&lt;/code&gt;标准错误&lt;br&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 表示等同于的意思，&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;，表示&lt;code&gt;2&lt;/code&gt;的输出重定向等同于&lt;code&gt;1&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGlueXdhbi9wLzYwMjU0NjguaHRtbA==&#34;&gt;Shell脚本———— &amp;#x2F;dev&amp;#x2F;null 2&amp;gt;&amp;amp;1详解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2t5ZWNoaW5hL2FydGljbGUvZGV0YWlscy81NDU4MjE0Ng==&#34;&gt;shell中&amp;gt;&amp;#x2F;dev&amp;#x2F;null 2&amp;gt;&amp;amp;1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0aG9tZXIvYXJ0aWNsZS9kZXRhaWxzLzkyODgzNTM=&#34;&gt;Linux Shell 1&amp;gt;&amp;#x2F;dev&amp;#x2F;null 2&amp;gt;&amp;amp;1 含义&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;扩展知识&#34;&gt;&lt;a href=&#34;#扩展知识&#34; class=&#34;headerlink&#34; title=&#34;扩展知识&#34;&gt;&lt;/a&gt;扩展知识&lt;/h2&gt;&lt;h3 id=&#34;自动化流程的发展趋势&#34;&gt;&lt;a href=&#34;#自动化流程的发展趋势&#34; class=&#34;headerlink&#34; title=&#34;自动化流程的发展趋势&#34;&gt;&lt;/a&gt;自动化流程的发展趋势&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;集中化&lt;/p&gt;
&lt;p&gt;以集群为基础，服务采用Saas方式进行交付。所有折构建、测试、发布全集中进行管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;微服务+无服务的应用模式&lt;/p&gt;
&lt;p&gt;应用程序执行环境的管理被新的编程模型和平台取代后，团队的交付生产率得到了进一步的提升。一方面它免去了很多环境管理的工作，包括设备、网络、主机以及对应的软件和配置工作，使得软件运行时环境更加稳定。另一方面，它大大降低了团队采用DevOps的技术门槛。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无服务器风格的架构（Serverless architecture）&lt;/strong&gt;把DevOps技术在微服务领域的应用推向极致。当应用程序执行环境的管理被新的编程模型和平台取代后，团队的交付生产率得到了进一步的提升。一方面它免去了很多环境管理的工作，包括设备、网络、主机以及对应的软件和配置工作，使得软件运行时环境更加稳定。另一方面，它大大降低了团队采用DevOps的技术门槛。&lt;/p&gt;
&lt;p&gt;在微服务端到端交付流程上，Netflix开源了自家的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5zcGlubmFrZXIuaW8v&#34;&gt;Spinnaker&lt;/span&gt;，Netflix作为微服务实践的先锋，不断推出新的开源工具来弥补社区中微服务技术和最佳实践的缺失。而&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3Byb2plY3RzLnNwcmluZy5pby9zcHJpbmctY2xvdWQv&#34;&gt;Spring Cloud&lt;/span&gt;则为开发者提供了一系列工具，以便他们在所熟悉的Spring技术栈下使用这些服务协调技术(coordination techniques)，如服务发现、负载均衡、熔断和健康检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;人工智能领域的应用&lt;/p&gt;
&lt;p&gt;DevOps的最早实践来自于互联网企业的Web应用，相应的思想被引入企业级应用并促进了一系列工具的发展。在人工智能领域，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcv&#34;&gt;TensorFlow&lt;/span&gt;就是这样一个例子，它可以有多种DevOps友好的安装和部署方式 ，例如采用Docker进行部署。&lt;/p&gt;
&lt;p&gt;随着Python在大数据、人工智能、区块链、微服务以及Docker中的发展，可以预见Python在日后的领域仍然会发挥重要的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安全推动DevOps的发展&lt;/p&gt;
&lt;p&gt;全是DevOps永远绕不开的话题，也往往是新技术在传统行业（例如金融和电信）应用中的最大阻碍。一方面，组织结构的转型迫使企业要打破原先的部门墙，这意味着很多原先的控制流程不再适用。另一方面，由于大量的DevOps技术来源于开源社区，缺乏强大技术实力的企业在应用相关技术时不免会有所担忧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Windows平台下.net的技术潜力巨大&lt;/p&gt;
&lt;p&gt;长期以来，Windows和.NET平台下的DevOps一直都是一个被低估的领域。一方面，社区缺乏对 Windows Server平台的兴趣。另一方面，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jb21tdW5pdHkuc3BpY2V3b3Jrcy5jb20vbmV0d29ya2luZy9hcnRpY2xlcy8yNDYyLXNlcnZlci12aXJ0dWFsaXphdGlvbi1hbmQtb3MtdHJlbmRz&#34;&gt;Windows Server却有接近90%的市场占用率&lt;/span&gt;，在Web服务器领域则有&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93M3RlY2hzLmNvbS90ZWNobm9sb2dpZXMvb3ZlcnZpZXcvb3BlcmF0aW5nX3N5c3RlbS9hbGw=&#34;&gt;33.5%的市场占有率&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非功能性自动化测试工具逐渐完善&lt;/p&gt;
&lt;p&gt;自动化测试水平往往是衡量DevOps技术能力高低的重要指标，尤其是针对生产环境应用程序的非功能性自动化测试工具。一直以来，技术雷达都在尝试从不同的角度宣扬自动化测试的重要性，从软件的开发阶段延展到了整个应用生命周期甚至整体IT资产的管理上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;复杂的DevOps相关工具&#34;&gt;&lt;a href=&#34;#复杂的DevOps相关工具&#34; class=&#34;headerlink&#34; title=&#34;复杂的DevOps相关工具&#34;&gt;&lt;/a&gt;复杂的DevOps相关工具&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/./assets/devops-hero-1-87966cfbc9c5713ae047551c7b22985c.png&#34; alt=&#34;DevOps&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;Jenkins的一些应用场景&#34;&gt;&lt;a href=&#34;#Jenkins的一些应用场景&#34; class=&#34;headerlink&#34; title=&#34;Jenkins的一些应用场景&#34;&gt;&lt;/a&gt;Jenkins的一些应用场景&lt;/h3&gt;&lt;p&gt;打包平台：&lt;/p&gt;
&lt;p&gt;使用Jenkins搭建iOS&amp;#x2F;Android&lt;/p&gt;
&lt;p&gt;测试平台：&lt;/p&gt;
&lt;p&gt;jenkins + python + selenium&lt;/p&gt;
&lt;p&gt;Jmeter+maven+Jenkins构建云性能测试平台&lt;/p&gt;
&lt;p&gt;Jenkins+PMD构建自动化静态代码检测&lt;/p&gt;
&lt;p&gt;使用jenkins+Emma统计&lt;/p&gt;
&lt;p&gt;客户端单元测试覆盖率&lt;/p&gt;
&lt;p&gt;Jenkins+Ant+Java+Junit+SVN执行junit单元测试&lt;/p&gt;
&lt;p&gt;jenkins+ant+jmeter搭建持续集成的接口测试平台&lt;/p&gt;
&lt;p&gt;自动部署：&lt;/p&gt;
&lt;p&gt;Jenkins+GitLab+蒲公英+FTP&lt;/p&gt;
&lt;p&gt;jenkins结合ansible用shell实现自动化部署和回滚&lt;/p&gt;
&lt;p&gt;持续集成：&lt;/p&gt;
&lt;p&gt;Tomcat+Sonar搭建持续集成环境&lt;/p&gt;
&lt;p&gt;Maven+Nexus+Jenkins+git&amp;#x2F;SVN&lt;/p&gt;
&lt;h3 id=&#34;Jenkins的Docker-compose-yml创建文件&#34;&gt;&lt;a href=&#34;#Jenkins的Docker-compose-yml创建文件&#34; class=&#34;headerlink&#34; title=&#34;Jenkins的Docker-compose.yml创建文件&#34;&gt;&lt;/a&gt;Jenkins的Docker-compose.yml创建文件&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;version: &amp;#39;3&amp;#39;
services:
  jenkins:
    container_name: &amp;#39;jenkins&amp;#39;
    image: jenkins/jenkins
    restart: always
    user: jenkins:&amp;lt;这里填Docker用户组的ID，见下面&amp;gt;
    ports:
    - &amp;quot;8080:8080&amp;quot;
    - &amp;quot;50000:50000&amp;quot;
    volumes:
    - /home/jenkins/data:/var/jenkins_home
    - /usr/bin/docker:/usr/bin/docker
    - /var/run/docker.sock:/var/run/docker.sock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的脚本使用注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建本地jenkins数据目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mkdir -p /home/jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看docker用户组的ID&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;cat /etc/group |grep docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行&lt;code&gt;docker-compose up -d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;gitlab的docker启动配置文件&#34;&gt;&lt;a href=&#34;#gitlab的docker启动配置文件&#34; class=&#34;headerlink&#34; title=&#34;gitlab的docker启动配置文件&#34;&gt;&lt;/a&gt;gitlab的docker启动配置文件&lt;/h3&gt;&lt;p&gt;项目地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NhbWVlcnNibi9kb2NrZXItZ2l0bGFi&#34;&gt;https://github.com/sameersbn/docker-gitlab&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: &amp;#39;2&amp;#39;

services:
  redis:
    restart: always
    image: sameersbn/redis:4.0.9-1
    command:
    - --loglevel warning
    volumes:
    - /srv/docker/gitlab/redis:/var/lib/redis:Z

  postgresql:
    restart: always
    image: sameersbn/postgresql:10
    volumes:
    - /srv/docker/gitlab/postgresql:/var/lib/postgresql:Z
    environment:
    - DB_USER=gitlab
    - DB_PASS=password
    - DB_NAME=gitlabhq_production
    - DB_EXTENSION=pg_trgm

  gitlab:
    restart: always
    image: sameersbn/gitlab:11.11.2
    depends_on:
    - redis
    - postgresql
    ports:
    - &amp;quot;10080:80&amp;quot;
    - &amp;quot;10022:22&amp;quot;
    volumes:
    - /srv/docker/gitlab/gitlab:/home/git/data:Z
    environment:
    - DEBUG=false

    - DB_ADAPTER=postgresql
    - DB_HOST=postgresql
    - DB_PORT=5432
    - DB_USER=gitlab
    - DB_PASS=password
    - DB_NAME=gitlabhq_production

    - REDIS_HOST=redis
    - REDIS_PORT=6379

    - TZ=Asia/Kolkata
    - GITLAB_TIMEZONE=Kolkata

    - GITLAB_HTTPS=false
    - SSL_SELF_SIGNED=false

    # 这里修改成服务器的IP或者域名
    - GITLAB_HOST=localhost
    - GITLAB_PORT=10080
    - GITLAB_SSH_PORT=10022
    - GITLAB_RELATIVE_URL_ROOT=
    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string
    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string
    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string

        # 这里给一个长度大于8的密码
    - GITLAB_ROOT_PASSWORD=12345678
    - GITLAB_ROOT_EMAIL=itheima@itcast.cn

    - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true
    - GITLAB_NOTIFY_PUSHER=false

    - GITLAB_EMAIL=notifications@example.com
    - GITLAB_EMAIL_REPLY_TO=noreply@example.com
    - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com

    - GITLAB_BACKUP_SCHEDULE=daily
    - GITLAB_BACKUP_TIME=01:00

    - SMTP_ENABLED=false
    - SMTP_DOMAIN=www.example.com
    - SMTP_HOST=smtp.gmail.com
    - SMTP_PORT=587
    - SMTP_USER=mailer@example.com
    - SMTP_PASS=password
    - SMTP_STARTTLS=true
    - SMTP_AUTHENTICATION=login

    - IMAP_ENABLED=false
    - IMAP_HOST=imap.gmail.com
    - IMAP_PORT=993
    - IMAP_USER=mailer@example.com
    - IMAP_PASS=password
    - IMAP_SSL=true
    - IMAP_STARTTLS=false

    - OAUTH_ENABLED=false
    - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER=
    - OAUTH_ALLOW_SSO=
    - OAUTH_BLOCK_AUTO_CREATED_USERS=true
    - OAUTH_AUTO_LINK_LDAP_USER=false
    - OAUTH_AUTO_LINK_SAML_USER=false
    - OAUTH_EXTERNAL_PROVIDERS=

    - OAUTH_CAS3_LABEL=cas3
    - OAUTH_CAS3_SERVER=
    - OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false
    - OAUTH_CAS3_LOGIN_URL=/cas/login
    - OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate
    - OAUTH_CAS3_LOGOUT_URL=/cas/logout

    - OAUTH_GOOGLE_API_KEY=
    - OAUTH_GOOGLE_APP_SECRET=
    - OAUTH_GOOGLE_RESTRICT_DOMAIN=

    - OAUTH_FACEBOOK_API_KEY=
    - OAUTH_FACEBOOK_APP_SECRET=

    - OAUTH_TWITTER_API_KEY=
    - OAUTH_TWITTER_APP_SECRET=

    - OAUTH_GITHUB_API_KEY=
    - OAUTH_GITHUB_APP_SECRET=
    - OAUTH_GITHUB_URL=
    - OAUTH_GITHUB_VERIFY_SSL=

    - OAUTH_GITLAB_API_KEY=
    - OAUTH_GITLAB_APP_SECRET=

    - OAUTH_BITBUCKET_API_KEY=
    - OAUTH_BITBUCKET_APP_SECRET=

    - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL=
    - OAUTH_SAML_IDP_CERT_FINGERPRINT=
    - OAUTH_SAML_IDP_SSO_TARGET_URL=
    - OAUTH_SAML_ISSUER=
    - OAUTH_SAML_LABEL=&amp;quot;Our SAML Provider&amp;quot;
    - OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient
    - OAUTH_SAML_GROUPS_ATTRIBUTE=
    - OAUTH_SAML_EXTERNAL_GROUPS=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_USERNAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME=

    - OAUTH_CROWD_SERVER_URL=
    - OAUTH_CROWD_APP_NAME=
    - OAUTH_CROWD_APP_PASSWORD=

    - OAUTH_AUTH0_CLIENT_ID=
    - OAUTH_AUTH0_CLIENT_SECRET=
    - OAUTH_AUTH0_DOMAIN=

    - OAUTH_AZURE_API_KEY=
    - OAUTH_AZURE_API_SECRET=
    - OAUTH_AZURE_TENANT_ID=
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/02/02/%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/</guid>
            <title>容器化运维操作</title>
            <link>https://dmqweb.cn/2024/02/02/%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/</link>
            <category term="容器化运维操作" scheme="https://dmqweb.cn/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/" />
            <category term="容器化运维操作" scheme="https://dmqweb.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/" />
            <pubDate>Fri, 02 Feb 2024 14:24:04 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;5-6-容器化运维操作&#34;&gt;&lt;a href=&#34;#5-6-容器化运维操作&#34; class=&#34;headerlink&#34; title=&#34;5-6 容器化运维操作&#34;&gt;&lt;/a&gt;5-6 容器化运维操作&lt;/h1&gt;&lt;p&gt;日趋复杂的运维开发环境，对虚拟服务器及应用服务的要求更加的多元化。我们需要更加容易扩展、性能优越、方便监控的管理服务，容器化应用、容器化运维应运而生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【知己知彼】你将在学习本课程中学习到：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理解&amp;#x2F;安装docker容器技术&lt;/li&gt;
&lt;li&gt;秒级快速部署mysql、nginx、tomcat等服务&lt;/li&gt;
&lt;li&gt;使用容器技术发布nodejs应用&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【工欲善其事，必先利其器】你需要准备的环境（三选一）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux环境(Centos 7以上&amp;#x2F;Debian 8以上&amp;#x2F;Ubuntu 16.04LTS以上版本)&lt;/li&gt;
&lt;li&gt;Windows 64位专业版&amp;#x2F;企业版&amp;#x2F;教育版(Build 15063以上)&lt;/li&gt;
&lt;li&gt;macOS Sierra 10.12以上的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果，你有了上面的环境，就可以很快速的跟着我们的内容快速学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;容器和Docker&#34;&gt;&lt;a href=&#34;#容器和Docker&#34; class=&#34;headerlink&#34; title=&#34;容器和Docker&#34;&gt;&lt;/a&gt;容器和Docker&lt;/h2&gt;&lt;h3 id=&#34;什么是容器化？&#34;&gt;&lt;a href=&#34;#什么是容器化？&#34; class=&#34;headerlink&#34; title=&#34;什么是容器化？&#34;&gt;&lt;/a&gt;什么是容器化？&lt;/h3&gt;&lt;p&gt;容器化是将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像的一种软件开发方法。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/docker-containerized-appliction-blue-border_2.png&#34; alt=&#34;docker-containerized-appliction-blue-border_2&#34;&gt;&lt;/p&gt;
&lt;p&gt;软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。&lt;/p&gt;
&lt;p&gt;容器化应用程序在容器主机上运行，而容器主机在 OS（Linux 或 Windows）上运行。因此，容器的占用比虚拟机 (VM) 映像小得多。&lt;/p&gt;
&lt;p&gt;容器化的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致的运行环境&lt;/li&gt;
&lt;li&gt;可伸缩性&lt;/li&gt;
&lt;li&gt;更方便的移植&lt;/li&gt;
&lt;li&gt;隔离性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;什么是Docker&#34;&gt;&lt;a href=&#34;#什么是Docker&#34; class=&#34;headerlink&#34; title=&#34;什么是Docker?&#34;&gt;&lt;/a&gt;什么是Docker?&lt;/h3&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL21vYnkvbW9ieQ==&#34;&gt;Docker&lt;/span&gt;是用GO语言开发的应用容器引擎，基于容器化，沙箱机制的应用部署技术。可适用于自动化测试、打包，持续集成和发布应用程序等场景，包括阿里云，亚马逊在内的云计算服务商都采用了docker来打造serverless服务平台。它不仅仅可以部署项目，还可以用于数据库搭建，nginx服务搭建，nodejs、php等编程语言环境搭建。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: docker现已改名为moby&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Docker中的三个&lt;strong&gt;重要概念&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;镜像(image)：分片的（只读）文件系统，由Dockerfile创建&lt;/p&gt;
&lt;p&gt;独立、易扩展、更效率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容器(container)：由Docker进程创建和管理的：文件系统 +  系统资源 + 网络配置 + 日志管理&lt;/p&gt;
&lt;p&gt;docker是docker镜像的运行环境，所以容器的概念就比较好理解了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;仓库(registry)：用来远端存储docker镜像&lt;/p&gt;
&lt;p&gt;版本控制、变更管理、为持续集成与快速部署提供便利&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Docker-vs-虚拟机&#34;&gt;&lt;a href=&#34;#Docker-vs-虚拟机&#34; class=&#34;headerlink&#34; title=&#34;Docker vs 虚拟机&#34;&gt;&lt;/a&gt;Docker vs 虚拟机&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/./assets/docker-containerized-and-vm-transparent-bg.png&#34; alt=&#34;docker-containerized-and-vm-transparent-bg&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器是应用层的抽象，它将代码和依赖关系打包在一起。 多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。 容器占用的空间比VM少（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要更少的VM和操作系统。&lt;/li&gt;
&lt;li&gt;虚拟机（VM）是物理硬件的抽象，将一台服务器转变为多台服务器。 管理程序允许多台VM在单台机器上运行。 每个VM都包含操作系统的完整副本，应用程序，必要的二进制文件和库 - 占用数十GB。 虚拟机也可能很慢启动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结一下：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;特性&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;容器&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;虚拟机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;启动&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;秒级&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分钟级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;硬盘使用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;一般为 &lt;code&gt;MB&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;一般为 &lt;code&gt;GB&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;性能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;接近原生&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;弱于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;系统支持量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;单机支持上千个容器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;一般几十个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;开发&amp;#x2F;环境定制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方便(命令行、面向对象式)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;进入虚拟机&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;相同点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件隔离&amp;#x2F;文件共享（沙箱）&lt;/li&gt;
&lt;li&gt;资源隔离&lt;/li&gt;
&lt;li&gt;网络隔离&lt;/li&gt;
&lt;li&gt;支持多种宿主环境（扩展）&lt;/li&gt;
&lt;li&gt;快照&amp;#x2F;镜像（版本控制&amp;#x2F;变更管理）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;不同点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同的资源管理&amp;#x2F;依赖&amp;#x2F;&amp;#x2F;释放（虚拟机占用更多的系统资源）&lt;/li&gt;
&lt;li&gt;不同的应用运行环境&lt;/li&gt;
&lt;li&gt;Docker是写时复制&lt;/li&gt;
&lt;li&gt;不同的日志方式(Docker收集日志，而虚拟机需要在虚拟系统里面看日志)&lt;/li&gt;
&lt;li&gt;不同的交互方式(Docker偏shell，虚拟机偏GUI)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;Docker的工作原理-重点&#34;&gt;&lt;a href=&#34;#Docker的工作原理-重点&#34; class=&#34;headerlink&#34; title=&#34;Docker的工作原理(重点)&#34;&gt;&lt;/a&gt;Docker的工作原理(重点)&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/./assets/work.png&#34; alt=&#34;work&#34;&gt;&lt;/p&gt;
&lt;p&gt;Docker是容器化部署技术，它主要作用在于通过运行容器来实现应用部署，而容器基于镜像运行。&lt;/p&gt;
&lt;p&gt;简单地说，就是将你的项目和依赖包(基础镜像)打成一个带有启动指令的项目镜像，然后在服务器创建一个容器，让镜像在容器内运行，从而实现项目的部署。&lt;/p&gt;
&lt;p&gt;服务器就是容器的宿主机，docker容器与宿主机之间是相互隔离的。&lt;/p&gt;
&lt;p&gt;Docker 的基础是Linux容器（LXC：Linux Containers）等技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般情况下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux(服务器) -&amp;gt; tomcat安装 -&amp;gt; Java依赖 -&amp;gt; maven依赖 -&amp;gt;放置在&amp;#x2F;usr&amp;#x2F;lib目录 -&amp;gt; 配置tomcat端口&amp;#x2F;目录 -&amp;gt; 运行tomcat中的startup.sh脚本 -&amp;gt; 配置网络、防火墙等(后续) -&amp;gt; 服务启动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用基于java的tomcat镜像 -&amp;gt; docker run -&amp;gt; 指定端口&amp;#x2F;挂载webapp目录 -&amp;gt; 服务启动&lt;/p&gt;
&lt;p&gt;这其中，发生了什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Docker会自己拉取镜像，若本地已经存在该镜像，则不用到网上去拉取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建新的容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分配文件系统并且挂着一个可读写的层，任何修改容器的操作都会被记录在这个读写层上，你可以保存这些修改成新的镜像，也可以选择不保存，那么下次运行改镜像的时候所有修改操作都会被消除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分配网络\桥接接口，创建一个允许容器与本地主机通信的网络接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置ip地址，从池中寻找一个可用的ip地址附加到容器上，换句话说，localhost并不能访问到容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行你指定的程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;捕获并且提供应用输出，包括输入、输出、报错信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Docker的价值：&lt;/p&gt;
&lt;p&gt;从应用架构角度：统一复杂的构建环境；&lt;/p&gt;
&lt;p&gt;从应用部署角度：解决依赖不同、构建麻烦的问题，结合自动化工具（如jenkins）提高效率。&lt;/p&gt;
&lt;p&gt;从集群管理角度：规范的服务&lt;strong&gt;调度&lt;/strong&gt;，&lt;strong&gt;服务发现&lt;/strong&gt;，&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;常见的应用场景介绍&#34;&gt;&lt;a href=&#34;#常见的应用场景介绍&#34; class=&#34;headerlink&#34; title=&#34;常见的应用场景介绍&#34;&gt;&lt;/a&gt;常见的应用场景介绍&lt;/h2&gt;&lt;p&gt;Docker提供了轻量级的虚拟化，相比于虚拟机，可以在同一台机器上创建更多数量的容器。它常见的应用场景：1. 快速部署；2. 隔离应用； 3. 提高开发效率； 4. 版本控制； 5. 简化配置，整合资源； &lt;/p&gt;
&lt;h3 id=&#34;快速部署&#34;&gt;&lt;a href=&#34;#快速部署&#34; class=&#34;headerlink&#34; title=&#34;快速部署&#34;&gt;&lt;/a&gt;快速部署&lt;/h3&gt;&lt;p&gt;我们尝试着来部署一个mysql：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -d --name mysql-test -e MYSQL_ROOT_PASSWORD=123456 mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/3.gif&#34; alt=&#34;3&#34;&gt;&lt;/p&gt;
&lt;p&gt;同样的道理，我们来部署一个nginx:&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/4.gif&#34; alt=&#34;4&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意：这里没有映射服务端口，所以在&lt;code&gt;80&lt;/code&gt;端口是看不到&lt;code&gt;index.html&lt;/code&gt;中的内容的。需要加入&lt;code&gt;-p&lt;/code&gt;参数来映射端口！！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -d --name web -p 8000:80 -v $&amp;#123;your_dir&amp;#125;:/usr/share/nginx/html nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;隔离应用&#34;&gt;&lt;a href=&#34;#隔离应用&#34; class=&#34;headerlink&#34; title=&#34;隔离应用&#34;&gt;&lt;/a&gt;隔离应用&lt;/h3&gt;&lt;p&gt;我们可以同时跑两个mysql，两个nginx，指定不同的端口进行映射：&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;mysql-test1&lt;/code&gt;映射到&lt;code&gt;8001&lt;/code&gt;端口，把&lt;code&gt;mysql-test2&lt;/code&gt;映射到&lt;code&gt;8002&lt;/code&gt;端口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -d --name mysql-test1 -p 8001:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
docker run -d --name mysql-test2 -p 8002:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把web1映射到8100端口，把web2映射到8200端口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -d --name web1 -p 8100:80 -v $&amp;#123;your_dir&amp;#125;:/usr/share/nginx/html nginx
docker run -d --name web2 -p 8200:80 -v $&amp;#123;your_dir&amp;#125;:/usr/share/nginx/html nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;提高开发效率&#34;&gt;&lt;a href=&#34;#提高开发效率&#34; class=&#34;headerlink&#34; title=&#34;提高开发效率&#34;&gt;&lt;/a&gt;提高开发效率&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一致的运行环境&lt;/p&gt;
&lt;p&gt;由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更快速的启动时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;   传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;p&gt;更高效的复用系统资源&lt;/p&gt;
&lt;p&gt;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;仓库&amp;#x2F;镜像机制&lt;/p&gt;
&lt;p&gt;使用仓库可以方便的在任何有docker进程的虚拟机&amp;#x2F;服务器&amp;#x2F;主机上运行docker应用，环境的统一，让它们的部署变的非常的简单。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;版本控制&#34;&gt;&lt;a href=&#34;#版本控制&#34; class=&#34;headerlink&#34; title=&#34;版本控制&#34;&gt;&lt;/a&gt;版本控制&lt;/h3&gt;&lt;p&gt;Docker容器还可以像git仓库一样，可以让你提交变更到Docker镜像中并通过不同的版本来管理它们，来看看下面的例子：&lt;/p&gt;
&lt;p&gt;我们之前创建了一个&lt;code&gt;mysql&lt;/code&gt;，现在，我们使用&lt;code&gt;commit&lt;/code&gt;命令就可以给它做一个快照，打上一个&lt;code&gt;tag&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/5.gif&#34; alt=&#34;5&#34;&gt;&lt;/p&gt;
&lt;p&gt;在后面的课程中，我们会详细的介绍&lt;a href=&#34;#Docker%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(%E9%87%8D%E7%82%B9)&#34;&gt;Docker的常见命令&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;DevOps流程&#34;&gt;&lt;a href=&#34;#DevOps流程&#34; class=&#34;headerlink&#34; title=&#34;DevOps流程&#34;&gt;&lt;/a&gt;DevOps流程&lt;/h3&gt;&lt;p&gt;对开发和运维（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvRGV2T3Bz&#34;&gt;DevOps&lt;/span&gt;）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。&lt;/p&gt;
&lt;p&gt;使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly95ZWFzeS5naXRib29rcy5pby9kb2NrZXJfcHJhY3RpY2UvaW1hZ2UvZG9ja2VyZmlsZQ==&#34;&gt;Dockerfile&lt;/span&gt; 来进行镜像构建，并结合 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udGludW91c19pbnRlZ3JhdGlvbg==&#34;&gt;持续集成(Continuous Integration)&lt;/span&gt; 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udGludW91c19kZWxpdmVyeQ==&#34;&gt;持续部署(Continuous Delivery&amp;#x2F;Deployment)&lt;/span&gt; 系统进行自动部署。&lt;/p&gt;
&lt;p&gt;而且使用 &lt;code&gt;Dockerfile&lt;/code&gt; 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。&lt;/p&gt;
&lt;h2 id=&#34;使用Docker&#34;&gt;&lt;a href=&#34;#使用Docker&#34; class=&#34;headerlink&#34; title=&#34;使用Docker&#34;&gt;&lt;/a&gt;使用Docker&lt;/h2&gt;&lt;h3 id=&#34;Docker如何进行安装&#34;&gt;&lt;a href=&#34;#Docker如何进行安装&#34; class=&#34;headerlink&#34; title=&#34;Docker如何进行安装&#34;&gt;&lt;/a&gt;Docker如何进行安装&lt;/h3&gt;&lt;h4 id=&#34;关于系统需求-重点&#34;&gt;&lt;a href=&#34;#关于系统需求-重点&#34; class=&#34;headerlink&#34; title=&#34;关于系统需求(重点)&#34;&gt;&lt;/a&gt;关于系统需求(重点)&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;平台类&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;操作系统&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;x86_64&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci1tYWMvaW5zdGFsbC8=&#34;&gt;Docker Desktop for Mac (macOS)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci13aW5kb3dzL2luc3RhbGwv&#34;&gt;Docker Desktop for Windows (Microsoft Windows 10)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;平台&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;x86_64 &amp;#x2F; amd64&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ARM&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ARM64 &amp;#x2F; AARCH64&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IBM Power (ppc64le)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IBM Z (s390x)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvY2VudG9zLw==&#34;&gt;CentOS&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/centos/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/centos/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvZGViaWFuLw==&#34;&gt;Debian&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/debian/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/debian/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/debian/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvZmVkb3JhLw==&#34;&gt;Fedora&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/fedora/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/fedora/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvdWJ1bnR1Lw==&#34;&gt;Ubuntu&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;&lt;img data-src=&#34;https://docs.docker.com/install/images/green-check.svg&#34; alt=&#34;yes&#34;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id=&#34;Linux-重点&#34;&gt;&lt;a href=&#34;#Linux-重点&#34; class=&#34;headerlink&#34; title=&#34;Linux(重点)&#34;&gt;&lt;/a&gt;Linux(重点)&lt;/h4&gt;&lt;p&gt;对于中国用户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于国外vps：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;脚本介绍：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9kb2NrZXItaW5zdGFsbA==&#34;&gt;https://github.com/docker/docker-install&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;Windows&#34;&gt;&lt;a href=&#34;#Windows&#34; class=&#34;headerlink&#34; title=&#34;Windows&#34;&gt;&lt;/a&gt;Windows&lt;/h4&gt;&lt;p&gt;安装Docker的系统需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统版本：Windows 10 64bit: Pro, Enterprise or Education (Build 15063 or later).&lt;/li&gt;
&lt;li&gt;在BIOS中开启了虚拟化（virtualization），正常情况下会默认开启，去系统管理中看看有没有Hyper-v被安装了。&lt;/li&gt;
&lt;li&gt;CPU特性：SLAT-capable.&lt;/li&gt;
&lt;li&gt;4GB以上的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果不满足上面的需求，则需要使用&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vdG9vbGJveC9vdmVydmlldy8=&#34;&gt;Docker Toolbox&lt;/span&gt;，相当于是运行了一个virtualbox的虚拟镜像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;MacOS&#34;&gt;&lt;a href=&#34;#MacOS&#34; class=&#34;headerlink&#34; title=&#34;MacOS&#34;&gt;&lt;/a&gt;MacOS&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;方法一官方&lt;code&gt;dmg&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方下载地址：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9lZGl0aW9ucy9jb21tdW5pdHkvZG9ja2VyLWNlLWRlc2t0b3AtbWFj&#34;&gt;Docker Descktop for Mac&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对系统的要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Requires Apple Mac OS Sierra 10.12 or above. Download &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vdG9vbGJveC9vdmVydmlldy8=&#34;&gt;Docker Toolbox&lt;/span&gt; for previous OS versions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要系统是 Mac OS Sierra 10.12以上即可。&lt;/p&gt;
&lt;p&gt;下载完&lt;code&gt;Docker.dmg&lt;/code&gt;安装包之后，双击即可以安装，可能需要系统管理员权限，输入密码即可。&lt;/p&gt;
&lt;p&gt;运行过后，小图标：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/2.gif&#34; alt=&#34;2&#34;&gt;&lt;/p&gt;
&lt;p&gt;安装完之后，在终端工具中，使用&lt;code&gt;docker version&lt;/code&gt;来查看Docker版本。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/docker-version.jpg&#34; alt=&#34;docker-version&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二brew cask：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;brew update 

brew cask install docker

# 删除的方法, 还需要手动删除Docker.app
brew cask uninstall docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令将会把Docker安装在&lt;code&gt;Applications&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h3 id=&#34;Docker国内加速&#34;&gt;&lt;a href=&#34;#Docker国内加速&#34; class=&#34;headerlink&#34; title=&#34;Docker国内加速&#34;&gt;&lt;/a&gt;Docker国内加速&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Docker的Toolbox镜像站(推荐)，主要是针对低版本的windows与mac用户：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS9kb2NrZXItdG9vbGJveC8=&#34;&gt;http://mirrors.aliyun.com/docker-toolbox/&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Docker镜像加速，主要是对&lt;code&gt;docker pull&lt;/code&gt;拉取镜像操作进行网络加速优化：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注册阿里云的账号，登录&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20v&#34;&gt;容器Hub服务&lt;/span&gt;，在左侧的加速器帮助页面就会显示为你独立分配的加速地址。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/image-20190524172015448.png&#34; alt=&#34;/images/image-20190524172015448&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;第一个Docker应用hello-world&#34;&gt;&lt;a href=&#34;#第一个Docker应用hello-world&#34; class=&#34;headerlink&#34; title=&#34;第一个Docker应用hello world&#34;&gt;&lt;/a&gt;第一个Docker应用hello world&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看docker版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行第一个Docker应用&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;docker run&lt;/code&gt;命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看容器运行状态&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;docker ps&lt;/code&gt;命令来查看正在运行的容器的状态，&lt;code&gt;-a&lt;/code&gt;参数来查看所有的已经运行的容器(无论是否停止)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/1.gif&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;Docker常见命令-重点&#34;&gt;&lt;a href=&#34;#Docker常见命令-重点&#34; class=&#34;headerlink&#34; title=&#34;Docker常见命令(重点)&#34;&gt;&lt;/a&gt;Docker常见命令(重点)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;**创建&lt;code&gt;run&lt;/code&gt;**，&lt;code&gt;-p&lt;/code&gt; 映射宿主机的端口给镜像服务使用，&lt;code&gt;-v&lt;/code&gt; 挂载宿主机的文件目录到镜像里面去，-it是提供交互式的终端工具，&lt;code&gt;-d&lt;/code&gt; 是让镜像容器在后台去持续运行,&lt;code&gt;--name&lt;/code&gt; 指定容器的名称，exec可以进入到容器里面去：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it &amp;lt;container_name&amp;gt; /bin/bash

docker exec -it &amp;lt;container_name&amp;gt; /bin/sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;启动&lt;code&gt;start&lt;/code&gt;&amp;#x2F;停止&lt;code&gt;stop&lt;/code&gt;&amp;#x2F;重启&lt;code&gt;restart&lt;/code&gt;&amp;#x2F;删除已停止容器&lt;code&gt;rm&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;登录仓库&lt;code&gt;login&lt;/code&gt;&amp;#x2F;拉取镜像&lt;code&gt;pull&lt;/code&gt;&amp;#x2F;推送&lt;code&gt;push&lt;/code&gt;&amp;#x2F;提交镜像&lt;code&gt;commit&lt;/code&gt;&amp;#x2F;给指定容器标签&lt;code&gt;tag&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker hub上去注册我们的账号，才能使用login&lt;/p&gt;
&lt;p&gt;使用docker commit来给运行中的容器打tag:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit &amp;lt;container_id&amp;gt; &amp;lt;namespace&amp;gt;/&amp;lt;image_name&amp;gt;:tag
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker commit e12b80defe8c itcast/mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;pull&lt;/code&gt;&amp;#x2F;&lt;code&gt;push&lt;/code&gt;命令来推送本地的镜像到远程仓库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull/push &amp;lt;namespace&amp;gt;/&amp;lt;image_name&amp;gt;:tag
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看所有本地镜像&lt;code&gt;images&lt;/code&gt;&amp;#x2F;删除本地镜像&lt;code&gt;rmi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除镜像之前，要停止&lt;code&gt;stop&lt;/code&gt;并且删除&lt;code&gt;rm&lt;/code&gt;运行中的容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看容器服务打印的日志&lt;code&gt;logs&lt;/code&gt;&amp;#x2F;检阅容器&lt;code&gt;inspect&lt;/code&gt;(更详细的容器信息，硬件&amp;#x2F;网络&amp;#x2F;版本等)&amp;#x2F;进入容器&lt;code&gt;exec&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看版本&lt;code&gt;version&lt;/code&gt;&amp;#x2F;docker进程信息&lt;code&gt;info&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看命令帮助：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;docker &amp;lt;run/pull&amp;gt; --help
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;扩展知识&#34;&gt;&lt;a href=&#34;#扩展知识&#34; class=&#34;headerlink&#34; title=&#34;扩展知识&#34;&gt;&lt;/a&gt;扩展知识&lt;/h2&gt;&lt;h3 id=&#34;制作Docker镜像-重点&#34;&gt;&lt;a href=&#34;#制作Docker镜像-重点&#34; class=&#34;headerlink&#34; title=&#34;制作Docker镜像(重点)&#34;&gt;&lt;/a&gt;制作Docker镜像(重点)&lt;/h3&gt;&lt;p&gt;Dockerfile 是一个由一堆命令+参数构成的脚本，使用 &lt;code&gt;docker build&lt;/code&gt; 即可执行脚本构建镜像，自动的去做一些事，主要用于进行持续集成。&lt;/p&gt;
&lt;p&gt;一般，Dockerfile 共包括四部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础镜像信息&lt;/li&gt;
&lt;li&gt;维护者信息&lt;/li&gt;
&lt;li&gt;镜像操作指令&lt;/li&gt;
&lt;li&gt;容器启动时执行指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当Node.js遇见Docker，下面介绍Docker在前端中的应用：&lt;/p&gt;
&lt;p&gt;一个简单的Koa应用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;const Koa = require(&amp;#39;koa&amp;#39;);
const app = new Koa();

// response
app.use(ctx =&amp;gt; &amp;#123;
  ctx.body = &amp;#39;Hello Koa!!&amp;#39;;
&amp;#125;);

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dockerfile示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;dockerfile&#34;&gt;FROM node:10

LABEL maintainer=itheima@itcast.cn

# 创建 app 目录
WORKDIR /app

# 把 package.json，package-lock.json(npm@5+) 或 yarn.lock 复制到工作目录(相对路径)
COPY [&amp;quot;package.json&amp;quot;,&amp;quot;*.lock&amp;quot;,&amp;quot;./&amp;quot;]

# 打包 app 源码
# 特别注意：要指定工作目录中的文件名
COPY src ./src

# 使用.dockerignore文件，上面两个COPY合并成一个
# COPY . .

# 使用Yarn安装 app 依赖
# 如果你需要构建生产环境下的代码，请使用：
# --prod参数
RUN yarn --prod --registry=https://registry.npm.taobao.org

# 对外暴露端口 -p 4000:3000
EXPOSE 3000

CMD [ &amp;quot;node&amp;quot;, &amp;quot;src/index.js&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;docker build&lt;/code&gt;打包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;docker build -t $&amp;#123;your_name&amp;#125;/$&amp;#123;image_name&amp;#125;:$&amp;#123;tag&amp;#125; .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;your_name&lt;/code&gt;代表的是远程仓库中的用户名，或者仓库地址; &lt;code&gt;image_name&lt;/code&gt;为镜像名称，&lt;code&gt;tag&lt;/code&gt;是给镜像打的标签，用于版本控制。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;docker build -t itheima/node-demo:1.0 .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包过程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ docker build -t itheima/node-demo:1.0 .
Sending build context to Docker daemon  17.92kB
Step 1/8 : FROM node:10
 ---&amp;gt; 5a401340b79f
Step 2/8 : LABEL maintainer=itheima@itcast.cn
 ---&amp;gt; Using cache
 ---&amp;gt; dd01419f30d5
Step 3/8 : WORKDIR /app
 ---&amp;gt; Using cache
 ---&amp;gt; bb9a44851ec9
Step 4/8 : COPY . .
 ---&amp;gt; Using cache
 ---&amp;gt; b08ff37c5456
Step 5/8 : RUN ls -la /app
 ---&amp;gt; Using cache
 ---&amp;gt; 4e0e57e807a1
Step 6/8 : RUN yarn --prod --registry=https://registry.npm.taobao.org
 ---&amp;gt; Using cache
 ---&amp;gt; 96ab842b4766
Step 7/8 : EXPOSE 3000
 ---&amp;gt; Using cache
 ---&amp;gt; 505dda4e680f
Step 8/8 : CMD [ &amp;quot;node&amp;quot;, &amp;quot;src/index.js&amp;quot; ]
 ---&amp;gt; Using cache
 ---&amp;gt; f60e25a577de
Successfully built f60e25a577de
Successfully tagged itheima/node-demo:1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;回顾前面的知识：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何使用？&lt;/p&gt;
&lt;p&gt;还记得&lt;code&gt;docker run&lt;/code&gt;命令吗？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -d --name nodedemo -p 3000:3000 itheima/node-demo:1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;docker ps&lt;/code&gt;来看运行状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ docker run -d --name nodedemo -p 3000:3000 itheima/node-demo:1.0
c863da9afea1558593843233aec08989184d8dafbb0f8443830d1e523104ab00
$ docker ps
CONTAINER ID        IMAGE                   COMMAND               CREATED             STATUS              PORTS                    NAMES
c863da9afea1        itheima/node-demo:1.0   &amp;quot;node src/index.js&amp;quot;   2 seconds ago       Up 1 second         0.0.0.0:3000-&amp;gt;3000/tcp   nodedemo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Docker-compose介绍&#34;&gt;&lt;a href=&#34;#Docker-compose介绍&#34; class=&#34;headerlink&#34; title=&#34;Docker-compose介绍&#34;&gt;&lt;/a&gt;Docker-compose介绍&lt;/h3&gt;&lt;p&gt;通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/docker-compose.png&#34; alt=&#34;docker-compose&#34;&gt;&lt;/p&gt;
&lt;p&gt;Compose 中有两个重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务 (service) ：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。&lt;/li&gt;
&lt;li&gt;项目 (project) ：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker Compose 是 Docker 的独立产品，因此需要安装 Docker 之后在单独安装 Docker Compose .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装方法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;#下载
sudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
#安装
chmod +x /usr/local/bin/docker-compose
#查看版本
docker-compose --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;常见使用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面的例子，使用&lt;code&gt;docker-compose&lt;/code&gt;改写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: &amp;#39;3&amp;#39;
services:
  mysql:
    image: mysql
    container_name: test-mysql
    ports:
    - &amp;quot;8000:3306&amp;quot;
    environment:
    - MYSQL_ROOT_PASSWORD=123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在此文件的当前目录下，使用&lt;code&gt;docker-compose up -d&lt;/code&gt;来执行。&lt;/p&gt;
&lt;p&gt;生命周期管理：&lt;/p&gt;
&lt;p&gt;创建：&lt;code&gt;run&lt;/code&gt;&amp;#x2F;&lt;code&gt;up&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动&amp;#x2F;停止&amp;#x2F;删除&amp;#x2F;重启：&lt;code&gt;start/stop/rm/restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;检视&amp;#x2F;日志：&lt;code&gt;logs&lt;/code&gt;&amp;#x2F;&lt;code&gt;ps&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看两个个复杂的应用：&lt;/p&gt;
&lt;p&gt;搭建本地mongo + mongo-express服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: &amp;#39;3.1&amp;#39;
services:
  mongo:
    image: mongo
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: 123456

  mongo-express:
    image: mongo-express
    restart: always
    ports:
      - 8081:8081
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: root
      ME_CONFIG_MONGODB_ADMINPASSWORD: 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给公司搭建一个git服务器吧？！&lt;/p&gt;
&lt;p&gt;项目地址: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NhbWVlcnNibi9kb2NrZXItZ2l0bGFi&#34;&gt;https://github.com/sameersbn/docker-gitlab&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;推荐服务器配置：适用于10人的小团队~~~~&lt;/p&gt;
&lt;p&gt;2core&lt;/p&gt;
&lt;p&gt;2GB+2GB(swap) &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: &amp;#39;2&amp;#39;

services:
  redis:
    restart: always
    image: sameersbn/redis:4.0.9-1
    command:
    - --loglevel warning
    volumes:
    - /srv/docker/gitlab/redis:/var/lib/redis:Z

  postgresql:
    restart: always
    image: sameersbn/postgresql:10
    volumes:
    - /srv/docker/gitlab/postgresql:/var/lib/postgresql:Z
    environment:
    - DB_USER=gitlab
    - DB_PASS=password
    - DB_NAME=gitlabhq_production
    - DB_EXTENSION=pg_trgm

  gitlab:
    restart: always
    image: sameersbn/gitlab:11.11.0
    depends_on:
    - redis
    - postgresql
    ports:
    - &amp;quot;10080:80&amp;quot;
    - &amp;quot;10022:22&amp;quot;
    volumes:
    - /srv/docker/gitlab/gitlab:/home/git/data:Z
    environment:
    - DEBUG=false

    - DB_ADAPTER=postgresql
    - DB_HOST=postgresql
    - DB_PORT=5432
    - DB_USER=gitlab
    - DB_PASS=password
    - DB_NAME=gitlabhq_production

    - REDIS_HOST=redis
    - REDIS_PORT=6379

    - TZ=Asia/Kolkata
    - GITLAB_TIMEZONE=Kolkata

    - GITLAB_HTTPS=false
    - SSL_SELF_SIGNED=false

    - GITLAB_HOST=localhost
    - GITLAB_PORT=10080
    - GITLAB_SSH_PORT=10022
    - GITLAB_RELATIVE_URL_ROOT=
    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string
    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string
    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string

    - GITLAB_ROOT_PASSWORD=123456
    - GITLAB_ROOT_EMAIL=itheima@itcast.cn
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker-compose在前端里面的使用：&lt;/p&gt;
&lt;p&gt;Nodejs + mongodb + koa + vue的应用组合：&lt;/p&gt;
&lt;p&gt;特别注意：&lt;/p&gt;
&lt;p&gt;视频中，我们使用vue是在局部安装的，所以使用npx命令在进行创建。&lt;/p&gt;
&lt;p&gt;vue官网推荐大家进行全局安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm i -g @vue/cli

# 然后使用
vue create myproject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; docker-compose.yml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;yaml&#34;&gt;version: &amp;#39;3&amp;#39;
services:
  web:
    image: web:1.0
    ports:
    - &amp;quot;8080:80&amp;quot;

  server:
    image: server:1.0
    ports:
    - &amp;quot;3000:3000&amp;quot;
    depends_on:
    - mongodb
    links:
    - mongodb:db

  mongodb:
    image: mongo
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;depends_on&lt;/code&gt; 决定了容器加载的先后顺序，这里&lt;code&gt;mongdb&lt;/code&gt;、&lt;code&gt;web&lt;/code&gt;先加载，&lt;code&gt;mongdb&lt;/code&gt;创建完成之后，再来创建&lt;code&gt;server&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;自学补充知识&#34;&gt;&lt;a href=&#34;#自学补充知识&#34; class=&#34;headerlink&#34; title=&#34;自学补充知识&#34;&gt;&lt;/a&gt;自学补充知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;什么是Kubernetes?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Kubernetes, 中文意思是舵手或导航员，它是一个容器集群管理系统，主要职责是容器编排（Container Orchestration）——启动容器，自动化部署、扩展和管理容器应用，还有回收容器。&lt;/p&gt;
&lt;p&gt;文档: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLw==&#34;&gt;https://kubernetes.io/zh/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;集群相关：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL21lc29zLmFwYWNoZS5vcmcv&#34;&gt;Mesos&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9zd2FybQ==&#34;&gt;Docker Swarm&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;简单的DevOps流程介绍：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/devOps-8692746.jpeg&#34; alt=&#34;devOps&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDcwNDY1&#34;&gt;从一张图看Devops全流程&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Docker中的文件系统，深入理解原理：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/./assets/%E4%B8%80%E5%9B%BE%E7%9C%8B%E5%B0%BDDocker%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png&#34; alt=&#34;一图看尽Docker容器文件系统&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;p&gt;Docker的一般开发流程介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寻找基础镜像&lt;/li&gt;
&lt;li&gt;基于基础镜像编写Dockerfile脚本&lt;/li&gt;
&lt;li&gt;根据Dockerfile脚本创建项目镜像&lt;/li&gt;
&lt;li&gt;将创建的镜像推送到docker仓库 (根据自身需要，可做可不做)&lt;/li&gt;
&lt;li&gt;基于项目镜像创建并运行docker容器 (实现最终部署)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里面如果一扩展，就变成了自动化开发流程，比如：加入版本控制git -&amp;gt; 使用webhook -&amp;gt; jenkins自动打包  -&amp;gt; docker自动构建 -&amp;gt; 推送镜像 -&amp;gt; 生产环境部署&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;课程资源&#34;&gt;&lt;a href=&#34;#课程资源&#34; class=&#34;headerlink&#34; title=&#34;课程资源&#34;&gt;&lt;/a&gt;课程资源&lt;/h2&gt;&lt;p&gt;Docker for Mac【系统：10.12以上】: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL21hYy9zdGFibGUvRG9ja2VyLmRtZw==&#34;&gt;https://download.docker.com/mac/stable/Docker.dmg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Docker for Windows【系统：专业版及企业版】: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL3dpbi9zdGFibGUvRG9ja2VyJTIwZm9yJTIwV2luZG93cyUyMEluc3RhbGxlci5leGU=&#34;&gt;https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Docker ToolBox for Mac【系统：10.10.3以上】: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL21hYy9zdGFibGUvRG9ja2VyVG9vbGJveC5wa2c=&#34;&gt;https://download.docker.com/mac/stable/DockerToolbox.pkg&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;Docker ToolBox for Windows【系统：windows7以上】：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL3dpbi9zdGFibGUvRG9ja2VyVG9vbGJveC5leGU=&#34;&gt;https://download.docker.com/win/stable/DockerToolbox.exe&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://dmqweb.cn/2024/02/02/%E4%BD%BF%E7%94%A8Jenkins%E9%85%8D%E5%90%88github%20hook%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</guid>
            <title>jenkins配合git hook持续集成</title>
            <link>https://dmqweb.cn/2024/02/02/%E4%BD%BF%E7%94%A8Jenkins%E9%85%8D%E5%90%88github%20hook%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</link>
            <category term="jenkins配合git hook持续集成" scheme="https://dmqweb.cn/categories/jenkins%E9%85%8D%E5%90%88git-hook%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/" />
            <category term="jenkins" scheme="https://dmqweb.cn/tags/jenkins/" />
            <category term="github hook" scheme="https://dmqweb.cn/tags/github-hook/" />
            <pubDate>Fri, 02 Feb 2024 14:04:04 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;环境&#34;&gt;&lt;a href=&#34;#环境&#34; class=&#34;headerlink&#34; title=&#34;环境&#34;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Centos 7.4&lt;/li&gt;
&lt;li&gt;JDK 1.8&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;主要步骤&#34;&gt;&lt;a href=&#34;#主要步骤&#34; class=&#34;headerlink&#34; title=&#34;主要步骤&#34;&gt;&lt;/a&gt;主要步骤&lt;/h2&gt;&lt;p&gt;以下包含相关所有的步骤，可根据现有环境进行跳过&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装JDK&lt;/li&gt;
&lt;li&gt;安装Centos&lt;/li&gt;
&lt;li&gt;Jenkins和Github配置&lt;/li&gt;
&lt;li&gt;配置任务&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;安装JDK&#34;&gt;&lt;a href=&#34;#安装JDK&#34; class=&#34;headerlink&#34; title=&#34;安装JDK&#34;&gt;&lt;/a&gt;安装JDK&lt;/h3&gt;&lt;p&gt;Jenkins需要JDK才可以运行，我们首先安装JDK&lt;/p&gt;
&lt;h4 id=&#34;下载&#34;&gt;&lt;a href=&#34;#下载&#34; class=&#34;headerlink&#34; title=&#34;下载&#34;&gt;&lt;/a&gt;下载&lt;/h4&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5vcmFjbGUuY29tL3RlY2huZXR3b3JrL2phdmEvamF2YXNlL2Rvd25sb2Fkcy9qZGs4LWRvd25sb2Fkcy0yMTMzMTUxLmh0bWw=&#34;&gt;下载链接查看地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先点击Accept License Agreement，选择Linux对应版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;若想要直接获取下载链接，使用wget进行下载是不行的，我们可以先点击链接进行下载，然后在chrome中的下载任务中查看下载链接进行复制。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /usr/local/src
wget `your download url`
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;解压&#34;&gt;&lt;a href=&#34;#解压&#34; class=&#34;headerlink&#34; title=&#34;解压&#34;&gt;&lt;/a&gt;解压&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;tar -zxvf jdk-8u91-linux-x64.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;环境变量&#34;&gt;&lt;a href=&#34;#环境变量&#34; class=&#34;headerlink&#34; title=&#34;环境变量&#34;&gt;&lt;/a&gt;环境变量&lt;/h4&gt;&lt;p&gt;将以下内容追加到 &amp;#x2F;etc&amp;#x2F;profile末尾,替换你对应的解压路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JAVA_HOME=/usr/local/tools/jdk1.8.0_144

JRE_HOME=$JAVA_HOME/jre

PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin

CLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jar

export JAVA_HOME JRE_HOME PATH CLASSPATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;启用配置&#34;&gt;&lt;a href=&#34;#启用配置&#34; class=&#34;headerlink&#34; title=&#34;启用配置&#34;&gt;&lt;/a&gt;启用配置&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;查看版本&#34;&gt;&lt;a href=&#34;#查看版本&#34; class=&#34;headerlink&#34; title=&#34;查看版本&#34;&gt;&lt;/a&gt;查看版本&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;java -version
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装Centos&#34;&gt;&lt;a href=&#34;#安装Centos&#34; class=&#34;headerlink&#34; title=&#34;安装Centos&#34;&gt;&lt;/a&gt;安装Centos&lt;/h3&gt;&lt;p&gt;使用yum进行安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#安装自动选择最快源的插件
$ yum install yum-fastestmirror -y
#添加Jenkins源:
$ sudo wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo
$ sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key
 #安装jenkins
$ yum install jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;启动&#34;&gt;&lt;a href=&#34;#启动&#34; class=&#34;headerlink&#34; title=&#34;启动&#34;&gt;&lt;/a&gt;启动&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;service jenkins start
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;更改端口&#34;&gt;&lt;a href=&#34;#更改端口&#34; class=&#34;headerlink&#34; title=&#34;更改端口&#34;&gt;&lt;/a&gt;更改端口&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;vim /etc/sysconfig/jenkins
service jenkins restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Jenkins和Github配置&#34;&gt;&lt;a href=&#34;#Jenkins和Github配置&#34; class=&#34;headerlink&#34; title=&#34;Jenkins和Github配置&#34;&gt;&lt;/a&gt;Jenkins和Github配置&lt;/h3&gt;&lt;p&gt;这里的配置就比较多了，主要是在github上生成key,然后在Jenkins与项目进行绑定即可&lt;/p&gt;
&lt;h4 id=&#34;初始化Jenkins&#34;&gt;&lt;a href=&#34;#初始化Jenkins&#34; class=&#34;headerlink&#34; title=&#34;初始化Jenkins&#34;&gt;&lt;/a&gt;初始化Jenkins&lt;/h4&gt;&lt;p&gt;这几步非常简单，按照提示进行即可&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问你的IP:8080&lt;/li&gt;
&lt;li&gt;cat &amp;#x2F;var&amp;#x2F;lib&amp;#x2F;jenkins&amp;#x2F;secrets&amp;#x2F;initialAdminPassword 把密码输入进去&lt;/li&gt;
&lt;li&gt;Install suggested plugins进行安装&lt;/li&gt;
&lt;li&gt;设置账户密码&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置Github-webhooks&#34;&gt;&lt;a href=&#34;#配置Github-webhooks&#34; class=&#34;headerlink&#34; title=&#34;配置Github webhooks&#34;&gt;&lt;/a&gt;配置Github webhooks&lt;/h3&gt;&lt;h4 id=&#34;在对项目有写权限的用户上获取token&#34;&gt;&lt;a href=&#34;#在对项目有写权限的用户上获取token&#34; class=&#34;headerlink&#34; title=&#34;在对项目有写权限的用户上获取token&#34;&gt;&lt;/a&gt;在对项目有写权限的用户上获取token&lt;/h4&gt;&lt;p&gt;进入github –&amp;gt; setting –&amp;gt; Personal Access Token –&amp;gt; Generate new token&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://callmedadaxin.github.io/images/jenkins-1.png&#34;&gt;&lt;img data-src=&#34;http://callmedadaxin.github.io/images/jenkins-1.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击保存，获取token,并&lt;strong&gt;保存好你的token&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;设置webhooks&#34;&gt;&lt;a href=&#34;#设置webhooks&#34; class=&#34;headerlink&#34; title=&#34;设置webhooks&#34;&gt;&lt;/a&gt;设置webhooks&lt;/h4&gt;&lt;p&gt;进入GitHub上指定的项目 –&amp;gt; setting –&amp;gt; WebHooks&amp;amp;Services –&amp;gt; add webhook –&amp;gt; 输入刚刚部署jenkins的服务器的IP&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://callmedadaxin.github.io/images/jenkins-2.png&#34;&gt;&lt;img data-src=&#34;http://callmedadaxin.github.io/images/jenkins-2.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置Jenkins的Git-Plugin&#34;&gt;&lt;a href=&#34;#配置Jenkins的Git-Plugin&#34; class=&#34;headerlink&#34; title=&#34;配置Jenkins的Git Plugin&#34;&gt;&lt;/a&gt;配置Jenkins的Git Plugin&lt;/h3&gt;&lt;p&gt;新版Jenkins在初始的时候已经默认安装了Git Plugin和相关依赖的Plugin，我们不用在重复进行安装，直接配置即可&lt;/p&gt;
&lt;p&gt;系统管理 –&amp;gt; 系统设置 –&amp;gt; GitHub –&amp;gt; Add GitHub Sever&lt;/p&gt;
&lt;p&gt;填写API URL为&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS8=&#34;&gt;https://api.github.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://callmedadaxin.github.io/images/jenkins-3.png&#34;&gt;&lt;img data-src=&#34;http://callmedadaxin.github.io/images/jenkins-3.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击旁边的Add按钮, 添加Secret Text&lt;br&gt;&lt;a href=&#34;http://callmedadaxin.github.io/images/jenkins-4.png&#34;&gt;&lt;img data-src=&#34;http://callmedadaxin.github.io/images/jenkins-4.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置任务&#34;&gt;&lt;a href=&#34;#配置任务&#34; class=&#34;headerlink&#34; title=&#34;配置任务&#34;&gt;&lt;/a&gt;配置任务&lt;/h3&gt;&lt;h3 id=&#34;1-新建&#34;&gt;&lt;a href=&#34;#1-新建&#34; class=&#34;headerlink&#34; title=&#34;1.新建&#34;&gt;&lt;/a&gt;1.新建&lt;/h3&gt;&lt;p&gt;回到主页 –&amp;gt; 新建任务 –&amp;gt; 新建一个自由风格的软件项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://callmedadaxin.github.io/images/jenkins-5.png&#34;&gt;&lt;img data-src=&#34;http://callmedadaxin.github.io/images/jenkins-5.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-配置源码管理&#34;&gt;&lt;a href=&#34;#2-配置源码管理&#34; class=&#34;headerlink&#34; title=&#34;2.配置源码管理&#34;&gt;&lt;/a&gt;2.配置源码管理&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;http://callmedadaxin.github.io/images/jenkins-6.png&#34;&gt;&lt;img data-src=&#34;http://callmedadaxin.github.io/images/jenkins-6.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-构建触发器，构建环境&#34;&gt;&lt;a href=&#34;#3-构建触发器，构建环境&#34; class=&#34;headerlink&#34; title=&#34;3.构建触发器，构建环境&#34;&gt;&lt;/a&gt;3.构建触发器，构建环境&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;http://callmedadaxin.github.io/images/jenkins-7.png&#34;&gt;&lt;img data-src=&#34;http://callmedadaxin.github.io/images/jenkins-7.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-编写你的构建脚本&#34;&gt;&lt;a href=&#34;#4-编写你的构建脚本&#34; class=&#34;headerlink&#34; title=&#34;4.编写你的构建脚本&#34;&gt;&lt;/a&gt;4.编写你的构建脚本&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;http://callmedadaxin.github.io/images/jenkins-8.png&#34;&gt;&lt;img data-src=&#34;http://callmedadaxin.github.io/images/jenkins-8.png&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;保存，应用&lt;/p&gt;
&lt;h2 id=&#34;问题记录&#34;&gt;&lt;a href=&#34;#问题记录&#34; class=&#34;headerlink&#34; title=&#34;问题记录&#34;&gt;&lt;/a&gt;问题记录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;项目会自动clone在&amp;#x2F;var&amp;#x2F;lib&amp;#x2F;jenkins&amp;#x2F;workspace&amp;#x2F;&lt;/li&gt;
&lt;li&gt;执行的全局脚本确定已经软链到 &amp;#x2F;usr&amp;#x2F;bin,否则访问不到&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
