{
    "version": "https://jsonfeed.org/version/1",
    "title": "杜明清的个人博客",
    "subtitle": "👻欢迎一起交流学习👻",
    "icon": "https://dmqweb.cn/images/favicon.ico",
    "description": "",
    "home_page_url": "https://dmqweb.cn",
    "items": [
        {
            "id": "https://dmqweb.cn/2024/07/29/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/",
            "url": "https://dmqweb.cn/2024/07/29/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/",
            "title": "架构风格",
            "date_published": "2024-07-29T06:56:39.000Z",
            "content_html": "<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzOTQzMDY4MjA1MDY0I2hlYWRpbmctMA==\">推荐</span></p>\n<h1 id=\"分层架构\"><a href=\"#分层架构\" class=\"headerlink\" title=\"分层架构\"></a>分层架构</h1><h1 id=\"管道架构\"><a href=\"#管道架构\" class=\"headerlink\" title=\"管道架构\"></a>管道架构</h1><h1 id=\"复制风格\"><a href=\"#复制风格\" class=\"headerlink\" title=\"复制风格\"></a>复制风格</h1><h1 id=\"微内核架构\"><a href=\"#微内核架构\" class=\"headerlink\" title=\"微内核架构\"></a>微内核架构</h1><h1 id=\"微前端架构\"><a href=\"#微前端架构\" class=\"headerlink\" title=\"微前端架构\"></a>微前端架构</h1><h1 id=\"组件化架构\"><a href=\"#组件化架构\" class=\"headerlink\" title=\"组件化架构\"></a>组件化架构</h1>",
            "tags": [
                "架构风格",
                "架构风格"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/07/26/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/",
            "url": "https://dmqweb.cn/2024/07/26/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/",
            "title": "框架高级",
            "date_published": "2024-07-26T04:24:04.000Z",
            "content_html": "<h1 id=\"vue高级用法\"><a href=\"#vue高级用法\" class=\"headerlink\" title=\"vue高级用法\"></a>vue高级用法</h1><h3 id=\"watchEffect函数\"><a href=\"#watchEffect函数\" class=\"headerlink\" title=\"watchEffect函数\"></a>watchEffect函数</h3><blockquote>\n<p>立即运行传入的函数，同时自动追踪其依赖，并在依赖更改时重新执行。<br>watchEffect的返回值是用于清除该副作用的函数。</p>\n</blockquote>\n<pre><code class=\"js\">const data = ref(0);\nconst stop = watchEffect(()=&gt;console.log(data.value,&#39;data变化了&#39;));\nstop(); //清除响应性监听\n</code></pre>\n<blockquote>\n<p>watchEffect的第二个参数是options配置项，可以配置flush、onTrack函数和onTrigger函数</p>\n</blockquote>\n<pre><code class=\"js\">watchEffect(()=&gt;&#123;&#125;,&#123;\n    flush:&quot;post&quot;, //flush配置项配置回调函数的刷新时机，post会在DOM渲染之后触发、sync会在vue进行任何更新之前进行触发\n    onTrack(e)&#123;debugger&#125;;\n    onTrigger(e)&#123;debugger&#125;;\n&#125;)\n</code></pre>\n<h3 id=\"watchSyncEffect函数\"><a href=\"#watchSyncEffect函数\" class=\"headerlink\" title=\"watchSyncEffect函数\"></a>watchSyncEffect函数</h3><blockquote>\n<p>回调函数会在DOM渲染之后触发,相当于watchEffect中配置了fulsh:”post”</p>\n</blockquote>\n<h3 id=\"watchSyncEffect函数-1\"><a href=\"#watchSyncEffect函数-1\" class=\"headerlink\" title=\"watchSyncEffect函数\"></a>watchSyncEffect函数</h3><blockquote>\n<p>回调函数在vue进行任何更新之前触发,相当于watchEffect中配置了fulsh:”sync”</p>\n</blockquote>\n<h3 id=\"effectScope函数\"><a href=\"#effectScope函数\" class=\"headerlink\" title=\"effectScope函数\"></a>effectScope函数</h3><blockquote>\n<p>effectScope函数创建一个effect作用域，可以捕获其中所创建的响应式副作用（即计算属性和侦听器），这样捕获到的副作用可以一起处理。</p>\n</blockquote>\n<pre><code class=\"javascript\">const scope = effectScope();\nscope.run(()=&gt;&#123;\n  const doubled = computed(() =&gt; counter.value * 2)\n  watch(doubled, () =&gt; console.log(doubled.value))\n  watchEffect(() =&gt; console.log(&#39;Count: &#39;, doubled.value))\n&#125;)\nscope.stop(); //清除掉作用域内所有的effect\n</code></pre>\n<h3 id=\"getCurrentScope函数\"><a href=\"#getCurrentScope函数\" class=\"headerlink\" title=\"getCurrentScope函数\"></a>getCurrentScope函数</h3><blockquote>\n<p>获取当前活跃的effect作用域</p>\n</blockquote>\n<h3 id=\"onScopeDispost函数\"><a href=\"#onScopeDispost函数\" class=\"headerlink\" title=\"onScopeDispost函数\"></a>onScopeDispost函数</h3><blockquote>\n<p>在当前活跃的effect作用域上注册一个处理回调函数。当相关的effect作用域停止时会调用这个回调函数。</p>\n</blockquote>\n<h3 id=\"shallowRef函数\"><a href=\"#shallowRef函数\" class=\"headerlink\" title=\"shallowRef函数\"></a>shallowRef函数</h3><blockquote>\n<p>用于浅层响应式,避免深层比较带来的效率问题</p>\n</blockquote>\n<h3 id=\"triggerRef函数\"><a href=\"#triggerRef函数\" class=\"headerlink\" title=\"triggerRef函数\"></a>triggerRef函数</h3><blockquote>\n<p>强制触发依赖于一个浅层ref的副作用，通常在对浅引用的内部值进行深度变更后使用</p>\n</blockquote>\n<h3 id=\"customRef函数\"><a href=\"#customRef函数\" class=\"headerlink\" title=\"customRef函数\"></a>customRef函数</h3><blockquote>\n<p>customRef函数创建一个自定义的ref，显示声明对其依赖追踪和更新触发的控制方式。预期接受一个工厂函数作为参数，这个工厂函数接收track和trigger两个函数作为参数，并返回一个带有get和set方法的对象</p>\n</blockquote>\n<pre><code class=\"js\">// 定义一个返回懒执行响应式数据的函数\nfunction useDebouncedRef(value,delay=200)&#123;\n    let timeout;\n    return customRef((track,trigger)=&gt;&#123;\n        return &#123;\n            get()&#123;\n                track();\n                return value;\n            &#125;,\n            set(newValue)&#123;\n                clearTimeout(timeout);\n                timeout = setTimeout(()=&gt;&#123;\n                    value = newValue;\n                    trigger();\n                &#125;,delay)     \n            &#125;\n        &#125;\n    &#125;)\n&#125;\n</code></pre>\n<h3 id=\"shallowReactive\"><a href=\"#shallowReactive\" class=\"headerlink\" title=\"shallowReactive\"></a>shallowReactive</h3><blockquote>\n<p>shallowReactive是reactive的浅层作用形式，只有跟级别的属性是响应式的，属性的值会被原样存储和暴露，这也意味着值为ref的属性不会被自动解包了。</p>\n</blockquote>\n<h3 id=\"shallowReadonly\"><a href=\"#shallowReadonly\" class=\"headerlink\" title=\"shallowReadonly\"></a>shallowReadonly</h3><blockquote>\n<p>shallowReadonly是readonly的浅层作用形式。</p>\n</blockquote>\n<h3 id=\"isRef函数\"><a href=\"#isRef函数\" class=\"headerlink\" title=\"isRef函数\"></a>isRef函数</h3><blockquote>\n<p>用于检查某个值是否是ref</p>\n</blockquote>\n<h3 id=\"unref函数\"><a href=\"#unref函数\" class=\"headerlink\" title=\"unref函数\"></a>unref函数</h3><blockquote>\n<p>如果是ref，返回ref内部的值，否则返回参数本身</p>\n</blockquote>\n<h3 id=\"toRef函数\"><a href=\"#toRef函数\" class=\"headerlink\" title=\"toRef函数\"></a>toRef函数</h3><ul>\n<li>传入ref返回ref本身</li>\n<li>传入props.key创建一个只读的ref</li>\n<li>传入number或者string相当于ref函数</li>\n<li>传入响应式数据和键值会封装为一个ref，但是相比于直接封装ref来说，会与源属性进行同步<pre><code class=\"js\">const state = reactive(&#123;foo:1,bar:2&#125;);\nconst fooRef = toRef(state,&#39;foo&#39;); //fooRef会和state的响应性相关联\nconst fooRef2 = ref(state.foo); //fooRef2不会和state.foo的响应性相关联\n</code></pre>\n</li>\n</ul>\n<h3 id=\"toRefs函数\"><a href=\"#toRefs函数\" class=\"headerlink\" title=\"toRefs函数\"></a>toRefs函数</h3><blockquote>\n<p>vue3中的ref将reactive响应性绑定到.value属性上，其本质就是为了防止开发者错误的将响应式数据进行解构后的变量又其当作响应式数据。所以加了一层隔离。toRefs函数也是用于解决这个问题。<br>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的ref。每个单独的ref都是使用toRef创建的</p>\n</blockquote>\n<pre><code class=\"js\">const state = reactive(&#123;\n  name:&quot;张三&quot;,\n  age:18  \n&#125;)\nconst stateAsRefs = toRefs(state);\nstate.name = &quot;李四&quot;; //toRefs返回的响应式数据和原响应式数据相互关联\nconsole.log(stateAsRefs.name.value) //李四\n//toRefs的存在是为了保证reactive响应式被解构之后仍然存在响应性\nconst &#123;name,age&#125; = toRefs(state)\n//解构之后的name和age都是响应式对象\n</code></pre>\n<h3 id=\"toRaw函数\"><a href=\"#toRaw函数\" class=\"headerlink\" title=\"toRaw函数\"></a>toRaw函数</h3><blockquote>\n<p>toRaw返回由reactive、readonly、shallowReactive或者shallowReadonly创建的代理对应的原始对象（栈赋值），返回的对象不再具有响应式，栈赋值时不会影响到页面的展示，但如果改变该对象的堆中的属性，原对象的依赖项也会随之变化</p>\n</blockquote>\n<h3 id=\"markRaw函数\"><a href=\"#markRaw函数\" class=\"headerlink\" title=\"markRaw函数\"></a>markRaw函数</h3><blockquote>\n<p>将一个对象标记为不可被转为代理，返回该对象本身</p>\n</blockquote>\n<h3 id=\"toValue函数\"><a href=\"#toValue函数\" class=\"headerlink\" title=\"toValue函数\"></a>toValue函数</h3><blockquote>\n<p>将值、函数、或响应式数据规范化为普通值，toValue(ref(1)) —&gt; 1</p>\n</blockquote>\n<h3 id=\"isProxy函数\"><a href=\"#isProxy函数\" class=\"headerlink\" title=\"isProxy函数\"></a>isProxy函数</h3><blockquote>\n<p>检查一个对象是否是由reactive、readonly、shallowReactive或者shallowReadonly创建的代理。</p>\n</blockquote>\n<h3 id=\"isReactive函数\"><a href=\"#isReactive函数\" class=\"headerlink\" title=\"isReactive函数\"></a>isReactive函数</h3><blockquote>\n<p>检查一个对象是否是由reactive或shallowReactive创建的代理</p>\n</blockquote>\n<h3 id=\"isreadonly函数\"><a href=\"#isreadonly函数\" class=\"headerlink\" title=\"isreadonly函数\"></a>isreadonly函数</h3><blockquote>\n<p>检查传入的值是否是只读对象，只读对象的属性可以更改，但是不能通过传入的对象直接赋值。</p>\n</blockquote>\n<h3 id=\"Transition组件\"><a href=\"#Transition组件\" class=\"headerlink\" title=\"Transition组件\"></a>Transition组件</h3><ul>\n<li>使用过渡样式</li>\n<li>mode属性定义动画进行的顺序,常用out-in </li>\n<li>name属性定义动画的名称,配合css使用</li>\n<li>appear属性初次渲染过渡</li>\n<li>生命周期钩子用于自定义过渡中执行过程,依次是before-enter,enter,after-enter,enter-cancelled,before-leave,leave,leave-cancelled,可用的参数有el和done()</li>\n<li>css样式过渡:name-enter-from\\name-enter-active\\name-enter-to\\name-leave-from\\name-leave-active\\name-leave-to定义对应时期的样式(只对可以过渡变化的样式生效)</li>\n</ul>\n<h3 id=\"TransitionGroup组件\"><a href=\"#TransitionGroup组件\" class=\"headerlink\" title=\"TransitionGroup组件\"></a>TransitionGroup组件</h3><ul>\n<li>TransitionGroup组件用于对v-for列表中的元素或组件插入 、移除或顺序变化添加动画效果.</li>\n<li>属性和生命周期和Transition一样</li>\n<li>tag属性可以指定TransitionGroup为一个容器</li>\n</ul>\n<h3 id=\"KeepAlive组件\"><a href=\"#KeepAlive组件\" class=\"headerlink\" title=\"KeepAlive组件\"></a>KeepAlive组件</h3><ul>\n<li>KeepAlive用于在多个组件间切换状态时缓存被移除的组件实例(使组件保存状态)</li>\n<li>KeepAlive的原理就是当KeepAlive中的组件被移除时,用变量将整个组件缓存起来,需要切换时直接使用缓存起来的变量</li>\n<li>include和exclude属性用于包含或排除对应的组件name</li>\n<li>KeepAlive的组件包含onActivated和onDeactived两个生命周期钩子</li>\n</ul>\n<h3 id=\"Teleport组件\"><a href=\"#Teleport组件\" class=\"headerlink\" title=\"Teleport组件\"></a>Teleport组件</h3><ul>\n<li>Teleport组件,用于将组件内部的一部分模板传送到外部结构中去</li>\n<li>to属性用于指定传送到的组件或者DOM元素</li>\n</ul>\n<h3 id=\"Suspense组件\"><a href=\"#Suspense组件\" class=\"headerlink\" title=\"Suspense组件\"></a>Suspense组件</h3><ul>\n<li>Suspense组件用于显示异步组件加载中的显示状态</li>\n<li>Suspense组件中fallback具名插槽用于显示加载内容</li>\n<li>Suspense组件嵌套Suspense组件时,给内部Suspense组件加上suspensible属性表示为异步组件,否则则会被父级Suspense组件视为同步组件</li>\n</ul>\n<h3 id=\"watch的options配置项\"><a href=\"#watch的options配置项\" class=\"headerlink\" title=\"watch的options配置项\"></a>watch的options配置项</h3><blockquote>\n<p>watch的options配置项中可以使用:</p>\n</blockquote>\n<ul>\n<li>immediate,为true时会在初始化时立即执行一次</li>\n<li>deep,为true时会深度监听对象堆中变化</li>\n<li>flush,调整回调函数的执行时机</li>\n<li>once,回调函数只会执行一次</li>\n<li>onTrack函数,当响应式被收集时进行触发<strong>只在开发模式下有效</strong></li>\n<li>onTrigger函数,当依赖项变更时进行触发<strong>只在开发模式下有效</strong></li>\n</ul>\n<h3 id=\"computed的options配置项\"><a href=\"#computed的options配置项\" class=\"headerlink\" title=\"computed的options配置项\"></a>computed的options配置项</h3><ul>\n<li>onTrack函数,当响应式被收集时进行触发<strong>只在开发模式下有效</strong></li>\n<li>onTrigger函数,当依赖项变更时进行触发<strong>只在开发模式下有效</strong></li>\n</ul>\n<h3 id=\"vue对jsx的支持友好\"><a href=\"#vue对jsx的支持友好\" class=\"headerlink\" title=\"vue对jsx的支持友好\"></a>vue对jsx的支持友好</h3><ul>\n<li>在vue中也可以很方便的去集成jsx或tsx语法，tsx语法需要在tsconfig.json中配置：jsx：preserve，最终的jsx语法会被转换为h函数</li>\n<li>对于事件和案件修饰符，可以使用vue中的withModifiers函数</li>\n</ul>\n<h3 id=\"vue对web-component的支持友好\"><a href=\"#vue对web-component的支持友好\" class=\"headerlink\" title=\"vue对web component的支持友好\"></a>vue对web component的支持友好</h3><ul>\n<li>在 Vue 应用中使用自定义元素基本上与使用原生 HTML 元素的效果相同</li>\n<li>需要在构建工具中配置compilerOptions.isCustomElement这个选项</li>\n<li>传递ODM属性时，需要使用v-bind绑定，通过.prop修饰符进行设置<pre><code class=\"html\">&lt;my-element :user.prop=&quot;&#123; name: &#39;jack&#39; &#125;&quot;&gt;&lt;/my-element&gt;\n&lt;!-- 等价简写 --&gt;\n&lt;my-element .user=&quot;&#123; name: &#39;jack&#39; &#125;&quot;&gt;&lt;/my-element&gt;\n</code></pre>\n</li>\n<li>使用vue构建web component需要使用defineCustomElement这个方法定义出组件，然后通过customElement.define这个方法将vue组件添加标签到HTML中</li>\n</ul>\n<h3 id=\"web-component的优缺点\"><a href=\"#web-component的优缺点\" class=\"headerlink\" title=\"web component的优缺点\"></a>web component的优缺点</h3><ul>\n<li>全部使用自定义元素来构建应用的方式可以使得应用永不过时和多平台、框架共享</li>\n<li>但是设想与显示总是存在偏差：</li>\n<li><ul>\n<li>1、原生web component并不具备响应式的系统</li>\n</ul>\n</li>\n<li><ul>\n<li>2、原生web component并不具备一个声明式的、高效的模板系统</li>\n</ul>\n</li>\n<li><ul>\n<li>3、SSR渲染时，web component需要在node.js中模拟出DOM，这将增大服务器端的压力</li>\n</ul>\n</li>\n<li><ul>\n<li>4、当下要想使用shadow DOM书写局部作用域的CSS，必须要将样式嵌入到JavaScript中才可以在运行时注入到shadow root上，这将导致SSR场景下需要渲染大量重复的样式标签。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vue结合js动画库\"><a href=\"#vue结合js动画库\" class=\"headerlink\" title=\"vue结合js动画库\"></a>vue结合js动画库</h3><ul>\n<li>以gsap为例，vue结合js动画库实现动画效果时，不能直接对响应式变量进行动画设置，因为是响应式完成之后才被监听到，此时响应式变量已经是最新的值，所以应该再来一个响应式变量中转一下，页面动画效果绑定的是中转的变量。</li>\n</ul>\n<h3 id=\"vue生命周期\"><a href=\"#vue生命周期\" class=\"headerlink\" title=\"vue生命周期\"></a>vue生命周期</h3><ul>\n<li>vue3中setup替代了beforeCreate和created</li>\n<li>beforeMount、monuted、beforeUpdate、updated、beforeUnmount、unMounted</li>\n<li>错误捕获钩子：onErrorCaptured，如果在onErrorCaptured中抛出一个错误，则会被app.config.errorHandler捕获到</li>\n<li>开发时钩子：onRenderTracked（组件渲染过程中追踪到响应式依赖时调用）和onRenderTriggered（当响应式依赖触发了组件渲染时调用）</li>\n<li>SSR钩子：onServerPrefetch（注册一个异步函数，在组件实例在服务器上被渲染之前调用），SSR渲染时，组件作为初始请求的一部分被渲染，这时可以在服务器上预请求数据，因为它比在客户端上更快。</li>\n<li>keepAlive组件下的钩子：onActivated和onDeactivated两个，用于当组件激活和失活时调用</li>\n</ul>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h1><h2 id=\"Fiber\"><a href=\"#Fiber\" class=\"headerlink\" title=\"Fiber\"></a>Fiber</h2><blockquote>\n<p>Fiber架构：Fiber架构是一个增量渲染，架构风格类似协程，Fiber架构出现的原因是由于 JS 单线程执行的特性当遇到繁琐的执行任务时，原来React15的协调过程就会很长，从而延迟DOM的渲染更新，进而出现掉帧。Fiber架构将任务分给一个个的迭代器进行执行，并且使迭代器的执行过程发生在浏览器的空闲时间，从而最大程度利用了这部分资源，使得UI渲染不会被大量执行任务所阻塞。<br>fiber树：fiber树是一个数据结构，架构在虚拟DOM转换到真实DOM之间，在Fiber结构中的任务是可以中断执行的，继续执行时会丢弃掉原来的工作从头再来，并且重新执行中断的任务，对用于来说也是无感的，因为Fiber架构的视图更新是后缓冲区视图 替换 前缓冲区视图的过程。<br>由于Fiber架构下的reconciler协调阶段是异步可中断的，且会被反复重新执行，使得反复执行时有可能触发的生命周期钩子被废弃，例如：componentWillMount、componentWillReceiveProps、componentWillUpdate这些。<br>fiber树（fiber节点构成的树状链表）的遍历与执行：</p>\n</blockquote>\n<ul>\n<li>fiber树遍历：children子节点—-sibling兄弟节点—-return父节点</li>\n<li>fiber树的执行：遍历到最底层子节点A—-A的兄弟节点—–A的父节点B——B的兄弟节点（深度优先遍历）<blockquote>\n<p>fiber节点（对象）：一个fiber节点对应一个React 组件，fiber节点里包含了组件的work任务等信息，比如组件的Hooks执行逻辑（它是一个链表，可以通过memorizedState拿到跟节点，Hooks执行逻辑里面存储了state）、生命周期、对于html组件的增删改查等副作用<br>当执行fiber节点中的任务时，每次执行完之后React就会检查当前帧还剩多少时间，没有时间就会将控制权让出去。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"fiber树、VDOM和diff算法\"><a href=\"#fiber树、VDOM和diff算法\" class=\"headerlink\" title=\"fiber树、VDOM和diff算法\"></a>fiber树、VDOM和diff算法</h3><blockquote>\n<p>fiber树就是VDOM,fiber树的变化反映了组件的状态变化<br>diff算法的本质就是: 对比<code>current fiber</code> 和 <code>JSX对象</code> 生成 <code>work-in-progress-fiber</code><br>即使是最前沿的算法,完全对比两棵树的时间复杂度也需要O(n^3),其中</p>\n</blockquote>\n<h2 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h2><blockquote>\n<p>注意：react Hooks只能在件顶层进行调用并且不能写在条件判断中，这是因为hooks以链表的形式存放在fiber节点中（类组件的副作用也存在fiber节点中），每次更新时会基于链表的顺序进行调用，而调用hooks所产生的state就存在于hooks节点之中，如果hooks写在条件判断中则导致hooks链表执行混乱，使得状态更新出错。</p>\n</blockquote>\n<h2 id=\"workLoop工作循环\"><a href=\"#workLoop工作循环\" class=\"headerlink\" title=\"workLoop工作循环\"></a>workLoop工作循环</h2><blockquote>\n<p>workLoop中会根据当前帧的剩余时间去执行fiber节点中的任务,如果时间不够就将控制权转给UI渲染,并保存当期的执行上下文(包括当前fiber节点的状态),当UI渲染完毕后,恢复其执行(执行到一半的任务会重新执行)</p>\n</blockquote>\n<h2 id=\"双缓冲策略\"><a href=\"#双缓冲策略\" class=\"headerlink\" title=\"双缓冲策略\"></a>双缓冲策略</h2><blockquote>\n<p>双缓冲策略是用于减少组件渲染过程中的闪烁和卡顿。双缓冲策略是对于fiber树来说的<br>双缓冲策略会维护两个Fiber树：Work-in-progress-fiber树 和 current-fiber树。协调过程中React会比较新旧两个fiber树的差异，从而确定哪些组件需要更新。一旦新的fiber树构建完成，React就会使用diff算法去更新真实DOM。更新完成后会将工作Fiber树的根节点与当前Fiber树的根节点进行交换，这个过程叫做提交。</p>\n</blockquote>\n<h3 id=\"Fiber更新的三个阶段\"><a href=\"#Fiber更新的三个阶段\" class=\"headerlink\" title=\"Fiber更新的三个阶段\"></a>Fiber更新的三个阶段</h3><ul>\n<li>开始阶段: <code>ReactFiberBeginWork</code></li>\n<li><ul>\n<li>这个阶段react需要决定哪些组件需要更新、哪些组件可以复用、哪些组件需要被挂载或卸载</li>\n</ul>\n</li>\n<li><ul>\n<li>React 通过比较新旧 Fiber 树来确定变化，这个过程称为协调算法（Reconciliation）。</li>\n</ul>\n</li>\n<li><ul>\n<li>此阶段会创建一个新的工作进度树（work-in-progress tree），表示 UI 的最新状态。</li>\n</ul>\n</li>\n<li><ul>\n<li>这个阶段是可中断的，React 可以决定挂起渲染过程，稍后再恢复。</li>\n</ul>\n</li>\n<li>完成阶段: <code>ReactFiberCompeleteWork</code></li>\n<li><ul>\n<li>这个阶段发生在实际将更新应用到屏幕之前。</li>\n</ul>\n</li>\n<li><ul>\n<li>React 执行生命周期方法，如 getSnapshotBeforeUpdate，允许组件捕获当前的 DOM 状态或执行捕获操作。</li>\n</ul>\n</li>\n<li><ul>\n<li>这个阶段用于执行那些需要在提交前知道布局效果的副作用，例如，测量组件的尺寸或位置。</li>\n</ul>\n</li>\n<li>提交阶段: <code>ReactFiberCommitWork</code></li>\n<li><ul>\n<li>这是实际将更改应用到真实 DOM 的阶段。</li>\n</ul>\n</li>\n<li><ul>\n<li>React 处理所有副作用，如 componentDidMount、componentDidUpdate 和 componentWillUnmount 生命周期方法。</li>\n</ul>\n</li>\n<li><ul>\n<li>更新 DOM 元素和属性，添加或删除 DOM 节点，以确保真实 DOM 与工作进度树同步。这个阶段是连续的，不能被中断，因为 DOM 更新通常需要原子性地完成。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"为什么hooks不能写在条件判断\"><a href=\"#为什么hooks不能写在条件判断\" class=\"headerlink\" title=\"为什么hooks不能写在条件判断\"></a>为什么hooks不能写在条件判断</h2><blockquote>\n<p>hooks函数最终会被存在组件对应的fiber节点的memoizatedState中，组件每次更新会按照顺序执行(hooks里面存着state状态)，如果组件每次更新时的hooks链表顺序乱了,就会导致state对应不上、状态混乱</p>\n</blockquote>\n<h2 id=\"react不可变数据\"><a href=\"#react不可变数据\" class=\"headerlink\" title=\"react不可变数据\"></a>react不可变数据</h2><blockquote>\n<p>例如当setData(data + 1)副作用在组件内连续调用三次时,其实是相当于只调用了一次,这就是react不可变数据或者说:当前快照只能操作当前快照的值 ;<br>出现react不可变数据现象的原因是由于: hooks执行逻辑最后会以链表的形式存储在fiber节点之中,而那里面不会有类似上面data这样的变量,data会在hooks执行过程被存储之前转换为其具体的值,上例正确的写法是写成一个函数,这样在存储hooks执行逻辑到fiber节点中时就会先执行传入的这个函数,例如应该写成:setData(()&#x3D;&gt;data+1)</p>\n</blockquote>\n<h3 id=\"useState钩子\"><a href=\"#useState钩子\" class=\"headerlink\" title=\"useState钩子\"></a>useState钩子</h3><blockquote>\n<p>创建可以直接更新的状态变量</p>\n</blockquote>\n<h3 id=\"useReducer钩子\"><a href=\"#useReducer钩子\" class=\"headerlink\" title=\"useReducer钩子\"></a>useReducer钩子</h3><blockquote>\n<p>与useState相似，创建状态变量，同时可以自定义reducer（内部变量变化的调度机制）</p>\n</blockquote>\n<pre><code class=\"jsx\">function App() &#123;\n  //注意：reducer中的返回值就是新的state\n  const dataReducer = (state, aciton) =&gt; &#123;\n    switch (aciton) &#123;\n      case 0: return &quot;你好&quot;;\n      case 1: return &quot;世界&quot;;\n      case 2: return &quot;你好世界&quot;;\n      default: return &quot;世界你好&quot;;\n    &#125;\n  &#125;\n  const [data, dispatchData] = useReducer(dataReducer, &quot;你好世界&quot;);\n  return (\n    &lt;&gt;\n      &lt;h1&gt;&#123;data&#125;&lt;/h1&gt;\n      &lt;button onClick=&#123;() =&gt; dispatchData(0)&#125;&gt;你好&lt;/button&gt;\n      &lt;button onClick=&#123;() =&gt; dispatchData(1)&#125;&gt;世界&lt;/button&gt;\n      &lt;button onClick = &#123;()=&gt;dispatchData(2)&#125;&gt;你好世界&lt;/button&gt;\n      &lt;button onClick=&#123;() =&gt; dispatchData(3)&#125;&gt;世界你好&lt;/button&gt;\n    &lt;/&gt;\n  )\n&#125;\n</code></pre>\n<h3 id=\"createContext和useContext钩子\"><a href=\"#createContext和useContext钩子\" class=\"headerlink\" title=\"createContext和useContext钩子\"></a>createContext和useContext钩子</h3><blockquote>\n<p>createContext和useContext直接使用相当于是创建可用的变量</p>\n</blockquote>\n<pre><code class=\"jsx\">const testContext = createContext(&quot;初始化数据&quot;)\n// 在组件中就可以拿到testContextData,然后使用:\nconst testContextData = useContext(testContext);\n</code></pre>\n<blockquote>\n<p>createContext和useContext高级用法本质上是依赖注入,他返回一个对象，对象的Provider属性是一个组件，用于注入数据（在Provider组件上绑定value属性），注入的数据可以通过useContext获取</p>\n</blockquote>\n<pre><code class=\"jsx\">const ThemeContext = createContext(null); //创建context\nfunction MyPage() &#123;\n  const [theme, setTheme] = useState(&#39;dark&#39;);\n  // 将依赖注入到组件内部\n  return (\n    &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;\n      &lt;ThemeText /&gt;\n    &lt;/ThemeContext.Provider&gt;\n  );\n&#125;\n// 组件内部使用注入的依赖\nfunction ThemeText()&#123;\n  const themeData = useContext(ThemeContext);\n  return &lt;&gt;&#123;themeData&#125;&lt;/&gt;\n&#125;\n</code></pre>\n<h3 id=\"useRef钩子\"><a href=\"#useRef钩子\" class=\"headerlink\" title=\"useRef钩子\"></a>useRef钩子</h3><blockquote>\n<p>帮助引用一个不需要渲染的值(不会触发组件重新渲染),返回一个具有current属性的对象,通常用于保存DOM节点<br>注意,改变 ref 不会触发重新渲染，所以 ref 不适合用于存储期望显示在屏幕上的信息。如有需要，使用 state 代替。React希望不要在渲染期间写入或者读取 ref.current,如果不得不在渲染期间读取 或者写入，那么应该 使用 state 代替。</p>\n</blockquote>\n<pre><code class=\"jsx\">function App() &#123;\n  const inputFocus = (ref) =&gt; &#123;\n    ref.current.focus();\n  &#125;;\n  const inputRef = useRef(null);\n  return (\n    &lt;&gt;&lt;input ref=&#123;inputRef&#125; /&gt;\n      &lt;button onclick=&#123;(e) =&gt; inputFocus(inputRef)&#125;&gt;聚焦输入框&lt;/button&gt;&lt;/&gt;\n  );\n&#125;\nexport default App\n</code></pre>\n<h3 id=\"useEffect钩子\"><a href=\"#useEffect钩子\" class=\"headerlink\" title=\"useEffect钩子\"></a>useEffect钩子</h3><blockquote>\n<p>接收两个参数: 副作用函数和依赖项数组,当依赖项变化时自动执行副作用函数,副作用函数的返回值是一个清理函数,会在每次组件更新前进行执行<br>useEffect中第二个参数不传代表<strong>每次渲染组件后都执行一次</strong>，传空数组代表<strong>只会在第一次挂载后执行</strong>，传依赖项代表在<strong>依赖项变化时执行。</strong>并且默认组件挂载时就会自动执行一次,以便可以读取到依赖项<br>useEffect 依赖项中传入 ref 通常是无效的，因为 ref 相当于不使用渲染赋值的 state 状态，传递过去的 ref 引用始终相同（不随着快照的渲染而变化）。<br>某些逻辑不能放在 effect 中执行，因为 effect 的执行是和组件渲染强绑定的（例如不能在 effect 中写购买商品的逻辑，这样会导致组件以任何方式被渲染都会执行购买逻辑，这样是不对的）<br>effect 中 return 的函数会在下一次 effect 执行前被执行，常用于执行清理函数（清除定时器等）</p>\n</blockquote>\n<h3 id=\"useLayoutEffect钩子\"><a href=\"#useLayoutEffect钩子\" class=\"headerlink\" title=\"useLayoutEffect钩子\"></a>useLayoutEffect钩子</h3><blockquote>\n<p>在浏览器重新绘制屏幕前执行，可以在此处测量布局。</p>\n</blockquote>\n<h3 id=\"useInsertionEffect钩子\"><a href=\"#useInsertionEffect钩子\" class=\"headerlink\" title=\"useInsertionEffect钩子\"></a>useInsertionEffect钩子</h3><blockquote>\n<p>在 React 对 DOM 进行更改之前触发，库可以在此处插入动态 CSS。</p>\n</blockquote>\n<h3 id=\"useMemo钩子\"><a href=\"#useMemo钩子\" class=\"headerlink\" title=\"useMemo钩子\"></a>useMemo钩子</h3><blockquote>\n<p>缓存函数的计算结果,只有当依赖项发生变化时,才会重新计算</p>\n</blockquote>\n<h3 id=\"useCallback钩子\"><a href=\"#useCallback钩子\" class=\"headerlink\" title=\"useCallback钩子\"></a>useCallback钩子</h3><blockquote>\n<p>缓存函数的定义,接收的参数是: 缓存函数和依赖项,只有当依赖项(栈值)发生变化时,才会更新</p>\n</blockquote>\n<pre><code class=\"jsx\">function ProductPage(&#123; productId, referrer, theme &#125;) &#123;\n  // 在多次渲染中缓存函数\n  const handleSubmit = useCallback((orderDetails) =&gt; &#123;\n    post(&#39;/product/&#39; + productId + &#39;/buy&#39;, &#123;\n      referrer,\n      orderDetails,\n    &#125;);\n  &#125;, [productId, referrer]); // 只要这些依赖没有改变\n\n  return (\n    &lt;div className=&#123;theme&#125;&gt;\n      &#123;/* ShippingForm 就会收到同样的 props 并且跳过重新渲染 */&#125;\n      &lt;ShippingForm onSubmit=&#123;handleSubmit&#125; /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n</code></pre>\n<blockquote>\n<p>useCallback是由useMemo封装而来: (useCallback内部存储的不是原来的函数体,而是一个普通函数返回函数体被useMemo缓存的结果)</p>\n</blockquote>\n<pre><code class=\"jsx\">function useCallback (fn,dependencies)&#123;\n  return useMemo(()=&gt;fn,dependencies)\n&#125;\n</code></pre>\n<h3 id=\"useTransition钩子\"><a href=\"#useTransition钩子\" class=\"headerlink\" title=\"useTransition钩子\"></a>useTransition钩子</h3><blockquote>\n<p>允许将状态转换标记为非阻塞，并允许其他更新中断它。为了更好地控制组件更新和动画而设计</p>\n</blockquote>\n<h3 id=\"useDeferredValue钩子\"><a href=\"#useDeferredValue钩子\" class=\"headerlink\" title=\"useDeferredValue钩子\"></a>useDeferredValue钩子</h3><blockquote>\n<p>允许延迟更新 UI 的非关键部分，以让其他部分先更新。</p>\n</blockquote>\n<h3 id=\"Fragment组件\"><a href=\"#Fragment组件\" class=\"headerlink\" title=\"Fragment组件\"></a>Fragment组件</h3><blockquote>\n<p><Fragment> 通常使用 &lt;&gt;…&lt;&#x2F;&gt; 代替，它们都允许你在不添加额外节点的情况下将子元素组合。</p>\n</blockquote>\n<h3 id=\"Profiler组件\"><a href=\"#Profiler组件\" class=\"headerlink\" title=\"Profiler组件\"></a>Profiler组件</h3><blockquote>\n<p><Profiler> 允许你编程式测量 React 树的渲染性能。接受一个id用于表示测量的UI部分,接受一个回调函数,当包裹的组件树更新时会传入渲染信息进行调用。</p>\n</blockquote>\n<pre><code class=\"jsx\">&lt;Profiler id=&quot;App&quot; onRender=&#123;onRender&#125;&gt;\n  &lt;App /&gt;\n&lt;/Profiler&gt;\n</code></pre>\n<h3 id=\"StrictMode组件\"><a href=\"#StrictMode组件\" class=\"headerlink\" title=\"StrictMode组件\"></a>StrictMode组件</h3><blockquote>\n<p>开启严格模式,开发阶段会渲染两次,使得尽早地发现组件中错误</p>\n</blockquote>\n<h3 id=\"Suspense组件-1\"><a href=\"#Suspense组件-1\" class=\"headerlink\" title=\"Suspense组件\"></a>Suspense组件</h3><blockquote>\n<p>展示子组件加载完成前渲染的内容.</p>\n</blockquote>\n<pre><code class=\"jsx\">&lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;\n  &lt;AsyncComponent /&gt;\n&lt;/Suspense&gt;\n</code></pre>\n<h3 id=\"memo方法\"><a href=\"#memo方法\" class=\"headerlink\" title=\"memo方法\"></a>memo方法</h3><blockquote>\n<p>memo允许你的组件在道具没有改变的情况下跳过重新渲染</p>\n</blockquote>\n<h3 id=\"createPortal方法\"><a href=\"#createPortal方法\" class=\"headerlink\" title=\"createPortal方法\"></a>createPortal方法</h3><blockquote>\n<p>createPortal 允许你将 JSX 作为 children 渲染至 DOM 的指定部分。</p>\n</blockquote>\n<h3 id=\"createRoot方法\"><a href=\"#createRoot方法\" class=\"headerlink\" title=\"createRoot方法\"></a>createRoot方法</h3><blockquote>\n<p>createRoot 允许在浏览器的 DOM 节点中创建根节点以显示 React 组件。</p>\n</blockquote>\n<h3 id=\"hydrateRoot方法\"><a href=\"#hydrateRoot方法\" class=\"headerlink\" title=\"hydrateRoot方法\"></a>hydrateRoot方法</h3><blockquote>\n<p>hydrateRoot 函数允许你在先前由 react-dom&#x2F;server 生成的浏览器 HTML DOM 节点中展示 React 组件。</p>\n</blockquote>\n<h3 id=\"act方法\"><a href=\"#act方法\" class=\"headerlink\" title=\"act方法\"></a>act方法</h3><blockquote>\n<p>行为测试助手,用于测试</p>\n</blockquote>\n<h3 id=\"forwardRef方法\"><a href=\"#forwardRef方法\" class=\"headerlink\" title=\"forwardRef方法\"></a>forwardRef方法</h3><blockquote>\n<p>允许组件使用ref将 DOM 节点指向给父组件。</p>\n</blockquote>\n<h3 id=\"lazy方法\"><a href=\"#lazy方法\" class=\"headerlink\" title=\"lazy方法\"></a>lazy方法</h3><blockquote>\n<p>延迟加载组件(懒加载)。常配合Suspense组件使用</p>\n</blockquote>\n<h3 id=\"startTransition方法\"><a href=\"#startTransition方法\" class=\"headerlink\" title=\"startTransition方法\"></a>startTransition方法</h3><blockquote>\n<p>可以在不阻止UI的情况下更新状态。</p>\n</blockquote>\n<h1 id=\"Vue和React比对\"><a href=\"#Vue和React比对\" class=\"headerlink\" title=\"Vue和React比对\"></a>Vue和React比对</h1><h3 id=\"setup和Hooks\"><a href=\"#setup和Hooks\" class=\"headerlink\" title=\"setup和Hooks\"></a>setup和Hooks</h3><ul>\n<li>React Hooks在组件每次更新时,如果不做优化就会重新调用,这也带来一些性能问题</li>\n<li>Hooks有严格的调用顺序,并且不能写在条件分支中,还必须要写在react组件里面</li>\n<li>昂贵的计算需要使用useMemo,也需要传入正确的数组</li>\n<li>要解决变量闭包导致的问题,再结合并发功能,使得很难推理出一段钩子代码是什么时候运行的,并且很不好处理需要在多次渲染间保持引用的可变状态</li>\n</ul>\n<h1 id=\"react类组件和函数式组件\"><a href=\"#react类组件和函数式组件\" class=\"headerlink\" title=\"react类组件和函数式组件\"></a>react类组件和函数式组件</h1><blockquote>\n<p>类组件和函数式的比对实际上是: 面向对象和函数式编程这两大编程思想的碰撞<br>函数式编程关心的是:  需要做什么,而不是怎么去做 , 而面向对象关心的是:  数据和对象</p>\n</blockquote>\n<h2 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h2><blockquote>\n<p>完成某项任务关心的是: 数据和对象<br>面向对象编程主要围绕着数据或者对象而不是功能和逻辑实现,他将<code>关注点放在对于数据的操作方法</code>,<code>面向对象将数据和操作方法封装为一个类中,这样有利于代码的可复用性和可扩展性</code><br>面向对象编程的优点是: 效率高(符合现实世界)、容易维护(结构清晰)、易扩展(面向对象的程序往往高内聚而低耦合)、可重用(得益于对象的继承)<br>面型对象编程的缺点是: 过度的对象化、状态过于共享导致推理复杂、状态共享导致的并发问题(可变状态复杂的共享机制导致面向对象的代码几乎不可能并行化,需要复杂的线程锁定、互斥等机制)、消耗内存、性能低(会创建很多的类和实例)</p>\n</blockquote>\n<h3 id=\"面向对象编程三大特点\"><a href=\"#面向对象编程三大特点\" class=\"headerlink\" title=\"面向对象编程三大特点:\"></a>面向对象编程三大特点:</h3><ul>\n<li>封装</li>\n<li><ul>\n<li><code>封装意味着所有的数据和方法都被封装在对象内</code>，由开发者自己选择性的去公开哪些属性和方法，对于创建的实例来说他能访问的只能是这些公开的属性和方法，而对于其他对象来说是无权访问此类或者进行更改，<code>封装这一特性为程序提供了更高的安全性</code>。</li>\n</ul>\n</li>\n<li>继承</li>\n<li><ul>\n<li><code>继承意味着代码的可重用性</code>，子类和父类这两个概念就是很好的体现，子类拥有父类所有的属性和方法避免数据和方法的重复定义，同时也能够保持独特的层析结构,<code>继承这一特性为程序提供了可重用性</code>。</li>\n</ul>\n</li>\n<li>多态</li>\n<li><ul>\n<li>多态意味着设计对象以共享行为，使用继承子类可以用新的方法去覆盖父类共享的行为，多态性允许同一个方法执行两种不同的行为：覆盖和重载。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><blockquote>\n<p>完成某项任务关心的是: 需要做什么,而不是怎么去做<br>函数式编程又称声明式编程,最明显的特点就是我们<code>不太关心函数的具体实现</code>,而<code>只关心自己的业务逻辑线路</code><br>函数式编程的优点是: 代码可读性强、有一定的逻辑复用能力、并发速度快、出错率少易排查 ;<br>函数式编程的缺点是: 性能消耗大(主要是创建执行上下文的消耗) 和 资源占用大(数据不可变导致要创建很多重复的对象),同时不利于实现时间旅行等操作(状态很难回滚)</p>\n</blockquote>\n<h3 id=\"函数式编程三大特点\"><a href=\"#函数式编程三大特点\" class=\"headerlink\" title=\"函数式编程三大特点:\"></a>函数式编程三大特点:</h3><ul>\n<li>函数是一等公民: 在JS中函数和其他数据类型一样处于平等地位,可以作为变量赋值给其他变量,并且可以作为参数和返回值</li>\n<li>声明式编程: 函数式编程又称声明式编程,我们不太关心函数内部的具体实现,而是关心业务逻辑的执行流程</li>\n<li>纯函数: 纯函数特点:无副作用、引用透明 和 数据不可变</li>\n<li><ul>\n<li>无副作用: 本身不会依赖和修改外部变量</li>\n</ul>\n</li>\n<li><ul>\n<li>引用透明: 输入相同的值一定会得到相同的结果</li>\n</ul>\n</li>\n<li><ul>\n<li>数据不可变: 针对引用数据类型的入参,最好的方式是重新生成一份数据</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "框架高级",
                "框架高级"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
            "url": "https://dmqweb.cn/2024/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
            "title": "操作系统",
            "date_published": "2024-07-23T07:02:19.000Z",
            "content_html": "<h1 id=\"操作系统定义\"><a href=\"#操作系统定义\" class=\"headerlink\" title=\"操作系统定义\"></a>操作系统定义</h1><blockquote>\n<p>操作系统（Operating System）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件应用程序，同时也是计算机系统的内核和基石。<br>操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。</p>\n</blockquote>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><blockquote>\n<p>进程是：操作系统进行<code>资源分配</code>的基本单位</p>\n</blockquote>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><blockquote>\n<p>线程是：操作系统进行<code>资源调度</code>的基本单位</p>\n</blockquote>\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><blockquote>\n<p>内存是：计算机的随机访问存储器（RAM），是计算机的主要存储资源之一，用于存储计算机运行时正在使用或即将使用的数据和指令。<br>内存具有：易失性（计算机关闭时内存中的数据会丢失）、访问速度快等特点</p>\n</blockquote>\n<h1 id=\"虚拟内存（地址空间）\"><a href=\"#虚拟内存（地址空间）\" class=\"headerlink\" title=\"虚拟内存（地址空间）\"></a>虚拟内存（地址空间）</h1><blockquote>\n<p>虚拟内存是：虚拟内存是操作系统对物理内存的抽象，是一种内存管理技术，允许操作系统将硬盘空间用作临时的RAM来使用<br>虚拟内存能够运行比物理内存更多的内存的程序，同时也为操作系统提供了更大的地址空间，虚拟内存的关键有：</p>\n</blockquote>\n<ul>\n<li>地址转换</li>\n<li>分页</li>\n<li>页面置换算法</li>\n<li>硬盘空间使用</li>\n<li>性能影响</li>\n<li>内存管理</li>\n</ul>\n<h1 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h1><blockquote>\n<p>文件是：操作系统对物理磁盘的抽象，是一个基本的数据存储单元，用于在计算机系统或存储设备上保存数据。</p>\n</blockquote>\n<h1 id=\"shell\"><a href=\"#shell\" class=\"headerlink\" title=\"shell\"></a>shell</h1><blockquote>\n<p>shell是：一个程序，可以从键盘中获取命令并将其提供给操作系统进行执行。</p>\n</blockquote>\n<h1 id=\"GUI\"><a href=\"#GUI\" class=\"headerlink\" title=\"GUI\"></a>GUI</h1><blockquote>\n<p>GUI是：一个用户界面，用户可以通过图形或图标指示符与电子设备进行交互</p>\n</blockquote>\n<h1 id=\"计算机架构\"><a href=\"#计算机架构\" class=\"headerlink\" title=\"计算机架构\"></a>计算机架构</h1><blockquote>\n<p>计算机架构是：计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法，主要包括：指令集、内存管理、I&#x2F;O和总线结构等。</p>\n</blockquote>\n<h1 id=\"多处理系统\"><a href=\"#多处理系统\" class=\"headerlink\" title=\"多处理系统\"></a>多处理系统</h1><blockquote>\n<p>多处理系统是：指计算机同时运行多个程序的能力。</p>\n</blockquote>\n<h1 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h1><blockquote>\n<p>程序计数器是：一个CPU中的寄存器，用于指示计算机在其程序序列中的位置。</p>\n</blockquote>\n<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><blockquote>\n<p>多线程是：指一个软件或硬件上实现多线程并发执行的技术。</p>\n</blockquote>\n<h1 id=\"CPU核心（core）\"><a href=\"#CPU核心（core）\" class=\"headerlink\" title=\"CPU核心（core）\"></a>CPU核心（core）</h1><blockquote>\n<p>CPU核心是：CPU的大脑，它接收指令，并执行计算或运算以满足这些指令，一个CPU可以有多个内核。</p>\n</blockquote>\n<h1 id=\"图形处理器（视觉处理器）\"><a href=\"#图形处理器（视觉处理器）\" class=\"headerlink\" title=\"图形处理器（视觉处理器）\"></a>图形处理器（视觉处理器）</h1><blockquote>\n<p>图形处理器是：</p>\n</blockquote>\n<h1 id=\"缓存命中\"><a href=\"#缓存命中\" class=\"headerlink\" title=\"缓存命中\"></a>缓存命中</h1><blockquote>\n<p>当应用程序或软件请求数据时，会首先发生缓存命中</p>\n</blockquote>\n<h1 id=\"RAM（随机存取存储器、主存）\"><a href=\"#RAM（随机存取存储器、主存）\" class=\"headerlink\" title=\"RAM（随机存取存储器、主存）\"></a>RAM（随机存取存储器、主存）</h1><blockquote>\n<p>RAM是：与CPU直接交换数据的内存存储器</p>\n</blockquote>\n<h1 id=\"ROM（只读存储器）\"><a href=\"#ROM（只读存储器）\" class=\"headerlink\" title=\"ROM（只读存储器）\"></a>ROM（只读存储器）</h1><blockquote>\n<p>ROM是：一助攻半导体存储器,特点是一旦存储数据就无法改变或删除</p>\n</blockquote>\n<h1 id=\"驱动程序\"><a href=\"#驱动程序\" class=\"headerlink\" title=\"驱动程序\"></a>驱动程序</h1><blockquote>\n<p>驱动程序是：一个允许高级别电脑软件与硬件交互的程序</p>\n</blockquote>\n<h1 id=\"USB\"><a href=\"#USB\" class=\"headerlink\" title=\"USB\"></a>USB</h1><blockquote>\n<p>USB是：连接计算机系统与外部设备的一种串口总线标准,也是一种输入输出接口的技术规范</p>\n</blockquote>\n<h1 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h1><blockquote>\n<p>地址空间是：内存中可供程序或进程使用的有效地址规范</p>\n</blockquote>\n<h1 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h1><blockquote>\n<p>进程间通信是：指至少两个进程或线程间传送数据或信号的一些技术或方法<br>进程间的通信方式有：管道、消息队列、共享内存、信号量、信号、套接字</p>\n</blockquote>\n<ul>\n<li>管道<br>管道一种半双工的通信方式，数据只能单向流动，管道实质上是一个内核缓冲区，且以先进先出的方式存取数据。<br>管道分为命名管道和匿名管道<br>匿名管道它的优点是：简单方便；缺点是：<br>因为管道局限于单向通信且缓冲区有限, 所以它的通信效率低, 不适合进程间频繁地交换数据<br>只能在父子进程间使用<br>命名管道，和匿名管道相比，它的优点是：可以实现任意关系的进程间的通信；缺点是：<br>长期存在系统中，使用不当容易出错</li>\n<li>消息队列<br>消息队列是保存在内核中的消息链表<br>优点：可以实现任意进程间的通信，并且通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题<br>缺点：<br>消息队列不适合比较大数据的传输，因为每个消息体都有最大长度限制，同时全体消息也有总长度上限<br>通信过程中，存在用户态与内核态之间的数据拷贝开销</li>\n<li>共享内存<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<br>优点：进程可以直接读写这块内存而不需要进行数据拷贝，提高效率<br>缺点：<br>多个进程同时修改同一个共享内存，会发生冲突<br>共享内存只能在同一计算机系统中共享</li>\n<li>信号量<br>信号量是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据<br>优点：信号量解决了止多进程竞争共享资源，而造成数据的错乱的<br>缺点：信号量有限</li>\n<li>信号<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>\n<li>套接字<br>套接字通信不仅可以跨网络与不同主机的进程通信，还可以在同主机进程通信<br>优点：<br>传输数据为字节级，传输数据可自定义<br>适合客户端和服务端之间信息实时交互<br>可以加密，数据安全性强<br>缺点：需对传输的数据进行解析，转化成应用级的数据</li>\n</ul>\n<h1 id=\"目录（文件夹）\"><a href=\"#目录（文件夹）\" class=\"headerlink\" title=\"目录（文件夹）\"></a>目录（文件夹）</h1><blockquote>\n<p>目录或文件夹是：指一个装有数字文件系统的虚拟容器</p>\n</blockquote>\n<h1 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h1><blockquote>\n<p>路径是：一种电脑文件或目录的名称的通用表现形式,它指向文件系统上的一个唯一位置</p>\n</blockquote>\n<h1 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a>根目录</h1><blockquote>\n<p>根目录是：</p>\n</blockquote>\n<h1 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h1><blockquote>\n<p>文件描述符是一个用于表述指向文件的引用的抽象化概念</p>\n</blockquote>\n<h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1><blockquote>\n<p>客户端是:访问服务器提供的服务的计算硬件或软件</p>\n</blockquote>\n<h1 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h1><blockquote>\n<p>服务端是:为其他程序或设备提供功能的计算机程序或设备</p>\n</blockquote>\n",
            "tags": [
                "操作系统",
                "操作系统"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/07/08/docker/",
            "url": "https://dmqweb.cn/2024/07/08/docker/",
            "title": "Docker",
            "date_published": "2024-07-08T02:26:39.000Z",
            "content_html": "<p><img data-src=\"https://dmqweb.cn/images/Docker.pdf\" alt=\"Docker\"><br><img data-src=\"https://dmqweb.cn/images/Docker%E6%96%87%E6%A1%A3.pdf\" alt=\"Docker文档\"><br><img data-src=\"https://dmqweb.cn/images/Docker%E5%A4%A7%E7%BA%B2.pdf\" alt=\"Docker大纲\"></p>\n<h1 id=\"虚拟化技术\"><a href=\"#虚拟化技术\" class=\"headerlink\" title=\"虚拟化技术\"></a>虚拟化技术</h1><blockquote>\n<p>虚拟化是一种计算机资源管理的技术,是将计算机的各种硬件资源,比如服务器、网络、CPU、内存、以及存储等,通过抽象和转换后呈现出的一套新的硬件资源环境,在这套资源环境中可以按照操作系统 , 部署应用环境等<br>虚拟化技术打破了计算机硬件资源不可切割的障碍,提高了计算机硬件资源的利用率</p>\n</blockquote>\n<h1 id=\"虚拟机-硬件级虚拟化技术\"><a href=\"#虚拟机-硬件级虚拟化技术\" class=\"headerlink\" title=\"虚拟机(硬件级虚拟化技术)\"></a>虚拟机(硬件级虚拟化技术)</h1><blockquote>\n<p>虚拟机是使用虚拟化的技术，使用抽象逻辑对物理计算机的模拟，包含整个操作系统和其中的应用程式。</p>\n</blockquote>\n<ul>\n<li>缺点是：启动慢、使用空间很大、性能通常不高，无法完全使用计算机的性能。</li>\n</ul>\n<h1 id=\"容器-操作系统级虚拟化技术\"><a href=\"#容器-操作系统级虚拟化技术\" class=\"headerlink\" title=\"容器(操作系统级虚拟化技术)\"></a>容器(操作系统级虚拟化技术)</h1><blockquote>\n<p>容器是包含在任何环境中的运行所需的所有元素的软件包，这样容器就可以模拟化应用程序，并可以在任何地方运行。它直接调用原操作系统的能力，并屏蔽了操作系统之间的差异。</p>\n</blockquote>\n<h1 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h1><blockquote>\n<p>docker 是一个用于构建、运行和传送应用程序的平台，docker 是容器的一种实现方式。<br>docker 和虚拟机的区别在于：是否模拟构建整个操作系统的能力。</p>\n</blockquote>\n<h2 id=\"image-镜像\"><a href=\"#image-镜像\" class=\"headerlink\" title=\"image 镜像\"></a>image 镜像</h2><blockquote>\n<p>image 镜像就相当于是一个菜谱，对应用程序的执行进行模板化。参照同一个 image 镜像运行的应用程序是相同的。它包含了运行容器所需的所有那日容（代码、运行时、库、环境变量和配置文件）<br>image 镜像打包了：</p>\n</blockquote>\n<ul>\n<li>配置文件、启动命令</li>\n<li>应用程序、环境变量</li>\n<li>第三方软件库和依赖包</li>\n<li>运行时环境</li>\n<li>操作系统</li>\n</ul>\n<h2 id=\"docker-容器\"><a href=\"#docker-容器\" class=\"headerlink\" title=\"docker 容器\"></a>docker 容器</h2><blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sYWJzLnBsYXktd2l0aC1kb2NrZXIuY29tLw==\">https://labs.play-with-docker.com/</span> ,在线运行各种 docker 容器<br>docker 容器就相当于是一个根据 image 镜像创建的运行实例，在 docker 容器中包含了运行时的全部环境，它屏蔽了操作系统之间的差异，使得应用程序的可移植性非常强。</p>\n</blockquote>\n<h1 id=\"docker-的优势\"><a href=\"#docker-的优势\" class=\"headerlink\" title=\"docker 的优势\"></a>docker 的优势</h1><blockquote>\n<p>如果不使用 docker，在开发环境和测试环境中都需要对应用程序的运行环境进行配置。尤其是当应用程序十分复杂时，配置运行环境的工作就十分复杂，使用 docker 之后就相当于封装了应用程序及其对应的运行环境，并且屏蔽了操作系统之间的差异，它直接调用主机操作系统的能力运行 docker 容器。<br>例如：使用 docker 之后，我们开发环境配置好运行环境，打包成镜像之后，测试环境中直接使用镜像构建 docker 容器，运行应用程序即可，无需重新配置环境。</p>\n</blockquote>\n<h1 id=\"docker-命令\"><a href=\"#docker-命令\" class=\"headerlink\" title=\"docker 命令\"></a>docker 命令</h1><blockquote>\n<p>安装 docker 之后，就可以使用 docker 对应的命令（windows 安装后需要开启 Hyper 选项），命令行中输入对应的命令之后会交给内部的 docker daemon 进行执行，docker daemon 会将执行结果返回给命令行。</p>\n</blockquote>\n<pre><code class=\"bash\"># docker run：运行一个新的容器实例。\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n# docker start：启动一个或多个已经停止运行的容器。\ndocker start [CONTAINER...]\n# docker stop：停止一个或多个正在运行的容器。\ndocker stop [CONTAINER...]\n# docker pause：暂停容器内的所有进程。\ndocker pause [CONTAINER...]\n# docker unpause：恢复之前被暂停的容器。\ndocker unpause [CONTAINER...]\n# docker restart：重启容器。\ndocker restart [CONTAINER...]\n# docker rm：删除一个或多个容器。\ndocker rm [CONTAINER...]\n# docker rmi：删除一个或多个镜像。\ndocker rmi [OPTIONS] IMAGE [IMAGE...]\n# docker ps：列出当前正在运行的容器。\ndocker ps [OPTIONS]\n# docker images：列出本地的镜像。\ndocker images [OPTIONS] [REPOSITORY[:TAG]]\n# docker build：根据 Dockerfile 构建镜像。\ndocker build [OPTIONS] PATH | URL | -\n# docker pull：从远程仓库拉取镜像或仓库到本地。\ndocker pull [OPTIONS] NAME[:TAG|@DIGEST]\n# docker push：将本地的镜像或仓库推送到远程仓库。\ndocker push [OPTIONS] NAME[:TAG]\n# docker login：登录到一个 Docker 远程仓库。\ndocker login [OPTIONS] [SERVER] USERNAME\n# docker logout：从 Docker 远程仓库登出。\ndocker logout [SERVER]\n# docker exec：在运行的容器中执行命令。\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n# docker logs：获取容器的日志。\ndocker logs [OPTIONS] CONTAINER\n# docker network：管理 Docker 网络设置。\ndocker network [OPTIONS]\n# docker volume：管理 Docker 数据卷。\ndocker volume [OPTIONS]\n# docker inspect：获取容器、镜像、网络或数据卷的详细信息。\ndocker inspect [OPTIONS] NAME|ID [NAME|ID...]\n# docker prune：删除未使用的 Docker 对象，如容器、镜像、网络、数据卷。\ndocker prune [OPTIONS]\n# docker stats：实时显示容器的资源使用情况。\ndocker stats [OPTIONS] [CONTAINER...]\n# docker-compose：使用 Docker Compose 工具管理多容器 Docker 应用程序。\ndocker-compose [OPTIONS] [COMMAND] [ARGS...]\n</code></pre>\n<h1 id=\"容器化\"><a href=\"#容器化\" class=\"headerlink\" title=\"容器化\"></a>容器化</h1><blockquote>\n<p>如何将应用程序和运行时的环境打包成一个镜像呢（）容器化？这时候就需要配置 dockerfile 定义容器的构建过程,构建镜像。最后使用 docker 命令镜像创建和运行容器（docker build -t app-name . 和 docker run -p 8080:8080 app-name）</p>\n</blockquote>\n<h1 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h1><blockquote>\n<p>dockerfile 文件用于定义软件依赖的构建过程，确保应用程序的依赖项得到满足。alpine 是一个轻量的 linx 发行版。</p>\n</blockquote>\n<pre><code class=\"dockerfile\"># Docker镜像是一层一层进行构建的\n# 指定对应的操作系统和版本，alpine是linx轻量级的发行版\nFROM node:14-alpine\n# 使用COPY命令，将文件复制到镜像中\nCOPY index.js /index.js\n# 运行应用程序\n# CMD [&quot;node&quot;,&quot;/index.js&quot;] 或者\nCMD node /index.js\n# 此时使用docker build -t docker-name:版本号 . 就可以构建docker镜像，不指定版本号默认是latest\n# 使用docker image ls 可以查看所有的镜像\n# 使用docker run docker-name 运行镜像\n# 将容器推送到远程镜像仓库：docker push your-dockerhub-username/your-app-name:tag\n# 如果想要根据这个镜像创建docker容器，只需要拿到Dockerfile文件，运行上述命令即可\n# 通常将应用程序上传到docker hub中，后面通过docker pull docker-name 进行拉取\n</code></pre>\n<h1 id=\"volumes-逻辑卷\"><a href=\"#volumes-逻辑卷\" class=\"headerlink\" title=\"volumes 逻辑卷\"></a>volumes 逻辑卷</h1><blockquote>\n<p>volumes 逻辑卷是 Docker 中用于存储数据的，因为 docker 中的数据是不会进行持久化的。它通常以一个干净的文件开始，容器启动之后，可以在容器中创建文件和修改文件，但是当容器停止之后，数据并不会持久化，从而丢失，这时候就要在 Docker Compose 中使用 volumes 逻辑卷<br>volumes 逻辑卷可以将容器中的目录或者指定路径映射到宿主机的某一个目录或者位置上，从而实现数据的持久化。</p>\n</blockquote>\n<h1 id=\"Dev-Environments\"><a href=\"#Dev-Environments\" class=\"headerlink\" title=\"Dev Environments\"></a>Dev Environments</h1><blockquote>\n<p>docker desktop 中的一个功能，可以将自己当前环境分享给其他人，从而共享开发环境。</p>\n</blockquote>\n<h1 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker Compose\"></a>Docker Compose</h1><p>容器编排工具</p>\n<blockquote>\n<p>一个项目中需要的应用程序和应用程序（容器）间的逻辑是十分复杂的，统一管理他们的启动和停止非常麻烦，Docker Compose 用一个 YAML 文件，定义和运行多容器 Docker 应用程序，其中可以配置多个容器、网络和数据卷等，以便在隔离的环境中快速启动和停止整个应用程序。</p>\n</blockquote>\n<p><strong>Docker Compose 的作用：</strong></p>\n<ul>\n<li>多容器管理：Docker Compose 允许你在一个文件中定义多个容器，统一管理它们的启动和停止。</li>\n<li>环境一致性：通过使用 Compose，你可以在不同的机器和环境中保持应用程序的一致性，因为它定义了应用程序的完整运行环境。</li>\n<li>配置简化：Compose 使用 YAML 格式，使得配置更加简洁和易于理解。</li>\n<li>服务依赖管理：Compose 可以处理容器之间的依赖关系，确保在启动和停止时按正确的顺序操作。</li>\n<li>网络配置：Compose 允许定义自定义网络，使容器之间能够相互发现和通信。</li>\n<li>数据卷管理：可以配置数据卷，以便在容器之间共享数据或持久化数据。</li>\n<li>扩展性：Compose 支持扩展服务，允许你指定服务运行的容器数量。</li>\n<li>自动化：通过简单的命令，Compose 可以自动构建、启动或停止整个应用程序。</li>\n</ul>\n<p><strong>docker-compose.yml</strong></p>\n<pre><code class=\"yaml\">version: &quot;3.8&quot; # 指定 docker-compose 的版本\n\nservices:\n  web:\n    image: nginx:alpine # 使用官方的 nginx 镜像（基于 Alpine 版本）\n    ports:\n      - &quot;80:80&quot; # 将容器的 80 端口映射到宿主机的 80 端口\n    volumes:\n      - ./src:/usr/share/nginx/html # 挂载当前目录下的 src 文件夹到容器的 nginx HTML 目录\n    depends_on:\n      - app # 表示 web 服务依赖于 app 服务\n\n  app:\n    build: ./app # 构建当前目录下 app 文件夹中的 Dockerfile\n    expose:\n      - &quot;9000&quot; # 暴露容器内部的 9000 端口，供其他服务访问，但不映射到宿主机\n    environment:\n      - APP_ENV=production # 设置环境变量\n    volumes:\n      - ./app:/var/www # 挂载当前目录下的 app 文件夹到容器的 /var/www 目录\n\n  db:\n    image: mysql:5.7 # 使用官方的 MySQL 5.7 镜像\n    volumes:\n      - db-data:/var/lib/mysql # 挂载卷 db-data 到容器的 MySQL 数据目录\n    environment:\n      - MYSQL_ROOT_PASSWORD=rootpassword # 设置 MySQL root 用户的密码\n      - MYSQL_DATABASE=myappdb # 创建并使用名为 myappdb 的数据库\n\nvolumes:\n  db-data: # 定义一个名为 db-data 的卷，用于持久化 MySQL 数据\n</code></pre>\n<p><code>docker-compose.yml</code>文件将一组互相关联的容器组合在一起，然后使用<code>docker compose up</code>命令（包含 docker-compose.yml 的文件中执行）即可启动整个应用程序。</p>\n<p>docker-compose.yml 可以结合 CI&#x2F;CD 工具，集成到自动化工作流中，实现从开发到部署的自动化。</p>\n<h1 id=\"Kubernetes\"><a href=\"#Kubernetes\" class=\"headerlink\" title=\"Kubernetes\"></a>Kubernetes</h1><p>Kubernetes 和 Docker Compose 类似，是一种容器编排工具，用于管理和部署容器化应用程序。但是 Kubernetes 相比之下更适合大规模的生产环境和复杂的容器编排需求。</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>k8s 和 Docker Compose 的区别</p>\n<ol>\n<li>功能和规模：<ul>\n<li>Docker Compose 是一个简单的工具，用于定义和运行多个 Docker 容器组成的应用程序。它适用于单机或简单的多机环境，并提供了一种简化的方式来定义容器之间的依赖关系和配置。</li>\n<li>Kubernetes 是一个更强大和复杂的容器编排平台，用于管理大规模的容器集群。它可以自动化容器的部署、扩展、负载均衡、故障恢复等操作，并提供了更丰富的功能和管理能力。</li>\n</ul>\n</li>\n<li>架构和部署方式：<ul>\n<li>Docker Compose 使用单个 YAML 文件来定义整个应用程序的配置和服务之间的关系。它可以在单个主机上使用<code>docker-compose</code>命令进行部署和管理。</li>\n<li>Kubernetes 使用一组 YAML 文件来定义应用程序的各个组件和资源，并通过 Kubernetes API 进行管理。它需要一个 Kubernetes 集群来部署和运行应用程序。</li>\n</ul>\n</li>\n<li>可扩展性和弹性：<ul>\n<li>Docker Compose 适用于小型应用程序或开发&#x2F;测试环境，它的扩展性和弹性有限。它可以在单个主机上运行多个容器，但无法自动进行水平扩展或故障恢复。</li>\n<li>Kubernetes 设计用于大规模的生产环境，具有强大的扩展性和弹性。它可以自动进行容器的水平扩展、负载均衡和故障恢复，以确保应用程序的高可用性和性能。</li>\n</ul>\n</li>\n<li>社区和生态系统：<ul>\n<li>Docker Compose 是 Docker 官方提供的工具，拥有庞大的用户社区和丰富的生态系统。它与 Docker Engine 紧密集成，并且易于上手和使用。</li>\n<li>Kubernetes 是由 Google 开源并托管在 Cloud Native Computing Foundation（CNCF）下的项目，也拥有庞大的用户社区和活跃的开发者社区。它有许多第三方工具和插件，可以扩展其功能和集成其他系统。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，Docker Compose 适用于简单的应用程序部署和开发&#x2F;测试环境，而 Kubernetes 适用于大规模的生产环境和复杂的容器编排需求。根据实际需求和规模选择合适的工具</p>\n",
            "tags": [
                "Docker",
                "Docker"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/07/07/gitlab-cicd/",
            "url": "https://dmqweb.cn/2024/07/07/gitlab-cicd/",
            "title": "gitlab cicd",
            "date_published": "2024-07-07T06:26:39.000Z",
            "content_html": "<h1 id=\"CICD\"><a href=\"#CICD\" class=\"headerlink\" title=\"CICD\"></a>CICD</h1><p>CI：持续集成</p>\n<p>CD：持续交付</p>\n<p>CD：持续部署</p>\n<h3 id=\"上线流程\"><a href=\"#上线流程\" class=\"headerlink\" title=\"上线流程\"></a>上线流程</h3><blockquote>\n<p>发布上线流程举例：git 上传，开始跑测试，进行打包，使用 docker 容器化镜像打包，推送到 dev 开发环境，部署到 staging 测试环境，最后部署到 production 生产环境</p>\n</blockquote>\n<h3 id=\"pipeline\"><a href=\"#pipeline\" class=\"headerlink\" title=\"pipeline\"></a>pipeline</h3><blockquote>\n<p>一次 pipeline 就相当于一次构建任务，里面可以包含多个流程，如：安装依赖，跑测试代码，eslint 校验，编译，部署测试服务器，部署生产服务器等流程，任何提交或者 Merge Request 的合并都可以触发 Pipeline。</p>\n</blockquote>\n<h3 id=\"runner\"><a href=\"#runner\" class=\"headerlink\" title=\"runner\"></a>runner</h3><blockquote>\n<p>一个 runner 就相当于一个打工仔，可以下载 gitlab runner 之后注册多个 runner，并且指定对应的 runner 执行任务。</p>\n</blockquote>\n<h1 id=\"gitlab-ci-yml-文件\"><a href=\"#gitlab-ci-yml-文件\" class=\"headerlink\" title=\".gitlab-ci.yml 文件\"></a>.gitlab-ci.yml 文件</h1><pre><code class=\"yaml\"># 一项代表一个pipeline作业\nhelloworld:\n  stage: linter\n  script:\n    - echo &quot;hello world,Gitlab!&quot;\n    - chmod +x ./run.sh # 将run.sh文件添加可执行权限\n    - ./run.sh # 将执行过程提取成可执行文件进行执行\n\n# 私密使用（不想暴露到代码中）的环境变量，可以在平台上进行设置\nvariables: # 全局的环境变量，还有一些内置的环境变量，例如：$CI_PIPELINE_SOURCE 详见文档\n  my_password: &quot;全局的配置变量&quot;\n\nrun_unit_tests:\n  variables: # 任务中配置变量，使用时加上$符号\n    my_password: &quot;iamsomepassword...&quot;\n  stage: testing\n  script:\n    - echo &quot;执行单元测试&quot;\n\n# 配置运行的容器镜像\nimage: alpine:latest\n\nbefore_script:\n  image: node:3.1.2-alpine3.16 # 配置单项作业运行的容器镜像\n  stage: build\n  needs: # 同一个stage中，通过needs来指定工作的相依性\n    - bad_job\n  script:\n    - echo &quot;安装套件&quot;\n    - echo &quot;设定资料链接&quot;\n\nworkflow: # 配置工作流\n  rules: # 当main分支commit时，才启动工作流程\n    - if: $CI_COMMIT_BRANCH == &quot;main&quot; # $CI_COMMIT_BRANCH是内置的环境变量\n      when: always\n    - when: never\n\nafter_script:\n  stage: deplpy\n  script:\n    - echo &quot;删除不必要的文件&quot;\n\nbuild_docker_image:\n  only: # 指定只有推送到main分支上才会执行，指定哪些分支不执行使用：except\n    - main\n  state: build\n  script:\n    - echo &quot;building docker image&quot;\n\nbad_job: # 假设错误的任务，则会中断当前工作的执行，每个工作独立执行\n  tags: # 指定runner(打工仔)进行执行，在注册runner时会创建一个tags\n    - runner_tags\n    - uname # 验证当前在runner中执行\n  stage: build\n  script: script:no_script\n\n# 建立舞台，使得工作按照指定先后顺序执行\nstages:\n  - linter\n  - testing\n  - build\n  - deploy\n# 服务端去官网安装gitlab runner，使用runner（打工仔）分配工作\n# 接着启动服务\n# 然后将这个服务进行注册（配置在gitlab runner的配置中）\n# runner分为：shared runner、 group runners和specific runners三种\n# 可以为某个群组设置runner，例如在群组中设置runner配置，服务中注册一个runner进行配置\n</code></pre>\n",
            "tags": [
                "gitlab cicd",
                "gitlab cicd"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/",
            "url": "https://dmqweb.cn/2024/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/",
            "title": "设计模式与设计原则",
            "date_published": "2024-07-07T06:26:39.000Z",
            "content_html": "<p>注：本教程总结自《设计模式之争》和《大话设计模式》，对设计模式感兴趣的同学强烈推荐这两本书。</p>\n<h1 id=\"23-种设计模式\"><a href=\"#23-种设计模式\" class=\"headerlink\" title=\"23 种设计模式\"></a>23 种设计模式</h1><h2 id=\"创建型\"><a href=\"#创建型\" class=\"headerlink\" title=\"创建型\"></a>创建型</h2><ul>\n<li><p>单例模式</p>\n</li>\n<li><p>原型模式</p>\n</li>\n<li><p>工厂模式</p>\n</li>\n<li><p>抽象工厂模式</p>\n</li>\n<li><p>建造者模式</p>\n</li>\n</ul>\n<h2 id=\"结构型\"><a href=\"#结构型\" class=\"headerlink\" title=\"结构型\"></a>结构型</h2><ul>\n<li><p>适配器模式</p>\n</li>\n<li><p>装饰器模式</p>\n</li>\n<li><p>代理模式</p>\n</li>\n<li><p>外观模式</p>\n</li>\n<li><p>桥接模式</p>\n</li>\n<li><p>组合模式</p>\n</li>\n<li><p>享元模式</p>\n</li>\n</ul>\n<h2 id=\"行为型\"><a href=\"#行为型\" class=\"headerlink\" title=\"行为型\"></a>行为型</h2><ul>\n<li><p>观察者模式</p>\n</li>\n<li><p>迭代器模式</p>\n</li>\n<li><p>策略模式</p>\n</li>\n<li><p>模板方法模式</p>\n</li>\n<li><p>职责链模式</p>\n</li>\n<li><p>命令模式</p>\n</li>\n<li><p>备忘录模式</p>\n</li>\n<li><p>状态模式</p>\n</li>\n<li><p>访问者模式</p>\n</li>\n<li><p>中介者模式</p>\n</li>\n<li><p>解释器模式</p>\n</li>\n</ul>\n<h1 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h1><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p>\n<pre><code class=\"javascript\">class Product &#123;\n  constructor(name) &#123;\n    this.name = name;\n  &#125;\n  init() &#123;\n    console.log(&quot;init&quot;);\n  &#125;\n  fun() &#123;\n    console.log(&quot;fun&quot;);\n  &#125;\n&#125;\nclass Factory &#123;\n  create(name) &#123;\n    return new Product(name);\n  &#125;\n&#125;\n// use\nlet factory = new Factory();\nlet p = factory.create(&quot;p1&quot;);\np.init();\np.fun();\n</code></pre>\n<ul>\n<li>适用场景</li>\n</ul>\n<p>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择<br>将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式；<br>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>创建对象的过程可能很复杂，但我们只需要关心创建结果。<br>构造函数和创建者分离, 符合“开闭原则”<br>一个调用者想创建一个对象，只要知道其名称就可以了。<br>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度<br>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</p>\n<ul>\n<li>什么时候不用<br>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。<br>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。<br>例子</li>\n</ul>\n<p>曾经我们熟悉的 JQuery 的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的 jQuery 对象</p>\n<pre><code class=\"javascript\">class jQuery &#123;\n  constructor(selector) &#123;\n    super(selector);\n  &#125;\n  add() &#123;&#125;\n  // 此处省略若干 API\n&#125;\nwindow.$ = function (selector) &#123;\n  return new jQuery(selector);\n&#125;;\n</code></pre>\n<ul>\n<li>vue 的异步组件</li>\n</ul>\n<p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p>\n<pre><code class=\"javascript\">Vue.component(&quot;async-example&quot;, function (resolve, reject) &#123;\n  setTimeout(function () &#123;\n    // 向 `resolve` 回调传递组件定义\n    resolve(&#123;\n      template: &quot;&lt;div&gt;I am async!&lt;/div&gt;&quot;,\n    &#125;);\n  &#125;, 1000);\n&#125;);\n</code></pre>\n<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>一个类只有一个实例，并提供一个访问它的全局访问点。</p>\n<pre><code class=\"javascript\">class LoginForm &#123;\n  constructor() &#123;\n    this.state = &quot;hide&quot;;\n  &#125;\n  show() &#123;\n    if (this.state === &quot;show&quot;) &#123;\n      alert(&quot;已经显示&quot;);\n      return;\n    &#125;\n    this.state = &quot;show&quot;;\n    console.log(&quot;登录框显示成功&quot;);\n  &#125;\n  hide() &#123;\n    if (this.state === &quot;hide&quot;) &#123;\n      alert(&quot;已经隐藏&quot;);\n      return;\n    &#125;\n    this.state = &quot;hide&quot;;\n    console.log(&quot;登录框隐藏成功&quot;);\n  &#125;\n&#125;\nLoginForm.getInstance = (function () &#123;\n  let instance;\n  return function () &#123;\n    if (!instance) &#123;\n      instance = new LoginForm();\n    &#125;\n    return instance;\n  &#125;;\n&#125;)();\nlet obj1 = LoginForm.getInstance();\nobj1.show();\n\nlet obj2 = LoginForm.getInstance();\nobj2.hide();\nconsole.log(obj1 === obj2);\n</code></pre>\n<ul>\n<li>优点</li>\n</ul>\n<p>划分命名空间，减少全局变量<br>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护<br>且只会实例化一次。简化了代码的调试和维护</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</p>\n<ul>\n<li>场景例子</li>\n</ul>\n<p>定义命名空间和实现分支型方法<br>登录框<br>vuex 和 redux 中的 store</p>\n<h1 id=\"适配器模式0\"><a href=\"#适配器模式0\" class=\"headerlink\" title=\"适配器模式0\"></a>适配器模式0</h1><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。</p>\n<pre><code class=\"javascript\">class Plug &#123;\n  getName() &#123;\n    return &quot;iphone 充电头&quot;;\n  &#125;\n&#125;\nclass Target &#123;\n  constructor() &#123;\n    this.plug = new Plug();\n  &#125;\n  getName() &#123;\n    return this.plug.getName() + &quot; 适配器 Type-c 充电头&quot;;\n  &#125;\n&#125;\nlet target = new Target();\ntarget.getName(); // iphone 充电头 适配器转 Type-c 充电头\n</code></pre>\n<ul>\n<li>优点</li>\n</ul>\n<p>可以让任何两个没有关联的类一起运行。<br>提高了类的复用。<br>适配对象，适配库，适配数据</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)<br>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</p>\n<ul>\n<li>场景</li>\n</ul>\n<p>整合第三方 SDK<br>封装旧接口</p>\n<p>自己封装的 ajax， 使用方式如下</p>\n<pre><code class=\"javascript\">ajax(&#123;\n  url: &quot;/getData&quot;,\n  type: &quot;Post&quot;,\n  dataType: &quot;json&quot;,\n  data: &#123;\n    test: 111,\n  &#125;,\n&#125;).done(function () &#123;&#125;);\n// 因为历史原因，代码中全都是：\n// $.ajax(&#123;....&#125;)\n\n// 做一层适配器\nvar $ = &#123;\n  ajax: function (options) &#123;\n    return ajax(options);\n  &#125;,\n&#125;;\n</code></pre>\n<p>vue 的 computed</p>\n<pre><code>&lt;template&gt;\n  &lt;div id=&quot;example&quot;&gt;\n    &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;\n    &lt;!-- Hello --&gt;\n    &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;\n    &lt;!-- olleH --&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nexport default &#123;\n  name: &quot;demo&quot;,\n  data() &#123;\n    return &#123;\n      message: &quot;Hello&quot;,\n    &#125;;\n  &#125;,\n  computed: &#123;\n    reversedMessage: function () &#123;\n      return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;);\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\nexport default &#123;\n  name: &quot;demo&quot;,\n  data() &#123;\n    return &#123;\n      message: &quot;Hello&quot;,\n    &#125;;\n  &#125;,\n  computed: &#123;\n    reversedMessage: function () &#123;\n      return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;);\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>原有 data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式<br>不同点<br>适配器与代理模式相似</p>\n<p>适配器模式： 提供一个不同的接口（如不同版本的插头）<br>代理模式： 提供一模一样的接口</p>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><p>动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案<br>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</p>\n<pre><code class=\"javascript\">class Cellphone &#123;\n  create() &#123;\n    console.log(&quot;生成一个手机&quot;);\n  &#125;\n&#125;\nclass Decorator &#123;\n  constructor(cellphone) &#123;\n    this.cellphone = cellphone;\n  &#125;\n  create() &#123;\n    this.cellphone.create();\n    this.createShell(cellphone);\n  &#125;\n  createShell() &#123;\n    console.log(&quot;生成手机壳&quot;);\n  &#125;\n&#125;\n// 测试代码\nlet cellphone = new Cellphone();\ncellphone.create();\n\nconsole.log(&quot;------------&quot;);\nlet dec = new Decorator(cellphone);\ndec.create();\n</code></pre>\n<ul>\n<li>场景例子</li>\n</ul>\n<p>比如现在有 4 种型号的自行车，我们为每种自行车都定义了一个单<br>独的类。现在要给每种自行车都装上前灯、尾<br>灯和铃铛这 3 种配件。如果使用继承的方式来给<br>每种自行车创建子类，则需要 4×3 &#x3D; 12 个子类。<br>但是如果把前灯、尾灯、铃铛这些对象动态组<br>合到自行车上面，则只需要额外增加 3 个类<br>ES7 Decorator 阮一峰<br>core-decorators</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。<br>方便动态的扩展功能，且提供了比继承更多的灵活性。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>多层装饰比较复杂。<br>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><blockquote>\n<p>代理模式和中介者模式的区别在于：代理模式往往是一对一的，但中介模式往往是一对多。<br>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>\n</blockquote>\n<p>假设当 A 在心情好的时候收到花，小明表白成功的几率有<br>60%，而当 A 在心情差的时候收到花，小明表白的成功率无限趋近于 0。<br>小明跟 A 刚刚认识两天，还无法辨别 A 什么时候心情好。如果不合时宜地把花送给 A，花<br>被直接扔掉的可能性很大，这束花可是小明吃了 7 天泡面换来的。<br>但是 A 的朋友 B 却很了解 A，所以小明只管把花交给 B，B 会监听 A 的心情变化，然后选<br>择 A 心情好的时候把花转交给 A，代码如下：</p>\n<pre><code class=\"javascript\">let Flower = function () &#123;&#125;;\nlet xiaoming = &#123;\n  sendFlower: function (target) &#123;\n    let flower = new Flower();\n    target.receiveFlower(flower);\n  &#125;,\n&#125;;\nlet B = &#123;\n  receiveFlower: function (flower) &#123;\n    A.listenGoodMood(function () &#123;\n      A.receiveFlower(flower);\n    &#125;);\n  &#125;,\n&#125;;\nlet A = &#123;\n  receiveFlower: function (flower) &#123;\n    console.log(&quot;收到花&quot; + flower);\n  &#125;,\n  listenGoodMood: function (fn) &#123;\n    setTimeout(function () &#123;\n      fn();\n    &#125;, 1000);\n  &#125;,\n&#125;;\nxiaoming.sendFlower(B);\n</code></pre>\n<ul>\n<li>场景</li>\n</ul>\n<p>HTML 元 素事件代理</p>\n<pre><code>&lt;template&gt;\n  &lt;ul id=&quot;ul&quot;&gt;\n    &lt;li&gt;1&lt;/li&gt;\n    &lt;li&gt;2&lt;/li&gt;\n    &lt;li&gt;3&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n&lt;script&gt;\nlet ul = document.querySelector(&quot;#ul&quot;);\nul.addEventListener(&quot;click&quot;, (event) =&gt; &#123;\n  console.log(event.target);\n&#125;);\n&lt;/script&gt;\n</code></pre>\n<p>ES6 的 proxy 阮一峰 Proxy<br>jQuery.proxy()方法</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用<br>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</p>\n<ul>\n<li><p>缺点<br>处理请求速度可能有差别，非直接访问存在开销</p>\n</li>\n<li><p>不同点<br>装饰者模式实现上和代理模式类似</p>\n</li>\n</ul>\n<p>装饰者模式： 扩展功能，原有功能不变且可直接使用<br>代理模式： 显示原有功能，但是经过限制之后的</p>\n<h1 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h1><p>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用<br>兼容浏览器事件绑定</p>\n<pre><code class=\"javascript\">let addMyEvent = function (el, ev, fn) &#123;\n  if (el.addEventListener) &#123;\n    el.addEventListener(ev, fn, false);\n  &#125; else if (el.attachEvent) &#123;\n    el.attachEvent(&quot;on&quot; + ev, fn);\n  &#125; else &#123;\n    el[&quot;on&quot; + ev] = fn;\n  &#125;\n&#125;;\n\n// 封装接口\nlet myEvent = &#123;\n  // ...\n  stop: (e) =&gt; &#123;\n    e.stopPropagation();\n    e.preventDefault();\n  &#125;,\n&#125;;\n</code></pre>\n<p>场景</p>\n<p>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade<br>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖。<br>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作。</p>\n<p>参考： 大话设计模式</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>减少系统相互依赖。<br>提高灵活性。<br>提高了安全性</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>\n<p>观察者模式<br>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p>\n<h1 id=\"发布-amp-订阅\"><a href=\"#发布-amp-订阅\" class=\"headerlink\" title=\"发布 &amp; 订阅\"></a>发布 &amp; 订阅</h1><ul>\n<li>一对多</li>\n</ul>\n<pre><code class=\"javascript\">// 主题 保存状态，状态变化之后触发所有观察者对象\nclass Subject &#123;\n  constructor() &#123;\n    this.state = 0;\n    this.observers = [];\n  &#125;\n  getState() &#123;\n    return this.state;\n  &#125;\n  setState(state) &#123;\n    this.state = state;\n    this.notifyAllObservers();\n  &#125;\n  notifyAllObservers() &#123;\n    this.observers.forEach((observer) =&gt; &#123;\n      observer.update();\n    &#125;);\n  &#125;\n  attach(observer) &#123;\n    this.observers.push(observer);\n  &#125;\n&#125;\n// 观察者\nclass Observer &#123;\n  constructor(name, subject) &#123;\n    this.name = name;\n    this.subject = subject;\n    this.subject.attach(this);\n  &#125;\n  update() &#123;\n    console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`);\n  &#125;\n&#125;\n// 测试\nlet s = new Subject();\nlet o1 = new Observer(&quot;o1&quot;, s);\nlet o2 = new Observer(&quot;02&quot;, s);\n\ns.setState(12);\n</code></pre>\n<ul>\n<li>场景</li>\n</ul>\n<p>DOM 事件</p>\n<pre><code class=\"javascript\">document.body.addEventListener(&quot;click&quot;, function () &#123;\n  console.log(&quot;hello world!&quot;);\n&#125;);\ndocument.body.click();\n</code></pre>\n<p>vue 响应式</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>支持简单的广播通信，自动通知所有已经订阅过的对象<br>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用<br>增加了灵活性<br>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p>\n<ul>\n<li>缺点<br>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</li>\n</ul>\n<h1 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h1><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</p>\n<pre><code class=\"javascript\">// 状态 （弱光、强光、关灯）\nclass State &#123;\n  constructor(state) &#123;\n    this.state = state;\n  &#125;\n  handle(context) &#123;\n    console.log(`this is $&#123;this.state&#125; light`);\n    context.setState(this);\n  &#125;\n&#125;\nclass Context &#123;\n  constructor() &#123;\n    this.state = null;\n  &#125;\n  getState() &#123;\n    return this.state;\n  &#125;\n  setState(state) &#123;\n    this.state = state;\n  &#125;\n&#125;\n// test\nlet context = new Context();\nlet weak = new State(&quot;weak&quot;);\nlet strong = new State(&quot;strong&quot;);\nlet off = new State(&quot;off&quot;);\n// 弱光\nweak.handle(context);\nconsole.log(context.getState());\n// 强光\nstrong.handle(context);\nconsole.log(context.getState());\n// 关闭\noff.handle(context);\nconsole.log(context.getState());\n</code></pre>\n<p>场景</p>\n<p>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为<br>一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便<br>状态与状态间，行为与行为间彼此独立互不干扰<br>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>会在系统中定义许多状态类<br>逻辑分散</p>\n<h1 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h1><p>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>\n<pre><code class=\"javascript\">class Iterator &#123;\n  constructor(conatiner) &#123;\n    this.list = conatiner.list;\n    this.index = 0;\n  &#125;\n  next() &#123;\n    if (this.hasNext()) &#123;\n      return this.list[this.index++];\n    &#125;\n    return null;\n  &#125;\n  hasNext() &#123;\n    if (this.index &gt;= this.list.length) &#123;\n      return false;\n    &#125;\n    return true;\n  &#125;\n&#125;\nclass Container &#123;\n  constructor(list) &#123;\n    this.list = list;\n  &#125;\n  getIterator() &#123;\n    return new Iterator(this);\n  &#125;\n&#125;\n// 测试代码\nlet container = new Container([1, 2, 3, 4, 5]);\nlet iterator = container.getIterator();\nwhile (iterator.hasNext()) &#123;\n  console.log(iterator.next());\n&#125;\n</code></pre>\n<ul>\n<li>场景例子</li>\n</ul>\n<p>Array.prototype.forEach<br>jQuery 中的$.each()<br>ES6 Iterator</p>\n<ul>\n<li>特点</li>\n</ul>\n<p>访问一个聚合对象的内容而无需暴露它的内部表示。<br>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</p>\n<ul>\n<li>总结<br>对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式</li>\n</ul>\n<h1 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h1><p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>\n<pre><code class=\"javascript\">class Color &#123;\n  constructor(name) &#123;\n    this.name = name;\n  &#125;\n&#125;\nclass Shape &#123;\n  constructor(name, color) &#123;\n    this.name = name;\n    this.color = color;\n  &#125;\n  draw() &#123;\n    console.log(`$&#123;this.color.name&#125; $&#123;this.name&#125;`);\n  &#125;\n&#125;\n\n//测试\nlet red = new Color(&quot;red&quot;);\nlet yellow = new Color(&quot;yellow&quot;);\nlet circle = new Shape(&quot;circle&quot;, red);\ncircle.draw();\nlet triangle = new Shape(&quot;triangle&quot;, yellow);\ntriangle.draw();\n</code></pre>\n<ul>\n<li>优点</li>\n</ul>\n<p>有助于独立地管理各组成部分， 把抽象化与实现化解耦<br>提高可扩充性</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少。</p>\n<h1 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h1><p>将对象组合成树形结构，以表示“整体-部分”的层次结构。<br>通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性。</p>\n<pre><code class=\"javascript\">class TrainOrder &#123;\n  create() &#123;\n    console.log(&quot;创建火车票订单&quot;);\n  &#125;\n&#125;\nclass HotelOrder &#123;\n  create() &#123;\n    console.log(&quot;创建酒店订单&quot;);\n  &#125;\n&#125;\nclass TotalOrder &#123;\n  constructor() &#123;\n    this.orderList = [];\n  &#125;\n  addOrder(order) &#123;\n    this.orderList.push(order);\n    return this;\n  &#125;\n  create() &#123;\n    this.orderList.forEach((item) =&gt; &#123;\n      item.create();\n    &#125;);\n    return this;\n  &#125;\n&#125;\n// 可以在购票网站买车票同时也订房间\nlet train = new TrainOrder();\nlet hotel = new HotelOrder();\nlet total = new TotalOrder();\ntotal.addOrder(train).addOrder(hotel).create();\n</code></pre>\n<ul>\n<li>场景</li>\n</ul>\n<p>表示对象-整体层次结构<br>希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）</p>\n<ul>\n<li>缺点<br>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</li>\n</ul>\n<h1 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h1><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>\n<pre><code class=\"javascript\">class Person &#123;\n  constructor(name) &#123;\n    this.name = name;\n  &#125;\n  getName() &#123;\n    return this.name;\n  &#125;\n&#125;\nclass Student extends Person &#123;\n  constructor(name) &#123;\n    super(name);\n  &#125;\n  sayHello() &#123;\n    console.log(`Hello， My name is $&#123;this.name&#125;`);\n  &#125;\n&#125;\nlet student = new Student(&quot;xiaoming&quot;);\nstudent.sayHello();\n</code></pre>\n<p>原型模式，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升。</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;策略模式-校验表单&lt;/title&gt;\n    &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;form id=&quot;registerForm&quot; method=&quot;post&quot; action=&quot;http://xxxx.com/api/register&quot;&gt;\n      用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot; /&gt; 密码：&lt;input\n        type=&quot;text&quot;\n        name=&quot;password&quot;\n      /&gt;\n      手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot; /&gt;\n      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;\n    &lt;/form&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n      // 策略对象\n      const strategies = &#123;\n        isNoEmpty: function (value, errorMsg) &#123;\n          if (value === &quot;&quot;) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n        isNoSpace: function (value, errorMsg) &#123;\n          if (value.trim() === &quot;&quot;) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n        minLength: function (value, length, errorMsg) &#123;\n          if (value.trim().length &lt; length) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n        maxLength: function (value, length, errorMsg) &#123;\n          if (value.length &gt; length) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n        isMobile: function (value, errorMsg) &#123;\n          if (\n            !/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$/.test(\n              value\n            )\n          ) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n      &#125;;\n      // 验证类\n      class Validator &#123;\n        constructor() &#123;\n          this.cache = [];\n        &#125;\n        add(dom, rules) &#123;\n          for (let i = 0, rule; (rule = rules[i++]); ) &#123;\n            let strategyAry = rule.strategy.split(&quot;:&quot;);\n            let errorMsg = rule.errorMsg;\n            this.cache.push(() =&gt; &#123;\n              let strategy = strategyAry.shift();\n              strategyAry.unshift(dom.value);\n              strategyAry.push(errorMsg);\n              return strategies[strategy].apply(dom, strategyAry);\n            &#125;);\n          &#125;\n        &#125;\n        start() &#123;\n          for (let i = 0, validatorFunc; (validatorFunc = this.cache[i++]); ) &#123;\n            let errorMsg = validatorFunc();\n            if (errorMsg) &#123;\n              return errorMsg;\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n      // 调用代码\n      let registerForm = document.getElementById(&quot;registerForm&quot;);\n      let validataFunc = function () &#123;\n        let validator = new Validator();\n        validator.add(registerForm.userName, [\n          &#123;\n            strategy: &quot;isNoEmpty&quot;,\n            errorMsg: &quot;用户名不可为空&quot;,\n          &#125;,\n          &#123;\n            strategy: &quot;isNoSpace&quot;,\n            errorMsg: &quot;不允许以空白字符命名&quot;,\n          &#125;,\n          &#123;\n            strategy: &quot;minLength:2&quot;,\n            errorMsg: &quot;用户名长度不能小于2位&quot;,\n          &#125;,\n        ]);\n        validator.add(registerForm.password, [\n          &#123;\n            strategy: &quot;minLength:6&quot;,\n            errorMsg: &quot;密码长度不能小于6位&quot;,\n          &#125;,\n        ]);\n        validator.add(registerForm.phoneNumber, [\n          &#123;\n            strategy: &quot;isMobile&quot;,\n            errorMsg: &quot;请输入正确的手机号码格式&quot;,\n          &#125;,\n        ]);\n        return validator.start();\n      &#125;;\n\n      registerForm.onsubmit = function () &#123;\n        let errorMsg = validataFunc();\n        if (errorMsg) &#123;\n          alert(errorMsg);\n          return false;\n        &#125;\n      &#125;;\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li>场景例子<br>如果在一个系统里面有许多类，它们之间的区别仅在于它们的’行为’，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br>一个系统需要动态地在几种算法中选择一种。<br>表单验证</li>\n<li>优点<br>利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句<br>提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，理解，易于扩展<br>利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的代替方案</li>\n<li>缺点<br>会在程序中增加许多策略类或者策略对象<br>要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy</li>\n</ul>\n<h1 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h1><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式</p>\n<pre><code class=\"javascript\">let examCarNum = 0 // 驾考车总数\n// /_ 驾考车对象 _/\nclass ExamCar &#123;\nconstructor(carType) &#123;\nexamCarNum++\nthis.carId = examCarNum\nthis.carType = carType ? &#39;手动档&#39; : &#39;自动档&#39;\nthis.usingState = false // 是否正在使用\n&#125;\n/* 在本车上考试 */\nexamine(candidateId) &#123;\n    return new Promise((resolve =&gt; &#123;\n        this.usingState = true\n        console.log(`考生- $&#123; candidateId &#125; 开始在$&#123; this.carType &#125;驾考车- $&#123; this.carId &#125; 上考试`)\n        setTimeout(() =&gt; &#123;\n            this.usingState = false\n            console.log(`%c考生- $&#123; candidateId &#125; 在$&#123; this.carType &#125;驾考车- $&#123; this.carId &#125; 上考试完毕`, &#39;color:#f40&#39;)\n            resolve()                       // 0~2秒后考试完毕\n        &#125;, Math.random() * 2000)\n    &#125;))\n&#125;&#125;\n// /_ 手动档汽车对象池 _/\nManualExamCarPool = &#123;\n\\_pool: [], // 驾考车对象池\n\\_candidateQueue: [], // 考生队列\n/* 注册考生 ID 列表 */\nregistCandidates(candidateList) &#123;\n  candidateList.forEach(candidateId =&gt; this.registCandidate(candidateId))\n&#125;,\n/* 注册手动档考生 */\nregistCandidate(candidateId) &#123;\n  const examCar = this.getManualExamCar()    // 找一个未被占用的手动档驾考车\n  if (examCar) &#123;\n      examCar.examine(candidateId)           // 开始考试，考完了让队列中的下一个考生开始考试\n        .then(() =&gt; &#123;\n            const nextCandidateId = this._candidateQueue.length &amp;&amp; this._candidateQueue.shift()\n            nextCandidateId &amp;&amp; this.registCandidate(nextCandidateId)\n        &#125;)\n  &#125; else this._candidateQueue.push(candidateId)\n&#125;,\n/* 注册手动档车 */\ninitManualExamCar(manualExamCarNum) &#123;\n  for (let i = 1; i &lt;= manualExamCarNum; i++) &#123;\n      this._pool.push(new ExamCar(true))\n  &#125;\n&#125;,\n/* 获取状态为未被占用的手动档车 */\ngetManualExamCar() &#123;\n  return this._pool.find(car =&gt; !car.usingState)\n&#125;\nManualExamCarPool.initManualExamCar(3) // 一共有 3 个驾考车\nManualExamCarPool.registCandidates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) // 10 个考生来考试\n&#125;\n</code></pre>\n<ul>\n<li>场景例子<br>文件上传需要创建多个文件实例的时候<br>如果一个应用程序使用了大量的对象，而这些大量的对象造成了很大的存储开销时就应该考虑使用享元模式</li>\n<li>优点<br>大大减少对象的创建，降低系统的内存，使效率提高。</li>\n<li>缺点</li>\n</ul>\n<p>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，<br>不应该随着内部状态的变化而变化，否则会造成系统的混乱</p>\n<h1 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h1><p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法和封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p>\n<pre><code class=\"javascript\">class Beverage &#123;\n  constructor(&#123; brewDrink, addCondiment &#125;) &#123;\n    this.brewDrink = brewDrink;\n    this.addCondiment = addCondiment;\n  &#125;\n  // /_ 烧开水，共用方法 _/\n  boilWater() &#123;\n    console.log(&quot;水已经煮沸=== 共用&quot;);\n  &#125;\n  // /_ 倒杯子里，共用方法 _/\n  pourCup() &#123;\n    console.log(&quot;倒进杯子里===共用&quot;);\n  &#125;\n  // /_ 模板方法 _/\n  init() &#123;\n    this.boilWater();\n    this.brewDrink();\n    this.pourCup();\n    this.addCondiment();\n  &#125;\n&#125;\n/_ 咖啡 _/;\nconst coffee = new Beverage(&#123;\n  // /_ 冲泡咖啡，覆盖抽象方法 _/\n  brewDrink: function () &#123;\n    console.log(&quot;冲泡咖啡&quot;);\n  &#125;,\n  // /_ 加调味品，覆盖抽象方法 _/\n  addCondiment: function () &#123;\n    console.log(&quot;加点奶和糖&quot;);\n  &#125;,\n&#125;);\ncoffee.init();\n</code></pre>\n<ul>\n<li>场景例子<br>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现<br>子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复</li>\n<li>优点<br>提取了公共代码部分，易于维护</li>\n<li>缺点<br>增加了系统复杂度，主要是增加了的抽象类和类间联系</li>\n</ul>\n<h1 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p>\n<pre><code class=\"javascript\">// 请假审批，需要组长审批、经理审批、总监审批\nclass Action &#123;\n  constructor(name) &#123;\n    this.name = name;\n    this.nextAction = null;\n  &#125;\n  setNextAction(action) &#123;\n    this.nextAction = action;\n  &#125;\n  handle() &#123;\n    console.log(`$&#123;this.name&#125; 审批`);\n    if (this.nextAction != null) &#123;\n      this.nextAction.handle();\n    &#125;\n  &#125;\n&#125;\nlet a1 = new Action(&quot;组长&quot;);\nlet a2 = new Action(&quot;经理&quot;);\nlet a3 = new Action(&quot;总监&quot;);\na1.setNextAction(a2);\na2.setNextAction(a3);\na1.handle();\n</code></pre>\n<ul>\n<li>场景例子<br>JS 中的事件冒泡<br>作用域链<br>原型链</li>\n<li>优点<br>降低耦合度。它将请求的发送者和接收者解耦。<br>简化了对象。使得对象不需要知道链的结构<br>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任<br>增加新的请求处理类很方便。</li>\n<li>缺点<br>不能保证某个请求一定会被链中的节点处理，这种情况可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。<br>使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能当面考虑，要避免过长的职责链到来的性能损耗。</li>\n</ul>\n<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><blockquote>\n<p>简单理解为一个类,光传递内部数据而不执行过程,类似于控制反转<br>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p>\n</blockquote>\n<pre><code class=\"javascript\">// 接收者类\nclass Receiver &#123;\n  execute() &#123;\n    console.log(&quot;接收者执行请求&quot;);\n  &#125;\n&#125;\n// 命令者\nclass Command &#123;\n  constructor(receiver) &#123;\n    this.receiver = receiver;\n  &#125;\n  execute() &#123;\n    console.log(&quot;命令&quot;);\n    this.receiver.execute();\n  &#125;\n&#125;\n// 触发者\nclass Invoker &#123;\n  constructor(command) &#123;\n    this.command = command;\n  &#125;\n  invoke() &#123;\n    console.log(&quot;开始&quot;);\n    this.command.execute();\n  &#125;\n&#125;\n// 仓库\nconst warehouse = new Receiver();\n// 订单\nconst order = new Command(warehouse);\n// 客户\nconst client = new Invoker(order);\nclient.invoke();\n</code></pre>\n<ul>\n<li>优点<br>对命令进行封装，使命令易于扩展和修改<br>命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行</li>\n<li>缺点<br>使用命令模式可能会导致某些系统有过多的具体命令类。</li>\n</ul>\n<h1 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h1><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>\n<pre><code class=\"javascript\">//备忘类\nclass Memento &#123;\n  constructor(content) &#123;\n    this.content = content;\n  &#125;\n  getContent() &#123;\n    return this.content;\n  &#125;\n&#125;\n// 备忘列表\nclass CareTaker &#123;\n  constructor() &#123;\n    this.list = [];\n  &#125;\n  add(memento) &#123;\n    this.list.push(memento);\n  &#125;\n  get(index) &#123;\n    return this.list[index];\n  &#125;\n&#125;\n// 编辑器\nclass Editor &#123;\n  constructor() &#123;\n    this.content = null;\n  &#125;\n  setContent(content) &#123;\n    this.content = content;\n  &#125;\n  getContent() &#123;\n    return this.content;\n  &#125;\n  saveContentToMemento() &#123;\n    return new Memento(this.content);\n  &#125;\n  getContentFromMemento(memento) &#123;\n    this.content = memento.getContent();\n  &#125;\n&#125;\n//测试代码\nlet editor = new Editor();\nlet careTaker = new CareTaker();\neditor.setContent(&quot;111&quot;);\neditor.setContent(&quot;222&quot;);\ncareTaker.add(editor.saveContentToMemento());\neditor.setContent(&quot;333&quot;);\ncareTaker.add(editor.saveContentToMemento());\neditor.setContent(&quot;444&quot;);\nconsole.log(editor.getContent()); //444\neditor.getContentFromMemento(careTaker.get(1));\nconsole.log(editor.getContent()); //333\neditor.getContentFromMemento(careTaker.get(0));\nconsole.log(editor.getContent()); //222\n</code></pre>\n<ul>\n<li>场景例子<br>分页控件<br>撤销组件</li>\n<li>优点<br>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li>\n<li>缺点<br>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>\n</ul>\n<h1 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h1><blockquote>\n<p>代理模式和中介者模式的区别在于：代理模式往往是一对一的，但中介模式往往是一对多。<br>解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者<br>模式使网状的多对多关系变成了相对简单的一对多关系（类似于观察者模式，但是单向的，由中介者统一管理。）</p>\n</blockquote>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.number = 0;\n  &#125;\n  setNumber(num, m) &#123;\n    this.number = num;\n    if (m) &#123;\n      m.setB();\n    &#125;\n  &#125;\n&#125;\nclass B &#123;\n  constructor() &#123;\n    this.number = 0;\n  &#125;\n  setNumber(num, m) &#123;\n    this.number = num;\n    if (m) &#123;\n      m.setA();\n    &#125;\n  &#125;\n&#125;\nclass Mediator &#123;\n  constructor(a, b) &#123;\n    this.a = a;\n    this.b = b;\n  &#125;\n  setA() &#123;\n    let number = this.b.number;\n    this.a.setNumber(number / 10);\n  &#125;\n  setB() &#123;\n    let number = this.a.number;\n    this.b.setNumber(number / 10);\n  &#125;\n&#125;\nlet a = new A();\nlet b = new B();\nlet m = new Mediator(a, b);\na.setNumber(10, m);\nconsole.log(a.number, b.number);\nb.setNumber(10, m);\nconsole.log(a.number, b.number);\n</code></pre>\n<ul>\n<li>场景例子<br>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象<br>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>\n<li>优点<br>使各对象之间耦合松散，而且可以独立地改变它们之间的交互<br>中介者和对象一对多的关系取代了对象之间的网状多对多的关系<br>如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码</li>\n<li>缺点<br>系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。</li>\n</ul>\n<h1 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h1><p>给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p>\n<pre><code class=\"javascript\">class Context &#123;\n  constructor() &#123;\n    this._list = []; // 存放 终结符表达式\n    this._sum = 0; // 存放 非终结符表达式(运算结果)\n  &#125;\n  get sum() &#123;\n    return this._sum;\n  &#125;\n  set sum(newValue) &#123;\n    this._sum = newValue;\n  &#125;\n  add(expression) &#123;\n    this._list.push(expression);\n  &#125;\n  get list() &#123;\n    return [...this._list];\n  &#125;\n&#125;\nclass PlusExpression &#123;\n  interpret(context) &#123;\n    if (!(context instanceof Context)) &#123;\n      throw new Error(&quot;TypeError&quot;);\n    &#125;\n    context.sum = ++context.sum;\n  &#125;\n&#125;\nclass MinusExpression &#123;\n  interpret(context) &#123;\n    if (!(context instanceof Context)) &#123;\n      throw new Error(&quot;TypeError&quot;);\n    &#125;\n    context.sum = --context.sum;\n  &#125;\n&#125;\n/** 以下是测试代码 **/\nconst context = new Context();\n// 依次添加: 加法 | 加法 | 减法 表达式\ncontext.add(new PlusExpression());\ncontext.add(new PlusExpression());\ncontext.add(new MinusExpression());\n// 依次执行: 加法 | 加法 | 减法 表达式\ncontext.list.forEach((expression) =&gt; expression.interpret(context));\nconsole.log(context.sum);\n</code></pre>\n<ul>\n<li>优点<br>易于改变和扩展文法。<br>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>\n<li>缺点<br>执行效率较低，在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度慢<br>对于复杂的文法比较难维护</li>\n</ul>\n<h1 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h1><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>\n<pre><code class=\"javascript\">// 访问者\nclass Visitor &#123;\n  constructor() &#123;&#125;\n  visitConcreteElement(ConcreteElement) &#123;\n    ConcreteElement.operation();\n  &#125;\n&#125;\n// 元素类\nclass ConcreteElement &#123;\n  constructor() &#123;&#125;\n  operation() &#123;\n    console.log(&quot;ConcreteElement.operation invoked&quot;);\n  &#125;\n  accept(visitor) &#123;\n    visitor.visitConcreteElement(this);\n  &#125;\n&#125;\n// client\nlet visitor = new Visitor();\nlet element = new ConcreteElement();\nelement.accept(visitor);\n</code></pre>\n<ul>\n<li>场景例子<br>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作<br>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>\n<li>优点<br>符合单一职责原则<br>优秀的扩展性<br>灵活性</li>\n<li>缺点<br>具体元素对访问者公布细节，违反了迪米特原则<br>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。<br>具体元素变更比较困难</li>\n</ul>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h4 id=\"开放封闭原则\"><a href=\"#开放封闭原则\" class=\"headerlink\" title=\"开放封闭原则\"></a>开放封闭原则</h4><blockquote>\n<p>开放封闭原则的核心是：对扩展开放，对修改封闭。</p>\n</blockquote>\n<ul>\n<li>对扩展开放意味着：软件实体（如类、模块、函数等）应该易于扩展，即：不修改现有代码的基础上添加新的功能</li>\n<li>对修改封闭意味着：软件实体应该避免修改，尤其是已经经过测试并被证明是稳定的代码</li>\n</ul>\n<h4 id=\"单一功能原则\"><a href=\"#单一功能原则\" class=\"headerlink\" title=\"单一功能原则\"></a>单一功能原则</h4><blockquote>\n<p>单一功能原则的核心是：一个类应该只有一个引起他变化的原因，它强调的是类的职责应该清晰明确，一个类只负责一项任务或功能，这样做的目的是为了降低类的复杂性，增加代码的可维护性和可复用性。</p>\n</blockquote>\n<h4 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h4><blockquote>\n<p>里氏替换原则是实现开放封闭原则的方式之一，里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>\n</blockquote>\n<h4 id=\"最少知识原则\"><a href=\"#最少知识原则\" class=\"headerlink\" title=\"最少知识原则\"></a>最少知识原则</h4><blockquote>\n<p>最少知识原则又称迪米特法则，意思是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。<br>最少知识原则降低了类的耦合性，提高了模块的独立性，从而提升了模块的可复用率和系统的扩展性。但是过度使用则会使系统产生大量的中介类，从而增加系统的复杂性。</p>\n</blockquote>\n<h4 id=\"合成复用原则\"><a href=\"#合成复用原则\" class=\"headerlink\" title=\"合成复用原则\"></a>合成复用原则</h4><blockquote>\n<p>类的复用分为两种：继承复用和合成复用</p>\n</blockquote>\n<ul>\n<li>继承复用的优点：简单清晰，易于实现</li>\n<li>继承复用的缺点：破坏了类的封装性（继承会将父类的实现细节暴露给子类，因此这种复用又称为白箱复用）、子类与父类的耦合度高，父类的实现改变会导致子类的实现改变。</li>\n<li>合成复用的优点：维持了类的封装性（对象内部细节对外部是不可见的，因此又称为黑盒复用）、新类和旧类之间耦合度低、复用的灵活性高</li>\n<li>合成复用的缺点：实现复杂、代码量多<blockquote>\n<p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"面向接口\"><a href=\"#面向接口\" class=\"headerlink\" title=\"面向接口\"></a>面向接口</h2><h4 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h4><blockquote>\n<p>依赖倒置原则：程序要依赖于抽象接口，而不要依赖于具体的实现，也就是说高层模块不应该依赖于底层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖抽象。<br>依赖倒置原则的核心是：通过面向接口的编程来降低类之间的耦合性。<br><code>依赖倒置</code>是面向接口领域的软件设计原则，<code>依赖反转</code>是遵守依赖倒置原则而提出的一种设计模式，而<code>依赖注入</code>是为了实现依赖反转的一种手段和方式。</p>\n</blockquote>\n<h4 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h4><blockquote>\n<p>接口隔离原则要求将臃肿庞大的接口进行拆分，拆分为更小的更具体的接口，小的接口之间相互隔离。<br>接口隔离原则的核心是：提高内聚，减少对外交互，使接口用最少的方法完成最多的事情。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中：</p>\n<ul>\n<li>开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；</li>\n<li>里氏替换原则告诉我们不要破坏继承体系；</li>\n<li>依赖倒置原则告诉我们要面向接口编程；</li>\n<li>单一职责原则告诉我们实现类要职责单一；</li>\n<li>接口隔离原则告诉我们在设计接口的时候要精简单一；</li>\n<li>最少知识原则告诉我们要降低耦合度；</li>\n<li>合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</li>\n</ul>\n",
            "tags": [
                "设计模式与设计原则",
                "设计模式与设计原则"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/27/OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/",
            "url": "https://dmqweb.cn/2024/05/27/OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/",
            "title": "OSI七层网络模型",
            "date_published": "2024-05-27T10:16:27.000Z",
            "content_html": "<h1 id=\"OSI七层网络模型\"><a href=\"#OSI七层网络模型\" class=\"headerlink\" title=\"OSI七层网络模型\"></a>OSI七层网络模型</h1><p><img data-src=\"/images/e3cc1860482648d5a2b2f6bac23280d3~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp\" alt=\"images\"></p>\n<h1 id=\"七、应用层（应用）\"><a href=\"#七、应用层（应用）\" class=\"headerlink\" title=\"七、应用层（应用）\"></a>七、应用层（应用）</h1><p>应用层就是我们最接近我们、最常用的一层，例如：</p>\n<ul>\n<li>ajax调用接口发送<strong>http请求</strong></li>\n<li>使用<strong>DNS域名查询</strong>系统</li>\n<li><strong>邮件协议SMTP</strong></li>\n<li><strong>websock长连接</strong></li>\n<li><strong>SSH协议</strong></li>\n<li>等。</li>\n</ul>\n<h1 id=\"六、表示层（安全、压缩、翻译）\"><a href=\"#六、表示层（安全、压缩、翻译）\" class=\"headerlink\" title=\"六、表示层（安全、压缩、翻译）\"></a>六、表示层（安全、压缩、翻译）</h1><p>表示层做了几件重要的事情如：</p>\n<ul>\n<li>压缩</li>\n<li>安全（数据发送前进行加密，在接受者的表示层进行解密）</li>\n<li>程序在网络中的翻译官（对图片文件等格式进行解码和编码）</li>\n</ul>\n<h1 id=\"五、会话层（检查点机制）\"><a href=\"#五、会话层（检查点机制）\" class=\"headerlink\" title=\"五、会话层（检查点机制）\"></a>五、会话层（检查点机制）</h1><ul>\n<li>会话层是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方</li>\n<li>会话层定义了一种机制，允许发送方和接收方启动或停止请求会话，当及当双方发生拥塞时仍然能保持对话</li>\n<li>会话层包含了一种<strong>检查点的机制</strong>来维持可靠会话，检查点定义了一个最接近成功通信的点，并且定义了当发生内容丢失或者损坏时需要回滚以便回复丢失或损坏数据的点，即断点下载的原理</li>\n</ul>\n<h1 id=\"四、传输层（TCP、UDP连接）\"><a href=\"#四、传输层（TCP、UDP连接）\" class=\"headerlink\" title=\"四、传输层（TCP、UDP连接）\"></a>四、传输层（TCP、UDP连接）</h1><ul>\n<li>传输层主要就是定义端口号，以及控流和校验</li>\n<li>TCP（面向连接的协议并且TCP是可靠的），因为TCP会进行三报文握手和四报文挥手，所以是可靠的，但是这样会降低速度</li>\n<li>UDP（UDP没有三报文握手和四报文挥手，因此不够稳定，但是速度快，常用于直播和游戏）</li>\n</ul>\n<h1 id=\"三、网络层（IP地址）\"><a href=\"#三、网络层（IP地址）\" class=\"headerlink\" title=\"三、网络层（IP地址）\"></a>三、网络层（IP地址）</h1><ul>\n<li>网络层是最复杂的一层，在网络层定义了IP</li>\n<li>网络层控制数据链路层与传输层之间的信息转发，建立，维持和终止网络的连接。</li>\n<li>数据链路层的数据在网络层被转换为数据包，然后通过路径选择、分段组合、顺序、进&#x2F;出路由等控制，将信息从一个网络设备传送到另一个网络设备</li>\n<li>寻址：对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信（类似于数据链路层的MAC地址）</li>\n<li>路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</li>\n<li>如果所有的使用互联网的用户在同一个网段中，<strong>会产生广播风暴，所以要将用户进行划分</strong>，让他们在不同的网段中，自己在自己的小网段中广播。而<strong>互联网就是这无数的子网络构成的一个巨型网络</strong>。</li>\n<li>在网络层中引入了一套新的地址，让我们能够区分不同的网段。这套地址就叫做“网络地址”，简称“网址”。于是，<strong>”网络层”出现以后，每台计算机有了两种地址</strong>，<strong>一种是MAC地址，另一种是网络地址</strong>。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。<strong>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。</strong>因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</li>\n<li>这一层中有一个<strong>规定网络地址的协议，叫做IP协议</strong>，它所定义的地址，就被称为IP地址。</li>\n<li>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。因为IPv4的地址已经不够用了，所以现在推广IPv6，</li>\n</ul>\n<h1 id=\"二、数据链路层（MAC地址）\"><a href=\"#二、数据链路层（MAC地址）\" class=\"headerlink\" title=\"二、数据链路层（MAC地址）\"></a>二、数据链路层（MAC地址）</h1><ul>\n<li>建立逻辑连接、进行硬件地址寻址、差错校验等功能（底层网络定义协议）</li>\n<li>及比特组合成字节进而组合成帧，用MAC地址访问介质，此时可以发现错误但不能纠正。</li>\n<li>MAC地址是每个网卡的唯一标识，有了MAC地址就能知道谁是接收者，谁是发送者，并且知道了数据的内容，并且进行分组。</li>\n<li>传播数据是通过广播的方式进行传输，在局域网中的所有计算机都能接收到消息</li>\n</ul>\n<h1 id=\"一、物理层（物理信道）\"><a href=\"#一、物理层（物理信道）\" class=\"headerlink\" title=\"一、物理层（物理信道）\"></a>一、物理层（物理信道）</h1><ul>\n<li><p>物理层是直接和物理介质打交道的。</p>\n</li>\n<li><p>物理层的设备 网卡，网线，集线器，中继器，调制解调器</p>\n</li>\n</ul>\n<p><strong>物理层信道：</strong></p>\n<ul>\n<li><p>有线信道</p>\n<ul>\n<li>明线（平行架设在电线杆上的架空线路）</li>\n<li>对称电缆（对多双绞线组成）</li>\n<li>同轴电缆（具有外层屏蔽层）</li>\n<li>光纤（利用光在纤维中的反射原理进行传输）</li>\n</ul>\n</li>\n<li><p>无线信道</p>\n<p>以辐射无线电波为传输方式无线信道主要有地波传输，天波传输和视距传输 例如：卫星通讯，电台广播</p>\n</li>\n</ul>\n<p>物理层通过以上的方式，会获取他们对应的传送信号，电压，转换成010101010101但是数据还未组织，仅作为原始的电气电压处理<code>单位为bit</code></p>\n",
            "tags": [
                "OSI七层网络模型",
                "OSI七层网络模型"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/24/node/",
            "url": "https://dmqweb.cn/2024/05/24/node/",
            "title": "Node学习笔记",
            "date_published": "2024-05-24T09:02:28.000Z",
            "content_html": "<h1 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>Node.js并不是JavaScript应用，也不是编程语言，而是JavaScript的运行时。</li>\n<li>Node.js是构建在V8引擎之上的，V8引擎由C &#x2F; C++编写，因此JavaScript语言需要编译为C &#x2F; C++代码之后才能执行。</li>\n<li>Node.js采用异步IO和事件驱动的设计理念，可以高效的处理大量并发请求，提供了非阻塞IO接口和事件循环机制，使其可以编写出高性能、高扩展的应用程序。（异步IO通过libuv库来实现）</li>\n<li>Node.js使用npm作为包管理工具</li>\n<li>Node.js适合做一些IO密集型应用，不适合做一些CPU密集型应用（事件循环机制和异步IO使得Node.js有很强的处理能力，但是因为Node.js单线程的原因，容易造成CPU占用率过高）</li>\n<li>如果非要用Node.js做CPU密集型应用，需要编写C++插件，或者Node提供的cluster模块。</li>\n</ul>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ul>\n<li>npm是Node.js的包管理工具，它基于命令行，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qaWF4aWFveGlhby5uZXRsaWZ5LmFwcC8yMDE5LzA3LzMwL25vZGUvbm9kZS1ucG0v\">npm命令大全</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTQ1NzU5ODY4MDEwMzY0OTU5\">package.json配置详解</span></li>\n</ul>\n<h4 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h4><p>执行<code>npm install</code>时，npm会通过广度优先遍历算法遍历依赖树，npm会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有的依赖被处理完成。在处理每个依赖时，npm会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本。</p>\n<p><img data-src=\"/images/Snipaste_2024-05-28_18-35-31.png\" alt=\"images\"></p>\n<h4 id=\"npmrc文件\"><a href=\"#npmrc文件\" class=\"headerlink\" title=\".npmrc文件\"></a>.npmrc文件</h4><pre><code class=\"bash\">registry=http://registry.npmjs.org/\n# 定义npm的registry，即npm的包下载源\nproxy=http://proxy.example.com:8080/\n# 定义npm的代理服务器，用于访问网络\nhttps-proxy=http://proxy.example.com:8080/\n# 定义npm的https代理服务器，用于访问网络\nstrict-ssl=true\n# 是否在SSL证书验证错误时退出\ncafile=/path/to/cafile.pem\n# 定义自定义CA证书文件的路径\nuser-agent=npm/&#123;npm-version&#125; node/&#123;node-version&#125; &#123;platform&#125;\n# 自定义请求头中的User-Agent\nsave=true\n# 安装包时是否自动保存到package.json的dependencies中\nsave-dev=true\n# 安装包时是否自动保存到package.json的devDependencies中\nsave-exact=true\n# 安装包时是否精确保存版本号\nengine-strict=true\n# 是否在安装时检查依赖的node和npm版本是否符合要求\nscripts-prepend-node-path=true\n# 是否在运行脚本时自动将node的路径添加到PATH环境变量中\n</code></pre>\n<h4 id=\"package-lock-json\"><a href=\"#package-lock-json\" class=\"headerlink\" title=\"package-lock.json\"></a>package-lock.json</h4><p>文件的作用：</p>\n<ul>\n<li><p>锁定版本号、记录依赖树详细信息</p>\n</li>\n<li><p>package-lock.json帮我们做了缓存，他会通过 <code>name + version + integrity</code> 信息生成一个唯一的key，这个key能找到对应的index-v5 下的缓存记录 （npm cache 文件夹下），如果发现有缓存记录，就会找到tar包的hash值，然后将对应的二进制文件解压到node_modeules</p>\n</li>\n</ul>\n<h4 id=\"npm-run\"><a href=\"#npm-run\" class=\"headerlink\" title=\"npm run\"></a>npm run</h4><p>读取package.json的scripts对应的脚本命令，查找的规则是：</p>\n<ol>\n<li>当前项目node_modules&#x2F;.bin查找</li>\n<li>全局node_modules&#x2F;.bin查找</li>\n<li>环境变量查找</li>\n<li>找不到，报错</li>\n</ol>\n<p>node_modules&#x2F;.bin中有三个文件（Node作为跨平台工具，需要处理平台兼容性）</p>\n<ul>\n<li>.sh文件是给Linux unix Macos 使用</li>\n<li>.cmd 给windows的cmd使用</li>\n<li>.ps1 给windows的powerShell 使用</li>\n</ul>\n<h4 id=\"npm-生命周期\"><a href=\"#npm-生命周期\" class=\"headerlink\" title=\"npm 生命周期\"></a>npm 生命周期</h4><p>在package.json中的scripts字段中，我们可以利用npm脚本命名规范使用npm的生命周期特性，例如：</p>\n<pre><code class=\"javascripton\">    &quot;pretest&quot;: &quot;node prev.js&quot;,\n    &quot;test&quot;: &quot;node index.js&quot;,\n    &quot;posttest&quot;: &quot;node post.js&quot;\n</code></pre>\n<p>则执行：npm run test时，会最先执行pretest，最后执行posttest。</p>\n<h4 id=\"npx\"><a href=\"#npx\" class=\"headerlink\" title=\"npx\"></a>npx</h4><p>npx是一个命令行工具，它是npm 5.2.0版本中新增的功能。它允许用户在不安装全局包的情况下，运行已安装在本地项目中的包或者远程仓库中的包。</p>\n<p>npx的作用是在命令行中运行node包中的可执行文件，而不需要全局安装这些包。这可以使开发人员更轻松地管理包的依赖关系，并且可以避免全局污染的问题。它还可以帮助开发人员在项目中使用不同版本的包，而不会出现版本冲突的问题。</p>\n<p><strong>npx 的优势</strong></p>\n<ol>\n<li>避免全局安装：<code>npx</code>允许你执行npm package，而不需要你先全局安装它。</li>\n<li>总是使用最新版本：如果你没有在本地安装相应的npm package，<code>npx</code>会从npm的package仓库中下载并使用最新版。</li>\n<li>执行任意npm包：<code>npx</code>不仅可以执行在<code>package.json</code>的<code>scripts</code>部分定义的命令，还可以执行任何npm package。</li>\n<li>执行GitHub gist：<code>npx</code>甚至可以执行GitHub gist或者其他公开的JavaScript文件。</li>\n</ol>\n<p><strong>npm 和 npx 区别</strong></p>\n<ul>\n<li><p><code>npx</code>侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令</p>\n</li>\n<li><p><code>npm</code>侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。</p>\n</li>\n</ul>\n<h4 id=\"npm私服\"><a href=\"#npm私服\" class=\"headerlink\" title=\"npm私服\"></a>npm私服</h4><p><strong>优势：</strong></p>\n<ul>\n<li><strong>可以离线使用</strong>，你可以将npm私服部署到内网集群，这样离线也可以访问私有的包。</li>\n<li><strong>提高包的安全性</strong>，使用私有的npm仓库可以更好的管理你的包，避免在使用公共的npm包的时候出现漏洞。</li>\n<li><strong>提高包的下载速度</strong>，使用私有 npm 仓库，你可以将经常使用的 npm 包缓存到本地，从而显著提高包的下载速度，减少依赖包的下载时间。这对于团队内部开发和持续集成、部署等场景非常</li>\n</ul>\n<p><strong>搭建：</strong></p>\n<ul>\n<li>可以克隆npm或cnpm仓库，更改yaml配置文件为自己想要的设置即可</li>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly92ZXJkYWNjaW8ub3JnL3poLWNuLw==\">verdaccio工具</span><ul>\n<li><code>npm install verdaccio -g</code></li>\n<li><code>verdaccio</code></li>\n<li>访问localhost:4873</li>\n<li>使用npm操作时，加上<code>--registry http://localhost:4873</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Node模块化\"><a href=\"#Node模块化\" class=\"headerlink\" title=\"Node模块化\"></a>Node模块化</h2><h4 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h4><ul>\n<li><p>支持引入内置模块例如 <code>http</code> <code>os</code> <code>fs</code> <code>child_process</code> 等nodejs内置模块</p>\n</li>\n<li><p>支持引入第三方模块<code>express</code> <code>md5</code> <code>koa</code> 等</p>\n</li>\n<li><p>支持引入自己编写的模块 .&#x2F; ..&#x2F; 等</p>\n</li>\n<li><p>支持引入addon C++扩展模块 .node文件</p>\n</li>\n</ul>\n<h4 id=\"ESM\"><a href=\"#ESM\" class=\"headerlink\" title=\"ESM\"></a>ESM</h4><ul>\n<li>import静态导入需要在顶层调用</li>\n<li>import导入json文件需要添加断言（低版本node不可用）</li>\n<li>支持函数式动态导入</li>\n</ul>\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><ol>\n<li>CommonJS基于运行时的同步加载，ESM基于编译时的异步加载</li>\n<li>CommonJS是可以修改值的，ESM值并且不可修改（可读的）</li>\n<li>CommonJS不可以tree shaking，ESM支持tree shaking</li>\n<li>CommonJS中顶层的this指向这个模块本身，而ESM中顶层this指向undefined</li>\n</ol>\n<h4 id=\"require执行顺序\"><a href=\"#require执行顺序\" class=\"headerlink\" title=\"require执行顺序\"></a>require执行顺序</h4><ol>\n<li>.js文件，调用compile函数进行执行。</li>\n<li>.json文件，读取文件内容，调用JSON.parse方法处理。</li>\n<li>.node文件，通过process.dlopen方法进行处理。</li>\n</ol>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><h4 id=\"global\"><a href=\"#global\" class=\"headerlink\" title=\"global\"></a>global</h4><ul>\n<li>浏览器端的全局对象是window</li>\n<li>Node环境的全局对象是global</li>\n<li>global上定义的变量在当前环境执行任何文件时都可以访问到</li>\n<li>ES2020推出globalThis用于兼容window和global（自动切换）</li>\n</ul>\n<h4 id=\"dirname\"><a href=\"#dirname\" class=\"headerlink\" title=\"__dirname\"></a>__dirname</h4><p>当前模块所在目录的绝对路径</p>\n<h4 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"__filename\"></a>__filename</h4><p>当前模块文件所在的绝对路径，包括文件名和文件扩展名</p>\n<h4 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"require\"></a>require</h4><h4 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h4><h4 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h4><ul>\n<li><p><code>process.argv</code></p>\n<ul>\n<li>第一个参数是当前执行环境的路径</li>\n<li>第二个参数是当前执行的文件的路径</li>\n<li>剩余的参数是传递给脚本文件的命令行参数</li>\n</ul>\n</li>\n<li><p><code>process.env</code>环境变量</p>\n</li>\n<li><p><code>process.cwd()</code>返回当前工作目录路径</p>\n</li>\n<li><p><code>process.on(event,listener)</code>，监听进程变化</p>\n</li>\n<li><p><code>process.exit([code])</code>，退出Node进程，提供退出码</p>\n</li>\n<li><p><code>process.pid</code>返回进程id</p>\n</li>\n</ul>\n<h4 id=\"Buffer类\"><a href=\"#Buffer类\" class=\"headerlink\" title=\"Buffer类\"></a>Buffer类</h4><p>Node.js 6.0版本开始，<code>Buffer</code>构造函数的使用已被弃用，推荐使用<code>Buffer.alloc()</code>、<code>Buffer.from()</code>等方法来创建<code>Buffer</code>实例。</p>\n<h4 id=\"DOM、BOM\"><a href=\"#DOM、BOM\" class=\"headerlink\" title=\"DOM、BOM\"></a>DOM、BOM</h4><p>Node环境中无法操作DOM和BOM，不过可以借助一些工具进行模拟，例如：<code>jsdom</code></p>\n<pre><code class=\"javascript\">const fs = require(&#39;node:fs&#39;)\nconst &#123; JSDOM &#125; = require(&#39;jsdom&#39;) // jsdom模拟浏览器环境\nconst dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;`)\nconst document = dom.window.document\nconst window = dom.window\nfetch(&#39;https://api.thecatapi.com/v1/images/search?limit=10&amp;page=1&#39;).then(res =&gt; res.json()).then(data =&gt; &#123;\n    const app = document.getElementById(&#39;app&#39;)\n    data.forEach(item=&gt;&#123;\n       const img =  document.createElement(&#39;img&#39;)\n       img.src = item.url\n       img.style.width = &#39;200px&#39;\n       img.style.height = &#39;200px&#39;\n       app.appendChild(img)\n    &#125;)\n    fs.writeFileSync(&#39;./index.html&#39;, dom.serialize())\n&#125;)\n</code></pre>\n<h2 id=\"path模块\"><a href=\"#path模块\" class=\"headerlink\" title=\"path模块\"></a>path模块</h2><p>path模块在windows和posix系统中是有差异的。</p>\n<ul>\n<li>posix表示可移植操作系统接口，也就是定义了一套标准，遵守这套标准的操作系统有(unix,like unix,linux,macOs,windows wsl)，用于多个平台间相互兼容</li>\n<li>Windows 并没有完全遵循 POSIX 标准，在 Windows 系统中，路径使用反斜杠（<code>\\</code>）作为路径分隔符。这与 POSIX 系统使用的正斜杠（<code>/</code>）是不同的</li>\n</ul>\n<p><strong>差异举例：</strong></p>\n<pre><code>path.basename(&#39;C:\\temp\\myfile.html&#39;); \n// 在posix中 返回: &#39;C:\\temp\\myfile.html&#39;\n// 在windows中 返回 empmyfile.html\n</code></pre>\n<ul>\n<li>path.basename返回文件名（包括后缀）</li>\n</ul>\n<pre><code class=\"javascript\">path.basename(&#39;C:/fs/dmq/MI/index.html&#39;) //返回index.html\n</code></pre>\n<ul>\n<li><code>path.extname</code>返回扩展名</li>\n<li><code>path.join</code>路径拼接（路径拼接）</li>\n<li><code>path.resolve</code>解析绝对路径并且返回绝对路径（路径解析）</li>\n<li><code>path.parse</code>将路径解析为对象</li>\n<li><code>path.format</code>将对象解析为路径</li>\n</ul>\n<h2 id=\"os模块\"><a href=\"#os模块\" class=\"headerlink\" title=\"os模块\"></a>os模块</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>API</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>os.type()</strong></td>\n<td>它在 Linux 上返回 <code>&#39;Linux&#39;</code>，在 macOS 上返回 <code>&#39;Darwin&#39;</code>，在 Windows 上返回 <code>&#39;Windows_NT&#39;</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><strong>os.platform()</strong></td>\n<td>返回标识为其编译 Node.js 二进制文件的操作系统平台的字符串。 该值在编译时设置。 可能的值为 <code>&#39;aix&#39;</code>、<code>&#39;darwin&#39;</code>、<code>&#39;freebsd&#39;</code>、<code>&#39;linux&#39;</code>、<code>&#39;openbsd&#39;</code>、<code>&#39;sunos&#39;</code>、以及 <code>&#39;win32&#39;</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><strong>os.release()</strong></td>\n<td>返回操作系统的版本例如10.xxxx win10</td>\n</tr>\n<tr>\n<td>4</td>\n<td><strong>os.homedir()</strong></td>\n<td>返回用户目录 例如c:\\user\\xiaoman 原理就是 windows <code>echo %USERPROFILE% </code>posix $HOME</td>\n</tr>\n<tr>\n<td>5</td>\n<td><strong>os.arch()</strong></td>\n<td>返回cpu的架构  可能的值为 <code>&#39;arm&#39;</code>、<code>&#39;arm64&#39;</code>、<code>&#39;ia32&#39;</code>、<code>&#39;mips&#39;</code>、<code>&#39;mipsel&#39;</code>、<code>&#39;ppc&#39;</code>、<code>&#39;ppc64&#39;</code>、<code>&#39;s390&#39;</code>、<code>&#39;s390x&#39;</code>、以及 <code>&#39;x64&#39;</code></td>\n</tr>\n<tr>\n<td>6</td>\n<td><strong>os.cups()</strong></td>\n<td>获取<code>cpu线程</code>和cpu详细信息</td>\n</tr>\n<tr>\n<td>7</td>\n<td><strong>os.networkInterfaces()</strong></td>\n<td>获取<code>网络信息</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"process模块\"><a href=\"#process模块\" class=\"headerlink\" title=\"process模块\"></a>process模块</h2><ul>\n<li><p><code>process.argv</code></p>\n<ul>\n<li>第一个参数是当前执行环境的路径</li>\n<li>第二个参数是当前执行的文件的路径</li>\n<li>剩余的参数是传递给脚本文件的命令行参数</li>\n</ul>\n</li>\n<li><p><code>process.env</code>环境变量</p>\n</li>\n<li><p><code>process.cwd()</code>返回当前工作目录路径</p>\n</li>\n<li><p><code>process.on(event,listener)</code>，监听进程变化</p>\n</li>\n<li><p><code>process.exit([code])</code>，退出Node进程，提供退出码</p>\n</li>\n<li><p><code>process.pid</code>返回进程id</p>\n</li>\n<li><p><code>process.arch</code>返回操作系统CPU架构</p>\n</li>\n<li><p><code>process.memoryUsage</code>获取当前进程内存使用情况</p>\n</li>\n<li><p><code>process.kill(process.pid)</code>用于杀死一个进程</p>\n</li>\n</ul>\n<h2 id=\"child-process模块\"><a href=\"#child-process模块\" class=\"headerlink\" title=\"child_process模块\"></a>child_process模块</h2><p>子进程是Nodejs核心API，如果你会shell命令，他会有非常大的帮助，或者你喜欢编写前端工程化工具之类的，他也有很大的用处，以及处理CPU密集型应用。</p>\n<h4 id=\"创建子进程\"><a href=\"#创建子进程\" class=\"headerlink\" title=\"创建子进程\"></a>创建子进程</h4><p>Nodejs创建子进程共有<code>7个</code>API Sync同步API ，不加是异步API</p>\n<ol>\n<li>spawn  执行命令</li>\n<li>exec   执行命令</li>\n<li>execFile   执行可执行文件</li>\n<li>fork   创建node子进程</li>\n<li><code>execSync</code> 执行命令 同步执行</li>\n<li><code>execFileSync</code> 执行可执行文件 同步执行</li>\n<li><code>spawnSync</code> 执行命令 同步执行</li>\n</ol>\n<h2 id=\"cluster模块\"><a href=\"#cluster模块\" class=\"headerlink\" title=\"cluster模块\"></a>cluster模块</h2><ul>\n<li><p>cluster模块也用于创建node子进程</p>\n</li>\n<li><p>相比较于child_process模块，cluster模块主要用于利用多核CPU的优势，通过创建多个工作进程来提高应用程序的并发处理能力。</p>\n</li>\n<li><p>cluster模块创建的每个工作进程都是独立地node.js进程，他们共享一个端口和监听器，由主进程负责分配请求到各个工作进程。</p>\n</li>\n<li><p>cluster模块自动实现请求的负载均衡，主进程会根据工作进程的负载请情况将请求分配给不同的工作进程。</p>\n</li>\n<li><p>进程通过process.send方法进行通信，但常用于工作进程和主进程之间的通信。</p>\n</li>\n<li><p>cluster模块支持优雅关闭工作进程，允许工作进程在关闭之前完成当前正在处理的请求。</p>\n</li>\n</ul>\n<h2 id=\"ffmpeg工具\"><a href=\"#ffmpeg工具\" class=\"headerlink\" title=\"ffmpeg工具\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9mZm1wZWcucDJocC5jb20vZG93bmxvYWQuaHRtbA==\">ffmpeg工具</span></h2><p>FFmpeg 是一个开源的跨平台多媒体处理工具，可以用于处理音频、视频和多媒体流。它提供了一组强大的命令行工具和库，可以进行视频转码、视频剪辑、音频提取、音视频合并、流媒体传输等操作。</p>\n<h2 id=\"events模块\"><a href=\"#events模块\" class=\"headerlink\" title=\"events模块\"></a>events模块</h2><p>Node.js的事件模型采用发布订阅的设计思想，将发布者和订阅者之间解耦合，使得双方能够独立地扩展自己。</p>\n<pre><code class=\"javascript\">const EventEmitter = require(&#39;events&#39;);\nconst event = new EventEmitter()\n//监听test\nevent.on(&#39;test&#39;,(data)=&gt;&#123;\n    console.log(data)\n&#125;)\nevent.emit(&#39;test&#39;,&#39;data数据&#39;) //派发事件\n</code></pre>\n<p>event实例默认监听10个为上限，可以通过<code>setMaxListeners()</code>方法来设置监听上限。</p>\n<pre><code class=\"javascript\">event.setMaxListeners(20)\n</code></pre>\n<p><code>event.once方法</code>可以只订阅一次</p>\n<pre><code class=\"javascript\">event.once(&#39;test&#39;,(data)=&gt;&#123;\n    console.log(&#39;once取代on，只监听一次&#39;)\n&#125;)\n</code></pre>\n<p><code>event.off</code>方法取消订阅</p>\n<pre><code class=\"javascript\">event.on(&#39;test&#39;, fn) // 订阅事件\nevent.off(&#39;test&#39;, fn) // 取消事件订阅\n</code></pre>\n<h4 id=\"SSE\"><a href=\"#SSE\" class=\"headerlink\" title=\"SSE\"></a>SSE</h4><ul>\n<li><p>SSE（server send events）服务端推送事件</p>\n</li>\n<li><p>是一种实现服务端向客户端推送数据的技术，也被称为事件流</p>\n</li>\n<li><p>它是基于HTTP协议，利用HTTP协议长连接的优势，实现服务端向客户端推送实时数据。</p>\n</li>\n<li><p>浏览器端需要使用<code>EventSource</code>注册api地址，服务端需要对该地址的响应头中设置Content-Type为 <code>text/event-stream </code></p>\n</li>\n</ul>\n<p><strong>node后端：</strong></p>\n<pre><code class=\"javascript\">import express from &#39;express&#39;;\nconst app = express();\napp.get(&#39;/api/sse&#39;, (req, res) =&gt; &#123;\n    res.writeHead(200, &#123;\n        &#39;Content-Type&#39;: &#39;text/event-stream&#39;, //核心返回数据流\n        &#39;Connection&#39;: &#39;close&#39;\n    &#125;)\n    const data = fs.readFileSync(&#39;./index.txt&#39;, &#39;utf8&#39;)\n    const total = data.length;\n    let current = 0;\n    //mock sse 数据\n    let time = setInterval(() =&gt; &#123;\n        console.log(current, total)\n        if (current &gt;= total) &#123;\n            console.log(&#39;end&#39;)\n            clearInterval(time)\n            return\n        &#125;\n        //返回自定义事件名\n        res.write(`event:name\\n`)\n        //返回数据\n        res.write(`data:$&#123;data.split(&#39;&#39;)[current]&#125;\\n\\n`)\n        current++\n    &#125;, 300)\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;Listening on port 3000&#39;);\n&#125;);\n</code></pre>\n<p><strong>客户端：</strong></p>\n<pre><code class=\"javascript\">const sse = new EventSource(&#39;http://localhost:3000/api/sse&#39; )\nif (sse.readyState === EventSource.CONNECTING) &#123;\n  console.log(&#39;正在连接服务器...&#39;);\n&#125; else if (sse.readyState === EventSource.OPEN) &#123;\n  console.log(&#39;已经连接上服务器！&#39;);\n&#125; else if (sse.readyState === EventSource.CLOSED) &#123;\n  console.log(&#39;连接已经关闭。&#39;);\n&#125;\nsse.onmessage = (data)=&gt;&#123;\n    console.log(data);\n&#125;\nsse.onerror = (e)=&gt;&#123;\n    sse.close(); //关闭连接\n    console.error(e);\n&#125;\nsse.addEventListener(&#39;open&#39;, (e) =&gt; &#123;\n    console.log(&#39;连接成功&#39;);\n&#125;)\n//对应后端nodejs自定义的事件名lol\nsse.addEventListener(&#39;name&#39;, (e) =&gt; &#123;\n    console.log(e.data)\n&#125;)\n</code></pre>\n<h2 id=\"util模块\"><a href=\"#util模块\" class=\"headerlink\" title=\"util模块\"></a>util模块</h2><p>Node.js内部提供的工具集模块，方便快速开发</p>\n<ul>\n<li><p><code>util.promisify</code>将函数改为promise类型的形式</p>\n</li>\n<li><p><code>util.callbackify</code>将promise类型的api改为函数形式</p>\n</li>\n<li><p><code>util.format</code>用于格式化文本</p>\n<ul>\n<li><code>%s</code>: <code>String</code> 将用于转换除 <code>BigInt</code>、<code>Object</code> 和 <code>-0</code> 之外的所有值。 <code>BigInt</code> 值将用 <code>n</code> 表示，没有用户定义的 <code>toString</code> 函数的对象使用具有选项 <code>&#123; depth: 0, colors: false, compact: 3 &#125;</code> 的 <code>util.inspect()</code> 进行检查。</li>\n<li><code>%d</code>: <code>Number</code> 将用于转换除 <code>BigInt</code> 和 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%i</code>: <code>parseInt(value, 10)</code> 用于除 <code>BigInt</code> 和 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%f</code>: <code>parseFloat(value)</code> 用于除 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%j</code>: JSON。 如果参数包含循环引用，则替换为字符串 <code>&#39;[Circular]&#39;</code>。</li>\n<li><code>%o</code>: <code>Object</code>. 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于具有选项 <code>&#123; showHidden: true, showProxy: true &#125;</code> 的 <code>util.inspect()</code>。 这将显示完整的对象，包括不可枚举的属性和代理。</li>\n<li><code>%O</code>: <code>Object</code>. 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于没有选项的 <code>util.inspect()</code>。 这将显示完整的对象，但不包括不可枚举的属性和代理。</li>\n<li><code>%c</code>: <code>CSS</code>. 此说明符被忽略，将跳过任何传入的 CSS。</li>\n<li><code>%%</code>: 单个百分号 (<code>&#39;%&#39;</code>)。 这不消费参数。</li>\n</ul>\n</li>\n<li><p>其他工具函数省略</p>\n</li>\n</ul>\n<h2 id=\"pngquant工具\"><a href=\"#pngquant工具\" class=\"headerlink\" title=\"pngquant工具\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbmdxdWFudC5vcmcv\">pngquant工具</span></h2><p><code>pngquant</code> 是一个用于压缩 PNG 图像文件的工具。它可以显著减小 PNG 文件的大小，同时保持图像质量和透明度。通过减小文件大小，可以提高网页加载速度，并节省存储空间。<code>pngquant</code> 提供命令行接口和库，可轻松集成到各种应用程序和脚本中。</p>\n<h2 id=\"fs模块\"><a href=\"#fs模块\" class=\"headerlink\" title=\"fs模块\"></a>fs模块</h2><p>在 Node.js 中，<code>fs</code> 模块是文件系统模块（File System module）的缩写，它提供了与文件系统进行交互的各种功能。通过 <code>fs</code> 模块，你可以执行诸如读取文件、写入文件、更改文件权限、创建目录等操作，<code>Node.js 核心API之一</code>。</p>\n<h4 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h4><ul>\n<li><p>fs支持同步和异步两种模式 增加了<code>Sync</code> fs 就会采用同步的方式运行代码，会阻塞下面的代码，不加Sync就是异步的模式不会阻塞。</p>\n</li>\n<li><p>fs新增了promise版本，只需要在引入包后面增加&#x2F;promise即可，fs便可支持promise回调。</p>\n</li>\n<li><p>fs返回的是一个buffer二进制数据 每两个十六进制数字表示一个字节</p>\n</li>\n</ul>\n<h4 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h4><ul>\n<li><code>fs.readFile</code>异步读取文件</li>\n<li><code>fs.writeFile</code>异步写入文件</li>\n<li><code>fs.appendFile</code>文件异步追加写入内容</li>\n<li><code>fs.copyFile</code>文件异步拷贝写入</li>\n<li><code>fs.open</code>异步打开文件</li>\n<li><code>fs.close</code>异步关闭文件</li>\n<li><code>fs.read</code>异步读取文件</li>\n<li><code>fs.write</code>异步将Buffer中的数据写入文件</li>\n<li><code>fs.access</code>异步检查文件是否可读可写</li>\n<li><code>fs.stat</code>异步获取文件目录的stats对象（文件夹信息）</li>\n<li><code>fs.mkdir</code>异步创建文件夹</li>\n<li><code>fs.readdir</code>异步读取文件夹</li>\n<li><code>fs.rmdir</code>异步删除目录</li>\n<li><code>fs.unlink</code>异步删除文件</li>\n<li>以上方法都有对应的同步执行的方法，在方法名后面加上Sync后缀即可。</li>\n</ul>\n<h4 id=\"fs-x2F-promises\"><a href=\"#fs-x2F-promises\" class=\"headerlink\" title=\"fs&#x2F;promises\"></a>fs&#x2F;promises</h4><p>node中fs模块的方法提供了Promise版本的调用形式，导入即可使用promise的使用方式调用api</p>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><p>Node.js中fs模块是由libuv来进行调度的，文件读取完成之后libuv才会将fs的结果推入V8的队列。</p>\n<h4 id=\"writeFileSync\"><a href=\"#writeFileSync\" class=\"headerlink\" title=\"writeFileSync\"></a>writeFileSync</h4><ul>\n<li>第一个参数是要写入的文件</li>\n<li>第二个参数是写入的内容</li>\n<li>第三个参数是写入方式配置项，其flag有以下配置：<ul>\n<li><code>&#39;a&#39;</code>: 打开文件进行追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;ax&#39;</code>: 类似于 <code>&#39;a&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;a+&#39;</code>: 打开文件进行读取和追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;ax+&#39;</code>: 类似于 <code>&#39;a+&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;as&#39;</code>: 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;as+&#39;</code>: 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;r&#39;</code>: 打开文件进行读取。 如果文件不存在，则会发生异常。</li>\n<li><code>&#39;r+&#39;</code>: 打开文件进行读写。 如果文件不存在，则会发生异常。</li>\n<li><code>&#39;rs+&#39;</code>: 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。</li>\n<li><code>&#39;w&#39;</code>: 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。</li>\n<li><code>&#39;wx&#39;</code>: 类似于 <code>&#39;w&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;w+&#39;</code>: 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。</li>\n<li><code>&#39;wx+&#39;</code>: 类似于 <code>&#39;w+&#39;</code> 但如果路径存在则失败。</li>\n</ul>\n</li>\n</ul>\n<p>例如追加文件内容除了可以使用<code>appendFileSync</code>之外，还可以：</p>\n<pre><code class=\"javascript\">fs.writeFileSync(&#39;index.txt&#39;, &#39;追加的内容&#39;,&#123;\n    flag: &#39;a&#39; //配置options中的flag\n&#125;)\n</code></pre>\n<h4 id=\"可写流\"><a href=\"#可写流\" class=\"headerlink\" title=\"可写流\"></a>可写流</h4><pre><code class=\"javascript\">const fs = require(&#39;node:fs&#39;)\nlet verse = [\n    &#39;待到秋来九月八&#39;,\n    &#39;我花开后百花杀&#39;,\n    &#39;冲天香阵透长安&#39;,\n    &#39;满城尽带黄金甲&#39;\n]\nlet writeStream = fs.createWriteStream(&#39;index.txt&#39;) //创建写入流\nverse.forEach(item =&gt; &#123;\n    writeStream.write(item + &#39;\\n&#39;) //写入内容\n&#125;)\nwriteStream.end()\nwriteStream.on(&#39;finish&#39;,()=&gt;&#123; //监听写入完成事件\n    console.log(&#39;写入完成&#39;)\n&#125;)\n</code></pre>\n<p>我们可以创建一个可写流 打开一个通道，可以一直写入数据，用于处理大量的数据写入，写入完成之后调用end 关闭可写流，监听finish 事件 写入完成</p>\n<h4 id=\"硬链接、软连接\"><a href=\"#硬链接、软连接\" class=\"headerlink\" title=\"硬链接、软连接\"></a>硬链接、软连接</h4><h6 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h6><ul>\n<li>文件存储在磁盘上，磁盘的最小存储单位叫做<code>扇区</code>，每个扇区存储512字节</li>\n<li>操作系统读取磁盘时，不会一个扇区一个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，多个扇区称之为<code>块</code></li>\n<li><code>块</code>是文件读取的最小单位</li>\n<li>文件数据都存储在<code>块</code>中，因此需要一个地方存储文件的元信息，这中存储文件元信息的区域就叫做<code>inode</code>，索引节点</li>\n<li>创建软链接时生成了新的<code>inode</code>，创建硬链接时没有。</li>\n</ul>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-07-39.png\" alt=\"扇区、块和inode\"></p>\n<p><strong>inode中包含信息：</strong></p>\n<ul>\n<li>文件的字节数</li>\n<li>文件拥有者ID</li>\n<li>文件的Group ID</li>\n<li>文件读、写、执行权限</li>\n<li>文件的时间戳</li>\n<li>链接数</li>\n<li>文件数据block的位置</li>\n</ul>\n<p>每一个 <code>inode</code> 都有一个唯一的标识码 ，上面的输出信息中 <code>ino</code> 就是 <code>inode</code> 的唯一标识码，在 <code>linux</code> 系统内部使用 <code>inode</code> 的标识码来识别文件，并不使用文件名。之前系的</p>\n<p>在 <code>linux</code> 系统中，目录也是一种文件。目录文件包含一系列目录项，每一个目录项由两部分组成：所包含文件的文件名，以及文件名对应的 <code>inode</code> 标识码。我们可以使用 <code>ls -i</code> 来列出目录中的文件以及所有的 <code>inde</code> 标识码。这里也可以解释可能小伙伴们觉得说不通的问题，仅修改目录的读权限，并不能实现读取目录下所有文件内容的原因，最后需要通过递归目录下的文件来进行修改。</p>\n<h6 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h6><p>软链接类似于 <code>Window</code> 中的 “快捷方式” 。创建软链接会创建一个新的 <code>inode</code>，比如为文件 <code>a</code> 创建了软链接文件 b，文件 <code>b</code> 内部会指向 <code>a</code> 的 <code>inode</code>。当我们读取文件<code>b</code>的时候，系统会自动导向文件 <code>a</code> ，文件 <code>b</code> 就是文件 <code>a</code> 软连接(或者叫符号链接)。</p>\n<ul>\n<li>访问：创建了软链接后我们就可以使用不同的文件名访问相同的内容，</li>\n<li>修改：修改文件 <code>a</code> 的内容，文件 <code>b</code> 的内容也会发生改变，对文件内容的修改向放映到所有文件。</li>\n<li>删除：当我们删除源文件 <code>a</code> 时，在访问软连接文件 b 是，会报错 <code>&quot;No such file or directory&quot;</code></li>\n</ul>\n<p>可以直接使用 <code>linux</code> 命令 <code>ln -s source target</code> 来创建软链接(注意：表示 <code>target</code> “指向” <code>source</code>）</p>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-12-05.png\" alt=\"软链接\"></p>\n<h6 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h6><p>一般情况，一个文件名”唯一”对应一个 <code>inode</code>。但是 <code>linux</code> 允许多个文件名都指向同一个 <code>inode</code>。表示我们可以使用不同对文件名访问同样的内容；对文件内容进行修改将放映到所有文件；删除一个文件不影响另一个文件对访问。这种机制就被称为”硬链接”</p>\n<p>硬链接的创建 可以直接使用 <code>linux</code> 命令 <code>ln source target</code> 来创建硬链接（注意：<code>source</code> 已存在的文件，target 是将要建立的链接）</p>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-14-11.png\" alt=\"硬链接\"></p>\n<h6 id=\"创建链接\"><a href=\"#创建链接\" class=\"headerlink\" title=\"创建链接\"></a>创建链接</h6><pre><code class=\"javascript\">fs.linkSync(&#39;./index.txt&#39;, &#39;./index2.txt&#39;) //硬链接\nfs.symlinkSync(&#39;./index.txt&#39;, &#39;./index3.txt&#39; ,&quot;file&quot;) //软连接\n</code></pre>\n<h6 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h6><p><strong>硬链接的作用和用途如下：</strong></p>\n<ol>\n<li>文件共享：硬链接允许多个文件名指向同一个文件，这样可以在不同的位置使用不同的文件名引用相同的内容。这样的共享文件可以节省存储空间，并且在多个位置对文件的修改会反映在所有引用文件上。</li>\n<li>文件备份：通过创建硬链接，可以在不复制文件的情况下创建文件的备份。如果原始文件发生更改，备份文件也会自动更新。这样可以节省磁盘空间，并确保备份文件与原始文件保持同步。</li>\n<li>文件重命名：通过创建硬链接，可以为文件创建一个新的文件名，而无需复制或移动文件。这对于需要更改文件名但保持相同内容和属性的场景非常有用。</li>\n</ol>\n<p><strong>软链接的一些特点和用途如下：</strong></p>\n<ol>\n<li>软链接可以创建指向文件或目录的引用。这使得你可以在不复制或移动文件的情况下引用它们，并在不同位置使用不同的文件名访问相同的内容。</li>\n<li>软链接可以用于创建快捷方式或别名，使得你可以通过一个简短或易记的路径来访问复杂或深层次的目录结构。</li>\n<li>软链接可以用于解决文件或目录的位置变化问题。如果目标文件或目录被移动或重命名，只需更新软链接的目标路径即可，而不需要修改引用该文件或目录的其他代码。</li>\n</ol>\n<h2 id=\"crypto模块\"><a href=\"#crypto模块\" class=\"headerlink\" title=\"crypto模块\"></a>crypto模块</h2><p>crypto模块的目的是为了提供通用的<code>加密和哈希算法</code>。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。nodejs用C&#x2F;C++实现这些算法后，通过crypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>\n<p>密码学是计算机科学中的一个重要领域，它涉及到加密、解密、哈希函数和数字签名等技术。Node.js是一个流行的服务器端JavaScript运行环境，它提供了强大的密码学模块，使开发人员能够轻松地在其应用程序中实现各种密码学功能。本文将介绍密码学的基本概念，并探讨Node.js中常用的密码学API。</p>\n<h4 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h4><pre><code class=\"javascript\">js复制代码const crypto = require(&#39;node:crypto&#39;);\n\n// 生成一个随机的 16 字节的初始化向量 (IV)\nconst iv = Buffer.from(crypto.randomBytes(16));\n\n// 生成一个随机的 32 字节的密钥\nconst key = crypto.randomBytes(32);\n\n// 创建加密实例，使用 AES-256-CBC 算法，提供密钥和初始化向量\nconst cipher = crypto.createCipheriv(&quot;aes-256-cbc&quot;, key, iv);\n\n// 对输入数据进行加密，并输出加密结果的十六进制表示\ncipher.update(&quot;小满zs&quot;, &quot;utf-8&quot;, &quot;hex&quot;);\nconst result = cipher.final(&quot;hex&quot;);\n\n// 解密\nconst de = crypto.createDecipheriv(&quot;aes-256-cbc&quot;, key, iv);\nde.update(result, &quot;hex&quot;);\nconst decrypted = de.final(&quot;utf-8&quot;);\n\nconsole.log(&quot;Decrypted:&quot;, decrypted);\n</code></pre>\n<p>对称加密是一种简单而快速的加密方式，它使用相同的密钥（称为对称密钥）来进行加密和解密。这意味着发送者和接收者在加密和解密过程中都使用相同的密钥。对称加密算法的加密速度很快，适合对大量数据进行加密和解密操作。然而，对称密钥的安全性是一个挑战，因为需要确保发送者和接收者都安全地共享密钥，否则有风险被未授权的人获取密钥并解密数据。</p>\n<h4 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h4><pre><code class=\"javascript\">js复制代码const crypto = require(&#39;node:crypto&#39;)\n// 生成 RSA 密钥对\nconst &#123; privateKey, publicKey &#125; = crypto.generateKeyPairSync(&#39;rsa&#39;, &#123;\n  modulusLength: 2048,\n&#125;);\n\n// 要加密的数据\nconst text = &#39;小满zs&#39;;\n\n// 使用公钥进行加密\nconst encrypted = crypto.publicEncrypt(publicKey, Buffer.from(text, &#39;utf-8&#39;));\n\n// 使用私钥进行解密\nconst decrypted = crypto.privateDecrypt(privateKey, encrypted);\n\nconsole.log(decrypted.toString());\n</code></pre>\n<p>非对称加密使用一对密钥，分别是公钥和私钥。发送者使用接收者的公钥进行加密，而接收者使用自己的私钥进行解密。公钥可以自由分享给任何人，而私钥必须保密。非对称加密算法提供了更高的安全性，因为即使公钥泄露，只有持有私钥的接收者才能解密数据。然而，非对称加密算法的加密速度相对较慢，不适合加密大量数据。因此，在实际应用中，通常使用非对称加密来交换对称密钥，然后使用对称加密算法来加密实际的数据。</p>\n<h4 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h4><pre><code class=\"javascript\">const crypto = require(&#39;node:crypto&#39;);\n// 要计算哈希的数据\nlet text = &#39;123456&#39;;\n// 创建哈希对象，并使用 MD5 算法\nconst hash = crypto.createHash(&#39;md5&#39;);\n// 更新哈希对象的数据\nhash.update(text);\n// 计算哈希值，并以十六进制字符串形式输出\nconst hashValue = hash.digest(&#39;hex&#39;);\nconsole.log(&#39;Text:&#39;, text);\nconsole.log(&#39;Hash:&#39;, hashValue);\n</code></pre>\n<p>哈希函数具有以下特点：</p>\n<ol>\n<li>固定长度输出：不论输入数据的大小，哈希函数的输出长度是固定的。例如，常见的哈希函数如 MD5 和 SHA-256 生成的哈希值长度分别为 128 位和 256 位。</li>\n<li>不可逆性：哈希函数是单向的，意味着从哈希值推导出原始输入数据是非常困难的，几乎不可能。即使输入数据发生微小的变化，其哈希值也会完全不同。</li>\n<li>唯一性：哈希函数应该具有较低的碰撞概率，即不同的输入数据生成相同的哈希值的可能性应该非常小。这有助于确保哈希值能够唯一地标识输入数据。</li>\n</ol>\n<p>使用场景</p>\n<ol>\n<li>我们可以避免密码明文传输 使用md5加密或者sha256</li>\n<li>验证文件完整性，读取文件内容生成md5 如果前端上传的md5和后端的读取文件内部的md5匹配说明文件是完整的</li>\n</ol>\n<h2 id=\"md转html\"><a href=\"#md转html\" class=\"headerlink\" title=\"md转html\"></a>md转html</h2><h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><ul>\n<li>ejs：模板渲染库，使用特定语法填充内容，进行模板渲染</li>\n<li>marked：用于将Markdown语法转为HTML</li>\n<li>browserSync：用于在浏览器实时预览和同步刷新</li>\n</ul>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>index.js</p>\n<pre><code class=\"javascript\">const ejs = require(&#39;ejs&#39;); // 导入ejs库，用于渲染模板\nconst fs = require(&#39;node:fs&#39;); // 导入fs模块，用于文件系统操作\nconst marked = require(&#39;marked&#39;); // 导入marked库，用于将Markdown转换为HTML\nconst readme = fs.readFileSync(&#39;README.md&#39;); // 读取README.md文件的内容,直接read的结果是buffer中的数据，通过toString方法变为原始内容\nconst browserSync = require(&#39;browser-sync&#39;); // 导入browser-sync库，用于实时预览和同步浏览器\nconst openBrowser =  () =&gt; &#123;\n    // 创建浏览器服务\n    const browser = browserSync.create()\n    // 初始化浏览器服务 ，传入目录和主页\n    browser.init(&#123;\n        server: &#123;\n            baseDir: &#39;./&#39;,\n            index: &#39;index.html&#39;,\n        &#125;\n    &#125;)\n    return browser\n&#125;\n// ejs模板进行渲染，传入变量\nejs.renderFile(&#39;template.ejs&#39;, &#123;\n    content: marked.parse(readme.toString()),\n    title:&#39;markdown to html&#39;\n&#125;,(err,data)=&gt;&#123;\n    if(err)&#123;\n        console.log(err)\n    &#125;\n    // 将文件内容写入到index.html\n    let writeStream = fs.createWriteStream(&#39;index.html&#39;)\n    writeStream.write(data)\n    writeStream.close()\n    writeStream.on(&#39;finish&#39;,()=&gt;&#123;\n        // index.html写入完毕之后，打开浏览器实时预览\n        openBrowser()\n    &#125;)\n&#125;)     \n</code></pre>\n<p>template.ejs</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;  &lt;!-- 引入css样式 --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%- content %&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>index.css</p>\n<pre><code class=\"css\">/* Markdown通用样式 */\n/* 设置全局字体样式 */\nbody &#123;\n    font-family: Arial, sans-serif;\n    font-size: 16px;\n    line-height: 1.6;\n    color: #333;\n  &#125;\n  /* 设置标题样式 */\n  h1,h2,h3,h4,h5,h6 &#123;\n    margin-top: 1.3em;\n    margin-bottom: 0.6em;\n    font-weight: bold;\n  &#125;\n  h1 &#123;\n    font-size: 2.2em;\n  &#125;\n  h2 &#123;\n    font-size: 1.8em;\n  &#125;\n  h3 &#123;\n    font-size: 1.6em;\n  &#125;\n  h4 &#123;\n    font-size: 1.4em;\n  &#125;\n  h5 &#123;\n    font-size: 1.2em;\n  &#125;\n  h6 &#123;\n    font-size: 1em;\n  &#125;\n  /* 设置段落样式 */\n  p &#123;\n    margin-bottom: 1.3em;\n  &#125;\n  /* 设置链接样式 */\n  a &#123;\n    color: #337ab7;\n    text-decoration: none;\n  &#125;\n  a:hover &#123;\n    text-decoration: underline;\n  &#125;\n  /* 设置列表样式 */\n  ul,\n  ol &#123;\n    margin-top: 0;\n    margin-bottom: 1.3em;\n    padding-left: 2em;\n  &#125;\n  /* 设置代码块样式 */\n  pre &#123;\n    background-color: #f7f7f7;\n    padding: 1em;\n    border-radius: 4px;\n    overflow: auto;\n  &#125;\n  code &#123;\n    font-family: Consolas, Monaco, Courier, monospace;\n    font-size: 0.9em;\n    background-color: #f7f7f7;\n    padding: 0.2em 0.4em;\n    border-radius: 4px;\n  &#125;\n  /* 设置引用样式 */\n  blockquote &#123;\n    margin: 0;\n    padding-left: 1em;\n    border-left: 4px solid #ddd;\n    color: #777;\n  &#125;\n  /* 设置表格样式 */\n  table &#123;\n    border-collapse: collapse;\n    width: 100%;\n    margin-bottom: 1.3em;\n  &#125;\n  table th,\n  table td &#123;\n    padding: 0.5em;\n    border: 1px solid #ccc;\n  &#125;\n  /* 添加一些额外的样式，如图片居中显示 */\n  img &#123;\n    display: block;\n    margin: 0 auto;\n    max-width: 100%;\n    height: auto;\n  &#125;\n  /* 设置代码行号样式 */\n  pre code .line-numbers &#123;\n    display: inline-block;\n    width: 2em;\n    padding-right: 1em;\n    color: #999;\n    text-align: right;\n    user-select: none;\n    pointer-events: none;\n    border-right: 1px solid #ddd;\n    margin-right: 0.5em;\n  &#125;\n  /* 设置代码行样式 */\n  pre code .line &#123;\n    display: block;\n    padding-left: 1.5em;\n  &#125;\n  /* 设置代码高亮样式 */\n  pre code .line.highlighted &#123;\n    background-color: #f7f7f7;\n  &#125;\n  /* 添加一些响应式样式，适应移动设备 */\n  @media only screen and (max-width: 768px) &#123;\n    body &#123;\n      font-size: 14px;\n      line-height: 1.5;\n    &#125;\n    h1 &#123;\n      font-size: 1.8em;\n    &#125;\n    h2 &#123;\n      font-size: 1.5em;\n    &#125;\n    h3 &#123;\n      font-size: 1.3em;\n    &#125;\n    h4 &#123;\n      font-size: 1.1em;\n    &#125;\n    h5 &#123;\n      font-size: 1em;\n    &#125;\n    h6 &#123;\n      font-size: 0.9em;\n    &#125;\n    table &#123;\n      font-size: 14px;\n    &#125;\n  &#125;    \n</code></pre>\n<h2 id=\"zlib模块\"><a href=\"#zlib模块\" class=\"headerlink\" title=\"zlib模块\"></a>zlib模块</h2><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ul>\n<li>Node.js中zlib模块用于对数据提供压缩和解压缩的功能，以便在应用程序中减少数据的传输大小、节省带宽和提高性能</li>\n<li>该模块包含各种压缩算法，包含Deflate、Gzip和Raw Deflate等</li>\n</ul>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><ul>\n<li><p>数据压缩，减少数据的大小，这在网络传输和磁盘存储中很有用，可以节省带宽和存储空间</p>\n</li>\n<li><p>数据解压缩</p>\n</li>\n<li><p>流压缩，zlib模块支持流式的方式进行数据的压缩和解压缩，使得可以对大型文件或者网络数据流进行逐步处理，而不需要将整个数据加载到内存中。</p>\n<pre><code class=\"javascript\">// 压缩文件（以Gzip为例）\nconst zlib = require(&#39;zlib&#39;)\nconst fs = require(&#39;node:fs&#39;)\nconst readStream = fs.createReadStream(&#39;./test.txt&#39;);\nconst writeStream = fs.createWriteStream(&#39;./test.txt.gz&#39;);\n// 将readStream利用zlib进行压缩,pipe到下一个管道，最后pipe到写入流\nreadStream.pipe(zlib.createGzip()).pipe(writeStream)\n// 解压缩文件\nconst reStr = fs.createReadStream(&#39;./test.txt.gz&#39;);\nconst wrStr = fs.createWriteStream(&#39;./t.txt&#39;);\nconst gunzip = zlib.createGunzip();\nreStr.pipe(gunzip).pipe(wrStr);\ngunzip.on(&#39;error&#39;, (err) =&gt; &#123;\n    console.error(&#39;Gunzip error:&#39;, err);\n&#125;);\n  reStr.on(&#39;end&#39;, () =&gt; &#123;\n    console.log(&#39;Input file has been read.&#39;);\n&#125;);\n  wrStr.on(&#39;finish&#39;, () =&gt; &#123;\n    console.log(&#39;Output file has been written.&#39;);\n&#125;);\n</code></pre>\n<h4 id=\"对比-1\"><a href=\"#对比-1\" class=\"headerlink\" title=\"对比\"></a>对比</h4><ol>\n<li>压缩算法：Gzip 使用的是 Deflate 压缩算法，该算法结合了 LZ77 算法和哈夫曼编码。LZ77 算法用于数据的重复字符串的替换和引用，而哈夫曼编码用于进一步压缩数据。</li>\n<li>压缩效率：Gzip 压缩通常具有更高的压缩率，因为它使用了哈夫曼编码来进一步压缩数据。哈夫曼编码根据字符的出现频率，将较常见的字符用较短的编码表示，从而减小数据的大小。</li>\n<li>压缩速度：相比于仅使用 Deflate 的方式，Gzip 压缩需要更多的计算和处理时间，因为它还要进行哈夫曼编码的步骤。因此，在压缩速度方面，Deflate 可能比 Gzip 更快。</li>\n<li>应用场景：Gzip 压缩常用于文件压缩、网络传输和 HTTP 响应的内容编码。它广泛应用于 Web 服务器和浏览器之间的数据传输，以减小文件大小和提高网络传输效率。</li>\n<li>deflate是一种过时的压缩方式，现代浏览器对其支持并不友好</li>\n</ol>\n</li>\n</ul>\n<p><strong>zlib模块可以用于对发送网络请求返回的数据进行压缩，节省带宽和传输速率。</strong></p>\n<h4 id=\"brotli\"><a href=\"#brotli\" class=\"headerlink\" title=\"brotli\"></a>brotli</h4><ul>\n<li>针对常见的 Web 资源内容，Brotli 的性能比 Gzip 提高了 17-25%；</li>\n<li>当 Brotli 压缩级别为 1 时，压缩率比 Gzip 的最高级别 9 还要高；</li>\n<li>在处理不同的 HTML 文档时，Brotli 依然能提供非常高的压缩率。</li>\n<li>除了 IE 和 Opera Mini 之外，几乎所有主流浏览器都已支持 Brotli 算法。</li>\n<li>尽管 Brotli 在压缩方面表现出色，但随着压缩级别的提高，Brotli 压缩所需的时间也会相应增加。换句话说，Brotli 需要更多的计算能力，这可能意味着更高的设备和软件成本。</li>\n<li>Brotli 要求浏览器必须支持 HTTPS 才能使用。</li>\n</ul>\n<h2 id=\"http模块\"><a href=\"#http模块\" class=\"headerlink\" title=\"http模块\"></a>http模块</h2><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ul>\n<li>http模块是Node.js中用于创建和处理HTTP服务器和客户端的核心模块</li>\n<li>http模块使得基于HTTP协议的应用程序更加简单和灵活</li>\n<li>http模块也可以用于创建代理服务器，用于转发客户端的请求到其他服务器，代理服务器可以用于负载均衡、缓存、安全过滤或跨域请求等场景。通过在代理服务器上添加逻辑，可以对请求和响应进行修改、记录或过滤。</li>\n<li>http模块也可以创建文件服务器，用于提供静态文件，通过读取文件并将其作为响应发送给客户端。</li>\n</ul>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code class=\"javascript\">const http = require(&#39;http&#39;)\nconst httpServer = http.createServer((req,res)=&gt;&#123;\n    if(req.method === &#39;POST&#39;)&#123;&#125;\n    else if(req.method === &#39;GET&#39;)&#123;&#125;\n&#125;)\nhttpServer.listen(98,()=&gt;&#123;\n    console.log(&#39;服务器启动，端口：98&#39;);\n&#125;)\n</code></pre>\n<h4 id=\"url模块\"><a href=\"#url模块\" class=\"headerlink\" title=\"url模块\"></a>url模块</h4><p>可以通过url模块来解析req的请求路径，来进一步精细化响应内容。</p>\n<pre><code class=\"javascript\">const http = require(&#39;node:http&#39;); // 引入 http 模块\nconst url = require(&#39;node:url&#39;); // 引入 url 模块\n// 创建 HTTP 服务器，并传入回调函数用于处理请求和生成响应\nhttp.createServer((req, res) =&gt; &#123;\n  const &#123; pathname, query &#125; = url.parse(req.url, true); // 解析请求的 URL，获取路径和查询参数\n  if (req.method === &#39;POST&#39;) &#123; // 检查请求方法是否为 POST\n    if (pathname === &#39;/post&#39;) &#123; // 检查路径是否为 &#39;/post&#39;\n      let data = &#39;&#39;;\n      req.on(&#39;data&#39;, (chunk) =&gt; &#123;\n        data += chunk; // 获取 POST 请求的数据\n        console.log(data);\n      &#125;);\n      req.on(&#39;end&#39;, () =&gt; &#123;\n        res.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); // 设置响应头的 Content-Type 为 &#39;application/json&#39;\n        res.statusCode = 200; // 设置响应状态码为 200\n        res.end(data); // 将获取到的数据作为响应体返回\n      &#125;);\n    &#125; else &#123;\n      res.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); // 设置响应头的 Content-Type 为 &#39;application/json&#39;\n      res.statusCode = 404; // 设置响应状态码为 404\n      res.end(&#39;Not Found&#39;); // 返回 &#39;Not Found&#39; 作为响应体\n    &#125;\n  &#125; else if (req.method === &#39;GET&#39;) &#123; // 检查请求方法是否为 GET\n    if (pathname === &#39;/get&#39;) &#123; // 检查路径是否为 &#39;/get&#39;\n      console.log(query.a); // 打印查询参数中的键名为 &#39;a&#39; 的值\n      res.end(&#39;get success&#39;); // 返回 &#39;get success&#39; 作为响应体\n    &#125;\n  &#125;\n&#125;).listen(98, () =&gt; &#123;\n  console.log(&#39;server is running on port 98&#39;); // 打印服务器启动的信息\n&#125;);\n</code></pre>\n<h2 id=\"net模块\"><a href=\"#net模块\" class=\"headerlink\" title=\"net模块\"></a>net模块</h2><p><strong>介绍：</strong></p>\n<ul>\n<li>net模块是Node.js的核心模块之一，提供了用于创建基于网络的应用程序的API</li>\n<li>net模块主要用于<strong>创建TCP服务器和TCP客户端，以及处理网络通信</strong></li>\n</ul>\n<p><strong>应用场景：</strong></p>\n<ul>\n<li><p>服务端之间的通讯</p>\n<ul>\n<li><p>服务端之间的通讯可以直接使用TCP通讯，而不需要上升到http层</p>\n</li>\n<li><p>server.js（TCP层面的服务端）</p>\n<pre><code class=\"javascript\">const net = require(&#39;net&#39;)\nconst server = net.createServer((client)=&gt;&#123;\n  setTimeout(() =&gt; &#123;\n  client.write(&#39;发送TCP内容&#39;)\n  &#125;, 1000);\n&#125;)\nserver.listen(3000,()=&gt;&#123;\n  console.log(&#39;3000端口启动服务&#39;);\n&#125;)\n</code></pre>\n</li>\n<li><p>connection.js（TCP层面的客户端）</p>\n<pre><code class=\"javascript\">const net = require(&#39;net&#39;)\nconst connection = net.createConnection(&#123;\n  host:&#39;127.0.0.1&#39;,\n  port:3000\n&#125;)\nconnection.on(&#39;data&#39;,(data)=&gt;&#123;\n  console.log(data.toString());\n&#125;)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>从传输层实现http协议</p>\n<pre><code class=\"javascript\">const net = require(&#39;net&#39;);\nconst html = `&lt;h1&gt;TCP Server&lt;/h1&gt;`\nconst reposneHeader = [\n    &#39;HTTP/1.1 200 OK&#39;,\n    &#39;Content-Type: text/html&#39;,\n    &#39;Content-Length: &#39; + html.length,\n    &#39;Server: Nodejs&#39;,\n    &#39;\\r\\n&#39;,\n    html\n]\nconst http = net.createServer((connect)=&gt;&#123;\n  connect.on(&#39;data&#39;,(data)=&gt;&#123;\n    console.log(data.toString().slice(0,3));\n    if(data.toString().startsWith(&#39;GET&#39;))&#123;\n      connect.write(reposneHeader.join(&#39;\\r\\n&#39;)) //向TCP连接中写入html响应\n      connect.end()\n    &#125;\n  &#125;)\n&#125;)\nhttp.listen(3000,()=&gt;&#123;\n  console.log(&#39;服务启动&#39;);\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><ul>\n<li>动静分离是Web服务器架构中常用的优化技术，用于提高网站的性能和可伸缩性</li>\n<li>原理就是将静态资源的请求和动态内容分开处理（通过url，例如加上static后缀表示静态）</li>\n<li>好处在于：<ul>\n<li>性能优化（静态资源内容不变，可以利用缓存）</li>\n<li>负载均衡（动态内容请求分发到不同的服务器或服务上，平衡服务器的负载）</li>\n<li>安全性（动态内容往往涉及敏感信息，动静分离可以更好地管理访问控制和安全策略）</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"javascript\">import http from &#39;node:http&#39; // 导入http模块\nimport fs from &#39;node:fs&#39; // 导入文件系统模块\nimport path from &#39;node:path&#39; // 导入路径处理模块\nimport mime from &#39;mime&#39; // 导入mime模块\nconst server = http.createServer((req, res) =&gt; &#123;\n    const &#123; url, method &#125; = req\n    // 处理静态资源\n    if (method === &#39;GET&#39; &amp;&amp; url.startsWith(&#39;/static&#39;)) &#123;\n        const filePath = path.join(process.cwd(), url) // 获取文件路径\n        const mimeType = mime.getType(filePath) // 获取文件的MIME类型\n        console.log(mimeType) // 打印MIME类型\n        fs.readFile(filePath, (err, data) =&gt; &#123; // 读取文件内容\n            if (err) &#123;\n                res.writeHead(404, &#123;\n                    &quot;Content-Type&quot;: &quot;text/plain&quot; // 设置响应头为纯文本类型\n                &#125;)\n                res.end(&#39;not found&#39;) // 返回404 Not Found\n            &#125; else &#123;\n                res.writeHead(200, &#123;\n                    &quot;Content-Type&quot;: mimeType, // 设置响应头为对应的MIME类型\n                    &quot;Cache-Control&quot;: &quot;public, max-age=3600&quot; // 设置缓存控制头\n                &#125;)\n                res.end(data) // 返回文件内容\n            &#125;\n        &#125;)\n    &#125;\n    // 处理动态资源\n    if (url.startsWith(&#39;/api&#39;)) &#123;\n        // ...处理动态资源的逻辑\n    &#125;\n&#125;)\nserver.listen(80) // 监听端口80\n</code></pre>\n<h2 id=\"邮件服务\"><a href=\"#邮件服务\" class=\"headerlink\" title=\"邮件服务\"></a>邮件服务</h2><p>邮件服务可以用于给成员发送邮件、通知成员信息，在node.js上创建邮件服务，需要提供授权码。</p>\n<p><strong>工具：</strong></p>\n<ul>\n<li>js-yaml：用于将yaml转为js对象</li>\n<li>nodemailer：用于创建邮件服务</li>\n</ul>\n<p><strong>使用：</strong></p>\n<pre><code class=\"javascript\">// node.js发送邮件\nconst yamlTrans = require(&#39;js-yaml&#39;);\nconst fs = require(&#39;fs&#39;);\nconst nodemailer = require(&#39;nodemailer&#39;)\nconst yamlCode = fs.readFileSync(&#39;./data.yaml&#39;,&#39;utf-8&#39;);\nconst dataObj = yamlTrans.load(yamlCode);\n//nodemailer.createTransport创建transPort服务,传入auth信息和配置项\n//授权码需要到对应官网生成\nconst transPort = nodemailer.createTransport(&#123;\n    serviece:&#39;qq&#39;,\n    port:587,\n    host:&#39;smtp.qq.cmo&#39;,\n    secure:true,\n    auth:&#123;\n        pass:dataObj.pass, //授权码需要去官网申请生成\n        user:dataObj.user\n    &#125;\n&#125;)\n// sendMail方法发送邮件，传入接收方信息\ntransPort.sendMail(&#123;\n    to: send.qq.com,\n    from: dataObj.user,\n    subject: &#39;邮件标题&#39;,\n    text: &#39;邮件内容&#39;\n&#125;)\n</code></pre>\n<h2 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h2><p>防盗链是指在网页或其他资源中，通过直接链接的方式链接到其他网站上的图片、视频或者其他媒体文件，显示在自己的网页上，这种行为通常会给被链接的网站带来额外的带宽消耗和资源浪费，而且可能侵犯了原始网站的版权。采用措施有：</p>\n<ul>\n<li><strong>通过HTTP引用检查</strong>：（查看请求来源地址，不匹配则不提供资源）</li>\n<li><strong>使用Referrer检查</strong>：检查HTTP请求中的Referrer字段，该字段指示了请求资源的来源页面（不匹配则不提供服务）</li>\n<li><strong>使用访问控制列表</strong>（ACL）：网站管理员可以配置服务器的访问控制列表，只允许特定的域名或IP地址访问资源，其他来源的请求将被拒绝。</li>\n<li><strong>使用防盗链插件或脚本</strong>：一些网站平台和内容管理系统提供了专门的插件或脚本来防止盗链。这些工具可以根据需要配置，阻止来自未经授权的网站的盗链请求。</li>\n<li><strong>使用水印技术</strong>：在图片或视频上添加水印可以帮助识别盗链行为，并提醒用户资源的来源。</li>\n</ul>\n<pre><code class=\"javascript\">import express from &#39;express&#39;;\nconst app = express();\nconst whitelist = [&#39;localhost&#39;];\n//防盗链中间件\nconst preventHotLinking = (req,res,next)=&gt;&#123;\n    const referer = req.get(&#39;referer&#39;); //请求中的referrer字段标识请求来源\n    if(referer)&#123;\n        const &#123;hostname&#125; = new URL(referer);\n        if(!whistlist.includes(hostname))&#123;\n            res.status(403).send(&#39;我不允许你访问我的资源&#39;);\n            return;\n        &#125;\n    &#125;\n    next();\n&#125;;\napp.use(preventHotLinking);\napp.listen(3000,()=&gt;&#123;\n    console.log(&#39;3000端口启动&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"响应头和请求头\"><a href=\"#响应头和请求头\" class=\"headerlink\" title=\"响应头和请求头\"></a>响应头和请求头</h2><p><strong>响应头：</strong></p>\n<ul>\n<li><p>HTTP响应头（HTTP response headers）是在HTTP响应中发送的元数据信息，用于描述响应的特性、内容和行为。他们以键值对的形式出现。每个键值对由一个标头字段和响应值组成。</p>\n<pre><code class=\"http\">Access-Control-Allow-Origin: *\nCache-Control:public, max-age=0, must-revalidate\nContent-Type:text/html; charset=utf-8\nServer:nginx\nDate:Mon, 08 Jan 2024 18:32:47 GMT\n</code></pre>\n</li>\n</ul>\n<p><strong>cors：</strong></p>\n<ul>\n<li><p>跨域资源共享（CORS）是一种机制，用于在浏览器中实现跨域请求访问资源的权限控制。</p>\n</li>\n<li><p>当一个网页通过XMLHttpRequest或者Fetch Api进行跨域请求时，浏览器会根据同源策略进行限制。</p>\n</li>\n<li><p>同源策略要求请求的协议、域名和端口号必须一致。</p>\n</li>\n</ul>\n<p><strong>请求头：</strong></p>\n<ul>\n<li><p>Accept：指定客户端能够处理的内容类型。</p>\n</li>\n<li><p>Accept-Language：指定客户端偏好的自然语言。</p>\n</li>\n<li><p>Content-Language：指定请求或响应实体的自然语言。</p>\n</li>\n<li><p>Content-Type：指定请求或响应实体的媒体类型。</p>\n</li>\n<li><p>DNT (Do Not Track)：指示客户端不希望被跟踪。</p>\n</li>\n<li><p>Origin：指示请求的源（协议、域名和端口）。</p>\n</li>\n<li><p>User-Agent：包含发起请求的用户代理的信息。</p>\n</li>\n<li><p>Referer：指示当前请求的源 URL。</p>\n</li>\n<li><p>Content-type: application&#x2F;x-www-form-urlencoded | multipart&#x2F;form-data |  text&#x2F;plain</p>\n</li>\n</ul>\n<p><strong>请求方法支持：</strong></p>\n<p>服务端默认只支持GET、POST、HEAD、OPTIONS请求，使用其他 restful api请求方法需要添加响应头<code>Access-Control-Allow-Methods: *</code></p>\n<h2 id=\"SSE-1\"><a href=\"#SSE-1\" class=\"headerlink\" title=\"SSE\"></a>SSE</h2><ul>\n<li><p>SSE（Server-Sent-Events）是一种在客户端和服务器之间实现单向事件流的机制，允许服务器主动向客户端发送事件数据，在SSE中可以自定义事件来完成。</p>\n</li>\n<li><p>SSE核心就是：</p>\n<ul>\n<li>前端通过<code>EventSource</code> 来注册事件源，监听对应事件。</li>\n<li>后端通过设置响应头<code>Content-Type</code>为：<code>text/event-stream</code> 之后 发送具有特定类型的事件数据。</li>\n</ul>\n</li>\n</ul>\n<p><strong>前端：</strong></p>\n<pre><code class=\"javascript\">const sse = new EventSource(&#39;http://localhost:3000/sse&#39;);\nsse.addEventListener(&#39;test&#39;,(event)=&gt;&#123;\n    console.log(event.data);\n&#125;)\n</code></pre>\n<p><strong>后端：</strong></p>\n<pre><code class=\"javascript\">app.get(&#39;/sse&#39;(req,res)=&gt;&#123;\n    res.setHeader(&#39;Content-Type&#39;,&#39;text/event-stream&#39;); //设置事件响应头\n    res.status(200);\n    setInterval(()=&gt;&#123;\n        res.write(&#39;event: test\\n&#39;); // 发送对应的事件\n        res.write(&#39;data: &#39; + new Date().getTime() + &#39;\\n\\n&#39;);\n    &#125;,1000)\n&#125;)\n</code></pre>\n<h2 id=\"ORM框架\"><a href=\"#ORM框架\" class=\"headerlink\" title=\"ORM框架\"></a>ORM框架</h2><ul>\n<li>ORM(Object Relation Map)：对象关系映射，常用于为关系型数据库提供类型安全的支持。</li>\n</ul>\n<h4 id=\"knex\"><a href=\"#knex\" class=\"headerlink\" title=\"knex\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9rbmV4anMub3JnL2d1aWRlL3F1ZXJ5LWJ1aWxkZXIuaHRtbCNzZWxlY3Q=\">knex</span></h4><ul>\n<li>knex是一个基于JavaScript的查询生成器</li>\n<li>knex允许使用JavaScript代码来生成和执行SQL查询语句</li>\n<li>knex提供了一种简单和直观的方式来与关系型数据库进行交互，而无需编写SQL语句</li>\n<li>可以使用knex来定义表结构，执行查询、插入、更新和删除等操作。</li>\n</ul>\n<p><strong>连接数据库：</strong></p>\n<pre><code class=\"javascript\">import knex from &#39;knex&#39;;\nconst db = knex(&#123;\n    client: &quot;mysql2&quot;,\n    connection:&#123;\n        user:root,\n        password:&#39;123456&#39;,\n        host:localhost,\n        port:3306,\n        database:test\n    &#125;\n&#125;)\n</code></pre>\n<p>增删改查详见官网。</p>\n<p><strong>事务：</strong></p>\n<p>事务相当于分组的一个概念，可以使用事务来确保一组数据库操作的原子性，要么全部成功提交，要么全部回滚。</p>\n<h4 id=\"prisma\"><a href=\"#prisma\" class=\"headerlink\" title=\"prisma\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wcmlzbWEueW9nYS9nZXR0aW5nLXN0YXJ0ZWQ=\">prisma</span></h4><p>Prisma 和 Knex 都是现代的 Node.js ORM（对象关系映射）库，它们可以帮助开发者以面向对象的方式来操作数据库。尽管它们的目标相似，但它们在设计理念、功能特性和使用方式上存在一些区别：</p>\n<ul>\n<li>prisma和TypeScript联系紧密</li>\n<li>prisma提供强大的类型安全</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcHJpc21h\">prisma CLI</span></p>\n<p>prisma对应的脚手架可以快速创建模板结构。</p>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><h4 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h4><p><strong>概念：</strong></p>\n<ul>\n<li><p>MVC是一种常用的软件架构模式，用于设计和组织应用程序的代码</p>\n</li>\n<li><p>它将应用程序分为三个主要的组件：模型(Model)、视图(view)和控制器(Controller)，各自负责不同的模块</p>\n</li>\n</ul>\n<p><strong>作用：</strong></p>\n<ul>\n<li>MVC将应用程序的逻辑数据等和界面相分离，以提高代码的可维护性、可扩展性和可重用性。</li>\n<li>通过将不同职责分配给不同组件，MVC提供了一种清晰的结构使得开发人员更好的管理应用程序的各个部分</li>\n</ul>\n<h4 id=\"loC控制反转\"><a href=\"#loC控制反转\" class=\"headerlink\" title=\"loC控制反转\"></a>loC控制反转</h4><p><strong>概念：</strong></p>\n<ul>\n<li><p>控制反转（IoC）是一种设计原则，它将组件的控制权从组件自身转移到外部容器。</p>\n</li>\n<li><p>传统上，组件负责自己的创建和管理，而控制反转则将这个责任转给了一个外部的容器或框架。容器负责创建组件实例并管理它们的生命周期，组件只需声明自己所需的依赖关系，并通过容器获取这些依赖。</p>\n</li>\n<li><p>loC控制反转使得组件更加松耦合、可测试和可维护。</p>\n</li>\n</ul>\n<p><strong>依赖注入：</strong></p>\n<ul>\n<li><p>依赖注入（DI）是实现控制反转的一种具体技术。</p>\n</li>\n<li><p>它通过将组件的依赖关系从组件内部移动到外部容器来实现松耦合。</p>\n</li>\n<li><p>组件不再负责创建或管理它所依赖的其他组件，而是通过构造函数、属性或方法参数等方式将依赖关系注入到组件中。</p>\n</li>\n<li><p>依赖注入可以通过构造函数注入（Constructor Injection）、属性注入（Property Injection）或方法注入（Method Injection）等方式实现。</p>\n</li>\n</ul>\n<p><strong>工具包：</strong></p>\n<p>可以使用inversify、reflect-metadata、inversify-express-utils来实现。</p>\n<h2 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h2><p><strong>介绍：</strong></p>\n<p>JWT（JSON Web Token）是一种开放的标准，是一种基于JSON的安全令牌，用于在客户端和服务端之间传输信息。</p>\n<p><strong>组成：</strong></p>\n<p>JWT由三部分组成，它们通过点（.）进行分隔：</p>\n<ol>\n<li>Header（头部）：包含了令牌的类型和使用的加密算法等信息。通常采用Base64编码表示。</li>\n<li>Payload（负载）：包含了身份验证和授权等信息，如用户ID、角色、权限等。也可以自定义其他相关信息。同样采用Base64编码表示。</li>\n<li>Signature（签名）：使用指定的密钥对头部和负载进行签名，以确保令牌的完整性和真实性。</li>\n</ol>\n<p><strong>工作流程：</strong></p>\n<ol>\n<li>用户通过提供有效的凭证（例如用户名和密码）进行身份验证。</li>\n<li>服务器验证凭证，并生成一个JWT作为响应。JWT包含了用户的身份信息和其他必要的数据。</li>\n<li>服务器将JWT发送给客户端。</li>\n<li>客户端在后续的请求中，将JWT放入请求的头部或其他适当的位置。</li>\n<li>服务器在接收到请求时，验证JWT的签名以确保其完整性和真实性。如果验证通过，服务器使用JWT中的信息进行授权和身份验证。</li>\n</ol>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><p><strong>内存存储系统</strong></p>\n<p><strong>介绍：</strong></p>\n<p>Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，提供了一个高效的键值存储解决方案，并支持多种数据结构，如：string字符串、hashes哈希、lists列表、sets集合和sorted sets有序集合等等。</p>\n<p><strong>应用：</strong></p>\n<p>Redis被广泛应用于缓存、消息队列和实时统计等场景。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>内存存储，因此具有快速的读写功能，能持久化数据到硬盘，以便在重新启动后恢复数据</li>\n<li>多种数据结构，Redis支持多种数据结构</li>\n<li>发布&#x2F;订阅，Redis支持发布订阅模式，允许多个客户端订阅同一个或多个频道，以接收实时发布的消息，这使得Redis可以用于实时消息系统</li>\n<li>事务支持，Redis支持事务，可以将多个命令打包成一个原子操作执行，确保命令要么全部成功，要么全部失败</li>\n<li>持久化，Redis提供两种持久化数据的方式：<ul>\n<li>RDB（Redis Database），RDB是将数据以快照的形式保存到磁盘。</li>\n<li>AOF（Append Only File），AOF是将每个写操作追加到文件中，确保数据在意外宕机或重启后的持久性</li>\n</ul>\n</li>\n<li>高可用性，Redis支持主从复制和Sentine哨兵机制，通过主从复制可以创建多个Redis实例的副本，以提高读取性和容错能力。<code>sentinel</code>是一个用于监控和自动故障转移的系统，可以在主节点宕机时自动将节点提升为主节点。</li>\n<li>缓存，Redis的快速读写能力和灵活的数据结构使其被广泛应用于缓存层，它可以将常用的数据存储在内存中，以加快数据访问速度，减轻后端数据库的负载。</li>\n<li>实时统计，Redis的计数器和有序集合等数据结构使其非常适合实时统计的场景，可以存储和更新计数器，并对有序集合进行排名和范围查询，用于统计和排行榜功能。</li>\n</ul>\n<p><strong>安装</strong></p>\n<p>安装文件，配置环境变量，然后启动即可。</p>\n<p>连接redis服务可以使用Navicate或者在vscode中下载对应的插件。</p>\n<p><strong>发布订阅模式：</strong></p>\n<p>在redis中，发布订阅模式通过命令：publish、subscribe、unsubscribe、psubscribe命令和punsubscribe命令来进行操作。</p>\n<p><strong>事务：</strong></p>\n<ul>\n<li>redis支持事务，允许用户将多个命令打包在一起作为一个单元进行执行，事务提供了一种原子性操作的机制，要么所有命令都执行成功，要么所有命令都不成功。</li>\n<li>Redis的事务不支持回滚操作，如果在事务执行期间发生错误，事务会继续执行，而不会会回滚已执行的命令。</li>\n<li>Redis事务常用命令：<ul>\n<li>multi：开启一个事务</li>\n<li>exec：执行事务中所有命令</li>\n<li>watch：对一个或多个键进行监视</li>\n<li>discard：取消事务，清空事务队列中的命令。</li>\n</ul>\n</li>\n</ul>\n<p><strong>redis持久化：</strong></p>\n<ul>\n<li>RDB（Redis Database）持久化<ul>\n<li>RDB持久化是一种快照的形式，会将内存中的数据定期保存到磁盘上。</li>\n<li>可以通过配置Redis服务器，设置自动触发RDB快照的条件，比如指定时间间隔或指定操作次数自动保存。</li>\n<li>RDB持久化生成的快照文件是二进制文件，包含了Redis数据的完整状态。</li>\n<li>在恢复数据时，可以通过加载快照文件将数据重新加载到内存中。</li>\n</ul>\n</li>\n<li>RDB使用：<ul>\n<li>找到redis的redis.conf文件，配置其中的save字段。</li>\n<li>或者在redis启动的命令行中输入save，手动保存快照。</li>\n</ul>\n</li>\n<li>AOF（Append Only File）持久化<ul>\n<li>AOF持久化记录了Redis服务器执行的所有写操作命令，在文件中以追加的方式保存</li>\n<li>当redis重启时，可以重新执行AOF文件中保存的命令，以重新构建数据集。相比于RDB持久化，AOF持久化提供了更好的数据恢复保证，因为它记录了每个写操作，而不是快照的形式。</li>\n<li>AOF文件相对于RDB文件更大，恢复数据的速度可能会比较慢。</li>\n</ul>\n</li>\n<li>AOF使用：<ul>\n<li>redus.conf文件的appendonly字段设置为yes。</li>\n</ul>\n</li>\n</ul>\n<p><strong>redis主从复制：</strong></p>\n<ul>\n<li>redis主从复制是一种数据复制和同步机制，其中一个redis服务器（主服务器）将其数据复制到一个或多个其他Redis服务器（从服务器）中，主从复制提供了数据冗余备份、读写分离和故障恢复等功能。</li>\n</ul>\n<p><strong>ioredis：在node.js中与Redis进行交互的三方库。</strong></p>\n<h2 id=\"lua\"><a href=\"#lua\" class=\"headerlink\" title=\"lua\"></a>lua</h2><p>轻量级、可嵌入的脚本语言。</p>\n<p><strong>介绍：</strong></p>\n<ul>\n<li>lua是一种轻量级、高效、可嵌入的脚本语言，被广泛应用于嵌入式系统、游戏开发、Web应用和脚本编写等领域。</li>\n<li>其设计目标之一就是作为扩展和嵌入式脚本语言，可以与其他编程语言无缝集成。</li>\n<li>在redius中可以直接执行lua脚本（.lua文件）。</li>\n<li>web应用为了增强性能和可扩展性，通常将Lua、Redis和Nginx结合使用，以构建高性能的Web应用程序或API服务。</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVhLm9yZy8=\">安装</span></p>\n<h2 id=\"corn表达式\"><a href=\"#corn表达式\" class=\"headerlink\" title=\"corn表达式\"></a>corn表达式</h2><p>corn表达式是一种用汉语指定定时任务执行时间的字符串表示形式，由6个或7个字段组成，每个字段表示任务执行的时间单位和范围。</p>\n<p><strong>格式为：</strong></p>\n<pre><code class=\"markdown\">*    *    *    *    *    *\n┬    ┬    ┬    ┬    ┬    ┬\n│    │    │    │    │    │\n│    │    │    │    │    └── 星期（0 - 6，0表示星期日）\n│    │    │    │    └───── 月份（1 - 12）\n│    │    │    └────────── 日（1 - 31）\n│    │    └─────────────── 小时（0 - 23）\n│    └──────────────────── 分钟（0 - 59）\n└───────────────────────── 秒（0 - 59）\n</code></pre>\n<p>常见的Cron表达式示例：</p>\n<ul>\n<li><code>* * * * * *</code>：每秒执行一次任务。</li>\n<li><code>0 * * * * *</code>：每分钟的整点执行一次任务。</li>\n<li><code>0 0 * * * *</code>：每小时的整点执行一次任务。</li>\n<li><code>0 0 * * * *</code>：每天的午夜执行一次任务。</li>\n<li><code>0 0 * * 1 *</code>：每周一的午夜执行一次任务。</li>\n<li><code>0 0 1 * * *</code>：每月的1号午夜执行一次任务。</li>\n<li><code>0 0 1 1 * *</code>：每年的1月1日午夜执行一次任务。</li>\n</ul>\n<p><strong>掘金定时自动签到：</strong></p>\n<pre><code class=\"javascript\">const schedule = require(&#39;node-schedule&#39;)\nconst axios = require(&#39;axios&#39;);\nconst aid = &#39;******&#39; //输入掘金账号的aid\nconst uid = &#39;******&#39; //输入掘金账号的uid\nconst cookie = &#39;******&#39; //输入在掘金的cookie\nschedule.scheduleJob(&#39;48 15 * * *&#39;,()=&gt;&#123;\n    //corn表达式表示43分钟15小时每天每月每星期（每天15点43分）点执行\n    axios.post(`https://api.juejin.cn/growth_api/v1/check_in?aid=$&#123;aid&#125;&amp;uid=$&#123;uid&#125;`,&#123;&#125;,&#123;\n        headers:&#123;\n            referer: &#39;https://juejin.cn/&#39;,\n            cookie: `sessionid=$&#123;&#125;`\n        &#125;\n    &#125;).then(res=&gt;&#123;\n        console.log(&#39;签到成功&#39;);\n    &#125;).catch(err=&gt;&#123;\n        console.log(&#39;出现错误&#39;,err);\n    &#125;)\n&#125;)\n</code></pre>\n<h2 id=\"serverLess\"><a href=\"#serverLess\" class=\"headerlink\" title=\"serverLess\"></a>serverLess</h2><p><strong>介绍：</strong></p>\n<ul>\n<li>serverLess并不是一项技术，而是一个架构模型（无服务器架构）。</li>\n<li>在传统模式下，部署一个服务需要选择服务器（linux、windows等），并且需要安装环境，熟悉操作系统命令，知晓安全知识等，都需要一定的成本，serverLess的核心思想就是让开发者更多关注业务本身而不是服务器运行成本。</li>\n</ul>\n<p><strong>Faas：函数即服务</strong></p>\n<p>FaaS是一种Serverless计算模型，它允许开发人员编写和部署函数代码，而无需关心底层的服务器管理。在FaaS中，开发人员只需关注函数的实现和逻辑，将其上传到云平台上，平台会负责函数的运行和扩展。当有请求触发函数时，云平台会自动为函数提供所需的计算资源，并根据请求量进行弹性扩展。这种按需计算的模式使开发人员可以更专注于业务逻辑的实现，同时实现了资源的高效利用。</p>\n<p>每个函数即一个服务，函数内只需处理业务，可以使用BASS层提供的服务已完成业务，无需关心背后计算资源的问题。</p>\n<p><strong>Baas：后端即服务</strong></p>\n<p>后端即服务是一种提供面向移动应用和Web应用的后端功能的云服务模型。BaaS为开发人员提供了一组预构建的后端服务，如用户身份验证、数据库存储、文件存储、推送通知等，以简化应用程序的开发和管理。开发人员可以使用BaaS平台提供的API和SDK，直接集成这些功能到他们的应用中，而无需自己构建和维护后端基础设施。</p>\n<p>对后端的资源当成一种服务，如文件存储，数据存储，推送服务，身份验证。该层只需提供对应的服务，无需关心业务。定义为底层基础服务，由其他服务调用，正常不触及用户终端。</p>\n<p><strong>脚手架快速编写：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHNlcnZlcmxlc3MtZGV2cy9z\">https://www.npmjs.com/package/@serverless-devs/s</span></strong></p>\n<h2 id=\"webSocket\"><a href=\"#webSocket\" class=\"headerlink\" title=\"webSocket\"></a>webSocket</h2><p><strong>传统HTTP的不足：</strong></p>\n<ul>\n<li><p>传统HTTP是一种单向请求–响应协议，客户端发送请求之后，服务器才会响应并返回相应的数据。</p>\n</li>\n<li><p>在传统HTTP中，客户端需要主动发送请求才能获取服务器上的资源，而且每次请求都需要重新建立连接，这种方式在实时通信和持续获取资源的场景下效率较低。</p>\n</li>\n</ul>\n<p><strong>Socket：</strong></p>\n<p>socket提供了实时的双向通信能力，可以实时地传输数据。客户端和服务器之间的通信是即时的，数据的传输和响应几乎是实时完成的，不需要轮询或定时发送请求。</p>\n<p><strong>node中使用webSocket：</strong></p>\n<ul>\n<li><strong>客户端：</strong></li>\n</ul>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        * &#123;\n            padding: 0;\n            margin: 0;\n        &#125;\n        html,\n        body,\n        .room &#123;\n            height: 100%;\n            width: 100%;\n        &#125;\n        .room &#123;\n            display: flex;\n        &#125;\n        .left &#123;\n            width: 300px;\n            border-right: 0.5px solid #f5f5f5;\n            background: #333;\n        &#125;\n        .right &#123;\n            background: #1c1c1c;\n            flex: 1;\n            display: flex;\n            flex-direction: column;\n        &#125;\n        .header &#123;\n            background: #8d0eb0;\n            color: white;\n            padding: 10px;\n            box-sizing: border-box;\n            font-size: 20px;\n        &#125;\n        .main &#123;\n            flex: 1;\n            padding: 10px;\n            box-sizing: border-box;\n            font-size: 20px;\n            overflow: auto;\n        &#125;\n        .main-chat &#123;\n            color: green;\n        &#125;\n        .footer &#123;\n            min-height: 200px;\n            border-top: 1px solid green;\n        &#125;\n        .footer .ipt &#123;\n            width: 100%;\n            height: 100%;\n            color: green;\n            outline: none;\n            font-size: 20px;\n            padding: 10px;\n            box-sizing: border-box;\n        &#125;\n        .groupList &#123;\n            height: 100%;\n            overflow: auto;\n        &#125;\n        .groupList-items &#123;\n            height: 50px;\n            width: 100%;\n            background: #131313;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;div class=&quot;room&quot;&gt;\n    &lt;div class=&quot;left&quot;&gt;\n        &lt;div class=&quot;groupList&quot;&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;\n        &lt;header class=&quot;header&quot;&gt;聊天室&lt;/header&gt;\n        &lt;main class=&quot;main&quot;&gt;\n        &lt;/main&gt;\n        &lt;footer class=&quot;footer&quot;&gt;\n            &lt;div class=&quot;ipt&quot; contenteditable&gt;&lt;/div&gt;\n        &lt;/footer&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;body&gt;\n    &lt;script type=&quot;module&quot;&gt;\n        const sendMessage = (message) =&gt; &#123;\n            const div = document.createElement(&#39;div&#39;);\n            div.className = &#39;main-chat&#39;;\n            div.innerText = `$&#123;message.user&#125;:$&#123;message.text&#125;`;\n            main.appendChild(div)\n        &#125;\n        const groupEl = document.querySelector(&#39;.groupList&#39;);\n        const main = document.querySelector(&#39;.main&#39;);\n        import &#123; io &#125; from &quot;https://cdn.socket.io/4.7.4/socket.io.esm.min.js&quot;;\n        const name = prompt(&#39;请输入你的名字&#39;);\n        const room = prompt(&#39;请输入房间号&#39;);\n        const socket = io(&#39;ws://localhost:3000&#39;);\n        //键盘按下发送消息\n        document.addEventListener(&#39;keydown&#39;, (e) =&gt; &#123;\n            if (e.key === &#39;Enter&#39;) &#123;\n                e.preventDefault();\n                const ipt = document.querySelector(&#39;.ipt&#39;);\n                socket.emit(&#39;message&#39;, &#123;\n                    text: ipt.innerText,\n                    room: room,\n                    user: name\n                &#125;);\n                sendMessage(&#123;\n                    text: ipt.innerText,\n                    user: name,\n                &#125;)\n                ipt.innerText = &#39;&#39;;\n            &#125;\n        &#125;)\n        //连接成功socket\n        socket.on(&#39;connect&#39;, () =&gt; &#123;\n            socket.emit(&#39;join&#39;, &#123; name, room &#125;);//加入一个房间\n            socket.on(&#39;message&#39;, (message) =&gt; &#123;\n                sendMessage(message)\n            &#125;)\n            socket.on(&#39;groupList&#39;, (groupList) =&gt; &#123;\n                console.log(groupList);\n                groupEl.innerHTML = &#39;&#39;\n                Object.keys(groupList).forEach(key =&gt; &#123;\n                    const item = document.createElement(&#39;div&#39;);\n                    item.className = &#39;groupList-items&#39;;\n                    item.innerText = `房间名称:$&#123;key&#125; 房间人数:$&#123;groupList[key].length&#125;`\n                    groupEl.appendChild(item)\n                &#125;)\n            &#125;)\n        &#125;)\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li><strong>服务端：</strong></li>\n</ul>\n<pre><code class=\"javascript\">import http from &#39;http&#39;\nimport &#123; Server &#125; from &#39;socket.io&#39;\nimport express from &#39;express&#39;\nconst app = express()\napp.use(&#39;*&#39;, (req, res, next) =&gt; &#123;\n    res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n    res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);\n    res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);\n    next();\n&#125;)\nconst server = http.createServer(app)\nconst io = new Server(server, &#123;\n    cors: true //允许跨域\n&#125;)\nconst groupList = &#123;&#125;\n/**\n * [&#123;1008:[&#123;name,room,id&#125;]&#125;]\n */\nio.on(&#39;connection&#39;, (socket) =&gt; &#123;\n    //加入房间\n    socket.on(&#39;join&#39;, (&#123; name, room &#125;) =&gt; &#123;\n        socket.join(room)\n        if (groupList[room]) &#123;\n            groupList[room].push(&#123; name, room, id: socket.id &#125;)\n        &#125; else &#123;\n            groupList[room] = [&#123; name, room, id: socket.id &#125;]\n        &#125;\n        socket.emit(&#39;message&#39;, &#123; user: &#39;管理员&#39;, text: `$&#123;name&#125;进入了房间` &#125;)\n        socket.emit(&#39;groupList&#39;, groupList)\n        socket.broadcast.emit(&#39;groupList&#39;, groupList)\n    &#125;)\n    //发送消息\n    socket.on(&#39;message&#39;, (&#123; text, room, user &#125;) =&gt; &#123;\n        socket.broadcast.to(room).emit(&#39;message&#39;, &#123;\n            text,\n            user\n        &#125;)\n    &#125;)\n    //断开链接内置事件\n    socket.on(&#39;disconnect&#39;, () =&gt; &#123;\n        Object.keys(groupList).forEach(key =&gt; &#123;\n            let leval = groupList[key].find(item =&gt; item.id === socket.id)\n            if (leval) &#123;\n                socket.broadcast.to(leval.room).emit(&#39;message&#39;, &#123; user: &#39;管理员&#39;, text: `$&#123;leval.name&#125;离开了房间` &#125;)\n            &#125;\n            groupList[key] = groupList[key].filter(item =&gt; item.id !== socket.id)\n        &#125;)\n        socket.broadcast.emit(&#39;groupList&#39;, groupList)\n    &#125;)\n&#125;);\nserver.listen(3000, () =&gt; &#123;\n    console.log(&#39;listening on :3000&#39;);\n&#125;);\n</code></pre>\n<h2 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h2><p><strong>介绍：</strong></p>\n<ul>\n<li>爬虫也称为网络爬虫或网络蜘蛛，是指一种自动化程序或脚本，用于在互联网上浏览和提取信息。</li>\n<li>爬虫模拟人类在网页上的行为，通过HTTP协议发送请求，获取网页内容，然后解析并提取需要的内容。</li>\n<li>在node中使用爬虫需要借助模拟浏览器环境的包（如 puppeteer）来模拟浏览器环境。</li>\n</ul>\n<p><strong>工具：</strong></p>\n<ul>\n<li>puppeteer（模拟浏览器环境）</li>\n</ul>\n<p><strong>使用：</strong></p>\n<p>npm包：</p>\n<pre><code class=\"bash\">npm i puppeteer\n</code></pre>\n<p>index.js：</p>\n<pre><code class=\"javascript\">import puppeteer from &quot;puppeteer&quot;;\nconst btnText = process.argv[2];\nconst browser = await puppeteer.launch(&#123;\n    headless:false, //取消无头模式\n&#125;)\nconst page = await browser.newPage(); //打开一个页面\nconsole.log(page);\npage.setViewport(&#123; width:1920,height:1080 &#125;); //设置页面宽高\nawait page.goto(&#39;https://juejin.cn/&#39;); //跳转\nawait page.waitForSelector(&#39;.side-navigator-wrap&#39;); //等待元素出现\nconst elements = await page.$$(&#39;.side-navigator-wrap .nav-item-wrap span&#39;) //获取元素\nconst articleList = [];\nconst collectFunc = async()=&gt;&#123;\n    await page.waitForSelector(&#39;.entry-list&#39;)\n    const elements = await page.$$(&#39;.entry-list .title-row a&#39;)\n    for await (let el of elements) &#123;\n        const text = await el.getProperty(&#39;innerText&#39;)\n        const name = await text.jsonValue()\n        articleList.push(name)\n    &#125;\n    console.log(articleList)\n&#125;\nfor await (let el of elements) &#123;\n    const text = await el.getProperty(&#39;innerText&#39;) //获取span的属性\n    const name = await text.jsonValue() //获取内容\n    if (name.trim() === (btnText || &#39;前端&#39;)) &#123;\n        await el.click() //自动点击对应的菜单\n        collectFunc() //调用函数\n    &#125;\n&#125;\n</code></pre>\n<p><strong>可以结合node子进程跑python脚本，使用pip仓库中相应的包和功能。</strong></p>\n<h2 id=\"C-扩展\"><a href=\"#C-扩展\" class=\"headerlink\" title=\"C++扩展\"></a>C++扩展</h2><p>Node.js在IO方面具有极强的能力，但是对CPU密集型的任务有所不足，为了填补这部分缺点，node.js支持C&#x2F;C++为其编写原生的nodejs插件，补充这方面能力。</p>\n<p><strong>node.js中C++扩展：</strong></p>\n<p>c++编写的代码能够被编译成一个动态链接库(dll),可以被nodejs require引入使用，后缀是<code>.node</code></p>\n<p>.node文件的原理就是(<code>window dll</code>) (<code>Mac dylib</code>) (<code>Linux so</code>)</p>\n<p>c++扩展编写语法</p>\n<ul>\n<li><p>NAN(Native Abstractions for Nodejs) 一次编写，到处编译</p>\n<ul>\n<li>因为 Nodejs和V8都更新的很快所有每个版本的方法名也不一样，对我们开发造成了很大的问题例如</li>\n<li>0.50版本 <code>Echo(const Prototype&amp;proto)</code></li>\n<li>3.00版本 <code>Echo(Object&lt;Prototype&gt;&amp; proto)</code></li>\n</ul>\n</li>\n<li><p>NAN的就是一堆宏判断，判断各种版本的API，用来实现兼容所以他会到处编译</p>\n<ul>\n<li>N-API(node-api) 无需重新编译</li>\n<li>基于C的API</li>\n<li>c++ 封装 node-addon-api</li>\n</ul>\n</li>\n</ul>\n<p>N-API 是一个更现代的选择，它提供了一个稳定的、跨版本的 API，使得你的插件可以在不同版本的 Node.js 上运行，而无需修改代码。这大大简化了编写和维护插件的过程。</p>\n<p>对于 C++，可以使用 node-addon-api，这是 N-API 的一个封装，提供了一个更易于使用的 C++ API。这将使你的代码更易于阅读和维护。</p>\n<p><strong>使用场景</strong></p>\n<ol>\n<li>使用C++编写的Nodejs库如<code>node-sass</code> <code>node-jieba</code> 等</li>\n<li>CPU密集型应用</li>\n<li>代码保护</li>\n</ol>\n<p><strong>需要安装C++编辑器：</strong></p>\n<pre><code class=\"bash\">npm install --global --production windows-build-tools #管理员运行\n#如果安装过python 以及c++开发软件就不需要装这个了\nnpm install node-gyp -g #全局安装\nnpm install node-addon-api -D #装到项目里\n</code></pre>\n<p><strong>使用：</strong></p>\n<p><strong>cpu.cpp：</strong></p>\n<pre><code class=\"c++\">#define NAPI_VERSION 3  //指定addon版本\n#define NAPI_CPP_EXCEPTIONS //启用 Node.js N-API 中的 C++ 异常支持\n#include &lt;napi.h&gt;  //addon API\n#include &lt;windows.h&gt; //windwos API\n\nNapi::Value GetScreenSize(const Napi::CallbackInfo&amp; info) &#123;\n    Napi::Env env = info.Env(); //指定环境\n\n    int cx = GetSystemMetrics(SM_CXSCREEN); //获取设备宽\n    int cy = GetSystemMetrics(SM_CYSCREEN); //获取设备高\n\n    Napi::Object result = Napi::Object::New(env); //创建一个对象\n    result.Set(&quot;width&quot;, cx);\n    result.Set(&quot;height&quot;, cy);\n\n    return result; //返回对象\n&#125;\n\nNapi::Object Init(Napi::Env env, Napi::Object exports) &#123;\n    //抛出一个函数  getScreenSize \n    exports.Set(&quot;getScreenSize&quot;, Napi::Function::New(env, GetScreenSize));\n    return exports;\n&#125;\n//addon固定语法 必须抛出这个方法\nNODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)\n</code></pre>\n<p><strong>binding.gyp：</strong></p>\n<pre><code class=\"python\">&#123;\n    &quot;targets&quot;:[\n        &#123;\n            &quot;target_name&quot;: &quot;cpu&quot;, //名称\n            &quot;sources&quot;: [ &quot;cpu.cpp&quot; ], //指定文件\n            &quot;include_dirs&quot;: [\n                 &quot;&lt;!@(node -p \\&quot;require(&#39;node-addon-api&#39;).include\\&quot;)&quot; //引入addon\n            ]\n        &#125;\n    ]\n&#125;\n</code></pre>\n<p><strong>index.js：</strong></p>\n<pre><code class=\"javascript\">const addon = require(&#39;./build/Release/cpu.node&#39;)\nconsole.log(addon.getScreenSize())\n</code></pre>\n<p><strong>命令行中打包addon：</strong></p>\n<pre><code class=\"bash\">node-gyp configure #生成配置文件\nnode-gyp build  #打包addon\n</code></pre>\n<h2 id=\"大文件上传\"><a href=\"#大文件上传\" class=\"headerlink\" title=\"大文件上传\"></a>大文件上传</h2><p>大文件上传方案：</p>\n<ul>\n<li>大文件分片：将大文件切分成较小的片段（通常称为分片或者块），然后逐个上传这些分片<ul>\n<li>优点是：提高上传的稳定性，因为上传失败时只需要重新上传该分片而不需要重新上传整个文件，同时分片上传还可以利用多个网络连接并行上传多个分片，提高上传速度。</li>\n</ul>\n</li>\n<li>断点续传：如果上传中止，断点传输可以记录已成功上传的分片信息，以便在恢复上传时继续上传未完成的任务，而不是重新上传整个文件<ul>\n<li>优点是可以大大减少上传失败的影响，并节省时间和带宽。</li>\n</ul>\n</li>\n</ul>\n<p>前端：</p>\n<pre><code class=\"html\">&lt;script&gt;\n    const fileDOM = document.getElementById(&#39;file&#39;);\n    fileDOM.addEventListener(&#39;change&#39;,(e)=&gt;&#123;\n        const file = e.target.files[0];\n        //对文件进行分片\n        const chunks = sliceFile(file);\n        //上传分片数据\n        postChunksData(chunks);\n    &#125;)\n    function sliceFile(file,size=1024 * 1024 * 4) &#123;\n        const chunks = [];\n        for(let i=0;i&lt;file.size;i+=size)&#123;\n            chunks.push(file.slice(i , i + size));\n        &#125;\n        return chunks;\n    &#125;\n    function postChunksData(chunks) &#123;\n        const list = [];\n        for(let i=0;i&lt;chunks.length;i++)&#123;\n            //使用formData上传所有分片\n            const formData = new FormData();\n            formData.append(&#39;index&#39;,i);\n            formData.append(&#39;total&#39;,chunks.length);\n            formData.append(&#39;fileName&#39;,&#39;分片文件&#39;);\n            formData.append(&#39;file&#39;,chunks[i]);\n            list.push(fetch(&#39;http://localhost:3000/up&#39;,&#123;\n                method:&#39;POST&#39;,\n                body: formData,\n            &#125;))\n        &#125;\n        //上传完所有分片之后将文件合并\n        Promise.all(list).then(res =&gt; &#123;\n            fetch(&#39;http://localhost:3000/merge&#39;,&#123;\n                method:&quot;POST&quot;,\n                headers:&#123;\n                    &quot;Content-Type&quot;:&quot;application/json&quot;\n                &#125;,\n                body:JSON.stringify(&#123;\n                    fileName:&quot;分片上传文件&quot;,\n                &#125;)\n            &#125;).then(res=&gt;&#123;\n                console.log(res);\n            &#125;)\n        &#125;)\n    &#125;    \n&lt;/script&gt;\n</code></pre>\n<p>服务端：</p>\n<pre><code class=\"javascript\">import express from &#39;express&#39;\nimport multer from &#39;multer&#39;\nimport cors from &#39;cors&#39;\nimport fs from &#39;node:fs&#39;\nimport path from &#39;node:path&#39;\nconst storage = multer.diskStorage(&#123;\n    destination: (req, file, cb) =&gt; &#123;\n        cb(null, &#39;uploads/&#39;)\n    &#125;,\n    filename: (req, file, cb) =&gt; &#123;\n        cb(null, `$&#123;req.body.index&#125;-$&#123;req.body.fileName&#125;`)\n    &#125;\n&#125;)\nconst upload = multer(&#123; storage &#125;)\nconst app = express()\napp.use(cors())\napp.use(express.json())\n// 使用multer将数据存到服务器磁盘中\napp.post(&#39;/up&#39;, upload.single(&#39;file&#39;), (req, res) =&gt; &#123;\n    res.send(&#39;ok&#39;)\n&#125;)\n// 使用fs.appendFileSync将切片文件进行合成\napp.post(&#39;/merge&#39;, async (req, res) =&gt; &#123;\n    const uploadPath = &#39;./uploads&#39;\n    let files = fs.readdirSync(path.join(process.cwd(), uploadPath))\n    files = files.sort((a, b) =&gt; a.split(&#39;-&#39;)[0] - b.split(&#39;-&#39;)[0])\n    const writePath = path.join(process.cwd(), `video`, `$&#123;req.body.fileName&#125;.mp4`)\n    files.forEach((item) =&gt; &#123;\n        fs.appendFileSync(writePath, fs.readFileSync(path.join(process.cwd(), uploadPath, item)))\n        fs.unlinkSync(path.join(process.cwd(), uploadPath, item))\n    &#125;)\n    res.send(&#39;ok&#39;)\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;Server is running on port 3000&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"文件流下载\"><a href=\"#文件流下载\" class=\"headerlink\" title=\"文件流下载\"></a>文件流下载</h2><ul>\n<li><p>文件流下载是一种将文件内容通过流的形式发送给客户端，实现文件下载的方法，适用于处理大型文件或者需要实时生成文件内容的情况。</p>\n</li>\n<li><p>核心知识响应头：</p>\n<ul>\n<li>Content-Type指定下载文件的MIME类型<ul>\n<li><code>application/octet-stream</code>（二进制流数据）</li>\n<li><code>application/pdf</code>：Adobe PDF 文件。</li>\n<li><code>application/json</code>：JSON 数据文件</li>\n<li><code>image/jpeg</code>：JPEG 图像文件</li>\n</ul>\n</li>\n<li><code>Content-Disposition</code> 指定服务器返回的内容在浏览器中的处理方式。它可以用于控制文件下载、内联显示或其他处理方式<ul>\n<li><code>attachment</code>：指示浏览器将响应内容作为附件下载。通常与 <code>filename</code> 参数一起使用，用于指定下载文件的名称</li>\n<li><code>inline</code>：指示浏览器直接在浏览器窗口中打开响应内容，如果内容是可识别的文件类型（例如图片或 PDF），则在浏览器中内联显示</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>前端：</p>\n<pre><code class=\"html\">&lt;script&gt;\n         const btn = document.getElementById(&#39;btn&#39;)\n         btn.onclick = () =&gt; &#123;\n            fetch(&#39;http://localhost:3000/download&#39;,&#123;\n                method:&quot;post&quot;,\n                body:JSON.stringify(&#123;\n                    fileName:&#39;1.png&#39;\n                &#125;),\n                headers:&#123;\n                    &quot;Content-Type&quot;:&quot;application/json&quot;\n                &#125;\n            &#125;).then(res=&gt;res.arrayBuffer()).then(res=&gt;&#123; //请求到stream流式数据后，通过res.arrayBuffer方法获得Buffer数据，用Blob容器存储二进制缓冲数据，通过URL.createObjectURL创建URL地址，赋给a标签进行下载。\n                const blob = new Blob([res],&#123;type:&#39;image/png&#39;&#125;)\n                const url = URL.createObjectURL(blob)\n                const a = document.createElement(&#39;a&#39;)\n                a.href = url\n                a.download = &#39;1.png&#39;\n                a.click()\n            &#125;)\n         &#125;\n     &lt;/script&gt;\n</code></pre>\n<p>服务端：</p>\n<pre><code class=\"javascript\">import express from &#39;express&#39;\nimport fs from &#39;fs&#39;\nimport path from &#39;path&#39;\nimport cors from &#39;cors&#39;\nconst app = express()\napp.use(cors())\napp.use(express.json())\napp.use(express.static(&#39;./static&#39;))\napp.post(&#39;/download&#39;, function (req, res) &#123; //当请求download路径时，通过fs读取文件数据，设置响应头后返回文件数据\n    const fileName = req.body.fileName\n    const filePath = path.join(process.cwd(), &#39;./static&#39;, fileName)\n    const content = fs.readFileSync(filePath)\n    res.setHeader(&#39;Content-Type&#39;, &#39;application/octet-stream&#39;)\n    res.setHeader(&#39;Content-Disposition&#39;, &#39;attachment;filename=&#39; + fileName)\n    res.send(content)\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;http://localhost:3000&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"HTTP缓存\"><a href=\"#HTTP缓存\" class=\"headerlink\" title=\"HTTP缓存\"></a>HTTP缓存</h2><p>HTTP缓存分为两大类：强缓存和协商缓存。这两种缓存都是通过HTTP响应头来控制，目的是提高网站的性能。</p>\n<ul>\n<li><p>强缓存</p>\n<ul>\n<li><p>强缓存之后则不需要重新向服务器发送请求，而是从浏览器缓存（内存缓存或者硬盘缓存中）读取。</p>\n<ul>\n<li>memory cache(内存缓存) 内存缓存存储在浏览器内存当中，一般刷新网页的时候会发现很多内存缓存</li>\n<li>disk cache(硬盘缓存) 硬盘缓存是存储在计算机硬盘中，空间大，但是读取效率比内存缓存慢</li>\n</ul>\n</li>\n<li><p>强缓存设置需要服务端设置对应的响应头Cache-Control，响应头含义如下：</p>\n<ul>\n<li><code>max-age</code>：浏览器资源缓存的时长(秒)。</li>\n<li><code>no-cache</code>：不走强缓存，<strong>走协商缓存</strong>。</li>\n<li><code>no-store</code>：禁止任何缓存策略。</li>\n<li><code>public</code>：资源即可以被浏览器缓存也可以被代理服务器缓存(CDN)。</li>\n<li><code>private</code>：资源只能被客户端缓存。</li>\n</ul>\n</li>\n<li><pre><code class=\"javascript\">const express = require(&#39;express&#39;);\nconst app = express();\napp.get(&#39;/&#39;,(req,res)=&gt;&#123;\n    res.setHeader(&#39;Cache-Control&#39;,&#39;public, max-age=20&#39;);\n    res.json(&#123;\n        name:&quot;cache&quot;,\n        version:&#39;1.0.0&#39;\n    &#125;)\n&#125;);\napp.listen(3000,()=&gt;&#123;\n    console.log(&#39;服务启动&#39;)\n&#125;)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>协商缓存</p>\n<ul>\n<li><p>当涉及到缓存机制时，强缓存优先于协商缓存。当资源的强缓存生效时，客户端可以直接从本地缓存中获取资源，而无需与服务器进行通信。</p>\n<p>如果强缓存未命中（例如<code>max-age</code>过期），或者服务器响应中设置了<code>Cache-Control: no-cache</code>，则客户端会发起协商缓存的请求。在协商缓存中，客户端会发送带有缓存数据标识的请求头部字段，以向服务器验证资源的有效性。</p>\n<p>服务器会根据客户端发送的协商缓存字段（如<code>If-Modified-Since</code>和<code>If-None-Match</code>）来判断资源是否发生变化。如果资源未发生修改，服务器会返回状态码 304（Not Modified），通知客户端可以使用缓存的版本。如果资源已经发生变化，服务器将返回最新的资源，状态码为 200。</p>\n</li>\n<li><blockquote>\n<p>服务端通过设置响应头<code>Last-Modified</code>和<code>If-Modified-Since</code>来通知客户端最后修改时间，客户端在后续请求中通过<code>If-Modified-Since</code>请求头携带该时间，服务器判断资源是否有更新，如何没有返回304状态码。</p>\n</blockquote>\n</li>\n<li><pre><code class=\"javascript\">import express from &#39;express&#39;\nimport cors from &#39;cors&#39;\nimport fs from &#39;node:fs&#39;\nconst getModifyTime = () =&gt; &#123;\n    return fs.statSync(&#39;./index.js&#39;).mtime.toISOString() //获取文件最后修改时间\n&#125;\nconst app = express()\napp.use(cors())\napp.get(&#39;/api&#39;, (req, res) =&gt; &#123;\n    res.setHeader(&#39;Cache-Control&#39;, &#39;no-cache, max-age=2592000&#39;)//表示走协商缓存\n    const ifModifiedSince = req.headers[&#39;if-modified-since&#39;] //获取浏览器上次修改时间\n    res.setHeader(&#39;Last-Modified&#39;, getModifyTime())\n    if (ifModifiedSince &amp;&amp; ifModifiedSince === getModifyTime()) &#123;\n        console.log(&#39;304&#39;)\n        res.statusCode = 304\n        res.end()\n        return\n    &#125; else &#123;\n        console.log(&#39;200&#39;)\n        res.end(&#39;value&#39;)\n    &#125;\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;Example app listening on port 3000!&#39;)\n&#125;)\n</code></pre>\n</li>\n<li><p>ETag：</p>\n<p>ETag 和 If-None-Match：服务器通过 ETag 响应头给资源生成一个唯一标识符。客户端在后续请求中通过 If-None-Match 请求头携带该标识符，服务器根据标识符判断资源是否有更新。如果没有更新，返回 304 状态码。</p>\n<blockquote>\n<p>ETag 优先级比 Last-Modified 高</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP2\"><a href=\"#HTTP2\" class=\"headerlink\" title=\"HTTP2\"></a>HTTP2</h2><ul>\n<li><p>HTTP2是超文本传输协议的下一个主要版本，是对HTTP&#x2F;1.1协议的重大改进。目标是改善性能、效率和安全性，提供更快更高效的网络通信。</p>\n</li>\n<li><p>多路复用</p>\n</li>\n<li><p>HTTP&#x2F;2支持在单个TCP连接上同时发送多个请求和响应，这意味着可以避免建立多个连接，减少网络延迟，提高效率。</p>\n</li>\n<li><p>二进制分帧</p>\n<ul>\n<li>在HTTP2应用层和传输层之间增加了二进制分帧层，将请求和响应拆分为多个帧，这种二进制格式的设计使得协议更加高效，并且容易解析和处理。<ul>\n<li>数据帧（Data Frame）：用于传输请求和响应的实际数据。</li>\n<li>头部帧（Headers Frame）：包含请求或响应的头部信息。</li>\n<li>优先级帧（Priority Frame）：用于指定请求的优先级。</li>\n<li>设置帧（Settings Frame）：用于传输通信参数的设置。</li>\n<li>推送帧（Push Promise Frame）：用于服务器主动推送资源。</li>\n<li>PING 帧（PING Frame）：用于检测连接的活跃性。</li>\n<li>重置帧（RST_STREAM Frame）：用于重置数据流或通知错误。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>头部压缩</p>\n<ul>\n<li>HTTP2采用首部表和动态压缩算法来减少头部的大小，这减少了每个请求和响应的开销，提高了传输效率。</li>\n</ul>\n</li>\n<li><p>node中实现</p>\n<ul>\n<li><blockquote>\n<p>可以使用openssl 生成 tls证书：</p>\n<p>生成私钥</p>\n<pre><code class=\"sh\">openssl genrsa -out server.key 1024\n</code></pre>\n<p>生成证书请求文件(用完可以删掉也可以保留)</p>\n<pre><code class=\"sh\">openssl req -new -key server.key -out server.csr\n</code></pre>\n<p>生成证书</p>\n<pre><code class=\"sh\">openssl x509 -req -in server.csr -out server.crt -signkey server.key -days 3650\n</code></pre>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"javascript\">import http2 from &#39;node:http2&#39;\nimport fs from &#39;node:fs&#39;\nconst server = http2.createSecureServer(&#123;\n    key: fs.readFileSync(&#39;server.key&#39;),\n    cert: fs.readFileSync(&#39;server.crt&#39;)\n&#125;)\nserver.on(&#39;stream&#39;, (stream, headers) =&gt; &#123;\n    stream.respond(&#123;\n        &#39;content-type&#39;: &#39;text/html; charset=utf-8&#39;,\n        &#39;:status&#39;: 200\n    &#125;)\n    stream.on(&#39;error&#39;, (err) =&gt; &#123;\n        console.log(err)\n    &#125;)\n    stream.end(`\n      &lt;h1&gt;http2&lt;/h1&gt;\n    `)\n&#125;)\nserver.listen(80, () =&gt; &#123;\n    console.log(&#39;server is running on port 80&#39;)\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h1 id=\"Node中事件循环\"><a href=\"#Node中事件循环\" class=\"headerlink\" title=\"Node中事件循环\"></a>Node中事件循环</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29sb3ZpbmcvcC8xNjUyMzY0OC5odG1s\">https://www.cnblogs.com/goloving/p/16523648.html</span></p>\n<blockquote>\n<p>本篇出于学习<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vY29sdW1uLzcyNzQ4OTM3MTQ5NzA5MTg5Njk=\">node.js教程</span>后所整理，内容中有大量引用和参照，详细可点击前去了解</p>\n</blockquote>\n",
            "tags": [
                "Node.js",
                "node.js"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/24/%E5%BE%AE%E5%89%8D%E7%AB%AF/",
            "url": "https://dmqweb.cn/2024/05/24/%E5%BE%AE%E5%89%8D%E7%AB%AF/",
            "title": "微前端",
            "date_published": "2024-05-24T06:26:39.000Z",
            "content_html": "<h1 id=\"微前端\"><a href=\"#微前端\" class=\"headerlink\" title=\"微前端\"></a>微前端</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，这样才能确保微应用真正具备独立开发、独立运行的能力（防止巨石应用）</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>微前端按业务功能将一整块前端应用分解成一系列更小的、更内聚的微前端应用，同时通过明确的交互协议来管理这些应用间的依赖关系，实现不同业务的解耦合。并将每个前端应用交给独立团队负责，各自独立开发、独立部署、充分利用并行性。</p>\n<ul>\n<li>微前端是一种架构风格，monorepo是一种开发策略，模块联邦是一种打包和部署方式<ul>\n<li>微前端将大型的前端应用分解成一组小的、独立的前端服务，每一个小的前端服务可以由不同的团队独立开发、部署和维护。微前端的目标是提高大型前端项目的可维护性、可扩展性和灵活性</li>\n<li>monorepo是一种开发策略（技巧），它将多个项目或服务的代码放在一个单一的版本控制系统仓库中，有助于简化依赖管理、代码共享和团队协作。对于工具库能更好的暴露单独模块。</li>\n<li>模块联邦是Webpack5引入的一个特性，允许将多个Webpack项目远程接入、联合起来，形成一个单一的应用，每个模块可以独立开发和部署，同时共享彼此的代码，模块联邦是一种新的打包和部署前端应用的方式。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"微前端应用\"><a href=\"#微前端应用\" class=\"headerlink\" title=\"微前端应用\"></a>微前端应用</h1><h2 id=\"EMP\"><a href=\"#EMP\" class=\"headerlink\" title=\"EMP\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbXAyLm5ldGxpZnkuYXBwLw==\">EMP</span></h2><p>模块联邦技术，微前端构建方案，是基于 webpack 5 module federation 的微前端方案。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>webpack 联邦编译可以保证所有子应用依赖解耦；</li>\n<li>应用间去中心化的调用、共享模块；</li>\n<li>模块远程 ts 支持；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>对 webpack 强依赖，老旧项目不友好；</li>\n<li>没有有效的 css 沙箱和 js 沙箱，需要靠用户自觉；</li>\n<li>子应用保活、多应用激活无法实现；</li>\n<li>主、子应用的路由可能发生冲突；</li>\n</ol>\n<p>底层原理 这个东西有点类似于拆包，也可以叫模块共享，例如React有个模块可以共享给Vue项目用Vue2的组件可以共享给Vue3用。</p>\n<h2 id=\"single-spa\"><a href=\"#single-spa\" class=\"headerlink\" title=\"single-spa\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnNpbmdsZS1zcGEuanMub3JnL2RvY3MvZ2V0dGluZy1zdGFydGVkLW92ZXJ2aWV3\">single-spa</span></h2><p>single-spa是微前端的基础框架，乾坤框架就是基于single-spa来实现的，在single-spa的基础上做了一层封装，也解决了single-spa的一些缺陷。</p>\n<p><strong>原理</strong></p>\n<ol>\n<li>single-spa原理是通过网络请求请求到文件资源（使用import导入语法时，需要在importmap中注册包名称和地址）</li>\n<li>对于样式隔离，single-spa推荐的方法有：Scoped CSS和shadow DOM</li>\n</ol>\n<p><strong>分析</strong></p>\n<p>single-spa实现了一个微前端框架需要具备的各种功能，但是实现的又不够彻底，遗留了很多需要解决的问题。</p>\n<h2 id=\"乾坤\"><a href=\"#乾坤\" class=\"headerlink\" title=\"乾坤\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vcWlhbmt1bi51bWlqcy5vcmcvemgv\">乾坤</span></h2><p>乾坤是在single-spa的基础之上进行的进一步封装</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；</li>\n<li>完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了 strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案；</li>\n<li>做了静态资源预加载能力；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；</li>\n<li>css 沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；</li>\n<li>无法同时激活多个子应用，也不支持子应用保活；</li>\n<li>无法支持 vite 等 esmodule 脚本运行；</li>\n</ol>\n<h2 id=\"无界\"><a href=\"#无界\" class=\"headerlink\" title=\"无界\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vd3VqaWUtbWljcm8uZ2l0aHViLmlvL2RvYy9hcGkvYnVzLmh0bWw=\">无界</span></h2><p><strong>特点</strong></p>\n<ol>\n<li>接入简单只需要四五行代码</li>\n<li>不需要针对vite额外处理</li>\n<li>预加载</li>\n<li>应用保活机制</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>隔离js使用一个空的iframe进行隔离</li>\n<li>子应用axios需要自行适配</li>\n<li>iframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从’about:blank’初始化为主应用的host，这个采用的计时器去等待的不是很悠亚。</li>\n</ol>\n<p>底层原理 使用shadowDom 隔离css，js使用空的iframe隔离，通讯使用的是proxy</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>无界的原理就是使用开启影子dom来进行样式的隔离，通过使用attachShadow方法开启影子dom（继承HTMLElement），获得的shadow影子dom添加template（无界的初始模板）为子元素，这样就进行了样式隔离，最后通过window.customElement.define注册dom元素wu-jie，使用标签即可。</p>\n<p>index.js：</p>\n<pre><code class=\"javascript\">window.onload = () =&gt; &#123;\n    class WuJie extends HTMLElement &#123;\n        constructor() &#123;\n            super()\n            this.init()\n            this.getAttr(&#39;url&#39;)\n        &#125;\n        init() &#123;\n          const shadow =  this.attachShadow(&#123; mode: &quot;open&quot; &#125;) //开启影子dom 也就是样式隔离\n          const template = document.querySelector(&#39;#wu-jie&#39;) as HTMLTemplateElement\n          console.log(template);\n          shadow.appendChild(template.content.cloneNode(true))\n        &#125;\n        getAttr (str:string) &#123;\n           console.log(&#39;获取参数&#39;,this.getAttribute(str));\n        &#125;\n        //生命周期自动触发有东西插入\n        connectedCallback () &#123;\n           console.log(&#39;类似于vue 的mounted&#39;);\n        &#125;\n        //生命周期卸载\n        disconnectedCallback () &#123;\n              console.log(&#39;类似于vue 的destory&#39;);\n        &#125;\n        //跟watch类似\n        attributeChangedCallback (name:any, oldVal:any, newVal:any) &#123;\n            console.log(&#39;跟vue 的watch 类似 有属性发生变化自动触发&#39;);\n        &#125;\n    &#125;\n    window.customElements.define(&#39;wu-jie&#39;, WuJie)\n&#125;\n</code></pre>\n<p>index.html：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!--外层写一个div测试隔离--&gt;\n    &lt;div&gt;我是div&lt;/div&gt;\n    &lt;wu-jie url=&quot;xxxxxx&quot;&gt;&lt;/wu-jie&gt;\n    &lt;template id=&quot;wu-jie&quot;&gt;\n       &lt;!--div的样式是作用于全局的--&gt;\n        &lt;style&gt;\n            div &#123;\n                background: red;\n            &#125;\n        &lt;/style&gt;\n         &lt;div&gt;\n            样式隔离的\n         &lt;/div&gt;\n    &lt;/template&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><p>使用：</p>\n<p>需要从wujie的实例导出<code>preloadApp</code>,参数跟<code>startApp</code> 一致，预加载必须开启exec选项</p>\n<pre><code class=\"javascript\">preloadApp(&#123; name: &quot;vue3&quot;, url: &quot;http://127.0.0.1:5174/&quot;, exec: true &#125;)\npreloadApp(&#123; name: &quot;react&quot;, url: &quot;http://127.0.0.1:5175/&quot;, exec: true &#125;)\n</code></pre>\n<ul>\n<li>exec代表是否进行预加载，默认值是true</li>\n<li>js的执行模式，由于子应用的执行会阻塞主应用的渲染线程，当设置为true时js采取类似于react fiber的模式方式间断执行，每个js文件的执行都包裹在<code>requestidlecallback</code>中，每执行一个js文件后就可以返回去响应外部的输入，不会造成浏览器渲染和加载之间的冲突从而造成卡顿，但是这个颗粒度是js文件，所以应该保证js文件不应过大。</li>\n</ul>\n<p>浏览器一帧之内要做的事情：</p>\n<ul>\n<li>处理用于输入（事件）</li>\n<li>执行定时任务</li>\n<li>执行requestAnimationFrame</li>\n<li>执行dom的回流和重绘</li>\n<li>计算更新涂层的更新指令</li>\n<li>绘制指令合并主线程，如果有空余时间执行requestidlecallbask</li>\n</ul>\n<p>react也有该机制 但是react并没有用 <code>requestidlecallback</code>，说是这个东西经过测试可能会超过16ms，超过16ms绘制就会看起来很卡 所以react16是用的 <code>requestAnimationFrame + postMessage</code> 实现的那为什么不用<code>setTimeOut</code> setTimeOut 及时为0 也会有一个最小毫秒延迟4ms，所以是用了postMessage，react18又换成了<code>MessageChannel</code> 实现了队列方式去执行任务。</p>\n<h2 id=\"micro-app\"><a href=\"#micro-app\" class=\"headerlink\" title=\"micro-app\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vemVyb2luZy5qZC5jb20vbWljcm8tYXBwL2RvY3MuaHRtbCUyMy8=\">micro-app</span></h2><p>micro-app 是基于 webcomponent + qiankun sandbox 的微前端方案。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>使用 webcomponet 加载子应用相比 single-spa 这种注册监听方案更加优雅；</li>\n<li>复用经过大量项目验证过 qiankun 的沙箱机制也使得框架更加可靠；</li>\n<li>组件式的 api 更加符合使用习惯，支持子应用保活；</li>\n<li>降低子应用改造的成本，提供静态资源预加载能力；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>css 沙箱依然无法绝对的隔离，js 沙箱做全局变量查找缓存，性能有所优化；</li>\n<li>支持 vite 运行，但必须使用 plugin 改造子应用，且 js 代码没办法做沙箱隔离；</li>\n<li>对于不支持 webcompnent 的浏览器没有做降级处理；</li>\n</ol>\n<p>底层原理 js隔离跟qiankun类似也是使用proxy + with，css隔离自定义前缀类似于scoped</p>\n<h1 id=\"模块联邦\"><a href=\"#模块联邦\" class=\"headerlink\" title=\"模块联邦\"></a>模块联邦</h1><p>模块联邦是跟<code>webpack5</code>强耦合的，是基于webpack5内置插件的 无须安装</p>\n<p>它相当于是一个去中心化技术，它可以让多个独立构建的应用之间，动态的调用彼此的模块。这种运行机制，可以让我们轻松的拆分应用，真正做到跨应用的模块共享。</p>\n<p>配置过程就是在webpack.config.js中配置ModuleFederationPlugin插件，打完包之后观察会发现其实就是import函数动态加载，使用模块联邦的好处就在于之前当多个项目共有的模块改变时，每一个项目都需要重新install一下，而使用模块联邦之后，就相当于动态导入，免去了重新install的过程（由项目的克隆转为类似软链接的过程）。</p>\n",
            "tags": [
                "微前端",
                "微前端"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/",
            "url": "https://dmqweb.cn/2024/05/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/",
            "title": "网络安全",
            "date_published": "2024-05-23T08:47:30.000Z",
            "content_html": "<h1 id=\"前端网络安全\"><a href=\"#前端网络安全\" class=\"headerlink\" title=\"前端网络安全\"></a>前端网络安全</h1><h2 id=\"1-XSS-跨站脚本攻击\"><a href=\"#1-XSS-跨站脚本攻击\" class=\"headerlink\" title=\"#1. XSS 跨站脚本攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzEteHNzLSVFOCVCNyVBOCVFNyVBQiU5OSVFOCU4NCU5QSVFNiU5QyVBQyVFNiU5NCVCQiVFNSU4NyVCQg==\">#</span>1. XSS 跨站脚本攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>XSS 是常见的 Web 攻击技术之一.所谓的跨站脚本攻击指得是:恶意攻击者往 Web 页面里注入恶意 Script 代码，用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取 cookie 信息、会话劫持等各种攻击。</p>\n</blockquote>\n<p><strong>危害</strong></p>\n<p>1、<strong>盗取各类用户帐号</strong>，如机器登录帐号、用户网银帐号、各类管理员帐号</p>\n<p>2、<strong>控制企业数据</strong>，包括读取、篡改、添加、删除企业敏感数据的能力</p>\n<p>3、<strong>盗窃企业重要的具有商业价值的资料</strong></p>\n<p>4、<strong>非法转账</strong></p>\n<p>5、<strong>强制发送电子邮件</strong></p>\n<p>6、<strong>网站挂马</strong></p>\n<p>7、<strong>控制受害者机器向其它网站发起攻击</strong></p>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>过滤用户的输入信息，禁止用户在输入的过程中输入 “&lt;”, “&gt;”, “引号”, “$”, “_”</li>\n<li>核心的用户身份标示或 token 保存在 Cookie 中,Cookie 中一定要加 “HTTPOnly” 在结尾，保证只有在 html 操作时才能将 cookie 中的内容发送出去，在 JS 中无法获得用户的 Cookie 信息</li>\n</ul>\n<h2 id=\"2-CSRF-网络攻击\"><a href=\"#2-CSRF-网络攻击\" class=\"headerlink\" title=\"#2. CSRF 网络攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzItY3NyZi0lRTclQkQlOTElRTclQkIlOUMlRTYlOTQlQkIlRTUlODclQkI=\">#</span>2. CSRF 网络攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为 “One Click Attack” 或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 XSS 更具危险性。</p>\n</blockquote>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>减少在 cookie 中存储客户核心内容比如用户的 token、ID、access_token 等</li>\n<li>GET 请求不对数据进行修改</li>\n<li>不让第三方网站访问到 Cookie</li>\n<li>阻止第三方网站请求接口</li>\n<li>请求时附带验证信息，比如验证码或者 Token</li>\n</ul>\n<h2 id=\"3-DDOS-攻击\"><a href=\"#3-DDOS-攻击\" class=\"headerlink\" title=\"#3. DDOS 攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzMtZGRvcy0lRTYlOTQlQkIlRTUlODclQkI=\">#</span>3. DDOS 攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>DDOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。</p>\n</blockquote>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。</li>\n</ul>\n<p><strong>后端如何处理</strong></p>\n<ul>\n<li>HTTP 请求的拦截，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。</li>\n<li>带宽扩容，或者使用 CDN</li>\n</ul>\n",
            "tags": [
                "网络安全",
                "网络安全"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/21/electron/",
            "url": "https://dmqweb.cn/2024/05/21/electron/",
            "title": "electron",
            "date_published": "2024-05-21T11:35:27.000Z",
            "content_html": "<p><strong>Electron中preload模块最为重要，它的源码逻辑如下：</strong></p>\n<ul>\n<li>首先electron中封装了c++模块对接node.js的addon模块,方法是：在头文件中标注了：#include &lt;node&#x2F;addon.h&gt;</li>\n<li>此c++模块将app实例绑定(linkedBinding)到process上，app实例中有<code>exposeAPIInWorld</code>方法</li>\n<li>接着<code>contextBridge</code>中的<code>expostInMainWorld</code>方法返回的是<code>process.linkedBinding.exposeAPIInWorld</code>方法。<br><img data-src=\"https://dmqweb.cn/images/Electron.pdf\" alt=\"Electron.pdf\"><br><a href=\"https://dmqweb.cn/images/Electron.pdf\">Electron pdf笔记</a></li>\n</ul>\n<h1 id=\"最近有些忙，未完待续哈\"><a href=\"#最近有些忙，未完待续哈\" class=\"headerlink\" title=\"最近有些忙，未完待续哈\"></a>最近有些忙，未完待续哈</h1>",
            "tags": [
                "electron",
                "electron"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/21/v8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
            "url": "https://dmqweb.cn/2024/05/21/v8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
            "title": "v8引擎编译原理",
            "date_published": "2024-05-21T10:36:10.000Z",
            "content_html": "<h1 id=\"v8-执行-JS\"><a href=\"#v8-执行-JS\" class=\"headerlink\" title=\"v8 执行 JS\"></a>v8 执行 JS</h1><p><img data-src=\"/images/image123.png\" alt=\"alt text\"></p>\n<h1 id=\"v8-引擎介绍\"><a href=\"#v8-引擎介绍\" class=\"headerlink\" title=\"v8 引擎介绍\"></a>v8 引擎介绍</h1><p>Blink 内核用于解析 HTML、DOM、CSS 渲染、嵌入了 v8 引擎用于解析 Javascript</p>\n<p>V8 是谷歌的开源高性能 JavaScript 和 WebAssembly 引擎，用 C++编写。它被用于 Chrome 和 Node.js 等。<strong>用于解析并执行 JavaScript 代码。</strong></p>\n<h1 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h1><ul>\n<li>初始化运行环境<ul>\n<li>堆栈空间</li>\n<li>全局执行上下文</li>\n<li>全局作用域</li>\n<li>事件循环系统</li>\n</ul>\n</li>\n<li>利用 Scanner 扫描器将输入的代码词法分析成 tokens<ul>\n<li>分析的结果就是一个个的 tokens 对象组成的数组</li>\n<li>分析的过程利用了有限自动状态机的概念</li>\n</ul>\n</li>\n<li>利用 parser 解析器将 tokens 转化为抽象语法树<ul>\n<li>根据分析 tokens 构造出一种树形关系结构</li>\n<li><strong>预解析</strong>：在 JS 代码执行之前对代码进行可选的预处理，用于提高执行效率</li>\n<li><strong>延迟解析</strong>：只有代码执行到的部分才会去解析，节省了不必要的时间和开销，提高了 JavaScript 的执行效率，其中 vite 脚手架就是利用了这个优点（还有 esbuild 打包快的优势），提高了效率。</li>\n</ul>\n</li>\n<li>利用 <code>ignation解释器</code>将 AST（抽象语法树）转为字节码（不直接转为机器码？）<ul>\n<li>当年v8以超越同行10倍的运行速度而备受青睐,其本质原因是当时v8将JS源码直接编译为机器码,使得首次运行速度和后续执行速度都很快,但也存在一个问题就是内存占用太大,并且编译时占用太多时间</li>\n<li>字节码使得v8能够很好的进行优化与反优化,当执行代码时,对机器码的存储和复用等操作时都十分繁琐(存储占用大,分析繁琐等),但是分析字节码就更加容易一些</li>\n<li>字节码跨平台能力强</li>\n<li>字节码更快的加载和解析执行</li>\n<li>动态优化易操作</li>\n<li>代码安全性</li>\n</ul>\n</li>\n<li>利用 <code>TurboFan编译器</code>将字节码转为 CPU 和 ARM 识别的机器码</li>\n</ul>\n<h1 id=\"v8-中的对象结构\"><a href=\"#v8-中的对象结构\" class=\"headerlink\" title=\"v8 中的对象结构\"></a>v8 中的对象结构</h1><h3 id=\"常规属性和排序属性\"><a href=\"#常规属性和排序属性\" class=\"headerlink\" title=\"常规属性和排序属性\"></a>常规属性和排序属性</h3><ul>\n<li>v8 中的对象主要分为三个指针构成的，分别是：隐藏类、常规属性和排序属性。</li>\n<li>对象的属性数字会从小到大排列，字符串会按照原创建顺序</li>\n<li>对象中数字属性被称为排序属性，字符串属性被称为常规属性</li>\n</ul>\n<h3 id=\"快属性和慢属性\"><a href=\"#快属性和慢属性\" class=\"headerlink\" title=\"快属性和慢属性\"></a>快属性和慢属性</h3><ul>\n<li>JS 对象很多属性是在原型链上进行查找，这样就会很慢，v8 将部分常规属性（10 个）直接存储到对象本身（对象内属性），以提高属性的查询效率。</li>\n<li>快属性容量是 10 个。</li>\n</ul>\n<h3 id=\"封装、继承、多态\"><a href=\"#封装、继承、多态\" class=\"headerlink\" title=\"封装、继承、多态\"></a>封装、继承、多态</h3><ul>\n<li>封装就是将抽象出来的数据和对数据的操作封装在一起，数据在内部被保护，程序其他部分只有通过成员才能对数据进行操作</li>\n<li>继承：有原型链继承、寄生继承和 call、apply 借用法继承。</li>\n<li>多态就是函数重载：同一个函数可以根据调用的情况（参数类型和数量等）来进行不同的操作。</li>\n</ul>\n<h1 id=\"隐藏类\"><a href=\"#隐藏类\" class=\"headerlink\" title=\"隐藏类\"></a>隐藏类</h1><p>JavaScript 是一门动态语言，其各种不确定性导致 JavaScript 的执行效率要远低于静态语言，V8 为了提升 JavaScript 的执行效率，借鉴了很多静态语言的特性，比如：JIT 机制，为了加速运算而引入了内联缓存，为了提升对象的属性访问速度而引入了隐藏类。</p>\n<p>隐藏类是 V8 引擎在运行时自动生成和管理的数据结构，用于跟踪对象的属性和方法，相当于提前定义好对象的形状，以便于提高操作对象的效率。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><ul>\n<li>当 JavaScript 运行时，例如查找对象上的某一个属性，V8 引擎会通过快慢属性去查找，整个过程非常耗时，因为 V8 在使用一个对象时，并不知道对象的具体形状（属性方法等）</li>\n<li>而 C++在声明一个对象前就需要定义该对象的结构，C++代码执行前是需要被编译的，编译时对象的结构就已经固定，也就是当代码执行时，对象的形状是无法改变</li>\n<li>所以 V8 引入了隐藏类的概念，用于跟踪对象的属性和方法以此在内存中快速查找对象属性</li>\n</ul>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>隐藏类就是把 JavaScript 的对象也进行静态化，<code>我们假设这个对象不会删除和新增</code>，这样形状就固定了</p>\n<p>满足条件之后 V8 就会创建隐藏类，在这个隐藏类会创建对象的基础属性</p>\n<p>在 V8 引擎中，每个隐藏类都有一个编号（<code>map id</code>），用于唯一标识该隐藏类</p>\n<p>举个例子，假设我们有以下两个对象：</p>\n<pre><code class=\"javascript\">let obj1 = &#123; name: 1, age: 2 &#125;;\nlet obj2 = &#123; name: 1, age: 2, address: 3 &#125;;\n</code></pre>\n<p>这两个对象具有相同的形状，即都有属性<code>name</code>和<code>age</code>，但<code>obj2</code>还额外有一个属性<code>address</code>。V8 会为它们生成两个不同的隐藏类</p>\n<pre><code class=\"sh\">// 隐藏类1：包含属性name和age\nHiddenClass_1\n├── map_id: 1\n├── property_names: [&#39;name&#39;, &#39;age&#39;]\n├── transitions: &#123;&#125;\n└── prototype: Object.prototype\n\n// 隐藏类2：包含属性name、age和address\nHiddenClass_2\n├── map_id: 2\n├── property_names: [&#39;name&#39;, &#39;age&#39;, &#39;address&#39;]\n├── transitions:\n│   ├── a: HiddenClass_1\n│   ├── b: HiddenClass_1\n│   └── c: null\n└── prototype: Object.prototype\n</code></pre>\n<p>可以看到，隐藏类 1 包含属性<code>name</code>和<code>age</code>，没有过渡表；而隐藏类 2 包含属性<code>name</code>、<code>age</code>和<code>address</code>，其中属性<code>name</code>和<code>age</code>的过渡表指向隐藏类 1，属性<code>address</code>没有过渡表，表示该属性是新添加的</p>\n<p><strong>如果两个对象属性一样呢？</strong></p>\n<p>如果两个对象具有相同的属性，它们将共享同一个隐藏类。具体来说，当两个对象的属性顺序和类型都相同时，V8 会为它们生成一个共享的隐藏类。</p>\n<p>举个例子，假设我们有以下两个对象：</p>\n<pre><code class=\"ini\">let obj1 = &#123; name: 1, age: 2 &#125;;\nlet obj2 = &#123; name: 1, age: 2 &#125;;\n</code></pre>\n<p>这两个对象具有相同的形状，即都有属性<code>name</code>和<code>age</code>，且属性的顺序和类型完全一致。V8 会为它们生成一个共享的隐藏类，如下所示：</p>\n<pre><code class=\"javascript\">HiddenClass_1\n├── map_id: 1\n├── property_names: [&#39;name&#39;, &#39;age&#39;]\n├── transitions: &#123;&#125;\n└── prototype: Object.prototype\n</code></pre>\n<p>可以看到，隐藏类 1 包含属性<code>name</code>和<code>age</code>，没有过渡表，而且两个对象都<code>共享</code>这个隐藏类。</p>\n<blockquote>\n<p>这种共享隐藏类的机制可以节省内存空间，因为不同的对象可以共享相同的隐藏类结构。</p>\n</blockquote>\n<p><img data-src=\"/images/Snipaste_2024-05-28_21-49-19.png\" alt=\"JavaScript隐藏类机制\"></p>\n<h1 id=\"v8引擎垃圾回收\"><a href=\"#v8引擎垃圾回收\" class=\"headerlink\" title=\"v8引擎垃圾回收\"></a>v8引擎垃圾回收</h1><blockquote>\n<p>首先垃圾回收机制是对于<code>引用数据类型而言的</code>,普通数据类型由于不知道后续是否会引用某个变量导致不能轻易将变量进行销毁</p>\n</blockquote>\n<h3 id=\"标记清除法\"><a href=\"#标记清除法\" class=\"headerlink\" title=\"标记清除法\"></a>标记清除法</h3><blockquote>\n<p>标记清除法是目前在JS引擎中最常用的算法,该算法分为<code>标记</code>和<code>清除</code>两个阶段,标记阶段将所有<code>活动对象做上标记</code>,默认标记为0,清除阶段将<code>没有标记的活动对象进行清除</code>,也就是销毁掉标记为0的对象</p>\n</blockquote>\n<ul>\n<li>优点: 实现简单</li>\n<li>缺点: 清除之后由于剩余对象的内存位置不变,就会出现<code>内存碎片</code>,这时候为了分配到合适的位置就要进行内存利用的算法判断,<code>导致分配效率慢</code></li>\n</ul>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><blockquote>\n<p>引用计数法的策略是跟踪每个对象被使用的次数,当对象被其他变量引用时,它的<code>引用次数就会加1</code>,引用次数为0就表示没有变量在使用它,就可以将其清除</p>\n</blockquote>\n<ul>\n<li>优点: 清晰,并且可以立即回收垃圾</li>\n<li>缺点: 需要一个计数器,同时计数器需要占很大的位置,因为<code>引用数量的上限可能会很大</code>,同时最重要的是无法解决<code>循环引用而无法回收的问题</code></li>\n</ul>\n<h3 id=\"分代式垃圾回收\"><a href=\"#分代式垃圾回收\" class=\"headerlink\" title=\"分代式垃圾回收\"></a>分代式垃圾回收</h3><blockquote>\n<p>V8 中将堆内存分为新生代和老生代两区域，采用不同的策略管理垃圾回收<br>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大</p>\n</blockquote>\n<h5 id=\"新生代\"><a href=\"#新生代\" class=\"headerlink\" title=\"新生代\"></a>新生代</h5><blockquote>\n<p>新生代堆内存一分为二:<code>使用区</code>和<code>空闲区</code>,新加入的对象就会放在使用区,当<code>使用区快写满时,就开始进行垃圾回收</code>，新生代垃圾回收器会对使用区中的<code>活动对象做标记</code>，标记完成之后<code>将使用区的 活动对象 复制进空闲区</code>并进行排序，随后进入垃圾清理阶段，即<code>将非活动对象占用的空间清理掉</code>。最后<code>进行角色互换</code>，把原来的使用区变成空闲区，把原来的空闲区变成使用区.当一个对象经过<code>多次复制后依然存活</code>，它将会被认为是生命周期较长的对象，随后<code>会被移动到老生代中</code>，采用老生代的垃圾回收策略进行管理<br>另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中<br>新生代采用复制方式的原因是因为:新生代中的大多数对象都是很快变为垃圾(需要进行清除),如果直接原地清除就要频繁清理对象,<code>只复制活动对象到空闲区之后就可以直接清除整个使用区</code>,提高了清除效率</p>\n</blockquote>\n<h5 id=\"老生代\"><a href=\"#老生代\" class=\"headerlink\" title=\"老生代\"></a>老生代</h5><blockquote>\n<p>对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是<code>标记清除法</code>了<br>而标记清除法造成的<code>内存碎片问题</code>采用标记整理算法进行优化.</p>\n</blockquote>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><blockquote>\n<p>分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，<code>新老生代的回收机制及频率是不同的</code>，可以说此机制的出现很大程度<code>提高了垃圾回收机制的效率</code></p>\n</blockquote>\n<h3 id=\"并行回收\"><a href=\"#并行回收\" class=\"headerlink\" title=\"并行回收\"></a>并行回收</h3><p>新生代对象空间采用并行策略,在执行垃圾回收时,会启动多个线程来负责垃圾清理,以此增加效率</p>\n<blockquote>\n<p>并行和并发: 并发是:一个处理器同时处理多个任务(并发是逻辑上同时发生),并行是:多个处理器同时处理多个不同任务(并行是物理上同时发生)</p>\n</blockquote>\n",
            "tags": [
                "v8引擎编译原理",
                "v8引擎",
                "底层原理"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/17/Blob%E5%92%8CFile/",
            "url": "https://dmqweb.cn/2024/05/17/Blob%E5%92%8CFile/",
            "title": "Blob、File和FileReader",
            "date_published": "2024-05-17T02:22:13.000Z",
            "content_html": "<h1 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h1><p>Blob的全称为：binary larget object（二进制大对象），blob的本质是一个js对象，里面可以存储大量的二进制编码的数据。</p>\n<h3 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h3><ul>\n<li>不可修改</li>\n<li>只能使用FileReader读取内容</li>\n<li>存储大量二进制数据的 js 对象</li>\n</ul>\n<h3 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p><strong>new Blob(array,options)</strong></p>\n<ul>\n<li><p>array是由ArrayBuffer、ArrayBufferView、Blob和DOMString对象构成的，将对被放进blob中</p>\n</li>\n<li><p>options配置项有：</p>\n<ul>\n<li><p>type：默认值为：” “，表示将会被放入到blob中的数组内容的MIME类型。</p>\n</li>\n<li><p>endings：默认值为：”transparent“，用于指定包含行结束符\\n的字符串如何被写入，不常用。</p>\n<table>\n<thead>\n<tr>\n<th>MIME类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>text&#x2F;plain</td>\n<td>纯文本文档</td>\n</tr>\n<tr>\n<td>text&#x2F;html</td>\n<td>HTML文档</td>\n</tr>\n<tr>\n<td>text&#x2F;javascript</td>\n<td>JavaScript文档</td>\n</tr>\n<tr>\n<td>text&#x2F;css</td>\n<td>CSS文件</td>\n</tr>\n<tr>\n<td>application&#x2F;json</td>\n<td>JSON文件</td>\n</tr>\n<tr>\n<td>application&#x2F;pdf</td>\n<td>pdf文件</td>\n</tr>\n<tr>\n<td>application&#x2F;xml</td>\n<td>XML文件</td>\n</tr>\n<tr>\n<td>image&#x2F;jpeg</td>\n<td>JPEG文件</td>\n</tr>\n<tr>\n<td>image&#x2F;png</td>\n<td>PNG文件</td>\n</tr>\n<tr>\n<td>image&#x2F;gif</td>\n<td>GIF文件</td>\n</tr>\n<tr>\n<td>image&#x2F;svg+xml</td>\n<td>SVG+XML文件</td>\n</tr>\n<tr>\n<td>audio&#x2F;mpeg</td>\n<td>MP3文件</td>\n</tr>\n<tr>\n<td>video&#x2F;mpeg</td>\n<td>MP4文件</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"javascript\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\n</code></pre>\n<h3 id=\"分片：\"><a href=\"#分片：\" class=\"headerlink\" title=\"分片：\"></a>分片：</h3><p>Blob 对象内置了 slice() 方法用来将 blob 对象分片</p>\n<p>其有三个参数：</p>\n<p>start：设置切片的起点，即切片开始位置。默认值为 0，这意味着切片应该从第一个字节开始；</p>\n<p>end：设置切片的结束点，会对该位置之前的数据进行切片。默认值为blob.size；</p>\n<p>contentType：设置新 blob 的 MIME 类型。如果省略 type，则默认为 blob 的原始值。</p>\n<pre><code class=\"javascript\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\nlet blob1 = blob.slice(0,2,&quot;text/plain&quot;);\n</code></pre>\n<h3 id=\"读取：\"><a href=\"#读取：\" class=\"headerlink\" title=\"读取：\"></a>读取：</h3><p>blob对象只能通过FileReader读取内容。</p>\n<pre><code class=\"javascript\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\nlet reader = new fileReader();\nreader.readAsText(blob);\nconsole.log(reader.result);\n</code></pre>\n<h1 id=\"File\"><a href=\"#File\" class=\"headerlink\" title=\"File\"></a>File</h1><h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>File对象是特殊的Blob对象。是基于Blob对象的进一步封装，js中主要有两种方式获得FIle对象：</p>\n<ol>\n<li>input元素选择后返回的FileList对象（通过change事件的event.target.files获取）</li>\n<li>文件拖放操作生成的DataTransfer对象（通过ondrop事件的event.dataTransfer.files获取）</li>\n</ol>\n<h1 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h1><h3 id=\"介绍：-1\"><a href=\"#介绍：-1\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>FileReader用于读取Blob对象（包含File对象）内容的方法，通过result属性获取。</p>\n<ul>\n<li><p>readAsArrayBuffer方法：读取为ArrayBuffer</p>\n</li>\n<li><p>readAsDataURL方法：读取为data:URL的Base64字符串表示文件内容</p>\n</li>\n<li><p>readAsText方法：读取为原始text文件内容</p>\n</li>\n<li><p>readAsBinaryString方法：读取为原始二进制数据</p>\n<p>但是直接使用此方法还是会得到原始的文本内容，因为二进制数据需要使用ArrayBuffer对象来进行处理。</p>\n</li>\n</ul>\n<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h1><h3 id=\"介绍：-2\"><a href=\"#介绍：-2\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>ArrayBuffer可以理解为一个特殊的数组，其本身是一个黑盒，不能直接读写所存储的数据，需要借助视图对象来读写。它只是一个用于存储二进制数据的缓冲区，创建时只能传一个空间大小biteLength。</p>\n<p><strong>读写ArrayBuffer的方式：</strong></p>\n<ol>\n<li>TypedArray</li>\n<li>DataView</li>\n<li>TextDecoder</li>\n<li>用Blob存储，然后用FileReader读写</li>\n</ol>\n<h3 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><p>ArrayBuffer提供了一个slice方法用于切片。参数为：开始位置，结束位置和解析类型。</p>\n<h3 id=\"使用：-1\"><a href=\"#使用：-1\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"javascript\">const buffer = new ArrayBuffer(32);\nbuffer.slice(0,4,&#39;text/plain&#39;);\n</code></pre>\n<h1 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h1><p>TypedArray只是一个概念，提供了一种机制来解读ArrayBuffer中的数据（相当于一个视图，将ArrayBuffer中的数据进行展示和操作），实际上是那九个类型对象（每个类型对应一个特定的数据类型和大小）：</p>\n<ul>\n<li><code>Int8Array</code>：8位有符号整数</li>\n<li><code>Uint8Array</code>：8位无符号整数</li>\n<li><code>Int16Array</code>：16位有符号整数</li>\n<li><code>Uint16Array</code>：16位无符号整数</li>\n<li><code>Int32Array</code>：32位有符号整数</li>\n<li><code>Uint32Array</code>：32位无符号整数</li>\n<li><code>Float32Array</code>：32位浮点数</li>\n<li><code>Float64Array</code>：64位浮点数</li>\n</ul>\n<h3 id=\"使用：-2\"><a href=\"#使用：-2\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"javascript\">const buffer = new ArrayBuffer(32);\nconst slice = buffer.slice(0,4,&#39;text/plain&#39;);\nconst sliceView = new Int8Array(slice);\nsliceView.set([10,20,30]);\nsliceView.forEach((value,index)=&gt;&#123;\n    console.log(value,index);\n&#125;)\n</code></pre>\n<h1 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h1><h3 id=\"读取：-1\"><a href=\"#读取：-1\" class=\"headerlink\" title=\"读取：\"></a>读取：</h3><p>DataView数据视图可以用于读写buffer,DataView实例提供了许多方法来读取内存，他们呢的参数都是一个字节序号。表示开始读取的字节位置：</p>\n<ul>\n<li>getInt8：读取1个字节，返回一个8位整数</li>\n<li>getUint8：读取1个字节，返回一个无符号8位整数</li>\n<li>getInt16：读取2个字节，返回一个16位整数</li>\n<li>getUnit16：读取2个字节，返回一个无符号16位整数</li>\n<li>getInt32：读取4个字节，返回一个32位整数</li>\n<li>getUnit32：读取4个字节，返回一个无符号32位整数</li>\n<li>getFloat32：读取4个字节，返回一个32位浮点数</li>\n<li>getUnit64：读取8个字节，返回一个64位浮点数</li>\n</ul>\n<h3 id=\"写入：\"><a href=\"#写入：\" class=\"headerlink\" title=\"写入：\"></a>写入：</h3><p>DataView实例提供以下方法写入内存，他们都接受两个参数，第一个参数表示开始写入数据的字节序号，第二个参数为写入的数据：</p>\n<ul>\n<li>setInt8：写入1个字节的8位整数</li>\n<li>setUint8：写入1个字节的8位无符号整数</li>\n<li>setInt16：写入2个字节的16位整数</li>\n<li>setUint16：写入2个字节的16位无符号整数</li>\n<li>setInt32：写入4个字节的32位整数</li>\n<li>setUnit32：写入4个字节的32位无符号整数</li>\n<li>setFloat32：写入4个字节的32位浮点数</li>\n<li>setFloat64：写入8个自己的64位浮点数</li>\n</ul>\n<h1 id=\"Object-URL\"><a href=\"#Object-URL\" class=\"headerlink\" title=\"Object URL\"></a>Object URL</h1><p>Object URL是一个用于表示File Object或者Blob Object的URL，可以将<strong>Blob对象（包括File对象）</strong>变为一个URL地址。</p>\n<h3 id=\"使用：-3\"><a href=\"#使用：-3\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p>使用URL.createObjectURL来创建。</p>\n<pre><code class=\"javascript\">const blob = new Blob([&#39;你好世界&#39;],&#123;type:&#39;text/plain&#39;&#125;);\nconst newUrl = URL.createObjectURL(blob);\n</code></pre>\n<h1 id=\"base64编码\"><a href=\"#base64编码\" class=\"headerlink\" title=\"base64编码\"></a>base64编码</h1><h3 id=\"介绍：-3\"><a href=\"#介绍：-3\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>base64是一个保存二进制数据的工具，将多种形式的二进制数据或其构成的文件<strong>以ASCII的形式保存</strong>，因为很多地方不支持直接的二进制文件保存或呈现，比如可以将图片直接转换成base64码嵌入HTML文档中，而避免使用网络http加载图片。另外，将数据编码为 base64 进行传输，然后解码获得数据，可以一定程度上保证数据的完整并且不用在传输过程中修改这些数据，避免在传输过程中可能出现的问题；</p>\n<h3 id=\"组成：\"><a href=\"#组成：\" class=\"headerlink\" title=\"组成：\"></a>组成：</h3><p><code>A-Z a-z 0-9 + /</code> 共64个字符组成;</p>\n<h3 id=\"使用：-4\"><a href=\"#使用：-4\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p>JS中有两个函数用于base64格式（ASCII码）的转换:</p>\n<ul>\n<li><p>btoa()：编码（Binary To ASCII  二进制转ASCII）</p>\n<p>该函数用于将二进制转为Base64字符串（ASCII码）</p>\n</li>\n<li><p>atob()：解码（ASCII To Binary  ASCII码转二进制）</p>\n<p>该函数用于将Base64字符串（ASCII码）解码为二进制</p>\n</li>\n</ul>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>btoa和atob方法有个弊端就是只能处理拉丁字符集内的字符，其不包括中文或非西欧语言的字符（<strong>只能处理单字节字符</strong>）。要处理多字节字符需要使用TextEncoder API将字符串转为Uint8Array，然后手动将这些字节转为一个字符串（String.fromCharCode）。</p>\n<h1 id=\"TextEncoder\"><a href=\"#TextEncoder\" class=\"headerlink\" title=\"TextEncoder\"></a>TextEncoder</h1><h3 id=\"介绍：-4\"><a href=\"#介绍：-4\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>TextEncoder构造函数创建一个编码器，encode方法用于将字符串编码为一个UTF-8编码文本的Uint8Array视图。</p>\n<h3 id=\"使用：-5\"><a href=\"#使用：-5\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"javascript\">const encoder = new TextEncoder();\nconst view = encoder.encode(&quot;$&quot;);\nconsole.log(view)\n</code></pre>\n",
            "tags": [
                "Blob",
                "Blob",
                "FileReader"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/17/esbuild/",
            "url": "https://dmqweb.cn/2024/05/17/esbuild/",
            "title": "esbuild",
            "date_published": "2024-05-17T01:14:12.000Z",
            "content_html": "<p>关于打包工具：esbuild、webpack和rollup三者的介绍推荐<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjI0MDk4NDIyOTM5MjU0ODIx\">这里</span>：</p>\n<p>简单来说就是esbuild打包更快；rollup打包产物更纯净、体积更小，但不支持热更新；webpack功能更全，生态更完善，支持文件类型更多。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>Esbuild是一个类webpack的打包工具，速度是webpack的几十倍。其底层基于go语言进行编写，不使用AST，优化了构建流程。js是单线程串行，esbuild是新开了一个进程，使用多线程并行，充分发挥了多核的优势。</p>\n<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>esbuild最显著的作用就是：快。它也是vite和snowpack底层的打包工具。同时也可以将esbuild打包工具集成到webpack中（使用plugin）。之所以esbuild没有流行起来是因为它绕过了AST，而直接进行构建，使没有很好的过渡到基于babel-loader这样通过AST进行打包的上层工具中。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><pre><code class=\"javascript\">const esbuild = require(&#39;esbuild&#39;);\n/**\n * 利用esbuild生成文件\n */\nesbuild.buildSync(&#123;\n    entryPoints:[&#39;vite.config.js&#39;],\n    outfile: &#39;out.js&#39;\n&#125;)\n/**\n * 利用esbuild处理jsx语法\n */\nconsole.log(\n    esbuild.transformSync(&#39;&lt;div&gt;利用esbuild处理jsx语法&lt;/div&gt;&#39;,&#123;\n        jsxFragment:&#39;Fragment&#39;,\n        loader:&#39;jsx&#39;\n    &#125;)\n);\n/**\n * 利用esbuld压缩代码体积\n */\nconsole.log(\n    esbuild.transformSync(&#39;const a = &quot;你好世界&quot;&#39;,&#123;\n        minify: true\n    &#125;)\n);\n/**\n * esbuild内置了一些loader，使用时会根据文件后缀自动执行loader，也可以手动确定loader\n * 支持：js,jsx,ts,tsx,css,text,binary,dataurl,file\n */\nconsole.log(\n    esbuild.buildSync(&#123;\n        entryPoints: [&#39;vite.config.js&#39;],\n        bundle:true,\n        loader: &#123;&#39;.js&#39;:&#39;jsx&#39;&#125;, //默认使用js loader，手动改为jsx-loader\n        outfile: &#39;out.js&#39;,\n    &#125;)\n);\n/**\n * 使用esbuild启动一个web server用于调试（热更新）\n */\nesbuild.serve(&#123;&#125;,&#123;\n    entryPoints: [&#39;vite.config.js&#39;],\n    bundle: true,\n    outfile: &#39;bundle.js&#39;,\n&#125;).then(serve=&gt;&#123;\n    serve.stop();\n&#125;)\n</code></pre>\n",
            "tags": [
                "esbuild",
                "esbuild",
                "打包工具"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/17/eslint%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
            "url": "https://dmqweb.cn/2024/05/17/eslint%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
            "title": "eslint源码",
            "date_published": "2024-05-17T01:14:12.000Z",
            "content_html": "<h1 id=\"eslint知识点\"><a href=\"#eslint知识点\" class=\"headerlink\" title=\"eslint知识点\"></a>eslint知识点</h1><h3 id=\"extends与plugins\"><a href=\"#extends与plugins\" class=\"headerlink\" title=\"extends与plugins\"></a>extends与plugins</h3><ol>\n<li>plugins本质是为了加强eslint的扩展性，使我们可以直接使用别人写好的eslint规则，方便快速用于项目中。</li>\n<li>官方规定npm包的扩展必须以eslint-config-开头，插件以eslint-plugin-开头，在使用过程中可以省略这个开头。</li>\n<li>eslint-config-文件是我们共享的一些配置文件，里面就是一个JS对象，其中包含一些配置信息，而eslint-plugin-文件是我们自定义的集合规则，可以导入和使用。</li>\n<li>一个插件能带来：<ul>\n<li>额外的规则，如<code>&#123;&quot;rules&quot;: &#123;&quot;react/boolean-prop-naming&quot;: &quot;warning&quot;&#125;&#125;</code>。</li>\n<li>环境，如<code>&#123;&quot;env&quot;: &#123;&quot;jest/global&quot;: true&#125;&#125;</code>。</li>\n<li>配置，如<code>&#123;&quot;extends&quot;: [&quot;plugin:react/recommended&quot;]&#125;</code>。</li>\n<li>预处理器，如<code>&#123;&quot;process&quot;: &quot;a-plugin/a-processor&quot;&#125;</code>。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"eslint配置大全\"><a href=\"#eslint配置大全\" class=\"headerlink\" title=\"eslint配置大全\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODU5NDg4MjkyODcx\">eslint配置大全</span></h1><h1 id=\"eslint源码分析\"><a href=\"#eslint源码分析\" class=\"headerlink\" title=\"eslint源码分析\"></a>eslint源码分析</h1>",
            "tags": [
                "eslint",
                "eslint",
                "源码"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/17/whistle%E4%BD%BF%E7%94%A8/",
            "url": "https://dmqweb.cn/2024/05/17/whistle%E4%BD%BF%E7%94%A8/",
            "title": "whistle抓包",
            "date_published": "2024-05-17T01:14:12.000Z",
            "content_html": "<h1 id=\"whistle简单使用\"><a href=\"#whistle简单使用\" class=\"headerlink\" title=\"whistle简单使用\"></a>whistle简单使用</h1><h3 id=\"whistle安装启动\"><a href=\"#whistle安装启动\" class=\"headerlink\" title=\"whistle安装启动\"></a>whistle安装启动</h3><p>安装：npm i -g whistle</p>\n<p>使用：w2 start</p>\n<p>访问：访问对应的页面</p>\n<p>作用：</p>\n<ul>\n<li>任何的链接都会经过工具转发一下，并记录下来</li>\n<li>使用前需要配置代理到whistle服务的地址和端口上（设置代理如下）</li>\n</ul>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>设置代理：</p>\n<ul>\n<li>手机端省略</li>\n<li>电脑端：<ul>\n<li>网络偏好设置—高级—代理—网页代理、安全网页代理</li>\n<li>配置代理的ip地址和端口号（8899）</li>\n</ul>\n</li>\n</ul>\n<p>确认证书：</p>\n<p>一般会自动下载，也可以打开8899端口找到证书下载并确认信任</p>\n<p><strong>查看抓包情况和设置代理转发：</strong></p>\n<p>打开127.0.0.1:8899端口进行设置</p>\n<h1 id=\"whistle高级\"><a href=\"#whistle高级\" class=\"headerlink\" title=\"whistle高级\"></a>whistle高级</h1><h3 id=\"mock数据\"><a href=\"#mock数据\" class=\"headerlink\" title=\"mock数据\"></a>mock数据</h3><p>设置线上地址转发到本地json文件（使用file路径），模拟请求数据。</p>\n<h3 id=\"部分文件请求转发（重要）\"><a href=\"#部分文件请求转发（重要）\" class=\"headerlink\" title=\"部分文件请求转发（重要）\"></a>部分文件请求转发（重要）</h3><p>例如线上环境有某个文件报错，生产环境无法复现，可以将该文件地址转发到本地的js文件（使用file路径），方便进行调试，提高调试效率。</p>\n<h3 id=\"请求转发\"><a href=\"#请求转发\" class=\"headerlink\" title=\"请求转发\"></a>请求转发</h3><p>可以作为跨域的一种方案，将本地的请求转发到线上的路径，这样就不会发生跨域问题</p>\n<h3 id=\"注入html、css和-js\"><a href=\"#注入html、css和-js\" class=\"headerlink\" title=\"注入html、css和 js\"></a>注入html、css和 js</h3><p>whistle会自动根据响应内容的类型，判断是否注入相应的文本以及如何注入（是否用标签包裹）</p>\n<p>例如：</p>\n<pre><code class=\"yaml\">https://www.baidu.com  css:///Users/dmq/Desktop/test.css\n</code></pre>\n<p>这将会在百度的官网注入自定义的css样式。</p>\n<h6 id=\"举例：\"><a href=\"#举例：\" class=\"headerlink\" title=\"举例：\"></a>举例：</h6><p>向百度网站注入vconsole.js源码，方便调试打印日志。</p>\n<ol>\n<li><p>下载vconsole到本地或者直接复制源码到whistle中的values中</p>\n</li>\n<li><p>本地js文件创建VConsole实例，或者直接在whistle的values中创建js文件，文件中创建vconsole实例。</p>\n</li>\n<li><p>在rules中向百度网站注入两个js文件（以whistle中配置values为示例）</p>\n<pre><code class=\"yaml\">www.baidu.com  jsPrepend://&#123;vConsole.min.js&#125;  #引入源码\nwww.baidu.com  jsPrepend://&#123;vconsole.js&#125;  #引入实例化js\nwww.baidu.com  log://  #在whistle中也打印log\n</code></pre>\n</li>\n</ol>\n<h3 id=\"同步抓包日志\"><a href=\"#同步抓包日志\" class=\"headerlink\" title=\"同步抓包日志\"></a>同步抓包日志</h3><p>在rules中配置网站的输出，可以将抓包的log日志同步到whistle中的log面板，配置例如：</p>\n<pre><code class=\"yaml\">www.baidu.com   log:// #同步日志\n</code></pre>\n<h3 id=\"解决跨域问题\"><a href=\"#解决跨域问题\" class=\"headerlink\" title=\"解决跨域问题\"></a>解决跨域问题</h3><p>可以单独设置网站允许跨域访问，例如在rules中配置：</p>\n<pre><code class=\"yaml\">https://localhost:5500/list   resCors://*  #表示该网站允许跨域访问\n</code></pre>\n<p>或者使用前端转发代理来处理跨域：</p>\n<pre><code class=\"yaml\">https://localhost:8080/list   https://localhost:5500/list  \n#将请求的网址代理到同域名同端口的网址，就不会发生跨域。\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTc3NjU1L2FydGljbGUvZGV0YWlscy8xMTkyODMwMjg=\">本文学习自b站，原文档地址</span></p>\n",
            "tags": [
                "whistle",
                "whistle",
                "抓包工具"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/11/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/",
            "url": "https://dmqweb.cn/2024/05/11/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/",
            "title": "性能指标",
            "date_published": "2024-05-11T01:14:12.000Z",
            "content_html": "<h1 id=\"常见浏览器性能指标\"><a href=\"#常见浏览器性能指标\" class=\"headerlink\" title=\"常见浏览器性能指标\"></a>常见浏览器性能指标</h1><h1 id=\"TTFB-Time-To-First-Byte\"><a href=\"#TTFB-Time-To-First-Byte\" class=\"headerlink\" title=\"TTFB(Time To First Byte)\"></a>TTFB(Time To First Byte)</h1><p>发出页面请求到接收到应答数据第一个字节的时间总和，包含了：</p>\n<ol>\n<li>DNS解析时间</li>\n<li>TCP链接时间</li>\n<li>发送HTTP请求时间</li>\n<li>获得响应消息第一个字节的时间。</li>\n</ol>\n<h1 id=\"FP（First-Paint）\"><a href=\"#FP（First-Paint）\" class=\"headerlink\" title=\"FP（First Paint）\"></a><strong>FP</strong>（First Paint）</h1><p>首次绘制时间，这个指标用于记录页面第一次绘制像素的时间。</p>\n<h1 id=\"FCP（First-Contentful-Paint）\"><a href=\"#FCP（First-Contentful-Paint）\" class=\"headerlink\" title=\"FCP（First Contentful Paint）\"></a><strong>FCP</strong>（First Contentful Paint）</h1><p>首次内容绘制时间，这个指标用于记录页面首次绘制文本、图片、非空白 Canvas 或 SVG 的时间。</p>\n<h1 id=\"LCP（Largest-Contentful-Paint）\"><a href=\"#LCP（Largest-Contentful-Paint）\" class=\"headerlink\" title=\"LCP（Largest Contentful Paint）\"></a><strong>LCP</strong>（Largest Contentful Paint）</h1><p>最大内容绘制时间，用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录。</p>\n<h1 id=\"CLS（Cumulative-Layout-Shift）\"><a href=\"#CLS（Cumulative-Layout-Shift）\" class=\"headerlink\" title=\"CLS（Cumulative Layout Shift）\"></a><strong>CLS</strong>（Cumulative Layout Shift）</h1><p>累计位移偏移，记录了页面上非预期的位移波动。计算方式为：位移影响的面积 * 位移距离。</p>\n<h1 id=\"TTI（Time-to-Interactive）\"><a href=\"#TTI（Time-to-Interactive）\" class=\"headerlink\" title=\"TTI（Time to Interactive）\"></a><strong>TTI</strong>（Time to Interactive）</h1><p>首次可交互时间。这个指标计算过程略微复杂，它需要满足以下几个条件：</p>\n<ol>\n<li>从 FCP 指标后开始计算；</li>\n<li>持续 5 秒内无长任务（执行时间超过 50 ms）且无两个以上正在进行中的 GET 请求；</li>\n<li>往前回溯至 5 秒前的最后一个长任务结束的时间。</li>\n</ol>\n<h1 id=\"FID（First-Input-Delay）\"><a href=\"#FID（First-Input-Delay）\" class=\"headerlink\" title=\"FID（First Input Delay）\"></a><strong>FID</strong>（First Input Delay）</h1><p>首次输入延迟时间，记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟。</p>\n<h1 id=\"TBT（Total-Blocking-Time）\"><a href=\"#TBT（Total-Blocking-Time）\" class=\"headerlink\" title=\"TBT（Total Blocking Time）\"></a><strong>TBT</strong>（Total Blocking Time）</h1><p>阻塞总时间，记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。</p>\n",
            "tags": [
                "性能优化",
                "性能指标"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/05/08/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/",
            "url": "https://dmqweb.cn/2024/05/08/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/",
            "title": "函数重载",
            "date_published": "2024-05-08T14:35:51.000Z",
            "content_html": "<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>函数重载是指在编程语言中允许定义多个同名函数，但是他们的参数类型、参数个数或者返回类型不同，编译器或解析器会根据调用时提供的参数类型和个数来确定使用哪个函数</p>\n<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>函数重载的主要目的就是提高代码的可读性和灵活性，同时避免了为不同功能编写不同的函数名导致的变量命名冲突和混乱。</p>\n<h1 id=\"实现函数重载\"><a href=\"#实现函数重载\" class=\"headerlink\" title=\"实现函数重载\"></a>实现函数重载</h1><h2 id=\"ts\"><a href=\"#ts\" class=\"headerlink\" title=\"ts\"></a>ts</h2><p>ts中进行函数重载其实就是根据型参数组的个数和对变量进行typeof检测，然后根据不同的情况进行分支处理</p>\n<pre><code class=\"ts\">// 函数重载的声明\nfunction average(numbers: number[]): number; // 函数签名1：接受数字数组并返回数字\nfunction average(...numbers: number[]): number; // 函数签名2：接受可变数量的数字参数并返回数字\n// 函数实现\nfunction average(...args: any[]): number &#123; // 实际函数实现\n    let sum = 0;\n    if (args.length === 1 &amp;&amp; Array.isArray(args[0])) &#123; // 如果传入的是数组\n        const numbers = args[0] as number[]; // 类型断言为数字数组\n        for (const num of numbers) &#123;\n            sum += num;\n        &#125;\n        return sum / numbers.length;\n    &#125; else if (args.length &gt; 1) &#123; // 如果传入的是多个数字\n        for (const num of args) &#123;\n            sum += num;\n        &#125;\n        return sum / args.length;\n    &#125; else &#123;\n        throw new Error(&#39;Invalid arguments&#39;); // 抛出错误，不支持的参数类型\n    &#125;\n&#125;\n\n// 调用函数重载\nconsole.log(average([1, 2, 3, 4, 5])); // 输出: 3\nconsole.log(average(1, 2, 3, 4, 5)); // 输出: 3\n</code></pre>\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><p>js中也可以通过typeof和形参数组进行函数重载，不过当然还有更好的做法，jQuery作者常用如下实现函数重载（进行重载之前要调用一次函数）：</p>\n<pre><code class=\"javascript\">function addMethod(object,name,fn)&#123;\n    const old = object[name];\n    object[name] = function (...args)&#123;\n        if(args.length === fn.length)&#123;\n            return fn.apply(this,args);\n        &#125;else if(typeof old === &#39;function&#39;)&#123;\n            return old.apply(this,args);\n        &#125;\n    &#125;\n&#125;;\nconst searcher = &#123;&#125;; //将对象中对应属性的重载方法全部存储起来\naddMethod(searcher,&#39;getUsers&#39;,()=&gt;&#123;\n    console.log(&#39;查询所有用户&#39;);\n&#125;);\naddMethod(searcher,&#39;getUsers&#39;,(name=&#39;a&#39;)=&gt;&#123; //注意默认参数的形参数量不与计数\n    console.log(&#39;按照姓名查询用户&#39;);\n&#125;);\n\nsearcher.getUsers();\n</code></pre>\n<p>另一种实现方法就是使用映射：</p>\n<pre><code class=\"javascript\">function createOverload()&#123;\n    const fnMap = new Map();\n    function overload(...args)&#123;\n        const key = args.map((it) =&gt; typeof it).join(&#39;,&#39;);\n        const fn = fnMap.get(key);\n        if(!fn)&#123;\n            throw new TypeError(&#39;没有找到对应的实现&#39;);\n        &#125;\n        return fn.apply(this,args);\n    &#125;\n    overload.addImpl = function(...args)&#123;\n        const fn = args.pop();\n        if(typeof fn !== &#39;function&#39;)&#123;\n            throw new TypeError(&#39;最后一个参数必须是函数&#39;)\n        &#125;\n        const key = args.join(&#39;,&#39;);\n        fnMap.set(key,fn);\n    &#125;;\n    return overload;\n&#125;\nconst getUsers = createOverload();\ngetUsers.addImpl(()=&gt;&#123;\n    console.log(&#39;查询所有用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;number&#39;,(page,size=10)=&gt;&#123;\n    console.log(&#39;按照页码和数量查询用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;number&#39;,&#39;number&#39;,(page,size=10)=&gt;&#123;\n    console.log(&#39;按照页码和数量查询用户&#39;);\n&#125;)\ngetUsers.addImpl(&#39;string&#39;,(name)=&gt;&#123;\n    console.log(&#39;按照姓名查询用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;string&#39;,&#39;string&#39;,()=&gt;&#123;\n    console.log(&#39;按照性别查询用户&#39;);\n&#125;);\ngetUsers(&#39;asfsdf&#39;);\n</code></pre>\n<p>总结一下实现思路，通过createOverload函数调用可以返回一个重载后的函数，createOverload函数中创建了一个map，map中将参数类型和个数与对应的函数相匹配，返回的重载函数在调用时会根据参数的类型去map中寻找对应的函数，通过apply绑定this作用域和参数执行即可。</p>\n",
            "tags": [
                "JS",
                "JS,函数重载"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/04/30/%E6%B7%B1%E6%8B%B7%E8%B4%9D/",
            "url": "https://dmqweb.cn/2024/04/30/%E6%B7%B1%E6%8B%B7%E8%B4%9D/",
            "title": "深拷贝",
            "date_published": "2024-04-30T09:34:25.000Z",
            "content_html": "<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>我们知道在javascript中有八种数据类型：其中number，string，undefined，null，boolean，symbol和bigint为基本数据类型，而object为复杂数据类型</p>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><ul>\n<li>对于基本数据类型，其值直接存储于栈中。</li>\n<li>对于复杂数据类型，其值存储于堆中，而栈中只存储堆中的地址。这样做的好处有：<ul>\n<li>节省内存空间：存储在堆中的对象可以通过栈内的引用被访问和操作，意味着对象可以在不同的上下文中被共享和引用，从而节省内存。</li>\n<li>垃圾回收：堆内存中的对象不再被引用时，垃圾回收机制就会自动进行回收，从而避免了内存泄漏和资源浪费。</li>\n<li>动态分配内存：堆内存允许对象动态的增长和缩小，因此可以根据需要灵活地修改对象的结构和内容，使得js对象可以轻松地扩展以适应不同的应用需求。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"深拷贝-1\"><a href=\"#深拷贝-1\" class=\"headerlink\" title=\"深拷贝\"></a><strong>深拷贝</strong></h2><p>而深拷贝和浅拷贝就是对于复杂数据类型object来说的，当拷贝了对象的一层（即堆的引用）时，就称之为浅拷贝，当拷贝了对象的两层（堆中创建新的对象）时，就称之为深拷贝。</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><ol>\n<li><p><code>JSON.parse(JSON.stringify(obj))</code>，第一种方法是使用JSON方法，但是这个方法有一些限制：JSON序列化时函数会被转为null，正则表达式会被转为空对象。</p>\n</li>\n<li><p>递归实现：</p>\n<pre><code class=\"js\">\n\n```javascript\nfunction deepCopy(obj, parent = null) &#123;\n    // 创建一个新对象\n    let result = &#123;&#125;;\n    let keys = Object.keys(obj),\n        key = null,\n        temp = null,\n        _parent = parent;\n    // 该字段有父级则需要追溯该字段的父级\n    while (_parent) &#123;\n        // 如果该字段引用了它的父级则为循环引用\n        if (_parent.originalParent === obj) &#123;\n            // 循环引用直接返回同级的新对象\n            return _parent.currentParent;\n        &#125;\n        _parent = _parent.parent;\n    &#125;\n    for (let i = 0; i &lt; keys.length; i++) &#123;\n        key = keys[i];\n        temp = obj[key];\n        // 如果字段的值也是一个对象\n        if (temp &amp;&amp; typeof temp === &#39;object&#39;) &#123;\n            // 递归执行深拷贝 将同级的待拷贝对象与新对象传递给 parent 方便追溯循环引用\n            result[key] = DeepCopy(temp, &#123;\n                originalParent: obj,\n                currentParent: result,\n                parent: parent\n            &#125;);\n\n        &#125; else &#123;\n            result[key] = temp;\n        &#125;\n    &#125;\n    return result;\n&#125;\n```\n</code></pre>\n</li>\n<li><p>MessageChannel实现深克隆：由于浏览器不能将一个函数正确的复制到另一个线程中，所以不能支持函数的深克隆。</p>\n<pre><code class=\"javascript\">function deepCopy(obj) &#123;\n  return new Promise((resolve) =&gt; &#123;\n    const &#123;port1, port2&#125; = new MessageChannel();\n    port2.onmessage = ev =&gt; resolve(ev.data);\n    port1.postMessage(obj);\n  &#125;);\n&#125;\n\ndeepCopy(obj).then((copy) =&gt; &#123;// 异步的\n    let copyObj = copy;\n    console.log(copyObj, obj)\n    console.log(copyObj == obj)\n&#125;);\n</code></pre>\n</li>\n<li><p>H5新增structuredClone<br>结构化克隆解决了该JSON.stringify()技术的许多（尽管不是全部）缺点。结构化克隆可以处理循环依赖，支持许多内置数据类型，并且更健壮且速度更快。<br>但是，它仍然有一些限制：</p>\n</li>\n</ol>\n<p>原型：如果你使用structuredClone()类实例，你将获得一个普通对象作为返回值，因为结构化克隆会丢弃对象的原型链。<br>函数：如果你的对象包含函数，它们将被悄悄丢弃。<br>不可克隆：有些值不是结构化可克隆的，尤其是Error、 DOM 节点 和 Function。尝试这样做将引发 DataCloneError 异常。<br>属性描述符：setter和getter(以及类似元数据的功能)不会被复制。例如，如果使用属性描述符将对象标记为只读，则复制后的对象中是可读写(默认配置)。<br>RegExp：RegExp对象的lastIndex字段不会保留。</p>\n<h1 id=\"浅拷贝实现方案\"><a href=\"#浅拷贝实现方案\" class=\"headerlink\" title=\"浅拷贝实现方案\"></a>浅拷贝实现方案</h1><ol>\n<li><code>Object.assign(&#123;&#125;,obj)</code>，第二方法是使用Object.assign()</li>\n<li><code>const obj1 = &#123;...obj2&#125;</code>，使用扩展运算符</li>\n</ol>\n",
            "tags": [
                "面试题",
                "深拷贝,面试题"
            ]
        },
        {
            "id": "https://dmqweb.cn/2024/04/29/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/",
            "url": "https://dmqweb.cn/2024/04/29/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/",
            "title": "前端监控",
            "date_published": "2024-04-29T00:36:51.000Z",
            "content_html": "<h1 id=\"前端监控\"><a href=\"#前端监控\" class=\"headerlink\" title=\"前端监控\"></a>前端监控</h1><h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><strong>为什么要进行前端监控：</strong></p>\n<ul>\n<li>页面的访问行为，PV、UV、IP、PV 点击率、UV 点击率、停留时长</li>\n<li>用户的操作行为，模块曝光、</li>\n<li>模块点击</li>\n<li>页面的性能，首屏渲染时间、API 请求时间</li>\n<li>异常的监控，JS Error、API 异常、业务异常</li>\n<li>业务的监控，成交金额、每日消息数</li>\n</ul>\n<p><strong>常见的应用场景：</strong></p>\n<ul>\n<li>流量分析</li>\n</ul>\n<p><strong>常见的前端监控平台：</strong></p>\n<ul>\n<li>百度统计</li>\n<li>阿里云 ARMS</li>\n<li>友盟</li>\n</ul>\n<p><strong>前端监控的数据有什么作用</strong></p>\n<ul>\n<li>流量数据监控，如：PV、UV、点击率、页面停留时长等</li>\n<li>自定义事件监控，如：曝光事件、滑动事件、请求事件等</li>\n<li>交易指标监控，如：成交额、转化率等</li>\n<li>其他综合分析，如：用户画像分析、流量漏斗、销量预测等</li>\n</ul>\n<p><strong>前端监控的三个阶段</strong></p>\n<ul>\n<li>初阶：使用第三方平台，百度、友盟、阿里云 ARMS 等</li>\n<li>中阶：自研前端监控库，缺乏完整的监控体系</li>\n<li>高阶：自研前端监控平台，具备完整的监控体系</li>\n</ul>\n<h1 id=\"百度统计接入\"><a href=\"#百度统计接入\" class=\"headerlink\" title=\"百度统计接入\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b25namkuYmFpZHUuY29tLw==\">百度统计接入</span></h1><p><strong>流量分析免费，行为分析需要付费。</strong></p>\n<ol>\n<li>官网创建网站，设置域名和首页</li>\n<li>保证域名公共可读</li>\n<li>复制统计代码，添加到要跟踪的网页中（加入到 head 标签之前）</li>\n</ol>\n<p><strong>阿里云 ARM 和友盟分析方案较全，接入方案大致相同，但是当数据量较大时，有一定的成本，所以考虑自建前端统计系统。</strong></p>\n<p><strong>什么时候需要考虑自建前端监控系统？</strong></p>\n<ol>\n<li>不仅仅需要流量分析，还需要做行为分析</li>\n<li>自建成本小于或等于平台付费</li>\n<li>希望网站监控数据能存到自己数据库中，并且数据隐私化。</li>\n</ol>\n<h1 id=\"监控平台架构\"><a href=\"#监控平台架构\" class=\"headerlink\" title=\"监控平台架构\"></a>监控平台架构</h1><p><strong>前端监控平台的分层：</strong></p>\n<ul>\n<li><p>前端监控 JSSDK</p>\n<ul>\n<li>采集</li>\n<li>上报<ul>\n<li>默认上报：页面 PV、性能等</li>\n<li>手动上报：页面操作行为</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端监控 API 和大数据仓库</p>\n<ul>\n<li>接收上报的数据</li>\n<li>数据仓库：MaxCompute<ul>\n<li>数据查询</li>\n<li>数据存储</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端监控数据可视化</p>\n<ul>\n<li>日志大数据清洗</li>\n<li>大数据回流 RDS（非结构化数据 &#x3D;&gt; 结构化数据）</li>\n</ul>\n</li>\n</ul>\n<p><strong>监控平台架构说明：</strong></p>\n<p><img data-src=\"/images/Snipaste_2024-04-29_08-11-46.jpg\" alt=\"监控平台架构\"></p>\n<h2 id=\"JS-库的开发\"><a href=\"#JS-库的开发\" class=\"headerlink\" title=\"JS 库的开发\"></a>JS 库的开发</h2><h4 id=\"JS-SDK\"><a href=\"#JS-SDK\" class=\"headerlink\" title=\"JS SDK\"></a>JS SDK</h4><p>monitor.js：</p>\n<pre><code class=\"javascript\">function collect() &#123;\n  console.log(&quot;collect&quot;);\n&#125;\nfunction upload() &#123;\n  console.log(&quot;upload&quot;);\n&#125;\nwindow.testMonitor = &#123;\n  collect,\n  upload,\n&#125;;\n</code></pre>\n<p>上传到服务器，在需要监控的页面引入脚本。</p>\n<p><strong>一、直接引入脚本：</strong></p>\n<p>直接使用 script 标签引入在线地址。</p>\n<p><strong>二、异步加载（确保脚本加载完成后再使用 api）：</strong></p>\n<pre><code class=\"html\">&lt;script&gt;\n  (function()\n      const script = document.createElement(&#39;script&#39;);\n      script.src = &#39;https://imooc.youbaobao.xyz/imooc-cli-monitor.js&#39;\n      const body = document.body;\n      body.insertBefore(script,body.firstChild);\n      script.onload = function()&#123;\n      var event = new CustomEvent(&#39;onMonitorScriptLoad&#39;);\n      window.dispatchEvent(event);\n  )()\n&lt;/script&gt;\n&lt;script&gt;\n      window.addEventListener(&#39;onMonitorScriptLoad&#39;,function()&#123;\n      window.testMonitor.collect();\n      window.testMonitor.upload();\n  &#125;):\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"PV-埋点\"><a href=\"#PV-埋点\" class=\"headerlink\" title=\"PV 埋点\"></a>PV 埋点</h4><p><strong>一、分包便于代码书写和维护</strong></p>\n<p>假设将项目分为：index.js、collect.js 和 upload.js 三个 js 文件，分别用于整合、收集和上报。</p>\n<p><strong>二、设置页面基本信息</strong></p>\n<p>在 meta 标签中设置变量，假设为：test-app-id，在 body 标签中设置 test-page-id，此变量用于区分不同的站点。</p>\n<p><strong>三、collect.js</strong></p>\n<pre><code class=\"javascript\">import &#123; upload &#125; from &quot;./upload&quot;;\n//自定义一些钩子函数\nlet beforeCreateParams;\nlet beforeUpload;\nlet afterUpload;\nlet onError = (err) =&gt; &#123;\n  console.error(err);\n&#125;;\n\nexport function collect() &#123;\n  console.log(&quot;收集开始...&quot;);\n&#125;\n// 采集信息\nfunction collection(customData, eventType) &#123;\n  let appId, pageId, timeStamp, ua;\n  beforeCreateParams &amp;&amp; beforeCreateParams();\n  const metaList = document.getElementsByTagName(&quot;meta&quot;);\n  for (let i = 0; i &lt; metaList.length; i++) &#123;\n    const meta = metaList[i];\n    console.log(meta.getAttribute(&quot;test-app-id&quot;));\n    if (meta.getAttribute(&quot;test-app-id&quot;)) &#123;\n      appId = meta.getAttribute(&quot;test-app-id&quot;);\n    &#125;\n  &#125;\n  const body = document.body;\n  pageId = body.getAttribute(&quot;test-page-id&quot;);\n  if (!appId || !pageId) return;\n  timeStamp = new Date().getTime();\n  ua = window.navigator.userAgent;\n  console.log(appId, pageId, timeStamp, ua);\n  let data = `appId=$&#123;appId&#125;&amp;pageId=$&#123;pageId&#125;&amp;timeStamp=$&#123;timeStamp&#125;&amp;ua=$&#123;ua&#125;`;\n  if (beforeUpload) &#123;\n    data = beforeUpload(data); //允许定制数据\n  &#125;\n  //日志上报\n  // upload(&#123; appId,pageId,timeStamp,ua &#125;)  不常用\n  let url, uploadData;\n  try &#123;\n    data = &#123; ...customData, ...data &#125;;\n    const ret = upload(data, &#123; eventType &#125;);\n    url = ret.url;\n    uploadData = ret.data;\n  &#125; catch (e) &#123;\n    onError(e);\n  &#125; finally &#123;\n    afterUpload &amp;&amp; afterUpload(url, uploadData);\n  &#125;\n&#125;\n//发送PV日志\nexport function sendPV() &#123;\n  collection(&#123;&#125;, &quot;PV&quot;);\n&#125;\n// 上报曝光埋点\nexport function sendExp(data = &#123;&#125;) &#123;\n  collection(data, &quot;EXP&quot;);\n&#125;\n//注册钩子函数\nexport function registerBeforeCreateParams(fn) &#123;\n  beforeCreateParams = fn;\n&#125;\nexport function registerBeforeUpload(fn) &#123;\n  beforeUpload = fn;\n&#125;\nexport function registerAfterUpload(fn) &#123;\n  afterUpload = fn;\n&#125;\nexport function registerOnError(fn) &#123;\n  onError = fn;\n&#125;\nexport default &#123;&#125;;\n</code></pre>\n<p><strong>四、upload.js</strong></p>\n<pre><code class=\"javascript\">export function upload(data) &#123;\n  const img = new Image(); //利用image标签跨域特性\n  const &#123; eventType = &quot;PV&quot; &#125; = options;\n  const params = encodeURIComponent(data) + &quot;&amp;eventType=&quot; + eventType;\n  const src = &quot;http://dmqtest.com?data=&quot; + params;\n  console.log(params, src, eventType);\n  img.src = src;\n  img = null; //注意内存释放\n  return &#123;\n    url: src,\n    data: &#123;\n      params,\n    &#125;,\n  &#125;;\n&#125;\nexport default upload;\n</code></pre>\n<p><strong>五、index.js</strong></p>\n<pre><code>import &#123; sendPV , registerBeforeCreateParams,registerBeforeUpload,registerAfterUpload &#125; from &#39;./collect&#39;;\nimport &#123; upload &#125; from &#39;./upload&#39;;\nwindow.testMonitor = &#123;\n    upload,\n    sendPV,\n    registerBeforeCreateParams,\n    registerBeforeUpload,\n    registerAfterUpload,\n    registerOnError\n&#125;\n</code></pre>\n<p><strong>六、index.html</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; test-app-id=&quot;app123456&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;script src=&quot;https://dmqtest.com/index.js&quot;&gt;&lt;/script&gt;\n  &lt;body test-page-id=&quot;page123456&quot;&gt;\n    &lt;script&gt;\n      window.onload = function () &#123;\n        window.testMonitor.registerBeforeCreateParams(() =&gt; &#123;\n          console.log(&quot;创建之前&quot;);\n        &#125;);\n        window.testMonitor.registerBrforeUpload((params) =&gt; &#123;\n          return params + &quot;&amp;custom=1&quot;; //添加自定义数据\n        &#125;);\n        window.testMonitor.registerAfterUpload((url, data) =&gt; &#123;&#125;);\n        window.testMonitor.sendPV();\n      &#125;;\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"曝光埋点\"><a href=\"#曝光埋点\" class=\"headerlink\" title=\"曝光埋点\"></a>曝光埋点</h4><p>曝光埋点记录元素由不可变到可变的过程，需要浏览器 IntersectionObserver 这个 API 的支持。</p>\n<p><strong>浏览器 5 种 Observer：</strong></p>\n<ul>\n<li>MutationObserver（用于监听 DOM 树的变化，一般为属性、子节点的增删改）</li>\n<li>IntersectionObserver（用于监听一个元素和可视区域相交部分的比列，然后在可视比列到达某一阈值的时候触发回调）</li>\n<li>PerformanceObserver（用于检测性能度量事件，在浏览器的性能事件轴记录下一个新的 performance entries 的时候将会被通知）</li>\n<li>ResizeObserver（用于监听 DOM 的变化，一般为节点的出现和隐藏，节点大小的变化）</li>\n<li>ReportingObserver（用于监听过时的 api、浏览器的一些干预行为的预告）</li>\n</ul>\n<p><strong>IntersectionObserver：</strong></p>\n<p><strong>方法：</strong></p>\n<ul>\n<li><p>observe：开始监听一个目标元素</p>\n<p>语法：IntersectionObserver.disconnect();</p>\n</li>\n<li><p>disconnect：停止监听</p>\n<p>语法：IntersectionObserver.observe(targetElement);</p>\n</li>\n<li><p>takeRecords:返回所有观察目标的 IntersectionObserverEntry 对象数组。</p>\n<p>语法：intersectionObserverEntries &#x3D; intersectionObserver.takeRecords();</p>\n</li>\n<li><p>unobserve:使 IntersectionObserver 停止监听特定目标元素</p>\n<p>语法：IntersectionObserver.unobserve(targetElement);</p>\n</li>\n</ul>\n<p><strong>配置项：</strong></p>\n<ul>\n<li>targetElement：目标 DOM</li>\n<li>root：指定根目录，也就就是当目标元素显示在这个元素中时会触发监控回调</li>\n<li>rootMargin：类似于 css 的 margin，设定 root 元素的边框区域。</li>\n<li>threhold：阈值，决定了什么时候触发回调函数。</li>\n</ul>\n<p><strong>返回参数：</strong></p>\n<ul>\n<li>tIme:可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li>\n<li>rootBounds:是在根元素矩形区域的信息</li>\n<li>intersectionRatio:目标元素的可见比例</li>\n<li>intersectionRect:目标元素与根元素交叉区域的信息</li>\n<li>isIntersecting:判断元素是否符合 options 中的可见条件</li>\n<li>boundingClientRect:目标元素的矩形区域的信息</li>\n<li>target:被观察的目标元素</li>\n</ul>\n<p><strong>upload.js 文件中添加：</strong></p>\n<pre><code class=\"javascript\">// ....省略\n// 上报曝光埋点\nexport function sendExp(data = &#123;&#125;) &#123;\n  collection(data, &quot;EXP&quot;);\n&#125;\n// 最后在index.js中暴露出去。\n</code></pre>\n<p><strong>collect.js 文件中添加：</strong></p>\n<pre><code class=\"javascript\">//....省略\nexport function collectAppear() &#123;\n  const appearEvent = new CustomEvent(&quot;onAppear&quot;);\n  const disappearEvent = new CustomEvent(&quot;onDisappear&quot;);\n  let ob;\n  if (window.testMonitorObserver) &#123;\n    ob = window.testMonitorObserver;\n  &#125; else &#123;\n    ob = new IntersectionObserver(function (e) &#123;\n      e.forEach((item) =&gt; &#123;\n        if (item.intersectionRatio &gt; 0) &#123;\n          console.log(item.target.className + &quot;appear&quot;);\n          item.target.dispatchEvent(appearEvent);\n        &#125; else &#123;\n          console.log(item.target.className + &quot;disappear&quot;);\n          item.target.dispatchEvent(disappearEvent);\n        &#125;\n      &#125;);\n    &#125;);\n  &#125;\n  let obList = [];\n  const appear = document.querySelectorAll(&quot;[appear]&quot;);\n  for (let i = 0; i &lt; appear.length; i++) &#123;\n    if (obList.includes(appear[i])) &#123;\n      ob.observe(appear[i]);\n      obList.push(appear[i]);\n    &#125;\n  &#125;\n  window.testMonitorObserver = ob; //存起来防止重复\n  window.monitorObserverList = obList;\n&#125;\n</code></pre>\n<p><strong>index.js 中使用：</strong></p>\n<pre><code class=\"javascript\">//...省略\n// import引入collectAppear函数。\nwindow.onload = function () &#123;\n  collectAppear();\n&#125;;\n</code></pre>\n<h4 id=\"点击埋点\"><a href=\"#点击埋点\" class=\"headerlink\" title=\"点击埋点\"></a><strong>点击埋点</strong></h4><p><strong>collect.js 中添加：</strong></p>\n<pre><code class=\"javascript\">//...省略\n//上报点击埋点\nexport function sendClick(data = &#123;&#125;) &#123;\n  collection(data, &quot;CLICK&quot;);\n&#125;\n//暴露出去，index.js导入该方法并暴露出去。\n</code></pre>\n<h4 id=\"自定义埋点\"><a href=\"#自定义埋点\" class=\"headerlink\" title=\"自定义埋点\"></a>自定义埋点</h4><p><strong>collect.js 中添加：</strong></p>\n<p>自定义埋点行为就直接在内部添加 CUSTOM 对应的处理逻辑，可以使用其他的 Observer 实现更多功能。</p>\n<pre><code class=\"javascript\">//...省略\n//上报自定义埋点\nexport function sendCustom(data = &#123;&#125;) &#123;\n  collection(data, &quot;CUSTOM&quot;);\n&#125;\n//暴露出去，index.js导入该方法并暴露出去。\n</code></pre>\n<h2 id=\"大数据平台开发\"><a href=\"#大数据平台开发\" class=\"headerlink\" title=\"大数据平台开发\"></a>大数据平台开发</h2><p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vemgvbWF4Y29tcHV0ZS8jOn46dGV4dD0lRTQlQkElOTElRTUlOEUlOUYlRTclOTQlOUYlRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUUlRTglQUUlQTElRTclQUUlOTclRTYlOUMlOEQlRTUlOEElQTEsJTI4TWF4Q29tcHV0ZSUyOSVFNiU5OCVBRiVFNCVCOCU4MCVFNyVBNyU4RCVFNSVCRiVBQiVFOSU4MCU5RiVFMyU4MCU4MSVFNSVBRSU4QyVFNSU4NSVBOCVFNiU4OSU5OCVFNyVBRSVBMSVFNyU5QSU4NFRCJTJGUEIlRTclQkElQTclRTYlOTUlQjAlRTYlOEQlQUUlRTQlQkIlOTMlRTUlQkElOTMlRTglQTclQTMlRTUlODYlQjMlRTYlOTYlQjklRTYlQTElODglRTMlODAlODIlMjBNYXhDb21wdXRlJUU1JTkwJTkxJUU3JTk0JUE4JUU2JTg4JUI3JUU2JThGJTkwJUU0JUJFJTlCJUU0JUJBJTg2JUU1JUFFJThDJUU1JTk2JTg0JUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU1JUFGJUJDJUU1JTg1JUE1JUU2JTk2JUI5JUU2JUExJTg4JUU0JUJCJUE1JUU1JThGJThBJUU1JUE0JTlBJUU3JUE3JThEJUU3JUJCJThGJUU1JTg1JUI4JUU3JTlBJTg0JUU1JTg4JTg2JUU1JUI4JTgzJUU1JUJDJThGJUU4JUFFJUExJUU3JUFFJTk3JUU2JUE4JUExJUU1JTlFJThCJUVGJUJDJThDJUU4JTgzJUJEJUU1JUE0JTlGJUU2JTlCJUI0JUU1JUJGJUFCJUU5JTgwJTlGJUU3JTlBJTg0JUU4JUE3JUEzJUU1JTg2JUIzJUU3JTk0JUE4JUU2JTg4JUI3JUU2JUI1JUI3JUU5JTg3JThGJUU2JTk1JUIwJUU2JThEJUFFJUU4JUFFJUExJUU3JUFFJTk3JUU5JTk3JUFFJUU5JUEyJTk4JUVGJUJDJThDJUU2JTlDJTg5JUU2JTk1JTg4JUU5JTk5JThEJUU0JUJEJThFJUU0JUJDJTgxJUU0JUI4JTlBJUU2JTg4JTkwJUU2JTlDJUFDJUVGJUJDJThDJUU1JUI5JUI2JUU0JUJGJTlEJUU5JTlBJTlDJUU2JTk1JUIwJUU2JThEJUFFJUU1JUFFJTg5JUU1JTg1JUE4JUUzJTgwJTgy\">MaxCompute 阿里云原生大数据计算服务</span>：</strong></p>\n<p>MaxCompute 是基于数据分析场景的企业级 SaaS 模式云数据仓库，以 Serverless 架构提供快速、全托管的在线数据仓库服务，消除了传统数据平台在资源扩展性和弹性方面的限制，最小化用户运维投入。</p>\n<p><strong>使用：</strong></p>\n<ol>\n<li><p>使用 MaxCompute 创建数据库，在数据开发页面创建表进行记录前端监控数据</p>\n</li>\n<li><p>使用 py 脚本对接（暂时没有 js 包），需要安装 python 和 pip（包管理工具）</p>\n</li>\n<li><p>安装 pyodps：<code>pip install pyodps</code></p>\n</li>\n<li><p>connect.py 文件中写入示例：</p>\n<pre><code class=\"python\">from odps import ODPS;\n\nodps = ODPS(&#39;LTAI5tBDj3HajwRVhc6me5KR&#39;,&#39;DJqWAI1IWUBZnZGE#FKDSFJDEJLet&#39;,&#39;test_monitor&#39;,endpoint=&#39;https://service-cn-hangzhou.odps.aliyun-inc.com&#39;)\n\nresult = odps.executexecute_sql(&#39;select * from test_monitor where datetime=&quot;20240325&quot;&#39;)\n\nwith result.open_reader() as reader:\n    for record in reader:\n        print(record[0],record[1])\n# 打印表名\nfor table in odps.list_tables():\n    print(table)\ndata = [\n    [&#39;appid123&#39;,&#39;pageid123&#39;,&#39;123456&#39;,&#39;ua123&#39;,&#39;http://www.baidu.com&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;202403&#39;]\n]\n# 写入数据\nodps.write_table(&#39;test_table&#39;, data)\n# ....等等后续操作\n</code></pre>\n</li>\n</ol>\n<p><strong>前端监控平台可视化架构图：</strong></p>\n<p><img data-src=\"/images/Snipaste_2024-04-30_15-14-09.jpg\" alt=\"前端监控流程架构\"></p>\n",
            "tags": [
                "前端监控",
                "前端监控"
            ]
        }
    ]
}