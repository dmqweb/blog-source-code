



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="杜明清的个人博客" href="https://dmqweb.cn/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="杜明清的个人博客" href="https://dmqweb.cn/atom.xml" />
<link rel="alternate" type="application/json" title="杜明清的个人博客" href="https://dmqweb.cn/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="算法,数据结构" />


<link rel="canonical" href="https://dmqweb.cn/2023/12/02/%E7%AE%97%E6%B3%95/">



  <title>
算法与数据结构 - 算法 |
Web blog = 杜明清的个人博客 = 👻欢迎一起交流学习👻</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">算法与数据结构
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-12-02 12:24:04">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-12-02T12:24:04+08:00">2023-12-02</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Web blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/07/a69a9d571bee6f0b.jpg"></li>
          <li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/15/807885ba1421e9b4.jpg"></li>
          <li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/04/eff89867286d822f.webp"></li>
          <li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/06/a16303594a53d8d1.jpg"></li>
          <li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/04/3149a0cc49823a9c.jpg"></li>
          <li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/06/a2c97e7bd0c6ecd6.webp"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="item" rel="index" title="分类于 算法"><span itemprop="name">算法</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://dmqweb.cn/2023/12/02/%E7%AE%97%E6%B3%95/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="dmq">
    <meta itemprop="description" content="👻欢迎一起交流学习👻, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="杜明清的个人博客">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="数据结构视频："><a href="#数据结构视频：" class="headerlink" title="数据结构视频："></a>数据结构视频：</h1><h1 id="栈：后进先出"><a href="#栈：后进先出" class="headerlink" title="栈：后进先出"></a>栈：后进先出</h1><p>（JS中可以使用array模拟栈）</p>
<p>【1】十进制转二进制【2】编辑器检查括号是否有效【3】JS函数调用堆栈（相互调用的函数，最后一个函数先执行完） 、等等</p>
<p>【练习：20有效的括号】（栈）</p>
<pre><code class="typescript">function isValid(s: string): boolean &#123;
    if(s.length % 2 === 1) return false
    const arr:Array&lt;string&gt;=[]
    for(let i =0 ;i&lt;s.length;i++)&#123;
        if(s[i]===&#39;(&#39; || s[i]===&#39;&#123;&#39; || s[i]===&#39;[&#39;)&#123; 
            arr.push(s[i])
        &#125;else&#123; 
           if((arr[arr.length-1]===&#39;(&#39; &amp;&amp; s[i]===&#39;)&#39;) || (arr[arr.length-1]===&#39;[&#39; &amp;&amp; s[i]===&#39;]&#39;) || (arr[arr.length-1]===&#39;&#123;&#39; &amp;&amp; s[i]===&#39;&#125;&#39;)) &#123;
            arr.pop()
           &#125;else&#123;
            return false
           &#125;
        &#125;
    &#125;
    return arr.length===0
&#125;;
</code></pre>
<h1 id="队列：先进先出"><a href="#队列：先进先出" class="headerlink" title="队列：先进先出"></a>队列：先进先出</h1><p>（JS中可以使用array模拟队列）</p>
<p>【1】排队打饭【2】JS异步中的任务队列（JS是单线程的）【3】计算最近请求次数</p>
<p>【练习：请求最近的请求次数】（队列）</p>
<pre><code class="typescript">class RecentCounter &#123;
    stack:number[]=[]
    ping(t: number): number &#123;
        this.stack.push(t)
        while(t - this.stack[0] &gt; 3000)&#123;
            this.stack.shift()
        &#125;
        return this.stack.length
    &#125;
&#125;
</code></pre>
<h1 id="链表：非连续存储"><a href="#链表：非连续存储" class="headerlink" title="链表：非连续存储"></a>链表：非连续存储</h1><p>【1】JS中的原型链（<strong>构造函数实例的__ proto __等于构造函数的prototype</strong> , 是一个链表）</p>
<p>一、<strong>实例的原型(_ _ proto _ _)就是其构造函数的原型对象(prototype)</strong></p>
<p>二、<strong>如果A沿着原型链能找到B的prototype,那么A instanceof B 为true</strong></p>
<p>三、<strong>如果在A对象上没有找到x属性，那么会沿着原型链找x属性</strong></p>
<p>【面试题】</p>
<p>一、instanceof的原理，并使用代码实现</p>
<pre><code class="js">const instanceof1 = (A,B) =&gt; &#123;
    let p = A
    while(p)&#123;
        if(p === B.prototype)&#123;
            return true
        &#125;
        p=p.__proto__
    &#125;
    return false
&#125;
</code></pre>
<p>二、代码演示对象属性会沿着原型链进行查找</p>
<pre><code class="js">let foo = &#123;&#125;,F = function()&#123;&#125;;
Object.prototype.a = &#39;value a&#39;;
Function.prototype.b = &#39;value b&#39;;
console.log(foo); //&#123;&#125;
console.log(foo.a); //value a
console.log(foo.b); //undefined
console.log(F.a); //value a
console.log(F.b); //value b
</code></pre>
<p>【原型链图解】</p>
<pre><code class="js">obj.__proto__------Object.prototype-------null
func.__proto__--------Function.prototype-------Object.prototype----------null
（其中：func.__proto__.__proto__ === Object.prototype   ； func也是Object的实例（instanceof））
arr.__proto__ -------------Array.prototype---------Object.prototype---------null
</code></pre>
<p><img data-src="/images/%E9%93%BE%E8%A1%A8.png" alt="/images/image-20240123164938769"> </p>
<p>【练习】（JS中可以使用对象object模拟链表 ，值得注意的是：<strong>链表由于只给一个头节点，所以不知道链表的长度（一般使用while循环遍历）</strong>）</p>
<p>【练习：237删除链表中的节点】</p>
<pre><code class="typescript"> function deleteNode(node: ListNode | null): void &#123;
    //将下一个节点的值赋值给当前节点值（相当于移动）
    node.val=node.next.val;
    //跳过下一个节点（跳过的是下一个节点，效果是删除了当前节点）
    node.next=node.next.next;
 &#125;;
</code></pre>
<p>【练习：206反转链表】（双指针）</p>
<pre><code class="typescript">//双指针法
function reverseList(head: ListNode | null): ListNode | null       &#123;
        let p1:ListNode | null=head
        let p2:ListNode | null=null
        let tmp;
        while(p1)&#123;
         tmp = p1.next
         p1.next=p2
         p2 = p1
         p1 = tmp
        &#125;
        return p2
      &#125;;
</code></pre>
<pre><code class="typescript">//标志变量法
    let pre
     var reverseList= function(head)&#123;
        // 遍历节点,进行迭代
        if(head===null) &#123;
            const a=pre
            pre =undefined
            return a || head
        &#125;
        const tem = head.next
        head.next = pre || null
        pre = head
        return reverseList(tem)
     &#125;
</code></pre>
<p>【练习：2两数相加】</p>
<pre><code class="js">var addTwoNumbers = function(l1, l2) &#123;
    let l3 = new ListNode(0)
    let p3 = l3;
    let carry = 0;
    while(l1 || l2)&#123;
    const v1 = l1?l1.val:0;
    const v2 = l2?l2.val:0;
    const sum = v1 + v2 + carry;
    carry = Math.floor(sum / 10)  
    p3.next = new ListNode(sum % 10)
    if(l1) l1=l1.next;
    if(l2) l2=l2.next;
        p3 = p3.next;
    &#125;
    if(carry)&#123;
        p3.next=new ListNode(carry)
    &#125;
    return l3.next;
&#125;;
</code></pre>
<p>【练习：83删除排序链表中的重复元素】</p>
<pre><code class="js">var deleteDuplicates = function(head) &#123;
    let firstNode = head;
    while(head &amp;&amp; head.next)&#123;
        if(head.val == head.next.val)&#123;
            head.next = head.next.next
        &#125;else&#123;
            head = head.next
        &#125;
    &#125;
    return firstNode
&#125;;
</code></pre>
<p>【练习：141环形链表】（快慢指针）</p>
<p>注意链表由于只给一个头节点，所以不知道链表的长度，此时不能直接拿到最后一个节点，一直在遍历过程中时无法确定是由于链表太长尚未遍历完还是由于是环形链表。</p>
<pre><code class="js">//快慢指针
var hasCycle = function(head) &#123;
    let p1 = head
    let p2 = head 
    while(p1 &amp;&amp; p2 &amp;&amp; p2.next)&#123;
        p1=p1.next
        p2 = p2.next.next
        if(p1===p2)&#123;
            return true
        &#125;
    &#125;
    return false
&#125;;
</code></pre>
<h1 id="集合：无序且唯一"><a href="#集合：无序且唯一" class="headerlink" title="集合：无序且唯一"></a>集合：无序且唯一</h1><p>JS中有set集合，内部有has、add、delete、clear、entries、forEach、kyes、values、intersection（求交集）、difference（求非交集）、union（联合）等方法，可以用于数组去重等。</p>
<p>【练习：349两个数组的交集】</p>
<pre><code class="js">var intersection = function(nums1, nums2) &#123;
    return [...new Set(nums1)].filter(item=&gt;nums2.includes(item))
&#125;;
</code></pre>
<p>【前端中的set集合】</p>
<p>set集合使用for of遍历（因为set集合中不包含属性），  使用Array.from方法可以将set集合转为array数组，使用new Set([])可以将数组转为set集合。</p>
<h1 id="字典：键值对映射（键不重复）"><a href="#字典：键值对映射（键不重复）" class="headerlink" title="字典：键值对映射（键不重复）"></a>字典：键值对映射（键不重复）</h1><p>JS中有map集合，内部有set、delete和clear等方法。</p>
<p>【优化：349两个数组的交集】</p>
<p>此方法利用了map集合的特点（键不重复，还有数据量很小的情况下：map.get方法的性能相比于arr.includes方法的性能更好）,此方法性能更好，时间复杂度为O(n)或O(m)</p>
<pre><code class="js">var intersection = function(nums1, nums2) &#123;
    const res = []
    const map = new Map()
    nums1.forEach(item=&gt;&#123;
        map.set(item,true);
    &#125;)
    nums2.forEach(item=&gt;&#123;
        if(map.get(item))&#123;
            res.push(item);
            map.delete(item);
        &#125;
    &#125;)
    return res
&#125;;
</code></pre>
<p>【优化：20有效的括号】</p>
<pre><code class="js">var isValid = function(s) &#123;
    if(s.length % 2 ===1) return false
    const map=new Map()
    map.set(&#39;(&#39;,&#39;)&#39;)
    map.set(&#39;&#123;&#39;,&#39;&#125;&#39;)
    map.set(&#39;[&#39;,&#39;]&#39;)
    const stack=[];
    for(let i=0;i&lt;s.length;i++)&#123;
        const c = s[i];
       if(map.has(c))&#123;
           stack.push(c)
       &#125; else&#123;
           const t = stack[stack.length-1];
           if(map.get(t)===c)&#123;
               stack.pop();
           &#125;else&#123;
               return false;
           &#125;
       &#125;
    &#125;
    return !stack.length
&#125;;
</code></pre>
<p>【练习：1两数之和】</p>
<pre><code class="js">var twoSum =function (nums,target)&#123;
    const map =new Map();
    for (let i =0;i&lt;nums.length;i+=1)&#123;
        const n= nums[i];
        const n2 =target -n;
    if (map.has(n2))&#123;
        return [map.get(n2),i];
    &#125;
    else&#123;
        map.set(n,i);
    &#125;
&#125;
&#125;
</code></pre>
<p>【练习：3无重复字符的最长子串】</p>
<pre><code class="js">var lengthOfLongestSubstring = function(s) &#123;
    let l = 0;
    let num = 0;
    let map =new Map()
    for(let r=0;r&lt;s.length;r++)&#123;
        if(map.has(s[r]) &amp;&amp; map.get(s[r])&gt;=l)&#123;
            l=map.get(s[r]) + 1;
        &#125;
        map.set(s[r],r)
        num=Math.max(num,r-l+1);
    &#125;
    return num
&#125;;
</code></pre>
<p>【练习：76最小覆盖子串】</p>
<pre><code class="js">var minWindow = function(s, t) &#123;
    let l=0,r=0,need=new Map();
    for(let item of t)&#123;
        need.set(item,need.has(item)?need.get(item)+1:1);
    &#125;
    let needType = need.size;//定义需要类型
    let res = &#39;&#39;;//定义结果字符串
    while(r&lt;s.length)&#123;
        const c = s[r] //定义又字符
        if(need.has(c))&#123;
            need.set(c,need.get(c) - 1);
            if(need.get(c)===0) needType -= 1; //如果说当前的数值为0，标识减一
        &#125;
        //遍历左边指针，如果needType为0,说明当前包含全部字符，遍历取最小长度
        while(needType===0)&#123;
            const newRes = s.substring(l,r+1)
            if(!res || newRes.length&lt;res.length) res = newRes
            const c2 = s[l]
            if(need.has(c2))&#123;
                need.set(c2,need.get(c2)+1);
                if(need.get(c2)===1) needType+=1;
            &#125;
            l+=1;
        &#125;
        r+=1;
    &#125;
    return res
&#125;
</code></pre>
<h1 id="哈希表-散列的数组"><a href="#哈希表-散列的数组" class="headerlink" title="哈希表:散列的数组"></a>哈希表:散列的数组</h1><p>哈希表通常基于数组实现，对下标值进行变换（哈希函数），基本可以瞬间查找到想要的元素，但是哈希表中的数据是没有顺序的，所以不能以一种固定的方式来遍历元素。</p>
<p>【例子：员工信息，用数组存储增删数据较慢，用链表存储查找较慢。】</p>
<p>1、哈希化：将大数字转化为数组范围内的下标的过程。</p>
<p>2、哈希函数：通常会将单词转化为大数字，将大数字进行哈希化的函数就是哈希函数，哈希算法得到的也可能会有相同的值（冲突），对此有很多解决方案。</p>
<p>3、哈希表：对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。</p>
<pre><code class="js">    //封装哈希表类
    function HashTable() &#123;
      //属性
      this.storage = []
      this.count = 0//计算已经存储的元素个数
      //装填因子：loadFactor &gt; 0.75时需要扩容；loadFactor &lt; 0.25时需要减少容量
      this.limit = 7//初始长度

      //方法
      //哈希函数
      HashTable.prototype.hashFunc = function(str, size)&#123;
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&gt; Unicode编码
      for(let i = 0 ;i &lt; str.length; i++)&#123;
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      &#125;

      //3.取余操作
      let index = hashCode % size
      return index
    &#125;

    //一.插入&amp;修改操作
    HashTable.prototype.put = function (key, value)&#123;
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index取出对应的bucket
      let bucket = this.storage[index]

      //3.判断该bucket是否为null
      if (bucket == null) &#123;
        bucket = []
        this.storage[index] = bucket
      &#125;

      //4.判断是否是修改数据
      for (let i = 0; i &lt; bucket.length; i++) &#123;
        let tuple = bucket[i];
        if (tuple[0] == key) &#123;
          tuple[1] = value
          return//不用返回值
        &#125;
      &#125;

      //5.进行添加操作
      bucket.push([key, value])
      this.count += 1

      //6.判断是否需要扩容操作
      if(this.count &gt; this.limit * 0.75)&#123;
        let newSize = this.limit * 2
        let newPrime = this.getPrime(newSize)
        this.resize(newPrime)
      &#125;
    &#125;

    //二.获取操作
    HashTable.prototype.get = function(key)&#123;
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否等于null
      if (bucket == null) &#123;
        return null
      &#125;

      //4.有bucket，那么就进行线性查找
      for (let i = 0; i &lt; bucket.length; i++) &#123;
        let tuple = bucket[i];
        if (tuple[0] == key) &#123;//tuple[0]存储key，tuple[1]存储value
          return tuple[1]
        &#125;
      &#125;

      //5.依然没有找到，那么返回null
      return null
    &#125;

    //三.删除操作
    HashTable.prototype.remove = function(key)&#123;
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否为null
      if (bucket == null) &#123;
        return null
      &#125;

      //4.有bucket,那么就进行线性查找并删除
      for (let i = 0; i &lt; bucket.length; i++) &#123;
        let tuple = bucket[i]
        if (tuple[0] == key) &#123;
          bucket.splice(i,1)
          this.count -= 1 
          return tuple[1]

          //6.缩小容量
          if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;
            let newSize = Math.floor(this.limit / 2)
            let newPrime = this.getPrime(newSize)
            this.resize(newPrime)
          &#125;
        &#125;
    &#125;

      //5.依然没有找到，返回null
      return null
    &#125;

  /*------------------其他方法--------------------*/
  //判断哈希表是否为null
  HashTable.prototype.isEmpty = function()&#123;
    return this.count == 0
  &#125;

  //获取哈希表中元素的个数
  HashTable.prototype.size = function()&#123;
    return this.count
  &#125;


  //哈希表扩容
  HashTable.prototype.resize = function(newLimit)&#123;
    //1.保存旧的storage数组内容
    let oldStorage = this.storage

    //2.重置所有的属性
    this.storage = []
    this.count = 0
    this.limit = newLimit

    //3.遍历oldStorage中所有的bucket
    for (let i = 0; i &lt; oldStorage.length; i++) &#123;
      //3.1.取出对应的bucket
      const bucket = oldStorage[i];

      //3.2.判断bucket是否为null
      if (bucket == null) &#123;
        continue
      &#125;      

      //3.3.bucket中有数据，就取出数据重新插入
      for (let j = 0; j &lt; bucket.length; j++) &#123;
        const tuple = bucket[j];
        this.put(tuple[0], tuple[1])//插入数据的key和value
      &#125;
    &#125;
  &#125;

  //判断传入的num是否质数
  HashTable.prototype.isPrime = function(num)&#123;
      if (num &lt;= 1) &#123;
        return false
      &#125;
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&lt;= Math.sqrt(num); i++ )&#123;
        if(num % i == 0)&#123;
          return false;
        &#125;
      &#125;
        return true;
    &#125;

    //获取质数的方法
    HashTable.prototype.getPrime = function(num)&#123;
       //7*2=14,+1=15,+1=16,+1=17(质数)
      while (!this.isPrime(num)) &#123;
        num++
      &#125;
      return num
    &#125;
 &#125;
</code></pre>
<h1 id="哈希算法-任意长度输入转为固定长度输出"><a href="#哈希算法-任意长度输入转为固定长度输出" class="headerlink" title="哈希算法:任意长度输入转为固定长度输出"></a>哈希算法:任意长度输入转为固定长度输出</h1><p>hash（散列），是将任意长度输入通过散列算法转变成固定长度的输出，该输出就是散列值。这种转换是一种<strong>压缩映射</strong>，映射表达的是一种一一对应的关系。散列值的空间通常空间会小于输出的空间。</p>
<p>哈希算法：</p>
<p>1、不可逆：哈希算法不能从结果去推算出输入</p>
<p>2、计算快</p>
<p>【例子：md5加密、webpack热更新检测文件是否变化】</p>
<h1 id="树：分层抽象数据模型"><a href="#树：分层抽象数据模型" class="headerlink" title="树：分层抽象数据模型"></a>树：分层抽象数据模型</h1><p>【前端】DOM树、级联选择、树形控件。</p>
<p>JS中没有树，但是可以使用Object和Array来模拟构建树。</p>
<p>【树的常用操作】：深度&#x2F;广度优先遍历、先序（后序遍历）</p>
<p>【树】</p>
<pre><code class="js">const tree = &#123;
    val:&#39;a&#39;,
    children:[
        &#123;
            val:&#39;b&#39;,
            children:[
                &#123;
                    val:&#39;c&#39;,
                    children:[]
                &#125;
            ]
        &#125;,
        &#123;
            val:&#39;d&#39;,
            children:[
                &#123;
                    val:&#39;e&#39;,
                    children:[]
                &#125;,&#123;
                    val:&#39;f&#39;,
                    children:[]
                &#125;
            ]
        &#125;

    ]
&#125;
</code></pre>
<p>【1】深度优先遍历：</p>
<p>尽可能深的搜索树的分支。（相当于一本书，一页一页翻着看）</p>
<pre><code class="js">// 深度优先遍历
const dfs = function(root)&#123;
    console.log(root.val,&#39;还好&#39;);
    root.children.forEach(dfs);//forEach回调不传参数，默认穿的参数就是item项
&#125;
</code></pre>
<p>【2】广度优先遍历：</p>
<p>先访问离根节点最近的节点。（相当于一本书，先看章节再看对应页）</p>
<pre><code class="js">//广度优先遍历
const bfs = (root)=&gt;&#123;
    const q = [root];
    while(q.length&gt;0)&#123;
        const n = q.shift();
        n.children.forEach(item=&gt;&#123;
            q.push(item);
        &#125;)
    &#125;
&#125;
</code></pre>
<h2 id="【二叉树】"><a href="#【二叉树】" class="headerlink" title="【二叉树】"></a>【二叉树】</h2><p>JS中使用Object来模拟二叉树</p>
<p>【二叉树】</p>
<pre><code class="js">const bt = &#123;
    val:1,
    left:&#123;
        val:2,
        left:&#123;&#125;,
        right:&#123;&#125;
    &#125;,
    right:&#123;
        val:3,
        left:&#123;
            val:4,
            left:&#123;&#125;,
            right:&#123;&#125;
        &#125;,
        right:&#123;
            val:5,
            left:&#123;&#125;,
            right:&#123;&#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>【1】递归版二叉树的先中后序遍历</p>
<p>（1）先序遍历：（中、左、右  向下递归）</p>
<pre><code class="js">//先序遍历
const preOrder = (root)=&gt;&#123;
    if(!root) return;
    console.log(root.val);
    preOrder(root.left);
    preOrder(root.right);
&#125;
</code></pre>
<p>（2）中序遍历：（左、中、右  向下递归）</p>
<pre><code class="js">//中序遍历
const centerOrder = (root)=&gt;&#123;
    if(!root) return;
    centerOrder(root.left);
    console.log(root.val);
    centerOrder(root.right);
&#125;
</code></pre>
<p> （3）后序遍历：（左、右、中  向下递归）</p>
<pre><code class="js">//后序遍历
const postOrder = (root)=&gt;&#123;
    if(!root) return;
    postOrder(root.left);
    postOrder(root.right);
    console.log(root.val);
&#125;
</code></pre>
<p>【2】函数调用栈版二叉树的先中后序遍历</p>
<p>此方法原理和函数递归相似，其实就是模拟函数递归调用时，调用栈的执行（通过栈结构）来模拟执行的全过程。</p>
<p>   <strong>（1）先序遍历（重要）：</strong></p>
<pre><code class="js">const preOrder = (root)=&gt;&#123;
    const stack = [root]
    while(stack.length)&#123;
    const n = stack.pop()
    console.log(n.val);
    if(n.right) stack.push(n.right);
    if(n.left) stack.push(n.left);
    &#125;
&#125;
</code></pre>
<p><strong>（2）中序遍历（重要）：</strong></p>
<pre><code class="js">const centerOrder = (root)=&gt;&#123;
    const stack = []
    let p = root
    while(stack.length || p)&#123;
        while(p)&#123;
            stack.push(p)
            p=p.left
        &#125;
        //到此将全部的左节点推入栈中
        const n = stack.pop();
        //弹出栈，输出
        console.log(n.val);
        //将右子节点赋值为p，当右子节点没有左子节点时，直接输出
        p = n.right;
    &#125;
&#125;;
</code></pre>
<p><strong>（3）后序遍历（重要）：</strong></p>
<pre><code class="js">//函数调用栈进行后序遍历（巧妙借鉴先序遍历（将输出变为存到另一个栈中））
const postOrder = (root)=&gt;&#123;
    const stack = [root]
    const outputStack = []
    while(stack.length)&#123;
        const n = stack.pop()
        outputStack.push(n)
        if(n.left) stack.push(n.left)
        if(n.right) stack.push(n.right)
    &#125;
    while(outputStack.length)&#123;
        const n = outputStack.pop()
        console.log(n.val);
    &#125;
&#125;
</code></pre>
<p>【练习：104二叉树的最大深度】</p>
<pre><code class="js">var maxDepth = function(root) &#123;
    let res = 0;
    //定义深度优先遍历
    const dfs = (root,l)=&gt;&#123;
        if(!root) return
        if(!root.left &amp;&amp; !root.right)&#123;
        res = Math.max(res,l)
        &#125;
         dfs(root.left,l+1)
         dfs(root.right,l+1)
    &#125;
    dfs(root,1)
    return res
&#125;;
</code></pre>
<p>【练习：111二叉树的最小深度】</p>
<pre><code class="js">var minDepth = function(root)&#123;
    if(!root) return 0;
    //使用广度优先遍历，注意使用队列，因为广度优先。
    let queue = [[root,1]]
    while(queue.length)&#123;
        const [n,l] = queue.shift()
        if(!n.left &amp;&amp; !n.right)&#123;
            return l
        &#125;
       if(n.left) queue.push([n.left,l+1])
       if(n.right) queue.push([n.right,l+1])
    &#125;
&#125;
</code></pre>
<p>【练习：102二叉树的层序遍历】</p>
<p>方法一：</p>
<pre><code class="js">var levelOrder = function(root) &#123;
    //使用广度优先遍历算法
    let queue = [[root,1]]
    if(!root) return [];
    let res = []
    while(queue.length)&#123;
        const [n,l] = queue.shift()
        if(res.length&lt;l)&#123;
            res.push([n.val])
        &#125;else&#123;
            res[l-1].push(n.val)
        &#125;
        if(n.left) queue.push([n.left,l+1])
        if(n.right) queue.push([n.right,l+1])
    &#125;
    return res
&#125;;
</code></pre>
<p>方法二：（性能更好&#x3D;&#x3D;）</p>
<pre><code class="js">var levelOrder = function(root) &#123;
    if(!root) return [];
    let queue = [root]
    let res = []
    while(queue.length)&#123;
        let n = queue.length
        const item = []
        while(n)&#123;
            const i = queue.shift();
            item.push(i.val)
            if(i.left) queue.push(i.left)
            if(i.right) queue.push(i.right)
            n--;
        &#125;
        res.push(item)
    &#125;
    return res;
&#125;;
</code></pre>
<p>【练习：94二叉树的中序遍历】</p>
<pre><code class="js">//递归版实现
var inorderTraversal = function(root) &#123;
    let res = []
    //定义递归函数，进行执行
    const rec = (n) =&gt;&#123;
        if(!n) return;
        rec(n.left);
        res.push(n.val);
        rec(n.right);
    &#125;;
    rec(root);
    return res
&#125;;
</code></pre>
<pre><code class="js">//模拟栈实现
var inorderTraversal = function(root) &#123;
    let stack = [];
    let res = [];
    let p = root;
    while(stack.length || p)&#123;
    // 中序遍历首先是将全部的左子节点进行添加
        while(p)&#123;
            stack.push(p);
            p = p.left;
        &#125;
    //从栈中弹出
        const n = stack.pop();
        res.push(n.val);
    //将右子节点添加进数组，此时为中序顺序添加
        p = n.right;
    &#125;
    return res;
&#125;;
</code></pre>
<p>【练习：112路径总和】</p>
<pre><code class="js">var hasPathSum = function(root, targetSum) &#123;
    if(!root) return false;
    let res = false;
    //使用深度优先遍历
    let dfs = (root,sum)=&gt;&#123;
       if(!root.left &amp;&amp; !root.right &amp;&amp; sum == targetSum) &#123;
           res=true;
       &#125;;
       // 深度优先遍历
       if(root.left) dfs(root.left,sum+root.left.val);
       if(root.right) dfs(root.right,sum+root.right.val);
    &#125;
    dfs(root,root.val);
    return res;
&#125;;
</code></pre>
<p>【前端与树—遍历JSON】</p>
<pre><code class="js">// 前端与树----json的遍历
const json = &#123;
    a:&#123;b:&#123;c:1&#125;&#125;,
    d:[1,2]
&#125;
const dfs = (n,path)=&gt;&#123;
    console.log(n,path);
    Object.keys(n).forEach(item=&gt;&#123;
        dfs(n[item],path.concat(item))
    &#125;);
&#125;;
dfs(json,[]);
</code></pre>
<p>【前端与树—渲染Antd中的树组件】</p>
<pre><code class="tsx">const json = [
    &#123;
        title:&#39;一&#39;,
        key:&#39;1&#39;,
        children:[&#123;title:&#39;三&#39;,key:&#39;3&#39;,children:[]&#125;]
    &#125;,
    &#123;
        title:&#39;二&#39;,
        key:&#39;2&#39;,
        children:[&#123;title:&#39;四&#39;,key:&#39;4&#39;,children:[]&#125;]
    &#125;
]
class Demo extends React.Component &#123;
    dfs = (n)=&gt;&#123;
        return (
            &lt;TreeNode title=&#123;n.title&#125; key=&#123;n.key&#125;&gt;
                &#123;n.children.map(this.dfs)&#125;
            &lt;/TreeNode&gt;
        );
    &#125;;
    render()&#123;
        return &lt;Tree&gt;&#123;json.map(this.dfs)&#125;&lt;/Tree&gt;;
    &#125;
&#125;;
ReactDOM.render(&lt;Demo /&gt;,mountNode)
</code></pre>
<h1 id="图：网络结构抽象模型"><a href="#图：网络结构抽象模型" class="headerlink" title="图：网络结构抽象模型"></a>图：网络结构抽象模型</h1><p>【理解：图相当于可以跨越多个父级和子级和相互指对的树。】</p>
<p> JS中没有图，但是可以使用Object和Array来构建图。</p>
<p>【图的表示】</p>
<p>一、临接矩阵（可连接则为1）</p>
<p><img data-src="/images/%E5%9B%BE.png" alt="/images/image-20240123164938769"></p>
<p>二、邻接表（对象键的数组中表示可连接的值）</p>
<p><img data-src="/images/%E5%9B%BE1.png" alt="/images/image-20240123164938769"></p>
<p>【图的操作】</p>
<p>【1】深度优先遍历</p>
<p><img data-src="/images/%E5%9B%BE2.png" alt="/images/image-20240123164938769"></p>
<pre><code class="js">// 图的深度优先遍历
const graph = &#123;
    0:[1,2],
    1:[2],
    2:[0,3],
    3:[3]
&#125;
//定义集合用于存储已经访问过的节点
const visited = new Set();
const dfs = (n)=&gt;&#123;
    console.log(n);
    visited.add(n)
    graph[n].forEach(item=&gt;&#123;
       if(!visited.has(item)) dfs(item)
    &#125;)
&#125; 
dfs(2)
</code></pre>
<p>【2】广度优先遍历</p>
<p><img data-src="/images/%E5%9B%BE3.png" alt="/images/image-20240123164938769"></p>
<pre><code class="js">// 图的广度优先遍历
const graph = &#123;
    0:[1,2],
    1:[2],
    2:[0,3],
    3:[3]
&#125;
//图的广度优先遍历
const bfs = (n)=&gt;&#123;
    //定义集合存储访问过的变量
    const visited = new Set([n])
    //定义队列，取出访问
    const queue = [n];
    while(queue.length)&#123;
        const i = queue.shift();
        console.log(i);
        graph[i].forEach(item=&gt;&#123;
            if(!visited.has(item))&#123;
                queue.push(item)
                //推入队列中就会执行，表示已经访问过了
                visited.add(item)
            &#125;
        &#125;)
    &#125;
&#125;
bfs(2)
</code></pre>
<p>【练习：65有效的数字】</p>
<pre><code class="js">var isNumber = function(s) &#123;
    const graph = &#123;
        0:&#123;&#39;blank&#39;:0,&#39;sign&#39;:1,&#39;.&#39;:2,&#39;digit&#39;:6&#125;,
        1:&#123;&#39;digit&#39;:6,&#39;.&#39;:2&#125;,
        2:&#123;&#39;digit&#39;:3&#125;,
        3:&#123;&#39;digit&#39;:3,&#39;e&#39;:4&#125;,
        4:&#123;&#39;digit&#39;:5,&#39;sign&#39;:7&#125;,
        5:&#123;&#39;digit&#39;:5&#125;,
        6:&#123;&#39;digit&#39;:6,&#39;.&#39;:3,&#39;e&#39;:4&#125;,
        7:&#123;&#39;digit&#39;:5&#125;
    &#125;
    let state = 0;
    for(let str of s.trim())&#123;
        if(str &gt;= 0 &amp;&amp; str &lt;= 9)&#123;
            str = &#39;digit&#39;;
        &#125;else if(str === &#39; &#39;)&#123;
            str = &#39;blank&#39;;
        &#125;else if(str === &#39;+&#39; || str === &#39;-&#39;)&#123;
            str = &#39;sign&#39;;
        &#125;else if(str === &#39;E&#39;)&#123;
            str=&#39;e&#39;
        &#125;
        state = graph[state][str]
        if(state === undefined) return false;
    &#125;
    if(state ==3 || state== 5 || state== 6) return true;
    return false;
&#125;;
</code></pre>
<p>【练习：417太平洋大西洋水流问题】</p>
<pre><code class="js">var pacificAtlantic = function(matrix) &#123;
    if(!matrix || !matrix[0]) return[];
    const m = matrix.length;
    const n = matrix[0].length;
    const flow1 = Array.from(&#123;length:m&#125;,()=&gt;new Array(n).fill(false));
    const flow2 = Array.from(&#123;length:m&#125;,()=&gt;new Array(n).fill(false));
    const dfs = (r,c,flow)=&gt;&#123;
        //在flow中，将当前节点设置为true
        flow[r][c] = true;
        //遍历当前项的四周节点
        [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].forEach(([nr,nc])=&gt;&#123;
            if(
                //保证遍历的项在矩阵中,并且遍历项海拔大于当前节点海拔
                nr&gt;=0 &amp;&amp; nr &lt;m &amp;&amp; nc&gt;=0 &amp;&amp; nc&lt;n &amp;&amp; !flow[nr][nc] &amp;&amp; matrix[nr][nc] &gt;= matrix[r][c]
            )&#123;
                dfs(nr,nc,flow);
            &#125;
        &#125;);
    &#125;;
    // 沿着两个海洋遍历节点，能到达的节点为true（海岸线使用flow1，大西洋使用flow2）
    for(let r = 0;r&lt;m;r++)&#123;
        dfs(r,0,flow1);
        dfs(r,n-1,flow2);
    &#125;
    for(let c = 0;c&lt;n;c++)&#123;
        dfs(0,c,flow1);
        dfs(m-1,c,flow2);
    &#125;
    //收集到能留到两个大洋里的坐标
    const res = [];
    for(let r=0;r&lt;m;r++)&#123;
        for(let c =0;c&lt;n;c++)&#123;
            if(flow1[r][c] &amp;&amp; flow2[r][c])&#123;
                res.push([r,c])
            &#125;
        &#125;
    &#125;
    return res;
&#125;;
</code></pre>
<p>【练习：133克隆图】</p>
<pre><code class="js">//深度优先遍历方法
var cloneGraph = function(node) &#123;
    if(!node) return;
    //深优先遍历图，将节点和拷贝的节点存起来
    const visited = new Map();
    const dfs = (node)=&gt;&#123;
        const cloneNode = new Node(node.val);
        visited.set(node,cloneNode);
        (node.neighbors || []).forEach(item=&gt;&#123;
            if(!visited.has(item))&#123;
                dfs(item)
            &#125;
             cloneNode.neighbors.push(visited.get(item));
        &#125;);
    &#125;;
    dfs(node);
    return visited.get(node);
&#125;;
</code></pre>
<h1 id="堆：特殊的完全二叉树"><a href="#堆：特殊的完全二叉树" class="headerlink" title="堆：特殊的完全二叉树"></a>堆：特殊的完全二叉树</h1><p><img data-src="/images/%E5%A0%86.png" alt="/images/image-20240123164938769"></p>
<p><img data-src="/images/%E5%A0%861.png" alt="/images/image-20240123164938769"></p>
<p><img data-src="/images/%E5%A0%862.png" alt="/images/image-20240123164938769"></p>
<p>【JS实现最小堆类】</p>
<pre><code class="js">// 最小堆类
class MinHeap&#123;
    constructor()&#123;
        this.heap=[];
    &#125;
    // 交换两个节点位置
    swap(i1,i2)&#123;
        const temp = this.heap[i1];
        this.heap[i1]=this.heap[i2]
        this.heap[i2]=temp;
    &#125;
    // 得到父元素索引
    getParentIndex(i)&#123;
        return i-1 &gt;&gt; 1
    &#125;
    //获取左侧子节点
    getLeftIndex(i)&#123;
        return (i*2)+1;
    &#125;
    //获取右侧子节点
    getRightIndex(i)&#123;
        return (i*2)+2;
    &#125;
    //比较大小值确定位置
    shiftup(index)&#123;
        if(index==0) return;
        const parentIndex = this.getParentIndex(index)
        if(this.heap[parentIndex]&gt;this.heap[index])&#123;
            this.swap(parentIndex,index);
            this.shiftup(parentIndex);
        &#125;
    &#125;
    //插入节点，并放置到正确的位置
    insert(value)&#123;
        this.heap.push(value);
        this.shiftup(this.heap.length-1);
    &#125;
    //下移操作
    shiftDown(index)&#123;
        const leftIndex = this.getLeftIndex(index);
        const rightIndex = this.getRightIndex(index);
        if(this.heap[leftIndex]&lt;this.heap[index])&#123;
            this.swap(leftIndex,index);
            this.shiftDown(leftIndex);
        &#125;
        if(this.heap[rightIndex]&lt;this.heap[index])&#123;
            this.swap(rightIndex,index);
            this.shiftDown(rightIndex);
        &#125;
    &#125;
    //删除操作
    pop()&#123;
        this.heap[0]=this.heap.pop();
        this.shiftDown(0);
    &#125;
    peek()&#123;
        return this.heap[0];
    &#125;
    size()&#123;
        return this.heap.length;
    &#125;
&#125;
const h = new MinHeap();
h.insert(3)
h.insert(2)
h.insert(1)
h.pop();
</code></pre>
<p>【练习：215数组中的第K个最大元素】</p>
<pre><code class="js">class MinHeap&#123;
    constructor()&#123;
        this.heap=[];
    &#125;
    // 交换两个节点位置
    swap(i1,i2)&#123;
        [this.heap[i1],this.heap[i2]]=[this.heap[i2],this.heap[i1]]
    &#125;
    // 得到父元素索引
    getParentIndex(i)&#123;
        return i-1 &gt;&gt; 1
    &#125;
    //获取左侧子节点
    getLeftIndex(i)&#123;
        return (i*2)+1;
    &#125;
    //获取右侧子节点
    getRightIndex(i)&#123;
        return (i*2)+2;
    &#125;
    //比较大小值确定位置
    shiftup(index)&#123;
        if(index==0) return;
        const parentIndex = this.getParentIndex(index)
        if(this.heap[parentIndex]&gt;this.heap[index])&#123;
            this.swap(parentIndex,index);
            this.shiftup(parentIndex);
        &#125;
    &#125;
    //插入节点，并放置到正确的位置
    insert(value)&#123;
        this.heap.push(value);
        this.shiftup(this.heap.length-1);
    &#125;
    //下移操作
    shiftDown(index)&#123;
        const leftIndex = this.getLeftIndex(index);
        const rightIndex = this.getRightIndex(index);
        if(this.heap[leftIndex]&lt;this.heap[index])&#123;
            this.swap(leftIndex,index);
            this.shiftDown(leftIndex);
        &#125;
        if(this.heap[rightIndex]&lt;this.heap[index])&#123;
            this.swap(rightIndex,index);
            this.shiftDown(rightIndex);
        &#125;
    &#125;
    //删除操作
    pop()&#123;
        this.heap[0]=this.heap.pop();
        this.shiftDown(0);
    &#125;
    peek()&#123;
        return this.heap[0];
    &#125;
    size()&#123;
        return this.heap.length;
    &#125;
&#125;
//算法使用创建的最小堆类
var findKthLargest = function(nums,k)&#123;
    const h = new MinHeap();
    nums.forEach(item=&gt;&#123;
        h.insert(item);
        if(h.size()&gt;k)&#123;
            h.pop();
        &#125;
    &#125;);
    return h.peek();
&#125;
</code></pre>
<p>【练习：347前K个最大元素】</p>
<pre><code class="js">//方法一：暴力解法（里面有排序算法，时间复杂度较高，至少为：O(n*log(n)) ）
var topKFrequent = function(nums, k) &#123;
    const map = new Map()
    nums.forEach(item=&gt;&#123;
        map.has(item)? map.set(item,map.get(item)+1):map.set(item,1)
    &#125;)
    return Array.from(map)
        .sort((a,b)=&gt;b[1]-a[1])
        .slice(0,k)
        .map(item=&gt;item[0]);
&#125;;
</code></pre>
<pre><code class="js">//方法二：使用堆
class MinHeap&#123;
    constructor()&#123;
        this.heap=[];
    &#125;
    // 交换两个节点位置
    swap(i1,i2)&#123;
        [this.heap[i1],this.heap[i2]]=[this.heap[i2],this.heap[i1]]
    &#125;
    // 得到父元素索引
    getParentIndex(i)&#123;
        return i-1 &gt;&gt; 1
    &#125;
    //获取左侧子节点
    getLeftIndex(i)&#123;
        return (i*2)+1;
    &#125;
    //获取右侧子节点
    getRightIndex(i)&#123;
        return (i*2)+2;
    &#125;
    //比较大小值确定位置
    shiftup(index)&#123;
        if(index==0) return;
        const parentIndex = this.getParentIndex(index)
        if(this.heap[parentIndex].value&gt;this.heap[index].value)&#123;
            this.swap(parentIndex,index);
            this.shiftup(parentIndex);
        &#125;
    &#125;
    //插入节点，并放置到正确的位置
    insert(value)&#123;
        this.heap.push(value);
        this.shiftup(this.heap.length-1);
    &#125;
    //下移操作
    shiftDown(index)&#123;
        const leftIndex = this.getLeftIndex(index);
        const rightIndex = this.getRightIndex(index);
        if(this.heap[leftIndex] &amp;&amp; this.heap[leftIndex].value&lt;this.heap[index].value)&#123;
            this.swap(leftIndex,index);
            this.shiftDown(leftIndex);
        &#125;
        if(this.heap[rightIndex] &amp;&amp; this.heap[rightIndex].value&lt;this.heap[index].value)&#123;
            this.swap(rightIndex,index);
            this.shiftDown(rightIndex);
        &#125;
    &#125;
    //删除操作
    pop()&#123;
        this.heap[0]=this.heap.pop();
        this.shiftDown(0);
    &#125;
    peek()&#123;
        return this.heap[0];
    &#125;
    size()&#123;
        return this.heap.length;
    &#125;
&#125;
var findKthLargest = function(nums,k)&#123;
    const h = new MinHeap();
    nums.forEach(item=&gt;&#123;
        h.insert(item);
        if(h.size()&gt;k)&#123;
            h.pop();
        &#125;
    &#125;);
    return h.peek();
&#125;
var topKFrequent = function(nums,k)&#123;
    const map = new Map();
    nums.forEach(item=&gt;&#123;
        map.set(item,map.has(item)?map.get(item)+1:1);
    &#125;)
    const h = new MinHeap();
    map.forEach((value,key)=&gt;&#123;
        h.insert(&#123;value,key&#125;);
        if(h.size()&gt;k)&#123;
            h.pop();
        &#125;;
    &#125;);
    return h.heap.map(item=&gt;item.key);
&#125;;
</code></pre>
<p>【练习：23合并K个排序链表】</p>
<pre><code class="js">class minHeap&#123;
    constructor()&#123;
        this.heap=[];
    &#125;
    //移动两个元素的位置
    swap(i1,i2)&#123;
        [this.heap[i1],this.heap[i2]]=[this.heap[i2],this.heap[i1]]
    &#125;
    //得到父元素下标
    getParentIndex(i)&#123;
        return i-1&gt;&gt;1;
    &#125;
    //得到左侧子节点下标
    getLeftIndex(i)&#123;
        return i*2+1;
    &#125;
    //得到右侧子节点下标
    getRightIndex(i)&#123;
        return i*2+2;
    &#125;
    //根据索引调整元素位置(冒泡将最小元素上移)
    shiftup(index)&#123;
        if(index==0) return;
        const parentIndex = this.getParentIndex(index);
        if(this.heap[parentIndex]&amp;&amp;this.heap[parentIndex].val&gt;this.heap[index].val)&#123;
            this.swap(index,parentIndex);
            this.shiftup(parentIndex);
        &#125;
    &#125;
    //插入
    insert(value)&#123;
        this.heap.push(value);
        this.shiftup(this.heap.length-1);
    &#125;
    //删除操作
    pop()&#123;
        if(this.size()===1) return this.heap.shift();
        const top = this.heap[0];
        this.heap[0]=this.heap.pop();
        this.shiftDown(0);
        return top;
    &#125;
    //下沉操作
    shiftDown(index)&#123;
        const leftIndex = this.getLeftIndex(index)
        const rightIndex = this.getRightIndex(index)
        if(this.heap[leftIndex]&amp;&amp;this.heap[leftIndex].val&lt;this.heap[index].val)&#123;
            this.swap(leftIndex,index)
            this.shiftDown(leftIndex)
        &#125;
        if(this.heap[rightIndex]&amp;&amp;this.heap[rightIndex].val&lt;this.heap[index].val)&#123;
            this.swap(rightIndex,index)
            this.shiftDown(rightIndex)
        &#125;
    &#125;
    //选取
    peek()&#123;
        return this.heap[0]
    &#125;
    size()&#123;
        return this.heap.length;
    &#125;
&#125;

class ListNode&#123;
    constructor(value)&#123;
    this.val = value;
    this.next = null
      &#125;
    &#125;
    var mergeKLists = function(lists) &#123;
        const res = new ListNode(0);
        let p =res;
        const h = new minHeap();
        lists.forEach(item=&gt;&#123;
            if(item) h.insert(item);
        &#125;);
        while(h.size())&#123;
            const n = h.pop();
            if(p)&#123;
            p.next = n;
            p = p.next;
            &#125;
            if(n &amp;&amp; n.next) h.insert(n.next);
        &#125;
        return res.next;
    &#125;;
</code></pre>
<h1 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h1><p>【排序算法】</p>
<p>1、冒泡排序：</p>
<p>冒泡排序比较所有相邻元素，如果第一个比第二个大，就交换他们，一轮下来可以保证最后一个数是最大的，则执行n-1轮之后可以实现排序，时间复杂度为O(n**2)</p>
<pre><code class="js">//冒泡排序
Array.prototype.bubbleSort=function()&#123;
        for(let i =0;i&lt;this.length-1;i++)&#123;
            for(let j =0;j&lt;this.length-1-i;j++)&#123;
                if(this[j]&gt;this[j+1])&#123;
                    [this[j],this[j+1]]=[this[j+1],this[j]]
                &#125;
            &#125;
        &#125;
        return this
&#125;
</code></pre>
<p>2、选择排序：</p>
<p>选择排序找到数组中的最小值，选中它并将其放置在第一位，接着找到第二小的值，选中它并将其放置在第二位，以此类推执行n-1轮，时间复杂度为O(n**2)</p>
<pre><code class="js">//选择排序
Array.prototype.selectionSort=function()&#123;
    for(let i =0;i&lt;this.length;i++)&#123;
        for(let j =i+1;j&lt;this.length;j++)&#123;
            if(this[j]&lt;this[i])&#123;
                [this[j],this[i]]=[this[i],this[j]]
            &#125;
        &#125;
    &#125;
    return this
&#125;
</code></pre>
<p>3、插入排序：</p>
<p> 插入排序会从第二个数开始往前比，比他大就往后排，以此类推进行到最后一个数。时间复杂度为： O(n**2)</p>
<pre><code class="js">//插入排序
Array.prototype.insertSort=function()&#123;
   for(let i=1;i&lt;this.length;i++)&#123;
    const temp = this[i];
    let j=i;
    while(j&gt;0)&#123;
        if(this[j-1]&gt;temp)&#123;
            this[j]=this[j-1];
        &#125;else&#123;
            break;
        &#125;
        j-=1;
    &#125;
    this[j]=temp;
   &#125;
&#125;
</code></pre>
<p>4、归并排序（火狐浏览器sort）</p>
<p>归：将数组分为两半，再递归的对子数组进行分操作，直到分成一个个单独的数。</p>
<p>并：将两个数合并成一个有序数组，再对有序数组进行合并，直到全部子数合并成一个完整数组。</p>
<p>时间复杂度为：O(nlogn)</p>
<pre><code class="js">Array.prototype.mergeSort = function()&#123;
    const rec = (arr)=&gt;&#123;
        if(arr.length===1) return arr;
        const mid = arr.length &gt;&gt; 1;
        const left = arr.slice(0,mid);
        const right = arr.slice(mid,arr.length)
        const orderLeft=rec(left);
        const orderRight=rec(right);
        const res = [];
        while(orderLeft.length || orderRight.length)&#123;
            if(orderLeft.length &amp;&amp; orderRight.length)&#123;
                res.push(orderLeft[0]&lt;orderRight[0]?orderLeft.shift():orderRight.shift())
            &#125;else if(orderLeft.length)&#123;
                res.push(orderLeft.shift())
            &#125;else if(orderRight.length)&#123;
                res.push(orderRight.shift())
            &#125;
        &#125;
        return res;
    &#125;;
    const res = rec(this);
    res.forEach((item,index)=&gt;&#123;this[index]=item;&#125;);
    return this;
&#125;
let ate = [2,3,1,-1,4,6,8,5,-3,-2];
console.log(ate.mergeSort());
</code></pre>
<p>5、快速排序（Chrome浏览器之前的sort）</p>
<p><strong>首先分区</strong>：从数组中任意选择一个基准，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面。</p>
<p><strong>然后递归</strong>：递归地对基准前后的子数组进行分区。</p>
<p>时间复杂度：O(nlogn)</p>
<pre><code class="js">Array.prototype.quickSort = function()&#123;
    const rec = (arr)=&gt;&#123;
        if(arr.length&lt;=1)&#123;return arr;&#125;
        const left = [];
        const right = [];
        const mid = arr[0];
        for(let i=1;i&lt;arr.length;i++)&#123;
            if(arr[i]&lt;mid)&#123;
                left.push(arr[i]);
            &#125;else&#123;
                right.push(arr[i]);
            &#125;
        &#125;
        return [...rec(left),mid,...rec(right)]
    &#125;
    const res = rec(this)
    res.forEach((item,index)=&gt;&#123;
        this[index]=item;
    &#125;)
    return this;
&#125;
const a2 = [-2,-4,0,3,5]
console.log(
a2.quickSort()
);
</code></pre>
<p>【搜索算法】</p>
<p>1、顺序搜索</p>
<p>首先遍历数组，找到跟目标值相等的元素就返回下标，遍历结束后如果没有找到搜索的目标值，就返回-1</p>
<p>时间复杂度为O(n)</p>
<pre><code class="js">Array.prototype.sequentialSearch = function(num)&#123;
    for(let i=0;i&lt;this.length;i++)&#123;
        if(this[i]===num)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;
const a = [-2,-4,0,3,5]
console.log(a.sequentialSearch(5));
</code></pre>
<p>2、二分搜索（前提是数组有序）</p>
<p>从数组的中间元素开始，如果中间元素正好是目标值，则索引结束，如果目标值大于或者等于中间元素，则在大于或小于中间元素的那一半数组中搜索。</p>
<p>时间复杂度为O(logn)</p>
<pre><code class="js">Array.prototype.bannerySearch = function(num)&#123;
    let head = 0;
    let tail = this.length-1;
    while(head&lt;=tail)&#123;
        const mid = head+tail &gt;&gt; 1;
        const item = this[mid];
        if(num&lt;item)&#123;
            tail=mid-1;
        &#125;else if(num&gt;item)&#123;
            head=mid+1;
        &#125;else&#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;
const a = [-2,0,3,4,9,11]
console.log(a.bannerySearch(11));
</code></pre>
<p>【练习：21合并两个有序链表】</p>
<p>时间复杂度为：O(m+n)</p>
<pre><code class="js">var mergeTwoLists = function(list1, list2) &#123;
    let list = new ListNode(0);
    const firstNode = list;
    let p1 = list1;
    let p2 = list2;
    while(p1 &amp;&amp; p2)&#123;
        if(p1.val&gt;p2.val)&#123;
            list.next=p2;
            p2=p2.next
        &#125;else&#123;
            list.next=p1;
            p1=p1.next
        &#125;
        list=list.next;
    &#125;
    if(p1)&#123;list.next=p1&#125;
    if(p2)&#123;list.next=p2&#125;
    return firstNode.next;
&#125;;
</code></pre>
<p>【练习：374猜数字大小】</p>
<pre><code class="js">var guessNumber = function(n) &#123;
    let head = 1;
    let tail = n;
    while(head&lt;tail)&#123;
       const mid = head+(tail-head&gt;&gt;1);
        if(guess(mid)&lt;=0)&#123;
            tail=mid;
        &#125;else&#123;
            head=mid+1;
        &#125;
    &#125;
    return head;
&#125;;
</code></pre>
<p>【练习：69x的平方】</p>
<pre><code class="js">var mySqrt = function(x) &#123;
    let left =1,right=x;
    while(left&lt;=right)&#123;
        let mid = left+(right-left&gt;&gt;1);
        if(mid*mid&lt;=x)&#123;
            if((mid+1)*(mid+1)&gt;x)&#123;
                return mid;
            &#125;
            left=mid+1;
        &#125;else&#123;
            right=mid-1;
        &#125;
    &#125;
    return 0;
&#125;;
</code></pre>
<h1 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h1><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分而治之是算法设计中的一种方法（思想），</p>
<p>分而治之将一个问题分为多个和原问题相似的<strong>相互独立的子问题</strong>，递归解决小问题，再将结果合并已解决原来的问题。应用场景有：归并排序、快速排序和二分搜索。</p>
<p>【练习：374猜数字大小】</p>
<p> 时间复杂度为：O(logn),空间复杂度为：O(logn)空间复杂度不如直接使用循环。</p>
<pre><code class="js">var guessNumber = function(n) &#123;
    const rec = (head,tail)=&gt;&#123;
        const mid = head+(tail-head&gt;&gt;1);
        const res = guess(mid);
        if(res===0)&#123;
            return mid;
        &#125;else if(res===1)&#123;
            return rec(mid+1,tail)
        &#125;else&#123;
            return rec(head,mid-1)
        &#125;
    &#125;
    return rec(1,n)
&#125;;
</code></pre>
<p>【练习：226翻转二叉树】</p>
<pre><code class="js">var invertTree = function(root) &#123;
    if(!root) return null;
    return &#123;
        val:root.val,
        left:invertTree(root.right),
        right:invertTree(root.left)
    &#125;
&#125;;
</code></pre>
<p>【练习：100相同的树】</p>
<p>时间复杂度为：O(n) , 空间复杂度为：O(n)</p>
<pre><code class="js">var isSameTree = function(p, q) &#123;
    if(!p &amp;&amp; !q) return true;
    if(p &amp;&amp; q &amp;&amp; p.val===q.val &amp;&amp; isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right))&#123;
       return true;
   &#125;
&#125;;
</code></pre>
<p>【练习：101对称二叉树】</p>
<pre><code class="js">var isSymmetric = function(root) &#123;
    if(!root) return true;
    const isMirror = (l,r)=&gt;&#123;
        if(!l &amp;&amp; !r) return true;
        if(l &amp;&amp; r &amp;&amp; l.val===r.val &amp;&amp; isMirror(l.left,r.right) &amp;&amp; isMirror(l.right,r.left))&#123;
            return true;
        &#125;
        return false;
    &#125;
    return isMirror(root.left,root.right)
&#125;;
</code></pre>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是算法设计中的一种方法，</p>
<p>动态规划将一个问题分解为<strong>相互重叠的子问题</strong>，通过反复求解子问题来解决原来的问题。</p>
<p>关键：找出<strong>状态转移方程</strong>。</p>
<p>【练习：70爬楼梯】</p>
<pre><code class="js">var climbStairs = function(n) &#123;
    if(n&lt;2) return 1;
    let dp0 = 1;
    let dp1 = 1;
    for(let i = 2;i&lt;=n;i++)&#123;
        const temp = dp0;
        dp0=dp1;
        dp1+=temp;
    &#125;
    return dp1;
&#125;;
</code></pre>
<p>【练习：198打家劫舍】</p>
<pre><code class="js">var rob = function(nums) &#123;
    if(nums.length===0) return 0;
    if(nums.length===1) return nums[0];
    let dp0 = 0,dp1=nums[0];
    for(let i=2;i&lt;=nums.length;i++)&#123;
       const dp2=Math.max(dp0+nums[i-1],dp1);
        dp0=dp1;
        dp1=dp2;
    &#125;
    return dp1;
&#125;;
</code></pre>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法是算法设计中的一种方法（思想），期盼通过每个阶段的<strong>局部最优</strong>选择，从而达到全局的最优，但是并不一定是最优的解法。</p>
<p>【练习：455分饼干】</p>
<pre><code class="js">var findContentChildren = function(g, s) &#123;
    const sortFn = function(a,b)&#123;
        return a-b
    &#125;
    g=g.sort(sortFn);
    s=s.sort(sortFn);
    let i =0;
    s.forEach(item=&gt;&#123;
        if(item&gt;=g[i])&#123;
            i++;
        &#125;
    &#125;)
    return i;
&#125;;
</code></pre>
<p>【练习：122买卖股票的最佳时机】</p>
<pre><code class="js">var maxProfit = function(prices) &#123;
    let profit = 0;
    for(let i=1;i&lt;prices.length;i++)&#123;
        if(prices[i]&gt;prices[i-1])&#123;
            profit+=prices[i]-prices[i-1]
        &#125;
    &#125;
    return profit;
&#125;;
</code></pre>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>回溯算法是算法设计中的一种方法（思想），</p>
<p>回溯算法是一种渐进式寻找并构建问题解决方式的策略。</p>
<p>回溯算法会先从一个可能的动作开始解决问题，如果不行就回溯并选择另一个动作，直到将问题解决。</p>
<p>【练习：46全排列】</p>
<p>时间复杂度：O(n!) ;空间复杂度：O(n)</p>
<pre><code class="js">var permute = function(nums) &#123;
    const res = [];
    const backtrack = (arr)=&gt;&#123;
        if(arr.length===nums.length)&#123;
            res.push(arr);
            return;
        &#125;
        nums.forEach(item=&gt;&#123;
            if(arr.includes(item)) return;
            backtrack(arr.concat(item))
        &#125;)
    &#125;
    backtrack([]);
    return res;
&#125;;
</code></pre>
<p>【练习：78子集】（难点）</p>
<p>时间复杂度：O(2**n)  , 空间复杂度：O(n)</p>
<pre><code class="js">var subsets = function(nums) &#123;
    const res = [];
    const backtrack = (path,l,start)=&gt;&#123;
        if(path.length===l)&#123;
            res.push(path);
            return;
        &#125;
        for(let i=start;i&lt;nums.length;i++)&#123;
            backtrack(path.concat(nums[i]),l,i+1)
        &#125;
    &#125;
    for(let i =0;i&lt;=nums.length;i++)&#123;
       backtrack([],i,0)
    &#125;
    return res;
&#125;;
</code></pre>
<h1 id="代码思想录"><a href="#代码思想录" class="headerlink" title="代码思想录"></a>代码思想录</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDQuJUU0JUJBJThDJUU1JTg4JTg2JUU2JTlGJUE1JUU2JTg5JUJFLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG">代码思想录</span></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度不是在计算执行时间因为执行时间是没有标准的，这个和我们的硬件设备和机器环境有关系。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法 的时间复杂度。</p>
<p>找到<strong>某条基本语句与问题规模N之间的数学表达式</strong>，就是算出了该算法的时间复杂度。</p>
<p>另外有些算法的时间复杂度存在最好、平均和最坏情况：</p>
<p>最坏情况：任意输入规模的最大运行次数(上界)</p>
<p>平均情况：任意输入规模的期望运行次数</p>
<p>最好情况：任意输入规模的最小运行次数(下界)</p>
<p>一般情况关注的是算法的最坏运行情况，所以以<strong>最坏情况的时间复杂度为准</strong>。</p>
<p>使用<strong>大O的渐进表示法</strong>进行估算。</p>
<p>o(1):</p>
<pre><code class="typescript">let i = 0;i+=1;
</code></pre>
<p>0(n):</p>
<pre><code class="typescript">for(let i =0;i&lt;n;i++)&#123;console.log(i);&#125;
</code></pre>
<p>o(n^2):</p>
<p><strong>双重for循环</strong></p>
<p>o(logN)：</p>
<pre><code class="typescript">let i = 1;
while(i&lt;n)&#123;
console.log(i)
i *= 2;
&#125;
</code></pre>
<p><img data-src="/images/%E7%AE%97%E6%B3%953.png" alt="/images/image-20240123164938769"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>相比而言现在算法不那么关注空间复杂度，因为现在的设备的存储空间都比较大。</p>
<p>空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度 ，也就是额外占取的空间的大小。在进行计算时需要注意空间是可以重复利用的，不进行累积。例如：for循环中定义的变量i每一次创建时使用的都是同一块空间。</p>
<p>【变量空间可以重复利用】</p>
<p><img data-src="/images/%E7%AE%97%E6%B3%951.png" alt="/images/image-20240123164938769"></p>
<p>【函数的调用需要建立栈】</p>
<p><img data-src="/images/%E7%AE%97%E6%B3%952.png" alt="/images/image-20240123164938769"></p>
<p>使用<strong>大O的渐进表示法</strong>进行估算。</p>
<h2 id="数组算法："><a href="#数组算法：" class="headerlink" title="数组算法："></a>数组算法：</h2><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<ul>
<li><strong>数组下标都是从0开始的。</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p>java中的二位数组不是一直连续的，而是n条连续的地址空间组成。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>【前提】传入的数组是有序数组，数组中无重复元素</p>
<p>【要点】区间定义  循环不变量</p>
<p>然后while循环(left&lt;right),定中间的mid变量为：left+((right-left) &gt;&gt; 1)，利用位运算进行除法操作。</p>
<pre><code class="ts">function search(nums: number[], target: number): number &#123;
    let mid: number, left: number = 0, right: number = nums.length - 1;
    while (left &lt;= right) &#123;
        // 位运算 + 防止大数溢出
        mid = left + ((right - left) &gt;&gt; 1);
        if (nums[mid] &gt; target) &#123;
            right = mid - 1;
        &#125; else if (nums[mid] &lt; target) &#123;
            left = mid + 1;
        &#125; else &#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;;
</code></pre>
<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>【前提】传入数组和val,移除数组中等于val的全部元素，返回移除后数组长度</p>
<p>【要点】数组的元素在内存空间是连续的，不能单独删除数组的某个元素，只能覆盖</p>
<p>两次循环（移动数组元素）：</p>
<pre><code class="ts">function solution(arr:any[],val:any):number&#123;
    let size:number = arr.length;
    for(let i =0;i&lt;arr.length;i++)&#123;
        if(arr[i]==val)&#123;
            //集体向前进位
            for(let j=i+1;j&lt;arr.length;j++)&#123;
                arr[j-1]=arr[j]
            &#125;
            i--;
            size--;
        &#125;
    &#125;
    return size;
&#125;
</code></pre>
<p><strong>快慢指针</strong>（给指定元素重新赋值）：</p>
<pre><code class="ts">function removeElement(nums: number[], val: number): number &#123;
    let slowIndex: number = 0, fastIndex: number = 0 //定义快慢指针index
    while (fastIndex &lt; nums.length) &#123;  //当快指针index小于数组长度时执行循环
        if (nums[fastIndex] !== val) &#123; //如果快指针对应的元素不等于val元素
            // 注意后置递增的运算顺序大于赋值运算，相当于确定了nums中的数值，表达式结束之后再自增加一
            nums[slowIndex++] = nums[fastIndex];  //满指针赋值
        &#125;
        fastIndex++;
    &#125;
    return slowIndex;
&#125;;
</code></pre>
<p>4  将排序数组平方后再排序（注意负数平方后可能大于正数）</p>
<p>暴力解法：</p>
<pre><code class="ts">function sortedSquares(arr:number[]):number[]&#123;
    return arr.map((item:number)=&gt;item ** 2).sort((a:number,b:number)=&gt;a-b)
&#125;
console.log(sortedSquares([2,1,4,0,3]));
</code></pre>
<p>双指针解法：</p>
<pre><code class="ts">// 数组本来是存在顺序的,问题在于负数平方之后变为了最大数
// 此时考虑双指针方法，向两边靠拢
function sortedSquares(arr:number[]):number[]&#123;
    let right:number = arr.length-1,left:number=0,newArr:number[]=[];
    while(right&gt;=left)&#123;
        if(arr[right] ** 2 &gt;= arr[left] ** 2)&#123;
            newArr.push(arr[right--]**2)
        &#125;else&#123;
            newArr.push(arr[left++]**2)
        &#125;
    &#125;
    return newArr
&#125;
console.log(sortedSquares([-9,-3,0,2,3,6]));
</code></pre>
<p>5  长度最小的子数组</p>
<p>双重for循环遍历</p>
<pre><code class="ts">function minSubArrayLen(s: number, nums: number[]): number &#123;
    let result = Infinity; 
    let sum = 0; 
    let subLength = 0; 
    for (let i = 0; i &lt; nums.length; i++) &#123;  //数组遍历一遍
      sum = 0;
      for (let j = i; j &lt; nums.length; j++) &#123;  //数组遍历一遍
        sum += nums[j]; //累加
        if (sum &gt;= s) &#123; //一旦累加的和大于指定数字
          subLength = j - i + 1; //数组长度
          result = result &lt; subLength ? result : subLength; //
          break; 
        &#125;
      &#125;
    &#125;
    return result == Infinity ? 0 : result;
  &#125;
</code></pre>
<p><strong>滑动窗口法（双指针的一种）</strong></p>
<p>双指针滑动判断条件，将满足条件的结果进行记录（这种方法执行的也是两次循环，但是省略了中间的部分步骤，剔除了不必要的记录结果的部分）</p>
<pre><code class="ts">function minSubArrayLen(target: number, nums: number[]): number &#123;
    // 创建指针
    let left: number = 0, right: number = 0;
    // 创建res变量
    let res: number = nums.length + 1;
    let sum: number = 0;
    while (right &lt; nums.length) &#123; //当右指针小于数组的长度时执行循环
        sum += nums[right]; //sum和累加right对应的元素（移动右指针）
        if (sum &gt;= target) &#123; //如果累加和大于目标值（移动左指针）
            while (sum - nums[left] &gt;= target) &#123; //移动到累加和小于目标值
                sum -= nums[left++]; 
            &#125;
            res = Math.min(res, right - left + 1); //每一次累加和大于目标值时，进行判断和统计
        &#125;
        right++;
    &#125;
    return res === nums.length + 1 ? 0 : res;
&#125;;
console.log(minSubArrayLen(7,[2,3,1,2,4,3]));
</code></pre>
<p>6  螺旋矩阵||</p>
<p>【条件】给定一个正整数n，生成一个包含1到n的平方的所有元素，按照顺时针顺序螺旋排列正方形矩阵。</p>
<p>【要点】循环不变量原则，坚持每一条边左闭右开原则</p>
<pre><code class="ts">function generateMatrix(n: number): number[][] &#123;
    let loopNum: number = Math.floor(n / 2); //定义循环次数
    const resArr: number[][] = new Array(n).fill(1).map(i =&gt; new Array(n));//定义二元数组
    let chunkNum: number = n - 1;  //循环长度
    let startX: number = 0; //开始x
    let startY: number = 0; //开始y
    let value: number = 1; //数值
    let x: number, y: number;
    while (loopNum--) &#123; //当loopNum的值大于0时执行循环，每一个loopNum自减
        x = startX;
        y = startY;
        while (x &lt; startX + chunkNum) &#123; //当x小于开始x加上循环长度时 向右执行循环
            resArr[y][x] = value;  //填充
            x++;
            value++;
        &#125;
        while (y &lt; startY + chunkNum) &#123; //当y小于开始Y加上循环长度时 向下执行循环
            resArr[y][x] = value;  //累加y的值到指定循环长度次
            y++;
            value++;
        &#125;
        while (x &gt; startX) &#123;  //当x大于开始的x时，向左执行循环
            resArr[y][x] = value;
            x--;
            value++;
        &#125;
        while (y &gt; startY) &#123;  //当y大于开始的y时，向上执行循环
            resArr[y][x] = value;
            y--;
            value++;
        &#125;
        startX++;  //每一次让开始x和开始y自增，以达到向内延展的效果
        startY++;
        chunkNum -= 2; //每一次循环之后，一行或一列需要的长度少2
    &#125;
    //全部循环完毕之后进行判断：如果n是奇数，则中间会有一个空出来，填充
    if (n % 2 === 1) &#123;  
        resArr[startX][startY] = value;
    &#125;
    return resArr;
&#125;;
</code></pre>
<h2 id="链表算法："><a href="#链表算法：" class="headerlink" title="链表算法："></a>链表算法：</h2><h4 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h4><p>链表理论基础：</p>
<p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链表的入口节点称为链表的头结点也就是head。</p>
<p>1 单链表</p>
<p><img data-src="/images/%E9%93%BE%E8%A1%A81.png" alt="/images/image-20240123164938769"></p>
<p>2 双链表</p>
<p><img data-src="/images/%E9%93%BE%E8%A1%A82.png" alt="/images/image-20240123164938769"></p>
<p>3 循环链表</p>
<p><img data-src="/images/%E9%93%BE%E8%A1%A83.png" alt="/images/image-20240123164938769"></p>
<p><strong>4 链表存储方式</strong></p>
<p><strong>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</strong></p>
<p><strong>链表是通过指针域的指针链接在内存中各个节点。</strong></p>
<p><strong>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</strong></p>
<p><img data-src="/images/%E9%93%BE%E8%A1%A84.png" alt="/images/image-20240123164938769"></p>
<p>【链表和数组的区别：】</p>
<p><img data-src="/images/%E9%93%BE%E8%A1%A85.png" alt="/images/image-20240123164938769"></p>
<p><strong>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</strong></p>
<p><strong>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</strong></p>
<p><strong>数组取值容易增删难，链表增删简单，取值难</strong></p>
<p><strong>5 链表的定义：</strong></p>
<pre><code class="ts">//定义链表
class ListNode&#123;
    public val:number;
    public next:ListNode | null=null;
    constructor(value:number,next?:ListNode | null)&#123;
        this.val = value;
        this.next = next || null;
    &#125;
&#125;
const head1 = new ListNode(1)
const head2 = new ListNode(2)
const head3 = new ListNode(2)
const head4 = new ListNode(1)
head1.next = head2
head2.next = head3
head3.next = head4
</code></pre>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>【练习：203移除链表中对应值的元素：】</p>
<p>（1）原链表上直接删除</p>
<pre><code class="ts">// 移除链表节点元素,传入ListNode链表，val数值
function removeElements(head: ListNode | null, val: number): ListNode | null &#123;
    //边界判断，如果当前链表头节点的值为目标值，不能直接移除头节点（设置虚拟头节点可以避免）
    while (head !== null &amp;&amp; head.val === val) &#123;
        head = head.next;
    &#125;
    if (head === null) return head;  //如果传入的链表是空对象，直接返回
    let pre: ListNode = head, cur: ListNode | null = head.next; //定义前一个节点，当前节点
    // 删除非头部节点
    while (cur) &#123; //当前节点有值时进行循环
        if (cur.val === val) &#123; //如果当前节点的值为进行判断的值，就将当前的下一项赋值给pre前一个的下一项（跳过当前节点）
            pre.next = cur.next;
        &#125; else &#123;  //否则遍历判断下一项
            //此处不加类型断言时：编译器会认为pre类型为ListNode, pre.next类型为ListNode | null
            pre = pre.next as ListNode;
        &#125;
        cur = cur.next;
    &#125;
    return head; //返回头节点
&#125;;
</code></pre>
<p>（2）创建虚拟头节点删除</p>
<pre><code class="ts">//在原链表上直接删除
var removeElements = function(head:ListNode | null, val:number):ListNode | null &#123;
   //添加虚拟头节点
   const data = new ListNode(0,head);
   let pre = data, cur = data.next;
   while(cur)&#123;
    if(cur.val===val)&#123;
        pre.next = cur.next;
    &#125;else&#123;
        pre = cur;
    &#125;
    cur=cur.next;
   &#125;
   return data.next;
&#125;;
console.log(removeElements(head1,2));
</code></pre>
<p>【练习：707设计链表】</p>
<pre><code class="ts">class ListNode &#123;
    public val: number;
    public next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) &#123;
        this.val = val === undefined ? 0 : val;
        this.next = next === undefined ? null : next;
    &#125;
&#125;

class MyLinkedList &#123;
    // 记录链表长度
    private size: number;
    private head: ListNode | null;
    private tail: ListNode | null;
    constructor() &#123;
        this.size = 0;
        this.head = null;
        this.tail = null;
    &#125;

    // 获取链表中第 index个节点的值
    get(index: number): number &#123;
        // 索引无效的情况
        if (index &lt; 0 || index &gt;= this.size) &#123;
            return -1;
        &#125;
        let curNode = this.getNode(index);
        // 这里在前置条件下，理论上不会出现 null的情况
        return curNode.val;
    &#125;

    // 在链表的第一个元素之前添加一个值为 val的节点。插入后，新节点将成为链表的第一个节点。
    addAtHead(val: number): void &#123;
        let node: ListNode = new ListNode(val, this.head);
        this.head = node;
        if (!this.tail) &#123;
            this.tail = node;
        &#125;
        this.size++;
    &#125;

    // 将值为 val 的节点追加到链表的最后一个元素。
    addAtTail(val: number): void &#123;
        let node: ListNode = new ListNode(val, null);
        if (this.tail) &#123;
            this.tail.next = node;
        &#125; else &#123;
            // 还没有尾节点，说明一个节点都还没有
            this.head = node;
        &#125;
        this.tail = node;
        this.size++;
    &#125;

    // 在链表中的第 index个节点之前添加值为 val的节点。
    // 如果 index等于链表的长度，则该节点将附加到链表的末尾。如果 index大于链表长度，则不会插入节点。如果 index小于0，则在头部插入节点。
    addAtIndex(index: number, val: number): void &#123;
        if (index === this.size) &#123;
            this.addAtTail(val);
            return;
        &#125;
        if (index &gt; this.size) &#123;
            return;
        &#125;
        // &lt;= 0 的情况都是在头部插入
        if (index &lt;= 0) &#123;
            this.addAtHead(val);
            return;
        &#125;
        // 正常情况
        // 获取插入位置的前一个 node
        let curNode = this.getNode(index - 1);
        let node: ListNode = new ListNode(val, curNode.next);
        curNode.next = node;
        this.size++;
    &#125;

    // 如果索引 index有效，则删除链表中的第 index个节点。
    deleteAtIndex(index: number): void &#123;
        if (index &lt; 0 || index &gt;= this.size) &#123;
            return;
        &#125;
        // 处理头节点
        if (index === 0) &#123;
            this.head = this.head!.next;
            // 如果链表中只有一个元素，删除头节点后，需要处理尾节点
            if (index === this.size - 1) &#123;
                this.tail = null
            &#125;
            this.size--;
            return;
        &#125;
        // 索引有效
        let curNode: ListNode = this.getNode(index - 1);
        curNode.next = curNode.next!.next;
        // 处理尾节点
        if (index === this.size - 1) &#123;
            this.tail = curNode;
        &#125;
        this.size--;
    &#125;

    // 获取指定 Node节点
    private getNode(index: number): ListNode &#123;
        // 这里不存在没办法获取到节点的情况，都已经在前置方法做过判断
        // 创建虚拟头节点
        let curNode: ListNode = new ListNode(0, this.head);
        for (let i = 0; i &lt;= index; i++) &#123;
            // 理论上不会出现 null
            curNode = curNode.next!;
        &#125;
        return curNode;
    &#125;
&#125;
</code></pre>
<p>【练习：206反转链表】</p>
<p>双指针法：</p>
<pre><code class="ts">     var reverseList= function(head:ListNode | null):ListNode | null&#123;
         let pre:ListNode | null=null;
         let curNode:ListNode | null = head;
         let tempNode:ListNode | null;
            while(curNode)&#123;
                tempNode=curNode.next;
                [curNode.next,pre]=[pre,curNode]
                curNode=tempNode;
            &#125;
            return pre;
     &#125;
</code></pre>
<p>递归法（从前往后翻转）：</p>
<pre><code class="ts">function reverseList(head:ListNode | null):ListNode | null&#123;
    function recur(preNode:ListNode | null,curNode:ListNode | null):ListNode | null&#123;
        if(curNode===null) return preNode;
        let tempNode:ListNode | null = curNode.next;
        curNode.next = preNode;
        preNode = curNode;
        curNode = tempNode;
        return recur(preNode,curNode)
    &#125;
    return recur(null,head)
&#125;
</code></pre>
<p>【练习：24两两交换链表中的节点】</p>
<pre><code class="js">var swapPairs = function(head) &#123;
    // 首先创建一个新的节点
    const res = new ListNode(0,head);
    let temp = res;
    while(temp &amp;&amp; temp.next &amp;&amp; temp.next.next)&#123;
        const node1 = temp.next;
        const node2 = temp.next.next;
        temp.next=node2;
        node1.next=node2.next;
        node2.next=node1;
        temp=node1;
    &#125;
    return res.next;
&#125;;
</code></pre>
<p>【练习：19删除链表的倒数第N个节点】</p>
<p>双指针</p>
<pre><code class="js">var removeNthFromEnd = function(head, n) &#123;
    let pre = new ListNode(0,head),tail =head;
    let res = pre;
    while(n--)&#123;
        tail=tail.next
    &#125;
    while(tail)&#123;
        tail=tail.next;
        pre=pre.next;
    &#125;
    pre.next=pre.next.next;
    return res.next;
&#125;;
</code></pre>
<p>【练习：160相交链表】</p>
<p>时间复杂度：O(n) 或 O(m)</p>
<pre><code class="js">function getListLen(list)&#123;
    let len=0 , head = list;
    while(head)&#123;
        len++;
        head=head.next
    &#125;
    return len;
&#125;
function getIntersectionNode(head1,head2)&#123;
    let len1 = getListLen(head1),len2 = getListLen(head2),shortList=head1,bigList=head2;
    if(len2 &lt; len1)&#123;
        shortList = head2;
        bigList = head1;
    &#125;
    let i = Math.abs(len1 - len2);
    while(i-- &gt; 0)&#123;
        bigList=bigList.next;
    &#125;
    while(bigList &amp;&amp; bigList !== shortList)&#123;
        bigList=bigList.next;
        shortList=shortList.next;
    &#125;
        return bigList
&#125;
</code></pre>
<p>【练习：142环形链表】</p>
<pre><code class="js">var detectCycle = function(head) &#123;
    if(!head || !head.next) return null;
    let slow = head.next,fast = head.next.next;
    //当快慢指针都有值，并且快指针和慢指针不相等时循环
    while(fast &amp;&amp; fast.next &amp;&amp; fast !== slow)&#123;
        slow = slow.next;
        fast = fast.next.next;
    &#125;
    //此时判断是由于遍历结束，还是两值相等（有环）
    if(!fast || !fast.next) return null;
    slow = head;
    while(fast !== slow)&#123;
        slow = slow.next;
        fast = fast.next;
    &#125;
    return slow;
&#125;;
</code></pre>
<h2 id="哈希算法："><a href="#哈希算法：" class="headerlink" title="哈希算法："></a>哈希算法：</h2><h4 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h4><p>1 哈希表</p>
<p>也称散列表，数组就是一张哈希表，哈希表将元素和数组的下标相对应，这样就可以快速查询到数组中的某个元素。一般哈希表用于快速判断一个元素是否出现在集合里。如果查询数组中是否有某个元素，或者获取该元素，需要遍历整个数组（O(n)），但要是查询哈希表中是否有某个元素，只需要找数组对应下标的元素。</p>
<p>其中关键在于将元素和数组下标对应起来，这就是哈希函数:</p>
<p>2 哈希函数</p>
<p>哈希函数通过算法，将元素和数组下标对应起来，例如当存储元素为a-z的字母时，可以巧妙使用Unicode值：</p>
<pre><code class="js">const hashArr = [];
function hashFn(str)&#123;
    const index = str.charCodeAt() - &#39;a&#39;.charCodeAt();
    hashArr[index] = str;
&#125;
</code></pre>
<p>但是，某情况下无法避免两个元素所计算的下标相同的情况（哈希碰撞）</p>
<p>3 哈希碰撞</p>
<p>两个不同元素，通过哈希函数所计算出来的下标相同。</p>
<p>4 拉链法</p>
<p>拉链法用于解决哈希碰撞，发生碰撞的时候，将碰撞处以链表形式添加，就是适当选择哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多空间。</p>
<p>5 线性探测法</p>
<p>线性探测法当发生哈希碰撞时，根据碰撞位置向下寻找，知道找到空位。</p>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>【242】有效的字母异位词</p>
<pre><code class="js">var isAnagram = function(s, t) &#123;
    if(s.length !== t.length) return false;
    const arr = new Array(26).fill(0);
    const base = &quot;a&quot;.charCodeAt();
    for(const i of s)&#123;
        arr[i.charCodeAt() - base]++;
    &#125;
    for(const i of t)&#123;
        if(!arr[i.charCodeAt() - base]) return false;
        arr[i.charCodeAt() - base]--;
    &#125;
    return true;
&#125;;
</code></pre>
<p>【349】两个数组的交集</p>
<pre><code class="js">var intersection = function(nums1, nums2) &#123;
    const res = []
    const map = new Map()
    nums1.forEach(item=&gt;&#123;
        map.set(item,true);
    &#125;)
    nums2.forEach(item=&gt;&#123;
        if(map.get(item))&#123;
            res.push(item);
            map.delete(item);
        &#125;
    &#125;)
    return res
&#125;;
</code></pre>
<pre><code class="js">var intersection = function(nums1, nums2) &#123;
  return Array.from(new Set(nums1.filter(item=&gt;nums2.includes(item))));
&#125;;
</code></pre>
<p>【202】快乐数</p>
<pre><code class="js">var getSum = function (n) &#123;
    let sum = 0;
    while (n) &#123;
        sum += (n % 10) ** 2;
        n =  Math.floor(n/10);
    &#125;
    return sum;
&#125;
var isHappy = function(n) &#123;
    let set = new Set();   // Set() 里的数是惟一的
    // 如果在循环中某个值重复出现，说明此时陷入死循环，也就说明这个值不是快乐数
    while (n !== 1 &amp;&amp; !set.has(n)) &#123;
        set.add(n);
        n = getSum(n);
    &#125;
    return n === 1;
&#125;;
</code></pre>
<p>【1】两数之和</p>
<pre><code class="js">var twoSum =function (nums,target)&#123;
    const map =new Map();
    for (let i =0;i&lt;nums.length;i+=1)&#123;
    const n= nums[i];
    const n2 =target -n;
    if (map.has(n2))&#123;
        return [map.get(n2),i];
    &#125;
    else&#123;
         map.set(n,i); 
    &#125;
 &#125;
&#125;
</code></pre>
<p>【454】四数相加 ||</p>
<pre><code class="js">var fourSumCount = function(nums1, nums2, nums3, nums4) &#123;
    const towSumMap = new Map();
    let count = 0;
    for(const n1 of nums1)&#123;
        for(const n2 of nums2)&#123;
            const sum = n1 + n2;
            //如果map中有sum就get++，如果map中没有sum就set
            towSumMap.set(sum,(towSumMap.get(sum) || 0) + 1);
        &#125;
    &#125;
    for(const n3 of nums3)&#123;
        for(const n4 of nums4)&#123;
            const sum = n3 + n4;
            count += towSumMap.get(-sum) || 0;
        &#125;
    &#125;
    return count;
&#125;;
</code></pre>
<p>【383】赎金信</p>
<pre><code class="js">var canConstruct = function(ransomNote, magazine) &#123;
    if(magazine.length&lt;ransomNote.length) return false;
    const arr = new Array(26).fill(0);
    const base = &quot;a&quot;.charCodeAt();
    for(let i of magazine)&#123;
        arr[i.charCodeAt()-base]++;
    &#125;
    for(let i of ransomNote)&#123;
        let index = i.charCodeAt()-base;
        if(arr[index]===0)&#123;
            return false
        &#125;
        arr[index]--;
    &#125;
    return true;
&#125;;
</code></pre>
<p>【15】三数之和</p>
<pre><code class="js">var threeSum = function(nums) &#123;
    const res = [],len = nums.length;
    //将数组排序
    nums.sort((a,b)=&gt;a-b);
    console.log(nums);
    //遍历数组
    for(let i = 0;i&lt;len;i++)&#123;
        let l = i+1, r = len-1,iNum = nums[i];
        //判断首元素
        if(nums[i]&gt;0) return res;
        if(iNum == nums[i-1]) continue;
        while(l&lt;r)&#123;
            let lNum = nums[l],rNum = nums[r],threeSum = iNum+lNum+rNum;
            console.log(iNum,lNum,rNum);
            console.log(threeSum);
            if(threeSum&lt;0) l++;
            else if(threeSum&gt;0) r--;
            else&#123;
                res.push([iNum,lNum,rNum]);
                //去重
                while(l&lt;r &amp;&amp; nums[l]==nums[l+1])&#123;
                    l++;
                &#125;
                while(l&lt;r &amp;&amp; nums[r]==nums[r-1])&#123;
                    r--;
                &#125;
                l++;
                r--;
            &#125;
        &#125;
    &#125;
    return res
&#125;;
</code></pre>
<p>【18】四数之和   <strong>难点</strong></p>
<pre><code class="js">var fourSum = function(nums, target) &#123;
    const len = nums.length;
    if(len&lt;4) return [];
    nums.sort((a,b)=&gt;a-b);
    const res = [];
    for(let i=0;i&lt;len-3;i++)&#123;
        //去重
        if(i&gt;0 &amp;&amp; nums[i] === nums[i-1]) continue;
        for(let j =i+1;j&lt;len-2;j++)&#123;
            // 去重
            if(j&gt;i+1 &amp;&amp; nums[j]===nums[j-1]) continue;
            let l = j+1,r = len-1;
            while(l&lt;r)&#123;
                const sum = nums[i]+nums[j]+nums[l]+nums[r];
                if(sum&lt;target)&#123; l++;continue &#125;
                if(sum&gt;target)&#123; r--;continue &#125;
                res.push([nums[i],nums[j],nums[l],nums[r]]);
                while(l&lt;r &amp;&amp; nums[l]===nums[++l]);
                while(l&lt;r &amp;&amp; nums[r]===nums[--r]);
            &#125;
        &#125;
    &#125;
    return res;
&#125;;
</code></pre>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>【27】移除元素</p>
<pre><code class="js">let removeElement = (nums,val)=&gt;&#123;
    let k =0;
    for(let i of nums)&#123;
        if(i != val)&#123;
            nums[k++]=i;
        &#125;
    &#125;
    return k;
&#125;
</code></pre>
<p>【344】反转字符串</p>
<pre><code class="js">var reverse = function(s) &#123;
    let l = -1, r = s.length;
    while(++l &lt; --r) [s[l], s[r]] = [s[r], s[l]];
    return s;
&#125;;
</code></pre>
<p>【】替换数字</p>
<pre><code class="js">let replaceNumber = (nums)=&gt;&#123;
    let str = &#39;&#39;;
    for(let i of nums)&#123;
        if(!Object.is(Number(i),NaN))&#123;
        console.log(i);
        str += &#39;number&#39;;
        &#125;else&#123;
            str += i;
        &#125;
    &#125;
    return str;
&#125;
</code></pre>
<p>【151】翻转字符串里的单词</p>
<pre><code class="js">/**
 * 删除前后的空格
 */
function removeExtraSpaces(strArr)&#123;
    let slowIndex = 0,fastIndex = 0;
    while(fastIndex &lt; strArr.length)&#123;
        if(strArr[fastIndex] === &#39; &#39; &amp;&amp; (fastIndex === 0 || strArr[fastIndex -1]===&#39; &#39;))&#123;
            fastIndex++;
        &#125;else&#123;
            strArr[slowIndex++] = strArr[fastIndex++];
        &#125;
    &#125;
    // 移除末尾的空格
    strArr.length = strArr[slowIndex -1] === &#39; &#39; ? slowIndex -1:slowIndex;
&#125;
/**
 * 翻转从start到end的字符
 */
function reverse(strArr,start,end)&#123;
    let left = start;
    let right = end;
    while(left &lt; right)&#123;
        [strArr[left],strArr[right]] = [strArr[right],strArr[left]];
        left ++;
        right
    &#125;
&#125;
/**
 * 翻转字符串
 */
function reverseWords(s)&#123;
    const strArr = Array.from(s);
    removeExtraSpaces(strArr);
    reverse(strArr,0,strArr.length - 1);
    let start = 0;
    for(let i=0;i&lt;=strArr.length;i++)&#123;
        if(strArr[i] === &#39; &#39; || i === strArr.length)&#123;
            reverse(strArr,start,i -1);
            start = i+i;
        &#125;
    &#125;
    return strArr.join(&#39;&#39;);
&#125;
</code></pre>
<p> 【28】实现strStr()</p>
<p>自己实现：</p>
<pre><code class="js">var strStr = function(str1, str2) &#123;
    if(str2.length === 0) return 0;
    if(str2.length &gt; str1.length) return -1;
    let l=0, r =0,len = str1.length,len2;
    while(l &lt; len)&#123;
         if(str1[l] === str2[0])&#123;
            if(str2.length===1) return l;
            let i=1;
            for(;i&lt;str2.length;i++)&#123;
                if(str1[l+i] != str2[i])&#123;
                    break;
                &#125;
            &#125;
            len2 = i-1;
         &#125;
         if(len2===str2.length-1)&#123;
            return l;
         &#125;
         l++;
    &#125;
    return -1;
&#125;;
</code></pre>
<p> next数组前缀表统一减一</p>
<pre><code class="js">var strStr = function (haystack, needle) &#123;
    if (needle.length === 0)
        return 0;

    const getNext = (needle) =&gt; &#123;
        let next = [];
        let j = -1;
        next.push(j);

        for (let i = 1; i &lt; needle.length; ++i) &#123;
            while (j &gt;= 0 &amp;&amp; needle[i] !== needle[j + 1])
                j = next[j];
            if (needle[i] === needle[j + 1])
                j++;
            next.push(j);
        &#125;

        return next;
    &#125;

    let next = getNext(needle);
    let j = -1;
    for (let i = 0; i &lt; haystack.length; ++i) &#123;
        while (j &gt;= 0 &amp;&amp; haystack[i] !== needle[j + 1])
            j = next[j];
        if (haystack[i] === needle[j + 1])
            j++;
        if (j === needle.length - 1)
            return (i - needle.length + 1);
    &#125;

    return -1;
&#125;;
</code></pre>
<p> 【459】重复的子字符串</p>
<pre><code class="js">var repeatedSubstringPattern = function (s) &#123;
    let str = s + s;
    return str.slice(1, str.length - 1).includes(s);
&#125;;
</code></pre>
<p>next数组实现</p>
<pre><code class="js">var repeatedSubstringPattern = function (s) &#123;
    if (s.length === 0) return false;
    const getNext = (s) =&gt; &#123; //得到next数组
        let next = [];
        let j = -1;
        next.push(j); //next数组第一个是-1
        for (let i = 1; i &lt; s.length; ++i) &#123; //遍历s的长度
            while (j &gt;= 0 &amp;&amp; s[i] !== s[j + 1]) 
                j = next[j];
            if (s[i] === s[j + 1])
                j++;
            next.push(j);
        &#125;
        return next;
    &#125;
    let next = getNext(s); //得到next数组
    if (next[next.length - 1] !== -1 &amp;&amp; s.length % (s.length - (next[next.length - 1] + 1)) === 0)&#123;
        // next数组最后一个元素不等于-1 并且 字符串的长度取余next数组最后一个元素
        return true;
    &#125;
    return false;
&#125;;
</code></pre>
<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>【27】移除元素</p>
<pre><code class="js">var removeElement = function(nums, val) &#123;
    let i =0 ,len = nums.length-1;
    while(i&lt;=len)&#123;
        if(nums[i]===val)&#123;
            nums[i]=nums[len];
            len--;
            i--;
        &#125;
        i++;
    &#125;
    nums.length = len+1;
    return len+1;
&#125;;
</code></pre>
<p>【344】反转字符串</p>
<pre><code class="js">var reverseString = function(s) &#123;
    let i =0,j=s.length-1;
    while(i&lt;=j)&#123;
        [s[i],s[j]] = [s[j],s[i]];
        j--;
        i++;
    &#125;
    return s;
&#125;;
</code></pre>
<p>【】替换数字</p>
<pre><code class="js">function reverseNumber(str)&#123;
    let i = 0,res = &#39;&#39;;
    while(i&lt;str.length)&#123;
        if(Object.is(+str[i],NaN))&#123;
            console.log(str[i]);
            res+=str[i]
        &#125;else&#123;
            console.log(str[i]);
            res+=&#39;number&#39;;
        &#125;
        i++;
    &#125;
    return res;
&#125;
</code></pre>
<p>【151】翻转字符串里的单词</p>
<pre><code class="js">var reverseWords = function(s) &#123;
    return s.split(/\s+/).reverse().join(&#39; &#39;).trim();
&#125;;
</code></pre>
<p>【160】链表相交</p>
<p>链表后长度统一：</p>
<pre><code class="js">
function getListLen(list)&#123;
    let len=0 , head = list;
    while(head)&#123;
        len++;
        head=head.next
    &#125;
    return len;
&#125;
function getIntersectionNode(head1,head2)&#123;
    let len1 = getListLen(head1),len2 = getListLen(head2),shortList=head1,bigList=head2;
    if(len2 &lt; len1)&#123;
        shortList = head2;
        bigList = head1;
    &#125;
    let i = Math.abs(len1 - len2);
    while(i-- &gt; 0)&#123;
        bigList=bigList.next;
    &#125;
    while(bigList &amp;&amp; bigList !== shortList)&#123;
        bigList=bigList.next;
        shortList=shortList.next;
    &#125;
        return bigList
&#125;
</code></pre>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>队列是先进先出，栈是先进后出。</p>
<h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>【232】用栈实现队列</p>
<pre><code class="js">//实现链表
class listNode &#123;
    constructor(val,next=null)&#123;
        this.val = val;
        this.next = next;
    &#125;
&#125;
//实现栈
class Stack&#123;
    constructor()&#123;
         this.items = []
    &#125;
&#125;
Stack.prototype.push = function(val)&#123;
    return this.items.push(val);
&#125;
Stack.prototype.pop = function()&#123;
    return this.items.pop();
&#125;
Stack.prototype.peek = function()&#123;
    return this.items[this.items.length - 1]
&#125;
Stack.prototype.isEmpty = function()&#123;
    return this.items.length === 0;
&#125;
Stack.prototype.size = function()&#123;
    return this.items.length;
&#125;
//用栈实现队列
class MyQueue&#123;
    constructor()&#123;
        this.stackIn = new Stack();
        this.stackOut = new Stack();
    &#125;
&#125;

MyQueue.prototype.push = function(x) &#123;
    this.stackIn.push(x);
&#125;;

MyQueue.prototype.pop = function() &#123;
    const size = this.stackOut.size();
    if(size)&#123;
        return this.stackOut.pop();
    &#125;
    while(this.stackIn.size())&#123;
        this.stackOut.push(this.stackIn.pop());
    &#125;
    return this.stackOut.pop();
&#125;;

MyQueue.prototype.peek = function() &#123;
    const size = this.stackOut.size();
    if(size) &#123;
        return this.stackOut[this.stackOut.size() - 1];
    &#125;
    while(this.stackIn.size())&#123;
        this.stackOut.push(this.stackIn.pop());
    &#125;
    return this.stackOut.peek();
&#125;;

MyQueue.prototype.empty = function() &#123;
    return !this.stackOut.size() &amp;&amp; !this.stackIn.size()
&#125;;
</code></pre>
<p>【225】用队列实现栈</p>
<pre><code class="js">//队列模拟栈
class Queue &#123;
    constructor()&#123;
        this.items = [];
    &#125;
&#125;
Queue.prototype.shift = function()&#123;
    return this.items.shift();
&#125;
Queue.prototype.push = function(val)&#123;
    return this.items.push(val);
&#125;
Queue.prototype.size = function()&#123;
    return this.items.length;
&#125;
Queue.prototype.peek = function()&#123;
    return this.items[0];
&#125;

class Stack&#123;
    constructor()&#123;
        this.queueIn = new Queue();
        this.queueOut = new Queue();
    &#125;
&#125;
Stack.prototype.push = function(val)&#123;
    this.queueIn.push(val);
&#125;
Stack.prototype.pop = function()&#123;
    if(!this.queueIn.size())&#123;
        [this.queueIn,this.queueOut] = [this.queueOut,this.queueIn];
    &#125;
    while(this.queueIn.size() &gt; 1)&#123;
        this.queueOut.push(this.queueIn.shift());
    &#125;
    return this.queueIn.shift();
&#125;
Stack.prototype.top = function()&#123;
    const x = this.pop();
    this.queueIn.push(x);
    return x;
&#125;
Stack.prototype.empty = function()&#123;
    return !this.queueIn.size() &amp;&amp; !this.queueOut.size()
&#125;
</code></pre>
<p>【1047】删除字符串中的所有相邻重复项</p>
<pre><code class="js">const removeDuplicates = (str)=&gt;&#123;
    //使用栈
    const resArr = []
    for(let i of str)&#123;
        if(resArr[resArr.length - 1] === i)&#123;
            resArr.pop();
        &#125;else&#123;
            resArr.push(i);
        &#125;
    &#125;
    return resArr.join(&#39;&#39;)
&#125;
</code></pre>
<p>【150】逆波兰表达式求值</p>
<pre><code class="js">/**
 * @param &#123;string[]&#125; tokens
 * @return &#123;number&#125;
 */
var evalRPN = function(tokens) &#123;
    //维持一个栈
    const stack = [];
    for(const token of tokens)&#123;
        if(isNaN(+token))&#123;
            const n2 = stack.pop();
            const n1 = stack.pop();
            switch(token)&#123;
                case &quot;+&quot;:
                     stack.push(n1 + n2);
                     break;
                case &quot;-&quot;:
                     stack.push(n1 - n2);
                     break;
                case &quot;*&quot;:
                     stack.push(n1 * n2);
                     break;
                case &quot;/&quot;:
                     stack.push(n1 / n2 | 0);
                     break;
            &#125;
        &#125;else&#123;
            stack.push(+token);
        &#125;
    &#125;
    return stack[0];
&#125;;
</code></pre>
<p>【239】滑动窗口最大值（难点）</p>
<p>使用队列：</p>
<pre><code class="js">var maxSlidingWindow = function (nums, k) &#123;
    class MonoQueue &#123;
        queue;
        constructor() &#123;
            this.queue = [];
        &#125;
        enqueue(value) &#123;
            let back = this.queue[this.queue.length - 1];
            while (back !== undefined &amp;&amp; back &lt; value) &#123;
                this.queue.pop();
                back = this.queue[this.queue.length - 1];
            &#125;
            this.queue.push(value);
        &#125;
        dequeue(value) &#123;
            let front = this.front();
            if (front === value) &#123;
                this.queue.shift();
            &#125;
        &#125;
        front() &#123;
            return this.queue[0];
        &#125;
    &#125;
    let helperQueue = new MonoQueue();
    let i = 0, j = 0;
    let resArr = [];
    while (j &lt; k) &#123;
        helperQueue.enqueue(nums[j++]);
    &#125;
    resArr.push(helperQueue.front());
    while (j &lt; nums.length) &#123;
        helperQueue.enqueue(nums[j]);
        helperQueue.dequeue(nums[i]);
        resArr.push(helperQueue.front());
        i++, j++;
    &#125;
    return resArr;
&#125;;
</code></pre>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>1、满二叉树</p>
<p>如果一棵二叉树只有度为0的结点和度为2的结点，并且<strong>度为0的结点在同一层上</strong>，则这颗二叉树就为满二叉树。</p>
<p>2、完全二叉树</p>
<p>在完全二叉树中，除了最底层节点可能没填满之外，其余每层结点数都达到最大值，并且最下面一层的结点都集中在该层最左边的若干位置。</p>
<p>3、二叉搜索树</p>
<p>二叉搜索树是一个有序树（左&lt;中&lt;右的排序向下递归）：</p>
<ul>
<li>若左子树不空，则左子树所有结点均小于它的根节点的值</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根节点的值</li>
<li>它的左右子树也分别为二叉搜索树</li>
</ul>
<p>4、平衡二叉树（左子树右子树高度差不超过1的方式向下递归）</p>
<p>平衡二叉树是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。</p>
<p>5、红黑树</p>
<p>当二叉搜索树插入序列是有序的时候会出现退化的情况，变成链表（查询速度变慢），这时使用平衡树，在插入的时候调整这棵树，让它的节点尽可能地均匀分布，变为平衡二叉搜索树。</p>
<p>红黑树其实就是平衡树的一种，它的复杂定义和规则都是为了保证树的平衡性。红黑树是一种更为宽松的二叉平衡搜索树，相对于二叉平衡搜索树，它的平衡条件更加宽松，可以容忍一定程度的不平衡。</p>
<p>保证树的平衡的意义：因为树的查找性能取决于树的高度，让树尽可能平衡就是为了降低树的高度。</p>
<p>6、B树</p>
<p>B树是一种<strong>多路搜索树</strong>，它的每个节点可以拥有多于两个孩子节点。M路的B树最多能拥有M个孩子节点。路数越多，树的高度越低。不限制路数，B树就退化成一个有序数组了。</p>
<p><strong>B树常用于文件系统的索引</strong>，文件系统和数据库的索引都是存在硬盘上的，如果数据量大的话，不一定能一次性加载到内存中（运行时内存）。这时就需要使用<strong>B树多路存储</strong>的威力，可以每次加载B树的一个节点，然后一步步往下找。</p>
<p>在内存中，红黑树确实比B树效率更高，但是当涉及到磁盘操作时，B树就更优了。</p>
<p>7、B+树</p>
<p>B+树是在B树的基础上进行改造的，它的数据都在叶子节点，同时叶子节点之间还加了指针形成链表。</p>
<p><strong>B+树在数据库索引中用的比较多</strong>，数据库中 Select 数据，不一定只选一条，很多时候会选多条。如果是多条的话，B 树需要做局部的中序遍历，可能要跨层访问。而 B+ 树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ul>
<li><p>用数组存储：如果父节点数组下标是i，则它的左孩子就是  i * 2 + 1 , 右孩子就是  i * 2 + 2 </p>
</li>
<li><p>用链表存储：用左右指针进行存储</p>
<pre><code class="ts">class TreeNode &#123;
    public val: number;
    public left: TreeNode | null
    public right: TreeNode | null
    constructor(val: number,left?: TreeNode,right?: TreeNode)&#123;
        this.val = val === undefined ? 0 : val;
        this.left = left === undefined ? null : left;
        this.right = left === undefined ? null : right;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>二叉树的遍历方式有：（中间节点的顺序就是所谓的遍历方式）</p>
<ul>
<li>前序遍历：中 左 右</li>
<li>中序遍历：左 中 右</li>
<li>后序遍历： 左 右 中</li>
</ul>
<p><strong>二叉树的递归遍历：</strong></p>
<pre><code class="ts">// 前序遍历
function preorderTracersal(node:TreeNode | null): number[]&#123;
    function traverse(node:TreeNode | null,res: number[]):void &#123;
        if(node === null) return ;
        res.push(node.val);
        traverse(node.left,res);
        traverse(node.right,res);//中序遍历和后序遍历除了此处顺序不同之外，其余都相同
    &#125;
    const res: number[] = [];
    traverse(node,res);
    return res;
&#125;
</code></pre>
<p><strong>二叉树的迭代遍历（需要维持一个栈）：</strong></p>
<pre><code class="ts">// 前序遍历（迭代法）
function preorderTraversal(root: TreeNode | null): number[] &#123;
    if (root === null) return [];
    let res: number[] = [];
    let helperStack: TreeNode[] = [];
    let curNode: TreeNode = root;
    helperStack.push(curNode);
    while (helperStack.length &gt; 0) &#123;
        curNode = helperStack.pop()!;
        res.push(curNode.val);
        if (curNode.right !== null) helperStack.push(curNode.right);
        if (curNode.left !== null) helperStack.push(curNode.left);
    &#125;
    return res;
&#125;;

// 中序遍历（迭代法）
function inorderTraversal(root: TreeNode | null): number[] &#123;
    let helperStack: TreeNode[] = [];
    let res: number[] = [];
    if (root === null) return res;
    let curNode: TreeNode | null = root;
    while (curNode !== null || helperStack.length &gt; 0) &#123;
        if (curNode !== null) &#123;
            helperStack.push(curNode);
            curNode = curNode.left;
        &#125; else &#123;
            curNode = helperStack.pop()!;
            res.push(curNode.val);
            curNode = curNode.right;
        &#125;
    &#125;
    return res;
&#125;;

// 后序遍历（迭代法）
function postorderTraversal(root: TreeNode | null): number[] &#123;
    let helperStack: TreeNode[] = [];
    let res: number[] = [];
    let curNode: TreeNode;
    if (root === null) return res;
    helperStack.push(root);
    while (helperStack.length &gt; 0) &#123;
        curNode = helperStack.pop()!;
        res.push(curNode.val);
        if (curNode.left !== null) helperStack.push(curNode.left);
        if (curNode.right !== null) helperStack.push(curNode.right);
    &#125;
    return res.reverse();
&#125;;
</code></pre>
<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列:"></a>最长递增子序列:</h1><p>在计算机科学中，最长递增子序列问题（英语：longest increasing subsequence problem）的目标是找到一个给定序列的子序列，其中子序列的元素按升序排序，并且子序列尽可能长。该子序列不一定是连续的或唯一的。最长递增连续性是在与数学相关的各种学科的背景下研究的，包括算法论，随机矩阵理论，表示论和物理学。 [<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlI2NpdGVfbm90ZS0x">1]</span> [<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlI2NpdGVfbm90ZS1yb21pay0y">2]</span> 最长递增子序列问题在时间上是可解的<img data-src="https://wikimedia.org/api/rest_v1/media/math/render/svg/497720dca0f6c8c6268f7a1332b993e597136e8b" alt="{\displaystyle O(n\log n),}"> 其中n表示输入序列的长度</p>
<p>技术blog，云服务器域名。</p>

      <div class="tags">
          <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="ic i-tag"></i> 算法</a>
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="ic i-tag"></i> 数据结构</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-05-20 09:02:34" itemprop="dateModified" datetime="2024-05-20T09:02:34+08:00">2024-05-20</time>
  </span>
  <span id="2023/12/02/算法/" class="item leancloud_visitors" data-flag-title="算法与数据结构" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="dmq 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="dmq 支付宝">
        <p>支付宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>dmq <i class="ic i-at"><em>@</em></i>杜明清的个人博客
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://dmqweb.cn/2023/12/02/%E7%AE%97%E6%B3%95/" title="算法与数据结构">https://dmqweb.cn/2023/12/02/算法/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/11/02/vue%E5%8E%9F%E7%90%86/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.uuu.ovh&#x2F;imgs&#x2F;2024&#x2F;04&#x2F;25&#x2F;1b093314ebaab948.jpg" title="vue原理">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> vue</span>
  <h3>vue原理</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/12/02/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.uuu.ovh&#x2F;imgs&#x2F;2024&#x2F;04&#x2F;15&#x2F;21b7a3f222ccbcb6.jpg" title="JS类型转换">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> JS</span>
  <h3>JS类型转换</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%86%E9%A2%91%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">数据结构视频：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%EF%BC%9A%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA"><span class="toc-number">2.</span> <span class="toc-text">栈：后进先出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%9A%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">队列：先进先出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8"><span class="toc-number">4.</span> <span class="toc-text">链表：非连续存储</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%EF%BC%9A%E6%97%A0%E5%BA%8F%E4%B8%94%E5%94%AF%E4%B8%80"><span class="toc-number">5.</span> <span class="toc-text">集合：无序且唯一</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%EF%BC%9A%E9%94%AE%E5%80%BC%E5%AF%B9%E6%98%A0%E5%B0%84%EF%BC%88%E9%94%AE%E4%B8%8D%E9%87%8D%E5%A4%8D%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">字典：键值对映射（键不重复）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">哈希表:散列的数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E4%BB%BB%E6%84%8F%E9%95%BF%E5%BA%A6%E8%BE%93%E5%85%A5%E8%BD%AC%E4%B8%BA%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E8%BE%93%E5%87%BA"><span class="toc-number">8.</span> <span class="toc-text">哈希算法:任意长度输入转为固定长度输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%EF%BC%9A%E5%88%86%E5%B1%82%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">树：分层抽象数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91"><span class="toc-number">9.1.</span> <span class="toc-text">【二叉树】</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">图：网络结构抽象模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%EF%BC%9A%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">11.</span> <span class="toc-text">堆：特殊的完全二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2"><span class="toc-number">12.</span> <span class="toc-text">排序和搜索</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">13.</span> <span class="toc-text">算法设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-number">13.0.1.</span> <span class="toc-text">分而治之</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">13.0.2.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">13.0.3.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">13.0.4.</span> <span class="toc-text">回溯算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3%E5%BD%95"><span class="toc-number">14.</span> <span class="toc-text">代码思想录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">14.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">14.2.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">14.3.</span> <span class="toc-text">数组算法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">14.3.0.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">14.3.0.2.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">14.3.0.3.</span> <span class="toc-text">移除元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">14.4.</span> <span class="toc-text">链表算法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA-1"><span class="toc-number">14.4.0.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">14.4.0.2.</span> <span class="toc-text">题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">14.5.</span> <span class="toc-text">哈希算法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA-2"><span class="toc-number">14.5.0.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-number">14.5.0.2.</span> <span class="toc-text">题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">14.6.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-number">14.6.0.1.</span> <span class="toc-text">题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95"><span class="toc-number">14.7.</span> <span class="toc-text">双指针算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="toc-number">14.7.0.1.</span> <span class="toc-text">题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">14.8.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="toc-number">14.8.0.1.</span> <span class="toc-text">题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">14.9.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">14.9.0.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">14.9.0.2.</span> <span class="toc-text">存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">14.9.0.3.</span> <span class="toc-text">遍历</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">15.</span> <span class="toc-text">最长递增子序列:</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2023/06/02/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="bookmark" title="图片上传解决方案">图片上传解决方案</a></li><li class="active"><a href="/2023/12/02/%E7%AE%97%E6%B3%95/" rel="bookmark" title="算法与数据结构">算法与数据结构</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="dmq"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">dmq</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">74</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">56</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">96</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtcTA/dGFiPXJlcG9zaXRvcmllcw==" title="https:&#x2F;&#x2F;github.com&#x2F;dmq0?tab&#x3D;repositories"><i class="ic i-github"></i></span>
      <span class="exturl item npm" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL35kbXEwMDA=" title="https:&#x2F;&#x2F;www.npmjs.com&#x2F;~dmq000"><i class="ic i-file"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9kLTg4LTYxLTgz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;d-88-61-83"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwMjc4OTk0OTE=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;8027899491"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vdS83NjI1OTAxNzE3" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7625901717"><i class="ic i-weibo"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOjMyNjc4MDc1MTRAcXEuY29t" title="mailto:3267807514@qq.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>介绍</a>
  </li>

    
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

    
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

    
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>工具</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/11/02/vue%E5%8E%9F%E7%90%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/12/02/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E9%83%A8%E7%BD%B2/" title="分类于 持续集成与部署">持续集成与部署</a>
</div>

    <span><a href="/2024/02/03/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/" title="持续集成与持续部署">持续集成与持续部署</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/JS/" title="分类于 JS">JS</a>
</div>

    <span><a href="/2024/05/08/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/" title="函数重载">函数重载</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 计算机组成原理">计算机组成原理</a>
</div>

    <span><a href="/2023/07/02/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/" title="浮点数存储">浮点数存储</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/JS/" title="分类于 JS">JS</a>
</div>

    <span><a href="/2023/07/02/forEach/" title="forEach">forEach</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" title="分类于 网络安全">网络安全</a>
</div>

    <span><a href="/2024/05/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" title="网络安全">网络安全</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/" title="分类于 渲染模式">渲染模式</a>
</div>

    <span><a href="/2023/05/17/%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/" title="渲染模式">渲染模式</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/typeScript/" title="分类于 typeScript">typeScript</a>
</div>

    <span><a href="/2023/12/11/TS/" title="typeScript笔记">typeScript笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/JS%E5%BA%95%E5%B1%82/" title="分类于 JS底层">JS底层</a>
</div>

    <span><a href="/2023/06/02/new%E5%85%B3%E9%94%AE%E5%AD%97/" title="new关键字的实现">new关键字的实现</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/vue/" title="分类于 vue">vue</a>
</div>

    <span><a href="/2023/09/02/vue3%E6%BA%90%E7%A0%81%E4%BD%8D%E8%BF%90%E7%AE%97/" title="vue3源码中的位运算">vue3源码中的位运算</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/JS/" title="分类于 JS">JS</a>
</div>

    <span><a href="/2024/01/11/webworker/" title="webWorker">webWorker</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">dmq @ Web blog</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/12/02/算法/',
    favicon: {
      show: "科技引领未来",
      hide: "欢迎与我交流"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//gcore.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9ba187659e850a6910681214f0faa16b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</body>
</html>
