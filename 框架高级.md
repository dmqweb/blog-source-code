---
title: 框架高级
date: 2024-7-26 12:24:4
categories:
- 框架高级
tags:
- 框架高级
---

# vue高级用法
### watchEffect函数
> 立即运行传入的函数，同时自动追踪其依赖，并在依赖更改时重新执行。
> watchEffect的返回值是用于清除该副作用的函数。
```js
const data = ref(0);
const stop = watchEffect(()=>console.log(data.value,'data变化了'));
stop(); //清除响应性监听
```
> watchEffect的第二个参数是options配置项，可以配置flush、onTrack函数和onTrigger函数
```js
watchEffect(()=>{},{
    flush:"post", //flush配置项配置回调函数的刷新时机，post会在DOM渲染之后触发、sync会在vue进行任何更新之前进行触发
    onTrack(e){debugger};
    onTrigger(e){debugger};
})
```
### watchSyncEffect函数
> 回调函数会在DOM渲染之后触发,相当于watchEffect中配置了fulsh:"post"
### watchSyncEffect函数
> 回调函数在vue进行任何更新之前触发,相当于watchEffect中配置了fulsh:"sync"
### effectScope函数
> effectScope函数创建一个effect作用域，可以捕获其中所创建的响应式副作用（即计算属性和侦听器），这样捕获到的副作用可以一起处理。
```javascript
const scope = effectScope();
scope.run(()=>{
  const doubled = computed(() => counter.value * 2)
  watch(doubled, () => console.log(doubled.value))
  watchEffect(() => console.log('Count: ', doubled.value))
})
scope.stop(); //清除掉作用域内所有的effect
```
### getCurrentScope函数
> 获取当前活跃的effect作用域
### onScopeDispost函数
> 在当前活跃的effect作用域上注册一个处理回调函数。当相关的effect作用域停止时会调用这个回调函数。
### shallowRef函数
> 用于浅层响应式,避免深层比较带来的效率问题
### triggerRef函数
> 强制触发依赖于一个浅层ref的副作用，通常在对浅引用的内部值进行深度变更后使用
### customRef函数
> customRef函数创建一个自定义的ref，显示声明对其依赖追踪和更新触发的控制方式。预期接受一个工厂函数作为参数，这个工厂函数接收track和trigger两个函数作为参数，并返回一个带有get和set方法的对象
```js
// 定义一个返回懒执行响应式数据的函数
function useDebouncedRef(value,delay=200){
    let timeout;
    return customRef((track,trigger)=>{
        return {
            get(){
                track();
                return value;
            },
            set(newValue){
                clearTimeout(timeout);
                timeout = setTimeout(()=>{
                    value = newValue;
                    trigger();
                },delay)     
            }
        }
    })
}
```
### shallowReactive
> shallowReactive是reactive的浅层作用形式，只有跟级别的属性是响应式的，属性的值会被原样存储和暴露，这也意味着值为ref的属性不会被自动解包了。
### shallowReadonly
> shallowReadonly是readonly的浅层作用形式。
### isRef函数
> 用于检查某个值是否是ref
### unref函数
> 如果是ref，返回ref内部的值，否则返回参数本身
### toRef函数
- 传入ref返回ref本身
- 传入props.key创建一个只读的ref
- 传入number或者string相当于ref函数
- 传入响应式数据和键值会封装为一个ref，但是相比于直接封装ref来说，会与源属性进行同步
  ```js
  const state = reactive({foo:1,bar:2});
  const fooRef = toRef(state,'foo'); //fooRef会和state的响应性相关联
  const fooRef2 = ref(state.foo); //fooRef2不会和state.foo的响应性相关联
  ```
### toRefs函数
> vue3中的ref将reactive响应性绑定到.value属性上，其本质就是为了防止开发者错误的将响应式数据进行解构后的变量又其当作响应式数据。所以加了一层隔离。toRefs函数也是用于解决这个问题。
> 将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的ref。每个单独的ref都是使用toRef创建的
```js
const state = reactive({
  name:"张三",
  age:18  
})
const stateAsRefs = toRefs(state);
state.name = "李四"; //toRefs返回的响应式数据和原响应式数据相互关联
console.log(stateAsRefs.name.value) //李四
//toRefs的存在是为了保证reactive响应式被解构之后仍然存在响应性
const {name,age} = toRefs(state)
//解构之后的name和age都是响应式对象
```
### toRaw函数
> toRaw返回由reactive、readonly、shallowReactive或者shallowReadonly创建的代理对应的原始对象（栈赋值），返回的对象不再具有响应式，栈赋值时不会影响到页面的展示，但如果改变该对象的堆中的属性，原对象的依赖项也会随之变化
### markRaw函数
> 将一个对象标记为不可被转为代理，返回该对象本身
### toValue函数
> 将值、函数、或响应式数据规范化为普通值，toValue(ref(1)) ---> 1
### isProxy函数
> 检查一个对象是否是由reactive、readonly、shallowReactive或者shallowReadonly创建的代理。
### isReactive函数
> 检查一个对象是否是由reactive或shallowReactive创建的代理
### isreadonly函数
> 检查传入的值是否是只读对象，只读对象的属性可以更改，但是不能通过传入的对象直接赋值。
### Transition组件
- 使用过渡样式
- mode属性定义动画进行的顺序,常用out-in 
- name属性定义动画的名称,配合css使用
- appear属性初次渲染过渡
- 生命周期钩子用于自定义过渡中执行过程,依次是before-enter,enter,after-enter,enter-cancelled,before-leave,leave,leave-cancelled,可用的参数有el和done()
- css样式过渡:name-enter-from\name-enter-active\name-enter-to\name-leave-from\name-leave-active\name-leave-to定义对应时期的样式(只对可以过渡变化的样式生效)
### TransitionGroup组件
- TransitionGroup组件用于对v-for列表中的元素或组件插入 、移除或顺序变化添加动画效果.
- 属性和生命周期和Transition一样
- tag属性可以指定TransitionGroup为一个容器
### KeepAlive组件
- KeepAlive用于在多个组件间切换状态时缓存被移除的组件实例(使组件保存状态)
- KeepAlive的原理就是当KeepAlive中的组件被移除时,用变量将整个组件缓存起来,需要切换时直接使用缓存起来的变量
- include和exclude属性用于包含或排除对应的组件name
- KeepAlive的组件包含onActivated和onDeactived两个生命周期钩子
### Teleport组件
- Teleport组件,用于将组件内部的一部分模板传送到外部结构中去
- to属性用于指定传送到的组件或者DOM元素
### Suspense组件
- Suspense组件用于显示异步组件加载中的显示状态
- Suspense组件中fallback具名插槽用于显示加载内容
- Suspense组件嵌套Suspense组件时,给内部Suspense组件加上suspensible属性表示为异步组件,否则则会被父级Suspense组件视为同步组件
### watch的options配置项
> watch的options配置项中可以使用:
- immediate,为true时会在初始化时立即执行一次
- deep,为true时会深度监听对象堆中变化
- flush,调整回调函数的执行时机
- once,回调函数只会执行一次
- onTrack函数,当响应式被收集时进行触发**只在开发模式下有效**
- onTrigger函数,当依赖项变更时进行触发**只在开发模式下有效**
### computed的options配置项
- onTrack函数,当响应式被收集时进行触发**只在开发模式下有效**
- onTrigger函数,当依赖项变更时进行触发**只在开发模式下有效**
### vue对jsx的支持友好
- 在vue中也可以很方便的去集成jsx或tsx语法，tsx语法需要在tsconfig.json中配置：jsx：preserve，最终的jsx语法会被转换为h函数
- 对于事件和案件修饰符，可以使用vue中的withModifiers函数
### vue对web component的支持友好
- 在 Vue 应用中使用自定义元素基本上与使用原生 HTML 元素的效果相同
- 需要在构建工具中配置compilerOptions.isCustomElement这个选项
- 传递ODM属性时，需要使用v-bind绑定，通过.prop修饰符进行设置
  ```html
  <my-element :user.prop="{ name: 'jack' }"></my-element>
  <!-- 等价简写 -->
  <my-element .user="{ name: 'jack' }"></my-element>
  ```
- 使用vue构建web component需要使用defineCustomElement这个方法定义出组件，然后通过customElement.define这个方法将vue组件添加标签到HTML中
### web component的优缺点
- 全部使用自定义元素来构建应用的方式可以使得应用永不过时和多平台、框架共享
- 但是设想与显示总是存在偏差：
- - 1、原生web component并不具备响应式的系统
- - 2、原生web component并不具备一个声明式的、高效的模板系统
- - 3、SSR渲染时，web component需要在node.js中模拟出DOM，这将增大服务器端的压力
- - 4、当下要想使用shadow DOM书写局部作用域的CSS，必须要将样式嵌入到JavaScript中才可以在运行时注入到shadow root上，这将导致SSR场景下需要渲染大量重复的样式标签。
### vue结合js动画库
- 以gsap为例，vue结合js动画库实现动画效果时，不能直接对响应式变量进行动画设置，因为是响应式完成之后才被监听到，此时响应式变量已经是最新的值，所以应该再来一个响应式变量中转一下，页面动画效果绑定的是中转的变量。
### vue生命周期
- vue3中setup替代了beforeCreate和created
- beforeMount、monuted、beforeUpdate、updated、beforeUnmount、unMounted
- 错误捕获钩子：onErrorCaptured，如果在onErrorCaptured中抛出一个错误，则会被app.config.errorHandler捕获到
- 开发时钩子：onRenderTracked（组件渲染过程中追踪到响应式依赖时调用）和onRenderTriggered（当响应式依赖触发了组件渲染时调用）
- SSR钩子：onServerPrefetch（注册一个异步函数，在组件实例在服务器上被渲染之前调用），SSR渲染时，组件作为初始请求的一部分被渲染，这时可以在服务器上预请求数据，因为它比在客户端上更快。
- keepAlive组件下的钩子：onActivated和onDeactivated两个，用于当组件激活和失活时调用

# React
## Fiber
> Fiber架构：Fiber架构是一个增量渲染，架构风格类似协程，Fiber架构出现的原因是由于 JS 单线程执行的特性当遇到繁琐的执行任务时，原来React15的协调过程就会很长，从而延迟DOM的渲染更新，进而出现掉帧。Fiber架构将任务分给一个个的迭代器进行执行，并且使迭代器的执行过程发生在浏览器的空闲时间，从而最大程度利用了这部分资源，使得UI渲染不会被大量执行任务所阻塞。
> fiber树：fiber树是一个数据结构，架构在虚拟DOM转换到真实DOM之间，在Fiber结构中的任务是可以中断执行的，继续执行时会丢弃掉原来的工作从头再来，并且重新执行中断的任务，对用于来说也是无感的，因为Fiber架构的视图更新是后缓冲区视图 替换 前缓冲区视图的过程。
> 由于Fiber架构下的reconciler协调阶段是异步可中断的，且会被反复重新执行，使得反复执行时有可能触发的生命周期钩子被废弃，例如：componentWillMount、componentWillReceiveProps、componentWillUpdate这些。
> fiber树（fiber节点构成的树状链表）的遍历与执行：
  - fiber树遍历：children子节点----sibling兄弟节点----return父节点
  - fiber树的执行：遍历到最底层子节点A----A的兄弟节点-----A的父节点B------B的兄弟节点（深度优先遍历）
> fiber节点（对象）：一个fiber节点对应一个React 组件，fiber节点里包含了组件的work任务等信息，比如组件的Hooks执行逻辑（它是一个链表，可以通过memorizedState拿到跟节点，Hooks执行逻辑里面存储了state）、生命周期、对于html组件的增删改查等副作用
> 当执行fiber节点中的任务时，每次执行完之后React就会检查当前帧还剩多少时间，没有时间就会将控制权让出去。
### fiber树、VDOM和diff算法
> fiber树就是VDOM,fiber树的变化反映了组件的状态变化
> diff算法的本质就是: 对比`current fiber` 和 `JSX对象` 生成 `work-in-progress-fiber`
> 即使是最前沿的算法,完全对比两棵树的时间复杂度也需要O(n^3),其中
## Hooks
> 注意：react Hooks只能在件顶层进行调用并且不能写在条件判断中，这是因为hooks以链表的形式存放在fiber节点中（类组件的副作用也存在fiber节点中），每次更新时会基于链表的顺序进行调用，而调用hooks所产生的state就存在于hooks节点之中，如果hooks写在条件判断中则导致hooks链表执行混乱，使得状态更新出错。
## workLoop工作循环
> workLoop中会根据当前帧的剩余时间去执行fiber节点中的任务,如果时间不够就将控制权转给UI渲染,并保存当期的执行上下文(包括当前fiber节点的状态),当UI渲染完毕后,恢复其执行(执行到一半的任务会重新执行)
## 双缓冲策略
> 双缓冲策略是用于减少组件渲染过程中的闪烁和卡顿。双缓冲策略是对于fiber树来说的
> 双缓冲策略会维护两个Fiber树：Work-in-progress-fiber树 和 current-fiber树。协调过程中React会比较新旧两个fiber树的差异，从而确定哪些组件需要更新。一旦新的fiber树构建完成，React就会使用diff算法去更新真实DOM。更新完成后会将工作Fiber树的根节点与当前Fiber树的根节点进行交换，这个过程叫做提交。
### Fiber更新的三个阶段
- 开始阶段: `ReactFiberBeginWork`
- - 这个阶段react需要决定哪些组件需要更新、哪些组件可以复用、哪些组件需要被挂载或卸载
- - React 通过比较新旧 Fiber 树来确定变化，这个过程称为协调算法（Reconciliation）。
- - 此阶段会创建一个新的工作进度树（work-in-progress tree），表示 UI 的最新状态。
- - 这个阶段是可中断的，React 可以决定挂起渲染过程，稍后再恢复。
- 完成阶段: `ReactFiberCompeleteWork`
- - 这个阶段发生在实际将更新应用到屏幕之前。
- - React 执行生命周期方法，如 getSnapshotBeforeUpdate，允许组件捕获当前的 DOM 状态或执行捕获操作。
- - 这个阶段用于执行那些需要在提交前知道布局效果的副作用，例如，测量组件的尺寸或位置。
- 提交阶段: `ReactFiberCommitWork`
- - 这是实际将更改应用到真实 DOM 的阶段。
- - React 处理所有副作用，如 componentDidMount、componentDidUpdate 和 componentWillUnmount 生命周期方法。
- - 更新 DOM 元素和属性，添加或删除 DOM 节点，以确保真实 DOM 与工作进度树同步。这个阶段是连续的，不能被中断，因为 DOM 更新通常需要原子性地完成。
## 为什么hooks不能写在条件判断
> hooks函数最终会被存在组件对应的fiber节点的memoizatedState中，组件每次更新会按照顺序执行(hooks里面存着state状态)，如果组件每次更新时的hooks链表顺序乱了,就会导致state对应不上、状态混乱

## react不可变数据
> 例如当setData(data + 1)副作用在组件内连续调用三次时,其实是相当于只调用了一次,这就是react不可变数据或者说:当前快照只能操作当前快照的值 ;
> 出现react不可变数据现象的原因是由于: hooks执行逻辑最后会以链表的形式存储在fiber节点之中,而那里面不会有类似上面data这样的变量,data会在hooks执行过程被存储之前转换为其具体的值,上例正确的写法是写成一个函数,这样在存储hooks执行逻辑到fiber节点中时就会先执行传入的这个函数,例如应该写成:setData(()=>data+1)
### useState
> 创建可以直接更新的状态变量
### useReducer
> 与useState相似，创建状态变量，同时可以自定义reducer（内部变量变化的调度机制）
```jsx
function App() {
  //注意：reducer中的返回值就是新的state
  const dataReducer = (state, aciton) => {
    switch (aciton) {
      case 0: return "你好";
      case 1: return "世界";
      case 2: return "你好世界";
      default: return "世界你好";
    }
  }
  const [data, dispatchData] = useReducer(dataReducer, "你好世界");
  return (
    <>
      <h1>{data}</h1>
      <button onClick={() => dispatchData(0)}>你好</button>
      <button onClick={() => dispatchData(1)}>世界</button>
      <button onClick = {()=>dispatchData(2)}>你好世界</button>
      <button onClick={() => dispatchData(3)}>世界你好</button>
    </>
  )
}
```
### createContext和useContext
> createContext和useContext是React Hook,可以读取和订阅组件中的context，他返回一个对象，对象的Provider属性是一个组件，用于注入数据（在Provider组件上绑定value属性），注入的数据可以通过useContext





# Vue和React比对
### setup和Hooks
- React Hooks在组件每次更新时,如果不做优化就会重新调用,这也带来一些性能问题
- Hooks有严格的调用顺序,并且不能写在条件分支中
- 昂贵的计算需要使用useMemo,也需要传入正确的数组
- 要解决变量闭包导致的问题,再结合并发功能,使得很难推理出一段钩子代码是什么时候运行的,并且很不好处理需要在多次渲染间保持引用的可变状态
