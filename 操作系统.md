# 操作系统
# 用户态和内核态
## 陷入
- 内核态可以访问所有硬件设备,也可以执行硬件上能够运行的各种指令
- 用户态只能执行一部分机器指令,不可以运行I/O指令或者影响机器控制的指令(特权指令)
- 内核态(由操作系统)封装了系统函数,维护了系统调用映射表,作为接口给应用程序(用户态),用户态传入对应的系统调用号即可执行系统函数
- 用户态的应用程序没有权限调用系统指令,此时需要去申请外部资源(1、系统调用2、syscall、3、中断和异常),然后就陷入到了内核态,内核态通过用户态传入的系统调用号找出系统调用映射表中的系统函数进行执行
## 系统调用分类
> 系统调用可以在终端执行man syscalls查看
- 进程:exit和fork等
- 文件:open、chown等
- 设备:read、write等
- 信息:getxxx、setxxx等
- 通信:mmap和sendfile等
## 操作系统启动
> 操作系统启动时,会建立一张系统调用映射表,标识是系统调用号,传入系统调用号就可以执行对应的函数
- 应用程序运行在用户态,当执行内核态提供的接口时,就会从用户态陷入到内核态,通过系统调用号去执行对应的内核态的接口
- 发生陷入时,用户态部分首先将参数保存到寄存器中,然后根据系统调用名得到系统调用号并保存到寄存器中,调用内核态的接口执行对应的系统函数,内核态执行完毕之后,会将执行结果返回给CPU的寄存器中进行存储,CPU拿到结果继续执行用户态剩下的内容
## 系统中断
> 由于CPU执行的效率很快,而I/O的操作很慢,为了使CPU不会长时间等待程序I/O,因此有了系统中断,程序中断时的状态存储在PCB进程控制块中
- linux操作系统中,32位操作系统中断使用int 0x80中断,64位操作系统通过调用syscall发生中断(陷入)
- 系统中断是为了提高CPU的执行效率
- 操作系统会为每一个设备控制器分配一个内存地址,然后CPU会根据内存地址找到对应的设备控制器的寄存器(有指令寄存器、数据寄存器和控制寄存器),CPU调用控制寄存器执行指令
- 当发生中断时,需要将CPU寄存器中的值复制到进程的内核中,这个过程称为保存现场
- 当CPU继续执行时,就会从PCB进程控制块中获取到存储的状态,然后写入到CPU的寄存器中,继续执行
## 零拷贝技术
[!普通IO](/images/普通IO.png)
- 一次普通的文件读写需要发生四次拷贝
- 例如当读写文件时:用户态首先陷入到内核态,调用对应的系统指令,读取磁盘文件的内容,拷贝到内核态的内存页缓存中(DMA copy),然后拷贝到用户态的缓存中(CPU copy),然后操作完文件之后,将新的文件内容拷贝到内核态的Socket缓冲区中(CPU copy),最后拷贝到磁盘(或者通过网络发送)(DMA copy)
> 零拷贝是指:在用户态到内核态之间状态共享时,没有发生拷贝
#### mmap通信
[!mmap通信](/images/mmap.png)
> mmap省略从内核态到用户态的拷贝过程,将这一过程变为共享,到需要拷贝时,直接从内核态的页缓存拷贝到内核态的Socket缓冲区中(用户态到内核态0拷贝)
- mmap减少了一次拷贝过程(变为3次),上下文切换次数仍然是四次
#### sendfile通信
[!sendfile通信](/images/sendfile.png)
> sendfile优化只进行两次拷贝过程,上下文切换变为两次,文件从磁盘拷贝到内核态的页缓存后直接DMA copy拷贝到网络(或磁盘)中,并传输给内核态socket缓存一个传输文件描述符(而不是拷贝)
#### 总结
> sendfile通信效率更高,例如kafka就是使用sendfile通信,使得并发量更高,但是sendfile通信时,用户态获取不到文件内容
> mmap通信通信效率略低,但是用户态可以获取到文件内容,进一步处理和操作,例如Rocket MQ就使用mmap通信,进行更多的处理
> mmap适合小数据量读写,sendfile适合大文件传输
# 硬件结构

### cpu执行
冯诺依曼模型

> 运算器 控制器 存储器 输入设备 输出设备 

![存储单元](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png)

### 内存

> 内存是程序和数据存储的地方,存储的区域是线性的

bit比特 = 8字节 = 10 ^ 3kb = ......

### cpu

32位CPU一次可计算32比特,也就是4个字节

64位CPU一次可计算64比特,也就是8个字节

> CPU位宽越大,可以计算的数值也就越大

> CPU内部还有一些组件,比如:寄存器、控制单元和逻辑运算单元等

- 控制单元用于控制CPU工作

- 寄存器用于存储数据,提升计算速度
- 逻辑运算单元负责计算

> CPU内部的寄存器访问速度最快,用于临时存放数据和指令,CPU外部的缓存有L1 L2 L3三个cache,也用于缓存数据

### 总线

> 总线是用于CPU和内存以及其他设备之间的通信,总线可分为:

- 地址总线: 指定CPU将要操作的内存地址
- 数据总线: 读写内存的数据
- 控制总线: 发送和接收信号

> 总线通常有一个位宽,是为了总线能够并行的传输数据,以提高传输效率

- CPU的位宽最好不要小于线路的位宽,这样工作起来很麻烦
- 计算数额不超过32位的情况下,32位和64位CPU之间没有什么区别
- 32位CPU最大只能操作4GB的内存(2 ^ 32),这样即使装了8GB的内存条也没用

### 程序执行

程序的运行过程就是一条条指令一步一步执行的过程,负责执行指令的就是CPU

CPU执行程序的过程:

- CPU读取程序计数器,也就是指令的内存地址(数据总线传输)
- CPU将指令数据存入到指令寄存器
- 程序计数器自增,指向下一条指令
- CPU分析指令类型,计算类型交给逻辑运算单元,存储类型交给控制单元

> CPU从程序计数器读取指令、到执行、再到下一条指令,这个过程不断循环的过程被称为CPU的指令周期

### 指令

> 指令是一串二进制数字的机器码,每条指令都有对应的机器码,每个CPU有不同的指令集

### 指令周期

- CPU通过程序计数器读取指令对应的内存地址(Fetch取得指令)
- CPU对指令进行解码(Decode指令译码)
- CPU执行指令(Execution执行指令)
- CPU将计算结果存入内存(Store数据回写)

### CPU Cache Line

> CPU Cache Line表示一次性加载的数据的大小

CPU Cache Line通常是64字节,也就是一般会加载目标数据,如果目标数据不够64字节,就会连同目标数据之后的一同进行加载,可以利用这个特性提升缓存命中率,提升代码性能

### 指令缓存命中率

CPU具有分支预测器,对于if条件语句,如果分支预测接下来还是if语句的话,就会提前将指令存放在缓存中,从而提高指令的执行速度

> 例如: 先将数组排序,在遍历数组,里面进行if(i < n)的条件判断就会比最后在进行数组排序的相同过程要快,因为缓存了if之后的指令

### 多核CPU缓存命中率

多核CPU之前高速缓冲区只有L3是共享的,由于每一个线程在不同CPU核心之间来回进行切换,就会导致每个核心的缓存命中率收到影响,当有多个同时执行计算密集型的线程时,为了防止因切换到不同核心导致缓存命中率下降的问题,我们可以将线程绑定在某一个CPU核心上

> 代码中可以使用api指定同一个CPU

### 伪共享

如果两个线程a和b分别使用同一个数组,a使用0,b使用1,由于Cache Line读取的原因,就会导致多核CPU下,同一时间,两个CPU对于这个数组是一种伪共享的状态,当修改Cache Line的时候,虽然没有影响到另一个CPU缓存中需要使用的数据,也要对其Cache Line进行同步,就会消耗性能

> 代码中可以使用api决定Cache Line的大小

# 操作系统结构

### 内核

计算机是由各种外部硬件设备组成的,比如内存、CPU、硬盘等,如果每个应用都要和这些硬件设备通信,就太繁琐了,`内核就充当应用连接硬件设备的桥梁`。

> 应用程序只需要关心与内核进行交互,而不用关心硬件的细节

### 内核的能力

- 管理进程线程,决定哪个进程线程使用CPU
- 管理内存,决定内存的分配和回收
- 管理硬件设备,为进程与硬件设备之间提供通信能力
- 提供系统调用,它是用户程序与操作系统之间的接口

### 内存区域

内核具有很高的权限,可以控制CPU 内存 硬盘等,但是应用程序只具有很小的权限,因此大多操作系统将内存分为两个区域:

- 内核空间,这个空间只有内核程序可以访问
- 用户空间,这个空间专门给应用程序使用

当程序使用用户空间时,就常说程序在用户态执行,当程序使用内核空间时,就说程序在内核态执行

# 内存管理

### 虚拟内存

进程持有的虚拟地址会通过CPU芯片中的内存管理单元的映射关系,来转变为物理地址,然后通过物理地址访问内存

# 进程管理

> 进程是操作系统进行资源分配的基本单位,线程是操作系统进行CPU调度的基本单位

一个进程的活动期间至少具备三种基本状态,即: 运行态、就绪态和阻塞态

### PCB

PCB全称:进程控制块,是进程存在的唯一标识
