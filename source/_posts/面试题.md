---
title: 面试题
tags: 面试题
categories: 面试题
date: 2023-08-29 00:26:56
---

# HTML

![image-20240615100110302](/images/image-20240615100110302.png)

![image-20240615100348230](/images/image-20240615100348230.png)

![image-20240615103856678](/images/image-20240615103856678.png)

# 网络请求

![image-20240615104315494](/images/image-20240615104315494.png)

![image-20240615144630951](/images/image-20240615144630951.png)

![image-20240615144850506](/images/image-20240615144850506.png)

# css

![image-20240615145615464](/images/image-20240615145615464.png)

![image-20240615145720791](/images/image-20240615145720791.png)

# cookie

![image-20240615154852705](/images/image-20240615154852705.png)

​

![image-20240615155246599](/images/image-20240615155246599.png)

# 状态码

![image-20240615155930056](/images/image-20240615155930056.png)

![image-20240615160004896](/images/image-20240615160004896.png)

![image-20240615161115653](/images/image-20240615161115653.png)

![image-20240615161945008](/images/image-20240615161945008.png)

# restful

![image-20240615162039503](/images/image-20240615162039503.png)

![image-20240615162814863](/images/image-20240615162814863.png)

![image-20240615163452260](/images/image-20240615163452260.png)

![image-20240615163708988](/images/image-20240615163708988.png)

![image-20240615164606824](/images/image-20240615164606824.png)

![image-20240615164703711](/images/image-20240615164703711.png)

![image-20240615165454563](/images/image-20240615165454563.png)

![image-20240615165036538](/images/image-20240615165036538.png)

![image-20240615165358744](/images/image-20240615165358744.png)

![image-20240615165253528](/images/image-20240615165253528.png)

# http

![image-20240615174235183](/images/image-20240615174235183.png)

![image-20240615174757319](/images/image-20240615174757319.png)

![image-20240615174819942](/images/image-20240615174819942.png)

![image-20240615175041938](/images/image-20240615175041938.png)

![image-20240615175155718](/images/image-20240615175155718.png)

![image-20240615175309361](/images/image-20240615175309361.png)

![image-20240615181223986](/images/image-20240615181223986.png)

![image-20240615182042111](/images/image-20240615182042111.png)

![image-20240615182506393](/images/image-20240615182506393.png)

![image-20240615182658126](/images/image-20240615182658126.png)

![image-20240615182946625](/images/image-20240615182946625.png)

![image-20240615183118177](/images/image-20240615183118177.png)

![image-20240615184908403](/images/image-20240615184908403.png)

![image-20240615190633946](/images/image-20240615190633946.png)

![image-20240615195704070](/images/image-20240615195704070.png)

![image-20240615201443518](/images/image-20240615201443518.png)

# webpack

![image-20240615235053481](/images/image-20240615235053481.png)

# vue2

![image-20240620212614138](/images/image-20240620212614138.png)

v-show 和 v-if：

- v-show

  - v-show 的原理是使用 display:none 进行隐藏，会引发重绘而不会回流。

  - v-show 适用于需要频繁切换 DOM 元素的场景中；

- v-if

  - v-if 原理是 DOM 元素是否添加，会引发回流与重绘
  - v-if 适用于不常切换 DOM 元素的条件判断中

![image-20240620213800567](/images/image-20240620213800567.png)

v-for 和 v-if 同时使用

- 在 vue2 中，v-for 和 v-if 同时使用会严重造成性能的浪费，这是因为 vue2 中 v-for 的优先级高于 vue3
- 但是在 vue3 中，v-if 的优先级高于 v-for，因此一起使用也无可厚非

![image-20240620214812889](/images/image-20240620214812889.png)

![image-20240620215109900](/images/image-20240620215109900.png)

![image-20240620215153287](/images/image-20240620215153287.png)

![image-20240620215803063](/images/image-20240620215803063.png)

![image-20240620224000511](/images/image-20240620224000511.png)

生命周期（父子子父）：

- 父组件 created 之后----子组件 created
- 子组件 mounted 到父组件之后----父组件 mounted
- 父组件 before update----子组件 before update
- 子组件 updated----父组件 updated

![image-20240622104018967](/images/image-20240622104018967.png)

![image-20240622105007968](/images/image-20240622105007968.png)

![image-20240622120259017](/images/image-20240622120259017.png)

vue 虚拟 dom 基于 snabbdom 来实现的。

- h 函数，生成 vnode
-

v-for 中：key 的作用（diff 算法的降级处理）：

- 在进行 diff 比对时，树的 diff 算法的时间复杂度是 O（n \*\* 3）

  - 遍历 tree1、遍历 tree2 然后 排序，这样在进行 diff 比对时，性能消耗就会很大，因此需要对 diff 算法进行降级处理。

- vnode 在进行 diff 算法时，需要比较两个节点是否相同，如果比较两个节点全部的属性，则时间复杂度就很高，因此采用 key+tag 的形式进行判断是否是相同节点，以降低 diff 算法的时间复杂度。

- 除了 diff 算法中起到作用之外，key 还有其他作用：

  - transition-group 中确保过渡效果准确应用。
  - 组件 vnode 中也有 key，它可以确保组件的状态在重新渲染时得以保留。

![image-20240622234014692](/images/image-20240622234014692.png)

# vue3

![image-20240624191248157](/images/image-20240624191248157.png)

- Proxy 代理整个对象，而不需要循环遍历属性进行代理，提升了速度
- patchFlag 标记：用于 diff 算法中，将节点进行标记使得 diff 算法可以跳过固定的静态节点的比对
  - 其中有一个技巧就是使用位运算进行累计各种类型。通过按位与判断是否包含某种类型。
- hoistStatic（静态节点提升）：对于静态节点，将其提升到父级作用域缓存起来，用于节点复用，并且不用每次重新生成静态节点。
  - 多个相邻的静态节点进行合并。
- cacheHandler 缓存事件处理函数，将事件处理函数提升到父级作用域进行缓存，以提高性能。
- SSR 优化：静态节点直接输出（html 格式标签），绕过了 vdom，动态节点还是动态渲染。
- tree shaking：根据模板的内容动态的 import 所需要的内容，没有用到就不会进行 import。
  - vue3 中按需导入会大大减小最终构建产物的体积，tree-shaking 会自动检测模板中用到的组件并导入，但是并不是所有的库和框架都支持 tree-shaking，需要三方适配或提供按需导入的方式。

vite 为什么快：

- 开发环境使用 ES6 Module，模块使用时才会去打包
- 使用 esbuild 工具进行预构建等，提升速度
  - esbuild 是基于 go 语言开发，可以多线程打包，并将代码直接编译为机器码。
- 生产环境使用 rollup，并且生产环境不能使用 ES6 Module，所以不会快很多。

Composition API 和 React Hooks 对比

- 前者 setup 只会被调用一次，而后者 hooks 会被多次调用（必要时进行缓存，并且 hooks 需要保证调用顺序一致，不能在分支中使用 hooks）。

Vue3 中使用 JSX

- JSX 语法被 React 使用之后越来越壮大。（现在已发展壮大）
- 使用.jsx 后缀格式文件和 defineComponent 定义组件，需要 babel 中的 jsx-loader 进行支持。

JSX 和 template 语法的区别

- JSX 的本质就是 js 代码，可以使用 js 的任何能力（组件大小写敏感）
- template 只能嵌入简单的 js 表达式，其他需要指令去完成（组件大小写不敏感）
- JSX 成为 ES 规范，template 仅仅是 Vue 的模板规范
- 都会被编译为 js 代码（render 函数）

Vue3 setup 语法糖

- this 为 undefined

# react

事件

- react 自身实现了一套自己的事件机制，包括事件注册、事件合成、事件冒泡和事件派发等。虽然和原生是两码事，但是也是基于浏览器的事件机制下完成的。
- react 所有事件并没有绑定到具体的 dom 节点上而是绑定在了 document 上，然后由统一的事件处理程序处理，同时也是基于浏览器的冒泡机制，所有节点事件都会在 document 上触发。
- 事件被存储在 React.createElement 的 props 中，接着被保存在 fiber 对象的 memoizedProps 和 pendingProps 上。
- 例如给 input 绑定 onChange 事件，最后被统一绑定在了 document 上，onChange 被处理成很多事件监听器，例如：blur，change，input，keydown，keyup 等。
- 意义：减少内存消耗，提升性能，不需要注册很多事件，一种事件类型只会在 document 上注册一次，对开发者友好。

性能优化

- shouldComponentUpdate

  - React 默认（SCU 默认返回 true）：父组件有更新时，子组件也无条件跟着更新
  - shouldComponentUpdate 一般进行判断下一张快照的 state 和当前快照的 state 有没有发生变化，从而判断是否需要进行更新。所以需要结合不可变值。（当更改当前快照的状态并且设置 state 时，会导致判断不按照相应地逻辑去走，这也是为什么 react 不直接内置 shouldComponentUpdate 的原因）

- PureComponent 和 React.memo

  - PureComponent 纯组件，用于避免不必要的渲染，从而提高效率，类组件中建议使用 PureComponent。

  - PureComponent 中，shouldComponentUpdate 实现了浅比较
  - memo 是函数组件中的 PureComponent
  - 浅比较已使用大部分情况（尽量不要做深度比较）

- 不可变值 immutable.js

公共逻辑抽离

- 高阶组件 HOC
  - 传入一个组件，返回一个组件（使用了传入的组件）
  - 通过...props 进行透传
- Render Props
  - 类组件接收一个 render 函数（render 函数返回需要显示的组件），类组件内部执行 this.props.render 函数，将 this.state 传入进去。

redux

- 单向数据流
  - dispatch（action）
  - reducer --> newState
  - subscribe 触发通知

react-redux

- 引入 react-redux 中的 Provider 组件
- 使用 redux 中的 createStore 创建 store（传入 reducer）
- 在跟组件外嵌套一层 Provider 组件，绑定 sotre 属性为 sotre

redux 中间件

- redux-thunk
- redux-promise
- redux-saga

react-router

- 路由模式
  - hash 模式
  - H5 history 模式（服务端配置支持）
- 使用

  - 从 react-router-dom 中导入 HashRouter 或者 BrowserRouter、Switch 和 Route 组件
  - 创建 RouterComponent 组件，外层 BrowserRouter 包裹 Switch 组件，里面嵌套 Route 组件
  - Route 组件 path 属性定义路径，component 属性显示组件（或者嵌套显示的内部组件）

- 懒加载
  - 使用 react 的 lazy 组件，lazy 组件包裹一个函数，函数返回 import 动态导入的组件。
  - 使用 Suspense 组件，传递 fallback 属性显示加载时内容。

react 原理

函数式编程

- 纯函数
- 不可变值

状态码
- 100:客户端继续请求
- 101:服务器根据客户端得请求切换协议
- 200:请求成功
- 202:已接受但未处理完成
- 204:无内容
- 301:永久重定向
- 302:临时重定向
- 304:未修改
- 400 bad:请求语法错误
- 401 unauthorized:要求用户身份认证
- 403 forbidden:拒绝此请求
- 500 server Error:服务器错误
- 502 bad gateway:网关或代理服务器错误
- 504 gateway time-out:网关或代理服务器超时

# vue
- 为什么vue2中只能有一个根节点但是vue3中可以有多个？
> vue2中vdom需要有一个单根节点作为入口，这样才能向下遍历，但vue3引入了Fragement节点，当顶层节点包含多个入口节点时会自动创建Fragement节点将这些节点包裹，转化为render函数时，会自动跳过Fragement节点转而遍历子节点。
# 原型链
![/images/image-20240123164938769](/images/原型链.png)
```js
const date = new Date();
const a = {name:1}
console.log(date.constructor.name);
console.log(Date.prototype);
console.log(date.__proto__);
console.log(Date.prototype===date.__proto__);
console.log(Date.prototype.constructor===Date);
console.log(date.constructor.prototype.constructor===date.__proto__.constructor);
console.log(date.constructor.prototype.constructor===Date.prototype.constructor);
console.log(date.__proto__.constructor===date.constructor);
console.log(Date.prototype.constructor===date.constructor);
console.log(Date.prototype.constructor===Date);
console.log(Date.prototype.__proto__===Object.prototype);
console.log(Date.prototype.__proto__===a.__proto__);
//Function相关
console.log(Function.prototype===Function.__proto__);
console.log(Function.constructor === Function);
const fn = function(){};
console.log(Function.__proto__===fn.__proto__);
```
# 手写题

```js
/**
 * 判断数据类型
 */
function myTypeOf(obj) {
    // 使用toString
        const typeMap = {
            "[object Object]": "Object",
            "[object Array]": "Array",
            "[object String]": "String",
            "[object Number]": "Number",
            "[object Boolean]": "Boolean",
            "[object Function]": "Function",
            "[object Null]": "Null", // 注意这里是 "Null" 而不是 "null"
            "[object Undefined]": "Undefined", // 注意这里是 "Undefined" 而不是 "undefined"
            "[object Symbol]": "Symbol",
            "[object BigInt]": "BigInt"
        };
    return typeMap[Object.prototype.toString.call(obj)];
    // 或者根据类型进行判断
    switch (typeof obj) {
        case "object":
            if(Array.isArray(obj)) return "Array"
            if(obj === "null") return "null";
            return "Object";
        case "number":
            return "Number";
        case "string":
            return "String";
        case "undefined":
            return "undefined";
        case "bigint":
            return "BigInt";
        case "boolean":
            return "Boolean";
        case "function":
            return "Function";
        case "symbol":
            return "Symbol";
        default:
            return "unknown"
    }
}
/**
 * 数组去重
 */
function unique(arr) {
    return new Array(...new Set(arr))
}
/**
 * 数组扁平化(扁平一层)
 */
function arrFlat(arr) {
    if(arr.flat){
      return arr.flat(); //Array.flat方法默认扁平一层
    }
    // 兼容es5版本：
    const res = [];
    arr.forEach(item=>{
        if(Array.isArray(item)) res.push(...item);
        else res.push(item) 
    })
    return res;
}

/**
 * 手写对象的[Symbol.iterator]迭代器协议（普通对象不内置迭代器）
 * 内置迭代器的异质对象有：Array，String，Set，Map
 */
Symbol.myIterator = Symbol('myIterator');
Object.prototype[Symbol.myIterator] = function () {
    const iterKeys = Object.keys(this);
    let iterIndex = 0;
    return {
        next: ()=> {
            if (iterIndex < iterKeys.length) {
                return {
                    value: this[iterKeys[iterIndex++]],
                    done: false
                };
            } else {
                return {
                    value: undefined,
                    done: true
                };
            }
        }
    }
}
/**
 * 手写for of循环（for of便利前提是对象内置迭代器）
 */
function myForOf(obj,fn) {
    if(!obj[Symbol.iterator]) throw new TypeError('obj不存在迭代器')
    const myIterator = obj[Symbol.iterator]();
    let cur = myIterator.next();
    while (!cur.done) {
        fn(cur.value);
        cur = myIterator.next();
    }
}
/**
 * 手写for in循环（for in的前提是对象属性可被枚举，Object.keys也是）
 */
function myForIn(obj,fn) {
    const keys = Object.keys(obj);
    keys.forEach(item=>{
        fn({[item]:obj[item]});
    })
}
/**
 * 浅拷贝，返回新的对象，丢失原型链
 */
function shallowClone(objLike) {
    if(typeof objLike !== 'object') return objLike;
    const res = Array.isArray(objLike)?[]:{};
    for(let item in objLike){
        if(objLike.hasOwnProperty(item)){
            res[item] = objLike[item];
        }
    }
    return res;
}
/**
 * 手写深拷贝
 */
// 是否是对象类型
const isObject = (obj) => typeof obj === 'object' || typeof obj === 'function' && obj !== null;
function deepClone(target,map = new WeakMap()) {
    if(structuredClone) return structuredClone(target);
    // 兼容structuredClone,因为要进行递归处理，所以需要增加默认参数
    if(map.get(target)) return target;
    let constructor = target.constructor; //获取到constructor
    // 如果是日期或者正则，就新创建一个实例
    if(/^(RegExp|Date)$/i.test(constructor.name)){
        return new constructor(target);
    }
    if(isObject(target)){
        map.set(target,true);
        const cloneTarget = Array.isArray(target) ? []:{};
        for(let prop in target){
            if(target.hasOwnProperty(prop)){
                cloneTarget[prop] = deepClone(target[prop],map);
            }
        }
        return cloneTarget;
    }else {
        return target;
    }
}
// > 注意：1、原型链不能形成闭环（报错），2、__proto__的值只能是对象或者null，3、一个对象只能又一个[[Prorotype]]，4、__proto__是内部[[Prototype]]的getter/setter。
/**
 * 手写全局事件总线
 */
class EventEmitter{
    #cache = {};
    constructor(){}
    on(name,fn){
        if(this.#cache[name]){
            this.#cache[name].push(fn);
        }else{
            this.#cache[name] = [fn]
        }
    }
    off(name,fn){
        if(!this.#cache[name]) return;
        this.#cache[name] = this.#cache[name].filter(item=>{
           return item !== fn;
        })
    }
    emit(name){
        this.#cache[name].forEach(item=>{
            item();
        })
    }
}
// 复习CustomEvent、Event和EventTarget（dispatchEvent和addEventListener）
const sayHiEvent = new CustomEvent('sayHi',{
    detail:{
        name:"sayHi事件"
    }
})
const eventTarget = new EventTarget();
eventTarget.addEventListener('sayHi',(e)=>{
    console.log(e.detail,'e.detail');
})
// eventTarget.dispatchEvent(sayHiEvent)

//深度思考：为什么eventTarget使用dispatchEvent时，要传入Event事件，而不是type类型？
//因为一个DOM同一事件不能重复，并且同一事件类型一般要创建很多个事件（用于不同的DOM，因此不能复用同一事件），此时用类型很难对其标识

/**
 * 遍历输出构造类
 */
function consoClass(classFn) {
    let a = Object.getPrototypeOf(classFn);
    while (a !== null) {
        console.log(a);
        a = Object.getPrototypeOf(a);
    }
}
// HTMLElement--Element--Node--EventTarget--Object--null
consoClass(HTMLElement)

/**
 * 图片懒加载
 */
const imgList = [...document.querySelectorAll("image")];
const imgLength = imgList.length;
const imgLazyLoad = (function () {
    let count = 0;
    return function () {
        let deleteIndexList = [];
        //遍历图片列表
        imgList.forEach((item,index)=>{
            let rect = item.getBoundingClientRect();
            // 如果rect.top小于window.innerHeight，代表以及进入视野之内
            if(rect.top < 0){
                item.src = item.dataset.src;
                deleteIndexList.push(index);
            }
        })
        imgList = imgList.filter((item,index)=>!deleteIndexList.includes(index));
    }
})()

document.addEventListener("scroll",imgLazyLoad);
/**
 * 函数防抖（多次执行，重新计时）
 */
function debounce(fn,time) {
    let timer = null;
    return function () {
        const bindFn = fn.bind(this,...arguments)
        clearTimeout(timer);
        setTimeout(() => {
            bindFn();
        }, time);
    }
}
/**
 * 函数节流（固定时间只执行一次）
 */
function th(fn,time) {
    let timer = null;
    return function () {
        if(timer) return;
        const bindFn = fn.bind(this,...arguments)
        timer = setTimeout(() => {
            bindFn();
            clearTimeout(timer);
        }, time);
    }
}
/**
 * 函数柯里化
 */
function curry(fn) {
    //将fn函数进行柯里化
    return function curried(...args) {
        if(args.length >= fn.length){
            return fn.apply(this,args);
        }else{
            return function (...args2) {
                return curried.apply(this,args.concat(args2))
            }
        }
    }
}
/**
 * 函数偏函数化
 */
function partial(fn,...args) {
    return (...arg) => {
        return fn(...args,...arg);
    }
}
/**
 * 使用jsonp进行跨域get请求
 */
const jsonp = ({ url, params, callbackName }) => {
    const generateUrl = () => {
        let dataSrc = ''
        for (let key in params) {
            if (params.hasOwnProperty(key)) {
                dataSrc += `${key}=${params[key]}&`
            }
        }
        dataSrc += `callback=${callbackName}`
        return `${url}?${dataSrc}`
    }
    return new Promise((resolve, reject) => {
        const scriptEle = document.createElement('script')
        scriptEle.src = generateUrl()
        document.body.appendChild(scriptEle)
        window[callbackName] = data => {
            resolve(data)
            document.removeChild(scriptEle)
        }
    })
}
/**
 * AJAX封装get请求JSON数据
 */
function getJSON(url) {
    return new Promise((resolve,reject)=>{
        const xhr = new XMLHttpRequest();
        xhr.open("GET",url,false);
        xhr.setRequestHeader("Accept","application/json");
        xhr.onreadystatechange = function () {
            if(xhr.status !== 4) return;
            if(xhr.status === 200 || xhr.status === 304) {
                resolve(xhr.responseText);
            }else {
                reject(new Error(xhr.responseText));
            }
        }
        xhr.send();
    })
}
/**
 * 实现forEach
 */
Array.prototype.myForEach = function (callback,thisArg) {
    if(this === null) throw new TypeError("this is null or not defined");
    // 如果回调不是函数
    if(typeof  callback !== 'function') throw new TypeError(callback + "is not a function");
    const superThis = Object(this); //将this进行兼容，确保不是null或undefined
    const len = superThis.length >>> 0; //确保该函数的参数是正整数或0
    let k = 0;
    while (k < len) { //当k小于0进行遍历
        if(k in superThis){
            callback.call(thisArg,superThis[k],k,superThis);
        }
        k++;
    }
}

/**
 * 实现map
 */
Array.prototype.myMap = function (callback,thisArg) {
    if(this.null) throw new TypeError("this is null or defined");
    if(typeof callback !== "function") throw new TypeError(callback.name + "is not a function");
    const thisObj = Object(this); //保证thisObj不是null或undefined，使用Object可以传入数组，使用Array需要列出来
    const len = thisObj.length >>> 0; //无符号右移0，内部全部流程：valueOf、toString、Number，然后无符号左移（去小数）
    let k =0;res = []
    while (k < len) {
        if(k in thisObj){
            res[k]=callback.call(thisArg,thisObj[k],k,thisObj);
        }
        k++;
    }
    return res;
}
/**
 * 实现filter
 */
Array.prototype.myFilter = function (callback,thisArg) {
    if(this == null) return new TypeError("this is null or undefined")
    if(typeof callback !== "function") return new TypeError(callback.name + "is not a function")
    // 处理filter
    const thisObj = Object(this);
    const len = thisObj.length >>> 0;
    let res = [],k = 0;
    while (k < len) {
        if(k in thisObj){
            if(callback.call(thisArg,thisObj[k],k,thisObj)){
                res.push(thisObj[k]);
            }
        }
        k++;
    }
    return res;
}
/**
 * 实现some
 */
Array.prototype.mySome = function (callback,thisArg) {
    if(this == null) return new TypeError("this is null or undefined");
    if(typeof callback !== "function") return new TypeError(callback.name + "is not a function")
    const thisObj = Object(this);
    let len = thisObj.length,k = 0;    
    while (k < len) {
        if(k in thisObj){
            if(callback.call(thisArg,thisObj[k],k,thisObj)){
                return true;
            }
        }
        k++;
    }
    return false;
}
/**
 * 实现reduce
 * callback = function(pre,item)=>{}
 */
Array.prototype.myReduce = function (callback,initialValue) {
    if(this == null) return new TypeError("this is null or undefined");
    if(typeof callback !== "function") return TypeError(callback.name + "is not a function");
    const thisObj = Object(this); //防止null或者undefined
    const len = thisObj.length;
    let res,k=0;
    while (k < len) {
        if(k in thisObj){
            //进行执行
            initialValue = callback(initialValue,thisObj[k]);
        }
        k++;
    }
    return initialValue;
}
/**
 * 手写call、apply 和 bind
 */
Function.prototype.myCall = function (thisContext) {
    // 将this（函数），绑定this,传入参数
    thisContext = thisContext || window; //this默认为window
    const fn = Symbol(thisContext);
    thisContext[fn] = this; //将this函数挂载到thisContext环境中
    let args = [...arguments].slice(1);
    thisContext[fn](...args); //用对象[属性]的方式使用函数（绑定this）
    delete thisContext[fn]; //最后删除属性
}
//小结：使用call绑定this的关键就在于：将this（也就是函数）挂载到thisContext（需要绑定的this上），使用对象[属性]的方式进行执行，从而自动绑定this

Function.prototype.myApply = function (thisContext) {
    const fn = Symbol("myApply");
    // 将fn绑定到黄经中
    thisContext[fn] = this;
    //执行
    const args = [...arguments].slice(1);
    thisContext[fn](args);
    delete thisContext[fn]; //删除属性之后，垃圾回收机制自动回收fn
}

Function.prototype.myBind = function (thisContext) {
    // 函数绑定
    //返会一个函数,绑定this指向，到固定的函数上
    const thisFn = this;
    const arg = [...arguments].slice(1); //保存传入的参数
    return function () {
        const newArg = [...arguments];
        return thisFn.apply(thisContext,[...arg,...newArg])
    }
}


```