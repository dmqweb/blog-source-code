---
title: 面试题
tags: 面试题
categories: 面试题
date: 2023-08-29 00:26:56
---

# HTML

![image-20240615100110302](/images/image-20240615100110302.png)

![image-20240615100348230](/images/image-20240615100348230.png)

![image-20240615103856678](/images/image-20240615103856678.png)

# 网络请求

![image-20240615104315494](/images/image-20240615104315494.png)

![image-20240615144630951](/images/image-20240615144630951.png)

![image-20240615144850506](/images/image-20240615144850506.png)

# css

![image-20240615145615464](/images/image-20240615145615464.png)

![image-20240615145720791](/images/image-20240615145720791.png)

# cookie

![image-20240615154852705](/images/image-20240615154852705.png)

​

![image-20240615155246599](/images/image-20240615155246599.png)

# 状态码

![image-20240615155930056](/images/image-20240615155930056.png)

![image-20240615160004896](/images/image-20240615160004896.png)

![image-20240615161115653](/images/image-20240615161115653.png)

![image-20240615161945008](/images/image-20240615161945008.png)

# restful

![image-20240615162039503](/images/image-20240615162039503.png)

![image-20240615162814863](/images/image-20240615162814863.png)

![image-20240615163452260](/images/image-20240615163452260.png)

![image-20240615163708988](/images/image-20240615163708988.png)

![image-20240615164606824](/images/image-20240615164606824.png)

![image-20240615164703711](/images/image-20240615164703711.png)

![image-20240615165454563](/images/image-20240615165454563.png)

![image-20240615165036538](/images/image-20240615165036538.png)

![image-20240615165358744](/images/image-20240615165358744.png)

![image-20240615165253528](/images/image-20240615165253528.png)

# http

![image-20240615174235183](/images/image-20240615174235183.png)

![image-20240615174757319](/images/image-20240615174757319.png)

![image-20240615174819942](/images/image-20240615174819942.png)

![image-20240615175041938](/images/image-20240615175041938.png)

![image-20240615175155718](/images/image-20240615175155718.png)

![image-20240615175309361](/images/image-20240615175309361.png)

![image-20240615181223986](/images/image-20240615181223986.png)

![image-20240615182042111](/images/image-20240615182042111.png)

![image-20240615182506393](/images/image-20240615182506393.png)

![image-20240615182658126](/images/image-20240615182658126.png)

![image-20240615182946625](/images/image-20240615182946625.png)

![image-20240615183118177](/images/image-20240615183118177.png)

![image-20240615184908403](/images/image-20240615184908403.png)

![image-20240615190633946](/images/image-20240615190633946.png)

![image-20240615195704070](/images/image-20240615195704070.png)

![image-20240615201443518](/images/image-20240615201443518.png)

# webpack

![image-20240615235053481](/images/image-20240615235053481.png)

# vue2

![image-20240620212614138](/images/image-20240620212614138.png)

v-show 和 v-if：

- v-show

  - v-show 的原理是使用 display:none 进行隐藏，会引发重绘而不会回流。

  - v-show 适用于需要频繁切换 DOM 元素的场景中；

- v-if

  - v-if 原理是 DOM 元素是否添加，会引发回流与重绘
  - v-if 适用于不常切换 DOM 元素的条件判断中

![image-20240620213800567](/images/image-20240620213800567.png)

v-for 和 v-if 同时使用

- 在 vue2 中，v-for 和 v-if 同时使用会严重造成性能的浪费，这是因为 vue2 中 v-for 的优先级高于 vue3
- 但是在 vue3 中，v-if 的优先级高于 v-for，因此一起使用也无可厚非

![image-20240620214812889](/images/image-20240620214812889.png)

![image-20240620215109900](/images/image-20240620215109900.png)

![image-20240620215153287](/images/image-20240620215153287.png)

![image-20240620215803063](/images/image-20240620215803063.png)

![image-20240620224000511](/images/image-20240620224000511.png)

生命周期（父子子父）：

- 父组件 created 之后----子组件 created
- 子组件 mounted 到父组件之后----父组件 mounted
- 父组件 before update----子组件 before update
- 子组件 updated----父组件 updated

![image-20240622104018967](/images/image-20240622104018967.png)

![image-20240622105007968](/images/image-20240622105007968.png)

![image-20240622120259017](/images/image-20240622120259017.png)

vue 虚拟 dom 基于 snabbdom 来实现的。

- h 函数，生成 vnode
-

v-for 中：key 的作用（diff 算法的降级处理）：

- 在进行 diff 比对时，树的 diff 算法的时间复杂度是 O（n \*\* 3）

  - 遍历 tree1、遍历 tree2 然后 排序，这样在进行 diff 比对时，性能消耗就会很大，因此需要对 diff 算法进行降级处理。

- vnode 在进行 diff 算法时，需要比较两个节点是否相同，如果比较两个节点全部的属性，则时间复杂度就很高，因此采用 key+tag 的形式进行判断是否是相同节点，以降低 diff 算法的时间复杂度。

- 除了 diff 算法中起到作用之外，key 还有其他作用：

  - transition-group 中确保过渡效果准确应用。
  - 组件 vnode 中也有 key，它可以确保组件的状态在重新渲染时得以保留。

![image-20240622234014692](/images/image-20240622234014692.png)

# vue3

![image-20240624191248157](/images/image-20240624191248157.png)

- Proxy 代理整个对象，而不需要循环遍历属性进行代理，提升了速度
- patchFlag 标记：用于 diff 算法中，将节点进行标记使得 diff 算法可以跳过固定的静态节点的比对
  - 其中有一个技巧就是使用位运算进行累计各种类型。通过按位与判断是否包含某种类型。
- hoistStatic（静态节点提升）：对于静态节点，将其提升到父级作用域缓存起来，用于节点复用，并且不用每次重新生成静态节点。
  - 多个相邻的静态节点进行合并。
- cacheHandler 缓存事件处理函数，将事件处理函数提升到父级作用域进行缓存，以提高性能。
- SSR 优化：静态节点直接输出（html 格式标签），绕过了 vdom，动态节点还是动态渲染。
- tree shaking：根据模板的内容动态的 import 所需要的内容，没有用到就不会进行 import。
  - vue3 中按需导入会大大减小最终构建产物的体积，tree-shaking 会自动检测模板中用到的组件并导入，但是并不是所有的库和框架都支持 tree-shaking，需要三方适配或提供按需导入的方式。

vite 为什么快：

- 开发环境使用 ES6 Module，模块使用时才会去打包
- 使用 esbuild 工具进行预构建等，提升速度
  - esbuild 是基于 go 语言开发，可以多线程打包，并将代码直接编译为机器码。
- 生产环境使用 rollup，并且生产环境不能使用 ES6 Module，所以不会快很多。

Composition API 和 React Hooks 对比

- 前者 setup 只会被调用一次，而后者 hooks 会被多次调用（必要时进行缓存，并且 hooks 需要保证调用顺序一致，不能在分支中使用 hooks）。

Vue3 中使用 JSX

- JSX 语法被 React 使用之后越来越壮大。（现在已发展壮大）
- 使用.jsx 后缀格式文件和 defineComponent 定义组件，需要 babel 中的 jsx-loader 进行支持。

JSX 和 template 语法的区别

- JSX 的本质就是 js 代码，可以使用 js 的任何能力（组件大小写敏感）
- template 只能嵌入简单的 js 表达式，其他需要指令去完成（组件大小写不敏感）
- JSX 成为 ES 规范，template 仅仅是 Vue 的模板规范
- 都会被编译为 js 代码（render 函数）

Vue3 setup 语法糖

- this 为 undefined

# react

事件

- react 自身实现了一套自己的事件机制，包括事件注册、事件合成、事件冒泡和事件派发等。虽然和原生是两码事，但是也是基于浏览器的事件机制下完成的。
- react 所有事件并没有绑定到具体的 dom 节点上而是绑定在了 document 上，然后由统一的事件处理程序处理，同时也是基于浏览器的冒泡机制，所有节点事件都会在 document 上触发。
- 事件被存储在 React.createElement 的 props 中，接着被保存在 fiber 对象的 memoizedProps 和 pendingProps 上。
- 例如给 input 绑定 onChange 事件，最后被统一绑定在了 document 上，onChange 被处理成很多事件监听器，例如：blur，change，input，keydown，keyup 等。
- 意义：减少内存消耗，提升性能，不需要注册很多事件，一种事件类型只会在 document 上注册一次，对开发者友好。

性能优化

- shouldComponentUpdate

  - React 默认（SCU 默认返回 true）：父组件有更新时，子组件也无条件跟着更新
  - shouldComponentUpdate 一般进行判断下一张快照的 state 和当前快照的 state 有没有发生变化，从而判断是否需要进行更新。所以需要结合不可变值。（当更改当前快照的状态并且设置 state 时，会导致判断不按照相应地逻辑去走，这也是为什么 react 不直接内置 shouldComponentUpdate 的原因）

- PureComponent 和 React.memo

  - PureComponent 纯组件，用于避免不必要的渲染，从而提高效率，类组件中建议使用 PureComponent。

  - PureComponent 中，shouldComponentUpdate 实现了浅比较
  - memo 是函数组件中的 PureComponent
  - 浅比较已使用大部分情况（尽量不要做深度比较）

- 不可变值 immutable.js

公共逻辑抽离

- 高阶组件 HOC
  - 传入一个组件，返回一个组件（使用了传入的组件）
  - 通过...props 进行透传
- Render Props
  - 类组件接收一个 render 函数（render 函数返回需要显示的组件），类组件内部执行 this.props.render 函数，将 this.state 传入进去。

redux

- 单向数据流
  - dispatch（action）
  - reducer --> newState
  - subscribe 触发通知

react-redux

- 引入 react-redux 中的 Provider 组件
- 使用 redux 中的 createStore 创建 store（传入 reducer）
- 在跟组件外嵌套一层 Provider 组件，绑定 sotre 属性为 sotre

redux 中间件

- redux-thunk
- redux-promise
- redux-saga

react-router

- 路由模式
  - hash 模式
  - H5 history 模式（服务端配置支持）
- 使用

  - 从 react-router-dom 中导入 HashRouter 或者 BrowserRouter、Switch 和 Route 组件
  - 创建 RouterComponent 组件，外层 BrowserRouter 包裹 Switch 组件，里面嵌套 Route 组件
  - Route 组件 path 属性定义路径，component 属性显示组件（或者嵌套显示的内部组件）

- 懒加载
  - 使用 react 的 lazy 组件，lazy 组件包裹一个函数，函数返回 import 动态导入的组件。
  - 使用 Suspense 组件，传递 fallback 属性显示加载时内容。

react 原理

函数式编程

- 纯函数
- 不可变值

状态码
- 100:客户端继续请求
- 101:服务器根据客户端得请求切换协议
- 200:请求成功
- 202:已接受但未处理完成
- 204:无内容
- 301:永久重定向
- 302:临时重定向
- 304:未修改
- 400 bad:请求语法错误
- 401 unauthorized:要求用户身份认证
- 403 forbidden:拒绝此请求
- 500 server Error:服务器错误
- 502 bad gateway:网关或代理服务器错误
- 504 gateway time-out:网关或代理服务器超时

# vue
- 为什么vue2中只能有一个根节点但是vue3中可以有多个？
> vue2中vdom需要有一个单根节点作为入口，这样才能向下遍历，但vue3引入了Fragement节点，当顶层节点包含多个入口节点时会自动创建Fragement节点将这些节点包裹，转化为render函数时，会自动跳过Fragement节点转而遍历子节点。
# 原型链
![/images/image-20240123164938769](/images/原型链.png)
```js
const date = new Date();
const a = {name:1}
console.log(date.constructor.name);
console.log(Date.prototype);
console.log(date.__proto__);
console.log(Date.prototype===date.__proto__);
console.log(Date.prototype.constructor===Date);
console.log(date.constructor.prototype.constructor===date.__proto__.constructor);
console.log(date.constructor.prototype.constructor===Date.prototype.constructor);
console.log(date.__proto__.constructor===date.constructor);
console.log(Date.prototype.constructor===date.constructor);
console.log(Date.prototype.constructor===Date);
console.log(Date.prototype.__proto__===Object.prototype);
console.log(Date.prototype.__proto__===a.__proto__);
//Function相关
console.log(Function.prototype===Function.__proto__);
console.log(Function.constructor === Function);
const fn = function(){};
console.log(Function.__proto__===fn.__proto__);
```
