---
title: 浮点数存储
date: 2023-7-2 12:24:4
categories:
- 计算机组成原理
tags:
- 浮点数
- 存储
---
思考：

为什么0.1+0.2 != 0.3？

为什么1.005.toFixed(2)=1.00而不是1.01

双精度存储
首先在开始之前需要了解一下JavaScript的number类型在计算机中是如何存储的，这也是一切问题的基础。JavaScript的数字都是number类型的，不管是整数还是浮点数都以IEEE754双精度的格式存储在计算机中，什么是双精度呢？就是以64个bit位来存储

分别是1个符号位+11个指数位+52个尾数位

举个例子，如果是5.5这个数字的话，则计算过程是这样的：

5.5 转二进制 =====> 101.1 科学计数法 =====> 1.011*2^2
存入计算机：
符号位：0
指数位：2 加1023 =====> 1025 转二进制 =====> 10000000001
尾数位：1.011 隐去小数点左边的1 =====> 011

为什么0.1+0.2 != 0.3？
答：0.1 转二进制 =====> 0.0001100110011001100…(1100循环)
转科学计数法 =====> 1.100110011…(1100循环) *2^-4
数据是无限循环的，但是可供使用的尾数位却是有限的，只有52位可以使用，所以在第53位会被舍去并且进位

计算结果转换为十进制数字就是0.30000000000000004

所以就是因为，0.1和0.2在计算机中的二进制存储会让它们本身损失掉一定的精度，而它们在计算机中的二进制存储转换成十进制时已经不是真正的0.1和0.2了，相加的结果也就自然不是0.3了。

问题来了，既然0.1在计算机中的存储已经有了舍入误差，那为什么num=0.1能得到0.1呢？

可以在控制台使用toPrecision看一下0.1在不同精度下的返回

可以看出来其实0.1是截断了一部分精度后得到的结果，那么这个问题就可以转化为：双精度浮点数是按什么规则来截断的呢？
答：如果一个 IEEE 754 的双精度浮点数被转成至少含17位有效数字的十进制数字字符串，当这个字符串转回双精度浮点数时，必须要跟原来的数相同；换句话说，如果一个双精度的浮点数转为十进制的数字时，只要它转回来的双精度浮点数不变，精度取最短的那个就行。

拿0.1来举例子，0.1和0.10000000000000001转成双精度浮点数的存储是一样的，所以取最短的0.1就行了。

为什么1.005.toFixed(2)=1.00而不是1.01
因为在第一个问题中已经说了，一个十进制数字转为双精度浮点数然后再取出来时，跟原十进制数字可能会有误差，试一下1.005取20个精度：

1.005.toPrecision(20) //返回1.0049999999999998934
很明显1.005只是一个被截断后的数字，它的双精度浮点数代表的20位精度的数字是1.0049999999999998934，所以进行保留2位的四舍五入时，2位后的数字会被全部舍去。