# 字符串

## →→→→比较版本号

* 变成数组，取最大长度
* 循环遍历，不够补零
* parseInt 转成数字进行比较

~~~js
var compareVersion = function (version1, version2) {
  const a = version1.split(".");
  const b = version2.split(".");
  const n = Math.max(a.length, b.length);
  for (let i = 0; i < n; i++) {
    const num1 = a[i] || 0;
    const num2 = b[i] || 0;
    if (num1 == num2) continue;
    if (parseInt(num1) > parseInt(num2)) return 1;
    if (parseInt(num2) >parseInt(num1)) return -1;
  }
  return 0;
};

~~~

## →→→→→大数相加

* 获取最大长度，注意遍历顺序

~~~js
var addStrings = function (num1, num2) {
  const maxLength = Math.max(num1.length, num2.length);
  num1 = num1.padStart(maxLength, 0);
  num2 = num2.padStart(maxLength, 0);
  let carry = 0;
  let res = "";
  for (let i = maxLength - 1; i >= 0; i--) {
    let sum = parseInt(num1[i]) + parseInt(num2[i]) + carry;
    carry = Math.floor(sum / 10);
    res += sum % 10;
  }
  if (carry === 1) res += "1";
  return res.split("").reverse().join("");
};

~~~

## 大数相减

~~~js
function subtract(num1, num2) {
  let maxLength = Math.max(num1.length, num2.length);
  num1 = num1.padStart(maxLength, 0);
  num2 = num2.padStart(maxLength, 0);
  if (num1 < num2) {
    [num1, num2] = [num2, num1];
  }
  let borrow = 0
  let res = ''
  for (let i = maxLength - 1; i >= 0; i--) {
    let diff = parseInt(num1[i]) - parseInt(num2[i]) - borrow
    if (diff < 0) {
      borrow = 1
      diff += 10
    } else {
      borrow = 0
    }
    res = diff.toString() + res
  }
  while (res.length > 1 && res[0] === '0') {
    res = res.substring(1)
  }
  return res
}
~~~

## →→→→大数相乘

* 使用数组存储
* 每个相乘，进行填充
* 把剩下的 0 去掉

~~~js
var multiply = function(num1, num2) {
  const m = num1.length;
  const n = num2.length;
  const res = new Array(m + n).fill(0);
  for (let i = m - 1; i >= 0; i--) {
    for (let j = n - 1; j >= 0; j--) {
      const mul = (num1[i] - "0") * (num2[j] - "0");
      // 高位
      const p1 = i + j;
      // 低位
      const p2 = i + j + 1;
      const sum = mul + res[p2];
       // 个位
      res[p2] = sum % 10;
       // 去掉个位，进位
      res[p1] += Math.floor(sum / 10);
    }
  }
  while (res[0] === 0) {
    res.shift();
  }
  return res.length? res.join(""):'0';
}
~~~

## →→→→字符串转换整数

* parseInt

~~~js
var myAtoi = function(str) {
    const number = parseInt(str, 10);
    if(isNaN(number)) {
        return 0;
    } else if (number < Math.pow(-2, 31) || number > Math.pow(2, 31) - 1) {
        return number < Math.pow(-2, 31) ? Math.pow(-2, 31) : Math.pow(2, 31) - 1;
    } else {
        return number;
    }
};

~~~

## 反转字符串

~~~js
var reverseString = function (s) {
  let left = 0 
  let right = s.length-1
  while (left < right) {
    swap(s, left, right)
    left++
    right--
  }
  return s
};
function swap(arr, i, j) {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}
~~~

## 反转字符串二

~~~js
var reverseStr = function (s, k) {
  const str = s.split("");
  for (let i = 0; i < str.length; i += 2 * k) {
    if (i + k > str.length) {
      reverse(str, i, str.length - 1);
      return str.join("");
    }
    reverse(str, i, i + k - 1);
    console.log(str);
  }
  return str.join("");
};
function reverse(s, i, j) {
  while (i < j) {
    swap(s, i, j);
    i++;
    j--;
  }
}
function swap(arr, i, j) {
  const temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

~~~

## 替换数字

~~~js
function replaceNum(str) {
  const s = str.split("");
  let count = 0;
  for (let i = 0; i < s.length; i++) {
    if (s[i] >= "0" && s[i] <= "9") {
      count++;
    }
  }
  let i = s.length - 1;
  let j = s.length - 1 + count * 5;
  for (let k = i + 1; k <= j; k++) {
    s[k] = 0;
  }
  while (i < j) {
    if (s[i] >= "0" && s[i] <= "9") {
      s[j] = "r";
      s[j - 1] = "e";
      s[j - 2] = "b";
      s[j - 3] = "m";
      s[j - 4] = "u";
      s[j - 5] = "n";
      j -= 5;
    }
    i--;
    j--;
  }

  return s.join("");
}
let str = "hvh33bbb";
console.log(replaceNum(str)); // hvhnumbernumber000

~~~

## 反转字符串中的单词

* 变成数组
* 去除空格
* 整体翻转

~~~js
var reverseWords = function (s) {
  const str = s.split("");
  removeSpace(str);
  reverse(str, 0, str.length - 1);

  let start = 0;
  for (let i = 0; i <= str.length; i++) {
    if (str[i] === " " || i === str.length) {
      reverse(str, start, i - 1);
      start = i + 1;
    }
  }
  return str.join("");
};

function removeSpace(str) {
  let j = 0;
  for (let i = 0; i < str.length; i++) {
      // 不要这个了：首位为" " || 前一个为" "
    if (str[i] === " " && (i === 0 || str[i - 1] === " ")) {
      continue;
    } else {
        // 把之前不要的覆盖掉 || 正常往后面追加
      str[j++] = str[i];
    }
  }
    // 倒数最后一个是不是为" "，是的话就 j-1，不是就是 j 个长度
  str.length = str[j - 1] === " " ? j - 1 : j;
}
function reverse(str, i, j) {
  while (i < j) {
    swap(str, i, j);
    i++;
    j--;
  }
}
function swap(str, i, j) {
  const temp = str[i];
  str[i] = str[j];
  str[j] = temp;
}

~~~

## 右旋字符串

~~~js
const reverseKString = (str, k) => {
  const s = str.split("");
  reverse(s, 0, s.length - 1);
  reverse(s, 0, k - 1);
  reverse(s, k, s.length - 1);
  return s.join("");
};
function reverse(str, i, j) {
  while (i < j) {
    swap(str, i, j);
    i++;
    j--;
  }
}
function swap(str, i, j) {
  const temp = str[i];
  str[i] = str[j];
  str[j] = temp;
}
~~~

## KMP

* 解决问题
  * 文本串是否出现模式串

* 作用    
  * 匹配失败，跳到之前匹配的位置
* 前缀表
  * 作用
    * 找到之前已经匹配过的内容

  * 存储值
    * 最长相等的前后缀
      * a 0
      * aa 1
      * aab 0
      * aaba 1
      * aabaa 2
      * aabaaf 0

    * 0 1 0 1 2 0

  * 获取
    * 初始化
    * 处理前后缀不相同的情况
    * 处理前后缀相同的情况
    * 更新 next 的值

* 代码
  * i：指向后缀末尾
    * 初始化：1

  * j：指向前缀末尾
    * 初始化：0




### 找出字符串中第一个匹配项的下标

~~~js
var strStr = function (haystack, needle) {
  const m = haystack.length;
  const n = needle.length;
  if (n === 0) return 0;
  const next = new Array(n).fill(0);
  for (let i = 1, j = 0; i < n; i++) {
    while (j > 0 && needle[j] !== needle[i]) {
      j = next[j - 1];
    }
    if (needle[i] === needle[j]) {
      j++;
    }
    next[i] = j;
  }
  for (let j = 0, i = 0; i < m; i++) {
    while (j > 0 && needle[j] !== haystack[i]) {
      j = next[j - 1];
    }
    if (needle[j] === haystack[i]) {
      j++;
    }
    if (j === n) {
      return i - j + 1;
    }
  }
  return -1;
};

~~~

### 重复的子字符串

~~~js
var repeatedSubstringPattern = function (s) {
  if (s.length === 0) return false;
  const next = [0];
  for (let i = 1, j = 0; i < s.length; i++) {
    while (j > 0 && s[i] !== s[j]) {
      j = next[j - 1];
    }
    if (s[i] === s[j]) {
      j++;
    }
    next[i] = j;
  }
  console.log(next);
  // 除数不能为 0                               长度 - next 数组长度
  if (next[next.length - 1] !== 0 && s.length % (s.length - next[next.length - 1]) === 0) return true;
  return false;
};

~~~



# 哈希表

## 有效的字母异位词

~~~js
var isAnagram = function (s, t) {
  const hash = new Array(26).fill(0);
  const base = "a".charCodeAt();
  for (const item of s) {
    hash[item.charCodeAt() - base]++;
  }
  for (const item of t) {
    hash[item.charCodeAt() - base]--;
  }
  for (let i = 0; i < hash.length; i++) {
    if (hash[i] !== 0) return false;
  }
  return true;
};

~~~

## 赎金信

~~~js
var canConstruct = function (ransomNote, magazine) {
  const hash = new Array(26).fill(0);
  const base = "a".charCodeAt();
  for (const i of magazine) {
    hash[i.charCodeAt() - base]++;
  }
  for (const i of ransomNote) {
    hash[i.charCodeAt() - base]--;
  }
  for (let i = 0; i < 26; i++) {
    if (hash[i] < 0) return false;
  }
  return true;
};

~~~



## →→→→→无重复字符的最长子串

* 哈希存储
  * key：元素
  * value：下标
* 双指针
  * i：有重复字符就跳
  * j

* 每次都比较，每次都存

~~~js
function getLength(str) {
  let map = new Map();
  let i = 0;
  let res = 0;
  for (let j = 0; j < str.length; j++) {
    if (map.has(str[j]) && map.get(str[j]) >= i) {
      i = map.get(str[j]) + 1;
    }
    res = Math.max(res, j - i + 1);
    map.set(str[j], j);
  }
  return res;
}
~~~

## →→→→→ LRU 缓存

* map 存储 key，value
* 迭代器获取最后一个 key：data.keys().next().value
  * 最后一个是最先放进来的


~~~js
var LRUCache = function(capacity){
    this.length = capacity
    this.data = new Map()
}
LRUCache.prototype.get = function(key){
    const data = this.data
    if(!data.has(key)) return -1
    const value = data.get(key)
    data.delete(key)
    data.set(key,value)
    return value
}
LRUCache.prototype.put = function(key,value){
	const data = this.data
    if(data.has(key)){
        data.delete(key)
    }
    data.set(key,value)
    if(data.size > this.length){
        const delKey = data.keys().next().value
        data.delete(delKey)
    }
}
~~~

## →→→→→两数之和

~~~js
function getTwoSum(nums,target){
    let map = new Map()
    for(let i = 0;i<nums.length;i++){
        const num1 = nums[i]
        const num2 = target - num1
        if(map.has(num2)){
            return [map.get(num2),i]
        }else{
            map.set(num1,i)
        }
    }
    return []
}
~~~

## 两数之和（去重）

~~~js
var twoSum = function(nums, target) {
  const used = {};
  const res = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] in used) {
      used[nums[i]] += 1;
    } else {
      used[nums[i]] = 1;
    }
  }
  for (let i = 0; i < nums.length; i++) {
    const num1 = nums[i];
    const num2 = target - num1;
    if (used[num1] > 0 && used[num2] > 0) {
      res.push([num1, num2]);
      used[num1] -= 1;
      used[num2] -= 1;
    }
  }
  return res;
};
~~~

## 最小覆盖子串

~~~js
var minWindow = function(s, t) {
	let l = 0
    let r = 0
    const need = new Map()
    let res = ''
    // 统计 t 中字符串
    for(const c of t){
        need.set(c,need.has(c)?need.get(c)+1:1)
    }
    let needType = need.size
    
    while(r < s.length){
        if(need.has(s[r])){
            need.set(s[r],need.get(s[r]) - 1)
            if(need.get(s[r])===0){
                needType -= 1
            }
        }
        // 已经满足需要了，开始缩小窗口
        while(needType === 0){
            // [0,r+1)
            const newStr = s.substring(l,r+1)
            // 首次赋值=》
            if(!res || newStr.length < res.length) res = newStr
            // 如果发现当前这个值是需要的（并且只有这一个），会跳出这个循环，即便 l++ 了，但是已经不会执行后面的语句
            if(need.has(s[l])){
                need.set(s[l],need.get(s[l])+1)
                if(need.get(s[l])===1){
                    needType += 1
                }
            }
            l++
        }
        // 
        r++
    }
    return res
};
~~~

## →→→→最长连续序列

~~~js
var longestConsecutive = function (nums) {
  let maxCount = 0;
  nums = new Set(nums);
  for (let value of nums) {
    if (nums.has(value - 1)) continue;
    let count = 1;
    while (nums.has(value + 1)) {
      nums.delete(value + 1);
      value++;
      count++;
    }
    maxCount = Math.max(maxCount, count);
  }

  return maxCount;
};

~~~

## 交集并集

~~~js
// 交集
var intersection = function (nums1, nums2) {
  const set1 = new Set(nums1);
  const set2 = new Set(nums2);
  const res = [];
  for (const item of set1) {
    set2.has(item) ? res.push(item) : "";
  }
  return res;
};
// 并集
var getUnion = function (nums1, nums2) {
  return [...new Set([...nums1, ...nums2])];
};

~~~

## 两个数组的交集 II

~~~js
var intersect = function (nums1, nums2) {
  const obj = {};
  const res = [];
  for (const item of nums1) {
    if (obj[item]) {
      obj[item]++;
    } else {
      obj[item] = 1;
    }
  }
  for (const item of nums2) {
    if (obj[item] > 0) {
      res.push(item);
      obj[item]--;
    }
  }
  return res;
};

~~~

## 快乐数

~~~js
var isHappy = function (n) {
  const set = new Set();
  while (n !== 1 && !set.has(n)) {
    set.add(n);
    n = getSum(n);
  }
  return n === 1;
};
function getSum(n) {
  let sum = 0;
  while (n) {
    // % 获取个位
    sum += (n % 10) ** 2;
    // / 去掉个位
    n = Math.floor(n / 10);
  }
  return sum;
}
~~~

## 两数之和

~~~js
function getTwoSum(nums, target) {
  let map = new Map();
  for (let i = 0; i < nums.length; i++) {
    const num1 = nums[i];
    const num2 = target - num1;
    if (map.has(num2)) {
      return [map.get(num2), i];
    }
    map.set(num1, i);
  }
  return [];
}

~~~

## 四数相加

~~~js
var fourSumCount = function (nums1, nums2, nums3, nums4) {
  const map = new Map();
  let count = 0;
  for (const i of nums1) {
    for (const j of nums2) {
      map.set(i + j, (map.get(i + j) || 0) + 1);
    }
  }
  for (const i of nums3) {
    for (const j of nums4) {
      count += map.get(-(i + j)) || 0;
    }
  }
  return count;
};

~~~

## 多数元素

~~~js
var majorityElement = function (nums) {
  if (nums.length === 1) return nums[0];
  const map = new Map();
  const target = nums.length/2
  for (let num of nums) {
    if (!map.get(num)) {
      map.set(num, 1);
    } else {
      map.set(num, map.get(num) + 1);
      if (map.get(num) > target) {
        return num;
      }
    }
  }
};
~~~



# 链表

## →→→回文链表

~~~js
var isPalindrome = function (head) {
  if (head === null || head.next === null) return true;
  let slow = head;
  let fast = head;
  let prev = null;
  while (fast && fast.next) {
    fast = fast.next.next;
    prev = slow;
    slow = slow.next;
  }
  prev.next = null;
  let newHead = reverse(slow);
  while (newHead && head) {
    if (newHead.val !== head.val) return false;
    newHead = newHead.next;
    head = head.next;
  }
  return true;
};
const reverse = (head) => {
  let newHead = null;
  while (head) {
    let current = head.next;
    head.next = newHead;
    newHead = head;
    head = current;
  }
  return newHead;
};
~~~

## 移除链表元素

~~~js
var removeElements = function (head, val) {
  let dummy = new ListNode(0, head);
  let cur = dummy;
  while (cur && cur.next) {
    if (val === cur.next.val) {
      cur.next = cur.next.next;
    } else {
      cur = cur.next;
    }
  }
  return dummy.next;
};

~~~

## →→→→→反转链表

~~~js
function reverseList(head) {
  if (head===null || head.next===null) return head
  let prev = null
  let cur = head
  while (cur) {
    let temp = cur.next
    cur.next = prev
    prev = cur
    cur = temp
  }
  return prev
}

~~~

## →→→→→反转链表二

~~~js
var reverseBetween = function (head, left, right) {
  const dummyNode = new ListNode(0);
  dummyNode.next = head;
  let prev = dummyNode;
  for (let i = 1; i < left; i++) {
    prev = prev.next;
  }
  let leftNode = prev.next;
  let rightNode = prev.next;
  for (let i = 1; i <= right - left; i++) {
    rightNode = rightNode.next;
  }
  let post = rightNode.next;
  prev.next = null;
  rightNode.next = null;
  prev.next = reverseLinkList(leftNode);
  leftNode.next = post;
  return dummyNode.next;
};
const reverseLinkList = (head) => {
  let prev = null;
  let cur = head;
  while (cur) {
    const temp = cur.next;
    cur.next = prev;
    prev = cur;
    cur = temp;
  }
  return prev;
};

~~~

## 两两交换链表中的节点

~~~js
var swapPairs = function (head) {
  if (!head || !head.next) {
    return head;
  }
  let dummy = new ListNode(0, head);
  let cur = dummy;
  while (cur.next && cur.next.next) {
    const temp1 = cur.next;
    const temp2 = cur.next.next.next;
    cur.next = cur.next.next;
    cur.next.next = temp1;
    temp1.next = temp2;
    cur = cur.next.next;
  }
  return dummy.next;
};
~~~

## →→→→→合并两个有序链表

~~~js
function mergeLists(list1,list2){
    const l3= new ListNode(0)
    let p = l3
    let p1 = list1
    let p2 = list2
    while(p1 && p2){
        if(p1.value <= p2.value){
            p.next = p1
            p1 = p1.next
        }else{
             p.next = p2
            p2 = p2.next
        }
        p = p.next
    }
    if(p1){
        p.next = p1
    }
    if(p2){
        p.next = p2
    }
    return l3.next
}
~~~

## →→→→→环形链表

~~~js
var hasCycle = function (head) {
  let slow = head;
  let fast = head;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (fast === slow) return true;
  }
  return false;
};

~~~

## →→→→→环形链表二

~~~js
var detectCycle = function (head) {
  if (head === null || head.next === null) return null;
  let slow = head
  let fast = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (slow === fast) {
      slow = head
      while (fast !== slow) {
        slow = slow.next
        fast = fast.next
      }
      return fast
    }
  }
  return null
};

~~~



## →→→→→重排链表

* 不需要虚拟节点捣乱

* 找到中点
* 反转后半部分
* 依次拼接

~~~js
var reorderList = function (head) {
  if (!head || !head.next) {
    return head;
  }
  let slow = head;
  let fast = head;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }
  let next = slow.next;
  slow.next = null;
  let newHead = reverseList(next);
   // 记录要返回的节点
  let resHead = head;
  while (newHead && head) {
      // 记录第二行第二个
    const cur = head.next;
      // 指向上面了
    head.next = newHead;
   	  // 跳到下一个 
    newHead = newHead.next;
      // 连成一个三角形
    head.next.next = cur;
   	  // 也跳到下一个
    head = cur;
  }
  return resHead;
};

function reverseList(head) {
  let prev = null;
  let cur = head;
  while (cur) {
    const temp = cur.next;
    cur.next = prev;
    prev = cur;
    cur = temp;
  }
  return prev;
}

~~~

## →→→→→删除链表的倒数第 N 个结点

~~~js
var removeNthFromEnd = function(head, n) {
    if(!head) return head
    let dummy = new ListNode(0,head)
    let fast = dummy
    n++
    while(n--){
        fast = fast.next
    }
    let slow = dummy
    while(fast){
        fast = fast.next
        slow = slow.next
    }
    slow.next = slow.next.next
    return dummy.next
};
~~~

## →→→→链表中的倒数第 k 个结点

~~~js
var trainingPlan = function(head, cnt) {
  let slow = head
  let fast = head
  while (cnt--) {
    fast = fast.next
  }
  while (fast) {
    fast = fast.next
    slow = slow.next
  }
  return slow
};
~~~

## →→→删除排序链表中的重复元素

~~~js
var deleteDuplicates = function(head) {
    if(!head){
        return head
    }
    const dummy = new ListNode(0,head)
    let cur = dummy
    while(cur.next && cur.next.next){
        if(cur.next.val === cur.next.next.val){
            cur.next = cur.next.next
        }else{
            cur = cur.next
        }
    }
    return dummy.next
};
~~~

## →→→→→删除排序链表中的重复元素二

* cur.next：所以 cur 就是 dummy 了

~~~js
var deleteDuplicates = function (head) {
  if (!head) return head;
  let dummy = new ListNode(0, head);
  let cur = dummy;
  while (cur.next && cur.next.next) {
    if (cur.next.val === cur.next.next.val) {
      const value = cur.next.val;
      while (cur.next && value === cur.next.val) {
        cur.next = cur.next.next;
      }
    } else {
      cur = cur.next;
    }
  }
  return dummy.next;
};


~~~

## →→→→→相交链表

~~~js
var getIntersectionNode = function (headA, headB) {
  if (!headA || !headB) return null;
  let pA = headA;
  let pB = headB;
  while (pA !== pB) {
    pA = pA ? pA.next : headB;
    pB = pB ? pB.next : headA;
  }
  return pA;
};

~~~

## →→→→排序链表

* 归并排序

~~~js
var sortList = function (head) {
  if (head === null || head.next === null) return head;
  let slow = head;
  let fast = head;
  let prev = null;
  while (fast && fast.next) {
    fast = fast.next.next;
    prev = slow;
    slow = slow.next;
  }
  // 从中间分割前后两个链表
  prev.next = null;
  // 递归
  const l1 = sortList(head);
  const l2 = sortList(slow);
  // 合并
  return mergeList(l1, l2);
};
const mergeList = (l1, l2) => {
  const dummy = new ListNode(0);
  let p = dummy;
  // 重新创建节点
  while (l1 && l2) {
    if (l1.val <= l2.val) {
      p.next = new ListNode(l1.val);
      l1 = l1.next;
    } else {
      p.next = new ListNode(l2.val);
      l2 = l2.next;
    }
    p = p.next;
  }
  if (l1) p.next = l1;
  if (l2) p.next = l2;
  return dummy.next;
};

~~~

## →→→→两数相加

* 从前往后
* 放在一条新的链表上面
* 循环条件

~~~js
var addTwoNumbers = function (l1, l2) {
  const l3 = new ListNode(0);
  let p1 = l1;
  let p2 = l2;
  let p3 = l3;
  let carry = 0;
  while (p1 || p2) {
    const v1 = p1 ? p1.val : 0;
    const v2 = p2 ? p2.val : 0;
    const val = v1 + v2 + carry;
    // 获取进位
    carry = Math.floor(val / 10);
    // 获取个位
    p3.next = new ListNode(val % 10);
    if (p1) p1 = p1.next;
    if (p2) p2 = p2.next;
    p3 = p3.next;
  }
  if (carry) {
    p3.next = new ListNode(carry);
  }
  return l3.next;
};
~~~



# 堆

## →→→→→数组中的第K个最大元素

~~~js
function findKthLargest(nums, k) {
  const heap = new MinHeap(nums);
  nums.forEach((n) => {
    heap.insert(n);
    if (heap.size() > k) {
      heap.extract();
    }
  });
  return heap.peek();
}
// 最小堆
class MinHeap {
  constructor() {
    this.data = [];
    this.length = 0;
  }
  swap(i, j) {
    const temp = this.data[i];
    this.data[i] = this.data[j];
    this.data[j] = temp;
  }
  // 插入
  insert(value) {
    this.data.push(value);
    this.length++;
    this.heapify_up();
  }
  // 上滤
  heapify_up() {
    let index = this.length - 1;
    while (index > 0) {
      let parentIndex = Math.floor((index - 1) / 2);
      if (this.data[parentIndex] <= this.data[index]) {
        break;
      }
      this.swap(index, parentIndex);
      index = parentIndex;
    }
  }
  // 删除
  extract() {
    if (this.length === 0) return undefined;
    if (this.length === 1) {
      this.length--;
      this.data.pop();
    }
    const top = this.data[0];
    this.data[0] = this.data.pop();
    this.length--;
    this.heapify_down(0);
    return top;
  }
  // 下滤
  heapify_down(index) {
    while (2 * index + 1 < this.length) {
      let leftIndex = 2 * index + 1;
      let rightIndex = leftIndex + 1;
      let smallerIndex = leftIndex;
      if (rightIndex <= this.length && this.data[leftIndex] > this.data[rightIndex]) 
          smallerIndex = rightIndex;
      if (this.data[smallerIndex] >= this.data[index]) break;
      this.swap(smallerIndex, index);
      index = smallerIndex;
    }
  }
  peek() {
    return this.data[0];
  }
  size() {
    return this.length;
  }
  isEmpty() {
    return this.length === 0;
  }
}

~~~

## 前 k 个高频元素

~~~js
function topKFrequent(nums, k) {
  const map = new Map();
  const heap = new Heap();
  for (const item of nums) {
    map.set(item, (map.get(item) || 0) + 1);
  }
  map.forEach((value, key) => {
    heap.insert({ key, value });
    if (heap.length > k) {
      heap.delete();
    }
  });
  return heap.data.map((item) => item.key);
}
class Heap {
  constructor() {
    this.data = [];
    this.length = 0;
  }
  insert(value) {
    this.data.push(value);
    this.length++;
    this.heapify_up();
  }
  swap(i, j) {
    const temp = this.data[i];
    this.data[i] = this.data[j];
    this.data[j] = temp;
  }
  heapify_up() {
    let index = this.length - 1;
    while (index > 0) {
      let parentIndex = Math.floor((index - 1) / 2);
      if (this.data[parentIndex] && this.data[parentIndex].value <= this.data[index].value) {
        break;
      }
      this.swap(parentIndex, index);
      index = parentIndex;
    }
  }
  delete() {
    if (this.length === 0) return undefined;
    if (this.length === 1) {
      this.length--;
      this.data.pop();
    }
    const top = this.data[0];
    this.data[0] = this.data.pop();
    this.length--;
    this.heapify_down(0);
    return top;
  }
  heapify_down(index) {
    while (2 * index + 1 <= this.length - 1) {
      let leftIndex = 2 * index + 1;
      let rightIndex = leftIndex + 1;
      let lesserIndex = leftIndex;
      if (this.data[rightIndex] && this.data[rightIndex].value < this.data[leftIndex].value) {
        lesserIndex = rightIndex;
      }
      if (this.data[lesserIndex].value >= this.data[index].value) {
        break;
      }
      this.swap(lesserIndex, index);
      index = lesserIndex;
    }
  }
}

~~~



# 双指针法

## →→→→→三数之和

~~~js
function threeSum(nums) {
  const res = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > 0) return res;
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    let left = i + 1;
    let right = nums.length - 1;
    while (left < right) {
      if (nums[i] + nums[left] + nums[right] === 0) {
        res.push([nums[i], nums[left], nums[right]]);
        while (left < right && nums[left] === nums[left + 1]) {
          left++;
        }
        while (left < right && nums[right] === nums[right - 1]) {
          right--;
        }
        left++;
        right--;
      } else if (nums[i] + nums[left] + nums[right] > 0) {
        right--;
      } else {
        left++;
      }
    }
  }
  return res;
}

~~~

## 四数之和

~~~js
var fourSum = function (nums, target) {
  const res = [];
  if (nums.length < 4) return res;
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    if (i > 0 && nums[i - 1] === nums[i]) {
      continue;
    }
    for (let j = i + 1; j < nums.length; j++) {
      if (j > i + 1 && nums[j - 1] === nums[j]) continue;
      let left = j + 1;
      let right = nums.length - 1;
      while (left < right) {
        const sum = nums[i] + nums[j] + nums[left] + nums[right];
        if (sum === target) {
          res.push([nums[i], nums[j], nums[left], nums[right]]);
          while (left < right && nums[left] === nums[left + 1]) {
            left++;
          }
          while (left < right && nums[right] === nums[right - 1]) {
            right--;
          }
          left++;
          right--;
        } else if (sum > target) {
          right--;
        } else {
          left++;
        }
      }
    }
  }
  return res;
};

~~~



## →→→→反转字符串中的单词

~~~js
var reverseWords = function (s) {
  const str = s.split("");
  // 去除无效空格
  removeSpace(str);
  // 全部翻转
  reverse(str, 0, str.length - 1);
  // 
  let  start = 0
  for (let i = 0; i <= str.length; i++){
    // 下一个是空格或者是最后一个了，就翻转
    if (str[i] === ' ' || i === str.length) {
      reverse(str, start, i-1)
      start = i+1
    }
  }
  return str.join('')
};
function removeSpace(str) {
  let j = 0;
  for (let i = 0; i < str.length; i++) {
    
    if (str[i] === " " && (i === 0 || str[i - 1] === " " || i===str.length-1)) {
      continue
    } else {
      str[j++] = str[i];
    }
  }
  str.length = str[j - 1] === " " ? j - 1 : j;
  console.log(str);
}
function reverse(str, i, j) {
  while (i < j) {
    swap(str, i, j);
    i++;
    j--;
  }
}
function swap(str, i, j) {
  const temp = str[i];
  str[i] = str[j];
  str[j] = temp;
}

~~~

## 反转字符串中的元音字母

~~~js
var reverseVowels = function (s) {
  let result;
  let temp;
  const arr = ["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"];
  const t = s.split("");
  let i = 0;
  let j = t.length - 1;

  while (i < j) {
    while (i < j && arr.indexOf(t[i]) === -1) {
      i++;
    }
    while (i < j && arr.indexOf(t[j]) === -1) {
      j--;
    }
    temp = t[i];
    t[i] = t[j];
    t[j] = temp;

    i++;
    j--;
  }
  result = t.join("");
  return result;
};

~~~

## 移除元素

~~~js
var removeElement = function(nums, val) {
  let j = 0
  for (let i = 0; i < nums.length; i++){
    if (nums[i] !== val) {
     nums[j++] = nums[i]
    }
  }
  return j
};
~~~

## 删除有序数组中的重复项

~~~js
var removeDuplicates = function(nums) {
  let j = 1
  for (let i = 1; i < nums.length; i++){
    if (nums[i] !== nums[i - 1]) {
      nums[j++] = nums[i]
    }
  }
  return j
};
~~~

## 移动 0

~~~js
function moveZeroes(nums) {
  let j = -1;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 0 && j < 0) {
      j = i;
    }
    if (nums[i] !== 0 && j >= 0) {
      swap(nums, i, j);
      j++;
    }
  }
  return nums;
}
const swap = (nums, i, j) => {
  const temp = nums[i];
  nums[i] = nums[j];
  nums[j] = temp;
};

~~~

## 比较含退格的字符串

~~~js
var backspaceCompare = function (s, t) {
  let i = s.length - 1;
  let j = t.length - 1;
  let skipS = 0;
  let skipT = 0;
  while (i >= 0 || j >= 0) {
    while (i >= 0) {
      if (s[i] === "#") {
        skipS++;
        i--;
      } else if (skipS > 0) {
        skipS--;
        i--;
      } else {
        break;
      }
    }
    while (j >= 0) {
      if (t[j] === "#") {
        skipT++;
        j--;
      } else if (skipT > 0) {
        skipT--;
        j--;
      } else break;
    }
    // 是否在有效范围内
    if (i >= 0 && j >= 0) {
      if (s[i] !== t[j]) {
        return false;
      }
      // 有一方不在有效范围内
    } else {
      // 如果有其中一个在有效范围内，说明长度不一样，返回 false
      if (i >= 0 || j >= 0) {
        return false;
      }
    }
    i--;
    j--;
  }
  return true;
};

~~~

## 有序数组的平方

~~~js
var sortedSquares = function (nums) {
  let i = 0;
  let j = nums.length - 1;
  let k = nums.length - 1;
  let res = [];
  while (i <= j) {
    const left = nums[i] * nums[i];
    const right = nums[j] * nums[j];
    if (left > right) {
      res[k--] = left;
      i++;
    } else {
      res[k--] = right;
      j--;
    }
  }
  return res;
};

~~~

## 长度最小的子数组

~~~js
var minSubArrayLen = function (target, nums) {
  let i = 0;
  let res = Infinity;
  let sum = 0;
  for (let j = 0; j < nums.length; j++) {
    sum += nums[j];
    while (sum >= target) {
      res = Math.min(res, j - i + 1);
      sum -= nums[i];
      i++;
    }
  }
  return res === Infinity ? 0 : res;
};
~~~

## 水果成篮

~~~js
var totalFruit = function (fruits) {
  const cnt = new Map();
  let i = 0;
  let res = 0;
  for (let j = 0; j < fruits.length; j++) {
    cnt.set(fruits[j], (cnt.get(fruits[j]) || 0) + 1);
    while (cnt.size > 2) {
      cnt.set(fruits[i], cnt.get(fruits[i]) - 1);
      if (cnt.get(fruits[i]) === 0) {
        cnt.delete(fruits[i]);
      }
      i++;
    }
    res = Math.max(res, j - i + 1);
  }
  return res;
};
~~~

## 最小覆盖子串

~~~js
var minWindow = function (s, t) {
  let i = 0;
  let res = "";
  const need = new Map();
  for (const item of t) {
    need.set(item, (need.get(item) || 0) + 1);
  }
  let needType = need.size;
  for (let j = 0; j <= s.length - 1; j++) {
    if (need.has(s[j])) {
      need.set(s[j], need.get(s[j]) - 1);
      if (need.get(s[j]) === 0) {
        needType--;
      }
    }
    while (needType === 0) {
      const newRes = s.substring(i, j + 1);
      if (!res || newRes.length < res.length) res = newRes;
      if (need.has(s[i])) {
        need.set(s[i], need.get(s[i]) + 1);
        if (need.get(s[i]) === 1) {
          needType++;
        }
      }
      i++;
    }
  }
  return res;
};

~~~

## →→→→→合并两个有序数组

* 逆向双指针
* 时间复杂度：O(m+n)
  * 指针移动单调递减，最多移动 m+n 次，因此时间复杂度为 O(m+n)
* 空间复杂度：O(1)

~~~js
const merge = (nums1, m, nums2, n) => {
  let i = m - 1;
  let j = n - 1;
  let tail = m + n - 1;
  while (i >= 0 && j >= 0) {
    if (nums1[i] > nums2[j]) {
      nums1[tail] = nums1[i];
      i--;
    } else {
      nums1[tail] = nums2[j];
      j--;
    }
    tail--
  }
  while (tail >= 0 && i >= 0) {
    nums1[tail] = nums1[i];
    tail--;
    i--;
  }

  while (tail >= 0 && j >= 0) {
    nums1[tail] = nums2[j];
    tail--;
    j--;
  }
};
~~~

## 

# 动态规划一维

>- 动规五部曲
>  - dp 数组以及下标的含义
>
>  - 递推公式
>
>  - dp 数组初始化
>
>  - 遍历顺序
>
>  - 打印 dp 数组
>

## →→→→→最大子数组（子序）和

- dp[i]

  - 以 i 为结尾的最大子序和

  - Math.max(...dp)

- 递推公式

  - 情况

    - **重开**

    - **延续前面的和**

  - 状态
    - dp[i] = Math.max(dp[i-1],nums[i])

- dp 数组初始化

  - dp[0] = nums[0]

~~~js
var maxSubArray = function (nums) {
  const dp = new Array(nums.length).fill(0);
  dp[0] = nums[0];
  let res = dp[0];
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
    res = Math.max(dp[i], res);
  }
  return res;
};

~~~

## →→→→→最长递增子序列

- dp[i]

  - 以 i 为结尾的最长递增子序列长度

  - Math.max(...dp)

- 递推公式

  - nums[i]>nums[j]     dp[i] = Math.max(dp[i],dp[j]+1)

- dp 数组初始化

  - fill(1)

~~~js
var lengthOfLIS = function (nums) {
  const dp = new Array(nums.length).fill(1);
  let max = -Infinity
  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
        max = Math.max(max,dp[i])
      }
    }
  }
  console.log(dp);
  return max === -Infinity ? 1 : max
};
~~~

## →→→→爬楼梯

~~~js
var climbStairs = function (n) {
  const dp = [];
  dp[1] = 1;
  dp[2] = 2;
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
};

~~~

## →→→→零钱兑换

- dp[j]

  - 装满容量为 j 的背包的最少物品
  - 凑成金额为 j 的最少硬币个数

- 递推公式

  - dp[j]=Math.min(dp[j],dp[j-coin[i]]+1)

- dp 数组初始化

  - dp[0] = 0

  - Infinity

- 遍历顺序

  - 组合
    - 先物品后背包

  - 排列
    - 先背包后物品

~~~js
var coinChange = function (coins, amount) {
  const dp = new Array(amount + 1).fill(Infinity);
  dp[0] = 0;
  for (let i = 0; i < coins.length; i++) {
    for (let j = coins[i]; j <= amount; j++) {
      dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount];
};

~~~

## →→→不同路径

~~~js
var uniquePaths = function (m, n) {
  const dp = new Array(m).fill().map((item) => new Array(n));
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1;
  }
  for (let i = 0; i < n; i++) {
    dp[0][i] = 1;
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
};
~~~



# 动态规划二维

## 最长回文子序列

>子序列：可以不连续
>
>子串：必须连续

- dp\[i][j]

  - i 到 j 范围的子串的最长回文子序列

- 递推公式

  - s[i] === s[j] 相同
    - dp\[i][j] = dp\[i+1][j-1] + 2

  - s[i] !== s[j] 不相同
    - dp\[i][j] = Math.max(dp\[i+1][j],dp\[i][j-1])

- dp 数组初始化

  - i===j      1

- 遍历顺序

  - 左下角开始

- 打印 dp 数组

~~~js
var longestPalindromeSubseq = function (s) {
  const dp = new Array(s.length).fill().map((item) => new Array(s.length).fill(0));
  for (let i = 0; i < s.length; i++) {
    dp[i][i] = 1;
  }
  for (let i = s.length - 1; i >= 0; i--){
    for (let j = i + 1; j <s.length; j++){
      if (s[i] === s[j]) {
        dp[i][j] = dp[i + 1][j - 1] + 2;
      } else {
        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
      }
    }
  }
  return dp[0][s.length-1]
};
~~~

## →→→→→最长回文子串

~~~js
var longestPalindrome = function (s) {
  let n = s.length;
  let res = s[0];
  let dp = new Array(n).fill().map(() => new Array(n).fill(false));
  for (let i = 0; i < s.length; i++) {
    dp[i][i] = true;
  }
  for (let i = s.length - 1; i >= 0; i--) {
    for (let j = i + 1; j < s.length; j++) {
      if (s[i] === s[j] && (j - i < 2 || dp[i + 1][j - 1])) {
        dp[i][j] = true;
      }
      if (dp[i][j] && j - i + 1 > res.length) {
        res = s.substring(i, j + 1);
      }
    }
  }
  return res;
};

~~~

## →→→→→买卖股票的最佳时机

- dp\[i][j]

  - dp\[i][0]
    - 第 i 天持有股票最大金额

  - dp\[i][1]
    - 第 i 天不持有股票的最大金额

- 递推公式（有 没有）

  - dp\[i][0] = Math.max(dp\[i-1][0],-price[i])
    - 之前就买了   或者  今天买了

  - dp\[i][1] =  Math.max(dp\[i-1][0]+price[i]，dp\[i-1][1])
    - 今天卖了   或者    前一天就没有了

- dp 数组初始化

  - dp\[0][0] = -price[0]

  - dp\[0][1] = 0



~~~js
var maxProfit = function(prices) {
  const dp = new Array(prices.length).fill().map(item=>new Array(2).fill(0));
  dp[0][0] = -prices[0]
  dp[0][1] = 0 
  for (let i = 1; i < prices.length; i++){
    dp[i][0] = Math.max(dp[i-1][0],-prices[i])
    dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i])
  }
  return dp[prices.length-1][1]

};
~~~

## 买卖股票的最佳时机 II



## →→→→→最长公共子序列

- dp\[i][j]

  - 以 i-1 为结尾的 nums1 和以 j-1 为结尾的 nums2 最长公共子序列长度

  - res 记录最大值

- 递推公式

  - if
    - nums1[i-1]===nums2[j-1]     dp\[i][j] = dp\[i-1][j-1] +1

  - else
    -  dp\[i][j] = Math.max( dp\[i-1][j], dp\[i][j-1])

- dp 数组初始化

  - 没有意义

    - 第一列

    - 第一行

  - fill(0)

~~~js
var longestCommonSubsequence = function(text1, text2) {
  const dp = new Array(text1.length + 1).fill(). map(item => new Array(text2.length + 1).fill(0))
  let res = -Infinity
  for (let i = 1; i <= text1.length; i++){
    for (let j = 1; j <= text2.length; j++){
      if(text1[i - 1] === text2[j - 1]){
        dp[i][j] = dp[i - 1][j - 1] + 1;
      }else{
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
      res = Math.max(res,dp[i][j])
    }
  }
  return res
};
~~~

## →→→→最小路径和

* dp\[i][j]=grid\[i][j]+Min(dp\[i-1][j],dp\[i][j-1])

~~~js
var minPathSum = function (grid) {
  const m = grid.length;
  const n = grid[0].length;
  const dp = new Array(m).fill().map(() => new Array(n).fill(Infinity));
  dp[0][0] = grid[0][0]
  for (let j = 1; j < n; j++){
    dp[0][j] = dp[0][j-1]+grid[0][j]
  }
  for (let i = 1; i < m; i++){
    dp[i][0] = dp[i-1][0]+grid[i][0]
  }
   console.log(dp)
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
    console.log(dp)
  return dp[m - 1][n - 1];
};

~~~

## →→→→最大正方形

* **dp\[ i ][ j ]** : 以 **(i, j)** 为 **右下顶点** 所能形成的最大正方形的**边长**
* dp\[1][1] =  1
* dp\[i][j] = Math.min(dp\[i - 1][j], dp\[i][j - 1], dp\[i - 1][j - 1]) + 1

~~~js
var maximalSquare = function (matrix) {
  const m = matrix.length;
  const n = matrix[0].length;
  const dp = new Array(m).fill().map(() => new Array(n).fill(0));

  let max = -Infinity;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (matrix[i][j] === "1") {
        if (i === 0 || j === 0) dp[i][j] = 1;
        else dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1;
      }
      max = Math.max(max, dp[i][j]);
    }
  }
  return max * max;
};

~~~

## →→→最长重复子数组

~~~js
var findLength = function (nums1, nums2) {
  const dp = new Array(nums1.length + 1).fill().map((item) => new Array(nums2.length + 1).fill(0));
  let res = 0
  for (let i = 1; i <= nums1.length; i++) {
    for (let j = 1; j <= nums2.length; j++) {
      if (nums1[i - 1] === nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
      res = Math.max(dp[i][j],res)
    }
  }
  return res
};
~~~



# 排序算法

## →→→→→快速排序

* 将一个大数组分成两个小数组，然后递归地对两个小数组进行排序
  * 通过选择一个基准元素，将数组分成左右两个部分，左部分的元素都小于或等于基准元素，右部分的元素都大于基准元素
    * 利用双指针算法，i找到比基准元素大的元素，j找到比基准元素小的元素
    * 直到j越过 i，基准元素和i交换
  * 对左右两部分分别进行递归调用快速排序，最终将整个数组排序

* 复杂度分析
  * **原地排序**算法，不需要额外的数组空间
  * 时间复杂度为O（nlogn）

~~~js
function quickSort(arr) {
  partition(0, arr.length-1)
  function partition(left, right) {
    if (left >= right) return 
    const pivot = arr[right]
    let i = left
    let j = right - 1
    while (i <= j) {
      while (arr[i] < pivot) i++
      while (arr[j] >= pivot) j--
      if (i < j) {
        swap(arr, i, j)
        i++
        j--
      }
    }
    swap(arr, i, right)
    partition(left,i-1 )
    partition(i+1,right)
  }
  return arr
}

function swap(arr, i, j) {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}
~~~

## 归并排序

~~~js
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  const mid = Math.floor(arr.length / 2);
  let leftArr = arr.slice(0, mid);
  let rightArr = arr.slice(mid);
  const newLeftArr = mergeSort(leftArr);
  const newRightArr = mergeSort(rightArr);
  let i = 0;
  let j = 0;
  let newArr = [];
  while (i < newLeftArr.length && j < newRightArr.length) {
    if (newLeftArr[i] <= newRightArr[j]) {
      newArr.push(newLeftArr[i]);
      i++;
    } else {
      newArr.push(newRightArr[j]);
      j++;
    }
  }
  if (i < newLeftArr.length) {
    newArr.push(...newLeftArr.slice(i));
  }
  if (j < newRightArr.length) {
    newArr.push(...newRightArr.slice(j));
  }
  return newArr;
}

~~~

## 冒泡排序

~~~js
function bubbleSort(arr) {
  const n = arr.length;
  // 外层 for 循环控制冒泡的次数
  for (let i = 0; i < n; i++) {
    let swaped = false;
    // 内层 for 循环控制每一次冒泡需要比较的次数
    for (let j = 0; j < n - 1-i; j++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        swaped = true;
      }
    }
    if (!swaped) break;
  }
  return arr;
}

~~~



# 二叉树

## →→→最大宽度

~~~js
var widthOfBinaryTree = function (root) {
  if (!root) return 0;
  let ans = 1n;
  let queue = [[0n, root]];
  while (queue.length) {
    const width = queue[queue.length - 1][0] - queue[0][0] + 1n;
    if (ans < width) {
      ans = width;
    }
    let temp = [];
    for (const [i, value] of queue) {
      value.left && temp.push([i * 2n, value.left]);
      value.right && temp.push([i * 2n + 1n, value.right]);
    }
    queue = temp;
  }
  return Number(ans);
};

~~~



## →→→→递归遍历——深度

~~~js
var preorderTraversal = function (root) {
  const res = [];
  const dfs = (node) => {
    if (!node) return;
    res.push(node.val);
    dfs(node.left);
    dfs(node.right);
  };
  dfs(root);
  return res;
};

var inorderTraversal = function (root) {
  const res = [];
  const dfs = (root) => {
    if (root === null) return;
    dfs(root.left);
    res.push(root.val);
    dfs(root.right);
  };
  dfs(root);
  return res;
};

var postorderTraversal = function (root) {
  const res = [];
  const dfs = (root) => {
    if (root === null) return;
    dfs(root.left);
    dfs(root.right);
    res.push(root.val);
  };
  dfs(root);
  return res;
};

~~~

## →→→→→迭代遍历——深度

>中序：一左走到头 =》出栈 =》右边入栈

~~~js
var preorderTraversal = function (root) {
  const res = [];
  if (!root) return res;
  const stack = [root];
  while (stack.length) {
    const cur = stack.pop();
    res.push(cur.val);
      // 为什么没有涉及到中呢，因为中在开始的时候已经加入进去了，剩下的都是左或者右
    cur.right && stack.push(cur.right);
    cur.left && stack.push(cur.left);
  }
  return res;
};

var inorderTraversal = function (root) {
  if (!root) return [];
    // 记录遍历的顺序
  const stack = [];
  const res = [];
    // 先处理的不是根节点
  let cur = root;
  while (stack.length || cur) {
    if (cur) {
      stack.push(cur);
      cur = cur.left;
    } else {
      // 获取结果
      cur = stack.pop();
      res.push(cur.val);
      // 处理完当前元素就去右边
      cur = cur.right;
    }
  }
  return res;
};

var postorderTraversal = function (root) {
  const res = [];
  if (!root) return res;
  const stack = [root];
  while (stack.length) {
    const cur = stack.pop();
    res.push(cur.val);
    cur.left && stack.push(cur.left);
    cur.right && stack.push(cur.right);
  }
    // 栈里面是 [中 右 左]
  return res.reverse();
};

~~~



## →→→→→最近公共祖先

* 找到最下边，然后向上返回 root

~~~js
var lowestCommonAncestor = function (root, p, q) {
  if (!root) return root;
  if (root === p || root === q) return root;
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  if (left && right) {
    return root;
  }
  if (left) return left;
  if (right) return right;
};

~~~

## →→→→→右视图

~~~js
var rightSideView = function (root) {
  if (!root) return [];
  const res = [];
  const queue = [root];
  while (queue.length) {
    let size = queue.length;
    while (size--) {
      const cur = queue.shift();
      if (size === 0) res.push(cur.val);
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
  }
  return res;
};

~~~

## 构造二叉树

### 中序与后序遍历

~~~js
var buildTree = function (inorder, postorder) {
  if (inorder.length === 0) return null;
  // 删除了一个
  const rootVal = postorder.pop();
  const root = new TreeNode(rootVal);
  const rootIndex = inorder.indexOf(rootVal);// 表示有几个
  root.left = buildTree(inorder.slice(0, rootIndex), postorder.slice(0, rootIndex));
  root.right = buildTree(inorder.slice(rootIndex + 1), postorder.slice(rootIndex));
  return root;
};

~~~

### →→→→前序与中序遍历

~~~js
var buildTree = function(preorder, inorder) {
  if (preorder.length === 0) return null
  const rootVal = preorder.shift()
  const root = new TreeNode(rootVal)
  const rootIndex = inorder.indexOf(rootVal)
  root.left = buildTree(preorder.slice(0,rootIndex),inorder.slice(0,rootIndex))
  root.right = buildTree(preorder.slice(rootIndex),inorder.slice(rootIndex+1))
  return root
};
~~~

### 最大二叉树

~~~js
var constructMaximumBinaryTree = function (nums) {
  const buildTree = (arr, left, right) => {
    if (left > right) return null;
    let index = -1;
    let max = -1;
    for (let i = left; i <= right; i++) {
      if (arr[i] > max) {
        max = arr[i];
        index = i;
      }
    }
    const node = new TreeNode(max);
    node.left = buildTree(arr, left, index - 1);
    node.right = buildTree(arr, index + 1, right);
    return node;
  };
  return buildTree(nums, 0, nums.length - 1);
};

~~~

### 合并二叉树

~~~js
var mergeTrees = function (root1, root2) {
  if (!root1) return root2;
  if (!root2) return root1;
  root1.val += root2.val;
  root1.left = mergeTrees(root1.left, root2.left);
  root1.right = mergeTrees(root1.right, root2.right);
  return root1;
};

~~~

## →→→→求根节点到叶节点数字之和

* getSum 函数

~~~js
var sumNumbers = function (root) {
  const getSum = (root, cur) => {
    if (!root) return 0;
    cur = 10 * cur + root.val;
    if (!root.left && !root.right) return cur;
    return getSum(root.left, cur) + getSum(root.right, cur);
  };
  return getSum(root, 0);
};

~~~

## →→→→最大深度

* 根节点到叶子节点的高度 === 最大深度

>深度：到根节点的距离

* 后序遍历

~~~js
var maxDepth = function (root) {
  if (root === null) return 0 
  const leftHeight = maxDepth(root.left)
  const rightHeight = maxDepth(root.right)
  // 1:自己的高度  
  const height = 1+ Math.max(leftHeight,rightHeight)
  return height
};

// 后序遍历：求高度，最大深度 = 根节点的高度
~~~

* 层序遍历

~~~js
var maxDepth = function (root) {
  if (!root) return null;
  const queue = [root];
  let maxDeep = 0;
  while (queue.length) {
    let size = queue.length;
    maxDeep++;
    while (size--) {
      let cur = queue.shift();
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
  }
  return maxDeep;
};

~~~

## 最小深度

~~~js
var minDepth = function(root) {
  if (root === null) return 0 
  if (!root.right && !root.left) return 1
  // 只有右子树，只能取左边
  if (!root.left) return minDepth(root.right) + 1
  // 只有左子树，只能取右边
  if (!root.right) return minDepth(root.left)+1
  const leftHeight = minDepth(root.left)
  const rightHeight = minDepth(root.right)
  const height = 1+ Math.min(leftHeight,rightHeight)

  return height
};
// 后序遍历：求高度，最大深度 = 根节点的高度
~~~

## →→→→平衡二叉树

* 高度：4 3 2 1
* 深度：1 2 3 4
* 时刻检测到底平不平衡

~~~js
var isBalanced = function (root) {
  const getHeight = (root) => {
    if (!root) return 0;
    const left = getHeight(root.left);
    if (left === -1) return -1;
    const right = getHeight(root.right);
    if (right === -1) return -1;
    if (Math.abs(left - right) > 1) {
      return -1;
    } else {
      return Math.max(left, right) + 1;
    }
  };
  return !(getHeight(root) === -1);
};

~~~

## →→→→直径

* 直径 =  节点数 - 1
* 每次返回深度
* 变量 ans 记录最深 = 左边最深 + 右边最深

~~~js
var diameterOfBinaryTree = function (root) {
  let ans = 1;
  function depth(rootNode) {
    if (!rootNode) return 0;
    // 递归获取左右子树的深度
    let leftDepth = depth(rootNode.left);
    let rightDepth = depth(rootNode.right);
    // 经过的最大节点数
    ans = Math.max(ans, leftDepth + rightDepth + 1);
    // 返回深度
    return Math.max(leftDepth, rightDepth) + 1;
  }
  depth(root);
  // 算了两次根节点
  return ans - 1;
};

~~~

## 验证二叉搜索树

~~~js
// 中序遍历是有序的:单调递增
var isValidBST = function (root) {
  if (!root) return true;
  const res = [];
  const inorder = (node) => {
    if (!node) return null;
    inorder(node.left);
    res.push(node.val);
    inorder(node.right);
  };
  inorder(root);
  for (let i = 0; i < res.length - 1; i++) {
    if (res[i] >= res[i + 1]) {
      return false;
    }
  }
  return true;
};

var isValidBST = function (root) {
  let prev = null;
  const inorder = (root) => {
    if (!root) return true;
    const left = inorder(root.left);
    if (prev && prev.val >= root.val) {
      return false;
    } else {
      prev = root;
    }
    const right = inorder(root.right);
    return left && right;
  };
  return inorder(root);
};

~~~

## 路径总和

### →→→路径总和

~~~js
var hasPathSum = function (root, targetSum) {
  const isTrue = (node, left) => {
    // 到达叶子节点
    if (node.left === null && node.right == null) {
      // 已经变成 0 了
      if (left === 0) {
        return true;
      } else {
        return false;
      }
    }
    if (node.left) {
      const res = isTrue(node.left, left - node.left.val);
      if (res) return true;
    }
    if (node.right) {
      const res = isTrue(node.right, left - node.right.val);
      if (res) return true;
    }
    return false;
  };
  if (!root) return false;
  return isTrue(root, targetSum - root.val);
};

~~~

### →→→→路径总和二

~~~js
var pathSum = function (root, targetSum) {
  const paths = [];
  const getPath = (node, left, curPath) => {
    if (node.left === null && node.right === null) {
      if (left === 0) {
        paths.push([...curPath]);
      }
    }
    if (node.left) {
      curPath.push(node.left.val);
      getPath(node.left, left - node.left.val, curPath);
      curPath.pop();
    }
    if (node.right) {
      curPath.push(node.right.val);
      getPath(node.right, left - node.right.val, curPath);
      curPath.pop();
    }
  };
  if (!root) return paths;
  getPath(root, targetSum - root.val, [root.val]);
  return paths;
};

~~~

### 路径总和三

~~~js
var pathSum = function (root, targetSum) {
  const getSum = (root, targetSum) => {
    let count = 0;
    if (root == null) {
      return 0;
    }
    const val = root.val;
    if (val === targetSum) {
      count++;
    }
    count += getSum(root.left, targetSum - val);
    count += getSum(root.right, targetSum - val);
    return count;
  };
  if (!root) return 0;
  let res = getSum(root, targetSum);
  res += pathSum(root.left, targetSum);
  res += pathSum(root.right, targetSum);
  return res;
};
~~~

## 翻转二叉树

* 前序遍历   后序遍历

~~~js
// root 指每一个变量
var invertTree = function (root) {
  if (!root) return null
  const temp = root.left
  root.left = root.right
  root.right = temp
  invertTree(root.left)
  invertTree(root.right)
  return root
};
~~~

## 判断

### →→→→对称二叉树

~~~js
var isSymmetric = function (root) {
  if (!root) return true;
  const compare = (left, right) => {
    if (left === null && right === null) return true;
    if (left === null || right === null) return false;
    if (left.val !== right.val) return false;
    const outside = compare(left.left, right.right);
    const inside = compare(left.right, right.left);
    return outside && inside;
  };
  return compare(root.left, root.right);
};

~~~

### 相同的树

~~~js
var isSameTree = function (p, q) {
  const compare = (p, q) => {
    if (p === null && q === null) return true;
    if (p === null || q === null) return false;
    if (p.val !== q.val) return false;
    const left = compare(p.left, q.left);
    const right = compare(p.right, q.right);
    return left && right;
  };
  return compare(p, q);
};

~~~

### 另一棵树的子树

~~~js
var isSameTree = function (p, q) {
  const compare = (p, q) => {
    if (p === null && q === null) return true;
    if (p === null || q === null) return false;
    if (p.val !== q.val) return false;
    const left = compare(p.left, q.left);
    const right = compare(p.right, q.right);
    return left && right;
  };
  return compare(p, q);
};
function isSubtree(root, subRoot) {
  if (isSameTree(root, subRoot)) {
    return true;
  }
  return isSubtree(root.left) || isSubtree(root.right);
}

~~~

## 后序遍历应用

### 最大深度

~~~js
var maxDepth = function (root) {
  if (root === null) return 0;
  const leftHeight = maxDepth(root.left);
  const rightHeight = maxDepth(root.right);
  const height = 1 + Math.max(leftHeight, rightHeight);
  return height;
};

~~~

### N叉树的最大深度

~~~js
var maxDepth = function (root) {
  if (!root) return 0;
  let childHeight = 0;
  for (const child of root.children) {
    const height = maxDepth(child);
    if (height > childHeight) {
      childHeight = height;
    }
  }
  return childHeight + 1;
};

~~~

### 最小深度

* 一直向上返回 0，最后根本无法统计到

~~~js
var minDepth = function (root) {
  if (root === null) return 0;
  if (!root.right && !root.left) return 1;
  // 只有右子树，只能取右边
  if (!root.left) return minDepth(root.right) + 1;
  // 只有左子树，只能取左边
  if (!root.right) return minDepth(root.left) + 1;
  const leftHeight = minDepth(root.left);
  const rightHeight = minDepth(root.right);
  const height = 1 + Math.min(leftHeight, rightHeight);
  return height;
};
// 后序遍历：求高度，最大深度 = 根节点的高度

~~~



## 左叶子之和

* 叶子节点
* 左孩子

~~~js
var sumOfLeftLeaves = function (root) {
  if (!root) return 0;
  let leftSum = 0;
  if (root.left && root.left.left === null && root.left.right === null) {
    leftSum += root.left.val;
  }
  leftSum += sumOfLeftLeaves(root.left);
  leftSum += sumOfLeftLeaves(root.right);
  return leftSum;
};

~~~

## 层序遍历

### →→→→→层序遍历——广度

* 迭代 + 队列

~~~js
var levelOrder = function (root) {
  if (!root) return [];
  const res = [];
  const queue = [root];
  while (queue.length) {
    let length = queue.length;
    const level = [];
    while (length--) {
      const cur = queue.shift();
      level.push(cur.val);
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
    res.push(level);
  }
  return res;
};
~~~

### →→→→→锯齿形层序遍历

~~~js
var zigzagLevelOrder = function (root) {
  if (!root) return [];
  const res = [];
  let queue = [root];
  while (queue.length) {
    let length = queue.length;
    const curRes = [];
    while (length--) {
      const cur = queue.shift();
      curRes.push(cur.val);
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
    res.push(curRes);
    if (res.length % 2 === 0) {
      curRes.reverse();
    }
  }
  return res;
};

~~~

## 

### 层序遍历二

~~~js
var levelOrderBottom = function(root) {
  const res = []
  if (!root) return res
  const queue = [root]
  while (queue.length) {
    let size = queue.length
    const constantRes =[]
    while (size--) {
      const cur = queue.shift()
      constantRes.push(cur.val)
      cur.left && queue.push(cur.left)
      cur.right && queue.push(cur.right)
    }
    res.push(constantRes)
  }
  return res.reverse()
};
~~~

### 右视图

~~~js
var rightSideView = function (root) {
  const res = [];
  if (!root) return res;
  const queue = [root];
  while (queue.length) {
    let size = queue.length;
    while (size--) {
      const cur = queue.shift();
      if (size === 0) res.push(cur.val);
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
  }
  return res;
};

~~~

### 层平均值

~~~js
var averageOfLevels = function (root) {
  const res = [];
  if (!root) return res;
  const queue = [root];
  while (queue.length) {
    let size = queue.length;
    let sum = 0;
    let count = size;
    while (size--) {
      const cur = queue.shift();
      sum += cur.val;
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
    const result = sum / count;
    res.push(result);
  }
  return res;
};

~~~

### N叉树的层序遍历

~~~js
var levelOrder = function (root) {
  const res = [];
  if (!root) return res;
  const queue = [root];
  while (queue.length) {
    let size = queue.length;
    const constantRes = [];
    while (size--) {
      const cur = queue.shift();
      constantRes.push(cur.val);
      for (const child of cur.children) {
        queue.push(child);
      }
    }
    res.push(constantRes);
  }
  return res;
};

~~~

### 在每个树行中找最大值

~~~js
var largestValues = function (root) {
  const res = [];
  if (!root) return res;
  const queue = [root];
  while (queue.length) {
    let size = queue.length;
    let max = queue[0].val;
    while (size--) {
      let cur = queue.shift();
      max = Math.max(max, cur.val);
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
    res.push(max);
  }
  return res;
};

~~~

### 填充每个节点的下一个右侧节点指针

~~~js
var connect = function (root) {
  if (!root) return null;
  const queue = [root];
  while (queue.length) {
    let size = queue.length;
    while (size--) {
      let cur = queue.shift();
      if (size === 0) {
        cur.next = null;
      } else {
        cur.next = queue[0];
      }
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
  }
  return root;
};

~~~

### 最大深度

~~~js
var maxDepth = function (root) {
  if (!root) return null;
  const queue = [root];
  let maxDeep = 0;
  while (queue.length) {
    let size = queue.length;
    maxDeep++;
    while (size--) {
      let cur = queue.shift();
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
  }
  return maxDeep;
};

~~~

### 最小深度

~~~js
var minDepth = function (root) {
  if (!root) return 0;
  const queue = [root];
  let minDeep = 0;
  while (queue.length) {
    let size = queue.length;
    minDeep++;
    while (size--) {
      let cur = queue.shift();
      if (cur.left === null && cur.right === null) {
        return minDeep;
      }
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
  }
  return minDeep;
};

~~~



## 完全二叉树

### 节点个数

~~~js
// 普通二叉树的写法
// O(n)
var countNodes = function (root) {
  if (root === null) return 0;
  const left = countNodes(root.left);
  const right = countNodes(root.right);
  return left + right + 1;
};
// 优化：利用完全二叉树 2^深度 - 1
// 避免全部遍历，只遍历两侧
// 终止条件：为空，为满二叉树
var countNodes = function (root) {
  if (root === null) return 0;
  let left = root.left
  let right = root.right
  let leftDeepth = 1
  let rightDeepth = 1
  while (left) {
    left = left.left
    leftDeepth++
  }
  while (right) {
    right = right.right
    rightDeepth++
  }
  // 比较深度
  if (rightDeepth === leftDeepth) {
    return Math.pow(2,leftDeepth)-1
  }
  return countNodes(root.left)+countNodes(root.right)+1
};

~~~

## 二叉搜索树

>特点：中序遍历是升序的
>
>左小右大

### 搜索

~~~js
var searchBST = function(root, val) {
  if (!root || root.val === val) return root
  let res = null
  if (root.val > val) {
    res= searchBST(root.left,val)
  }
  if (root.val < val) {
    res = searchBST(root.right,val)
  }
  return res
};


var searchBST = function(root, val) {
  if (!root) return root
  while (root) {
    if (root.val === val) {
      return root
    } else if (root.val > val) {
      root = root.left
    } else {
      root = root.right
    }
  }
  return null
};
~~~

### →→→→验证

>中序遍历是升序

~~~js
var isValidBST = function (root) {
  if (!root) return true;
  const res = [];
  const inorder = (node) => {
    if (!node) return null;
    inorder(node.left);
    res.push(node.val);
    inorder(node.right);
  };
  inorder(root);
  let num = res[0];
  for (let i = 1; i < res.length; i++) {
    if (res[i] > num) {
        // 不断更新 num 为下一个
      num = res[i];
    } else {
      return false;
    }
  }
  return true;
};


var isValidBST = function (root) {
  if (!root) return true;
  let prev = null;
  const inorder = (root) => {
   if(!root) return true
   const left  = inorder(root.left)
   if(prev && prev.val >= root.val){
       return false
   }
   prev = root
   const right = inorder(root.right)
   return left && right
  };
  return inorder(root);
};


~~~

### 最小绝对差

~~~js
var getMinimumDifference = function (root) {
  let res = Infinity;
  let prev = null;
  const getMin = (node) => {
    if (!root) return;
    getMin(node.left);
    if (prev) {
      res = Math.min(res, node.val - prev.val);
    }
    prev = node;
    getMin(node.right);
  };
  getMin(root);
  return res;
};

~~~

### 众数

~~~js
var findMode = function(root) {
    if(!root) return []
    let res  = []
    let count = 1
    let prev = null
    let maxCount = 0
    const inorder = (root)=>{
        if(!root) return
        inorder(root.left)
        if(prev){
            if(prev.val === root.val){
                count++
            }else{
                count = 1
            }
        }
        prev = root
        if(count > maxCount){
            maxCount = count
            res = []
            res.push(root.val)
        }else if(count === maxCount){
            res.push(root.val)
        }
        prev =root
        inorder(root.right)

    }
    inorder(root)
    return res
};
~~~

### 最近公共祖先

~~~js
var lowestCommonAncestor = function (root, p, q) {
  if (!root) return root;
  if (root.val > p.val && root.val > q.val) {
    const left = lowestCommonAncestor(root.left, p, q);
    if (left) return left;
  }
  if (root.val < p.val && root.val < q.val) {
    const right = lowestCommonAncestor(root.right, p, q);
    if (right) return right;
  }
  return root;
};

var lowestCommonAncestor = function (root, p, q) {
  if (!root) return root;
  while (root) {
    if (root.val > p.val && root.val > q.val) {
      root = root.left;
    }else if(root.val < p.val && root.val < q.val){
   root = root.right;
    }else{
    return root
    }

  }
};

~~~

### 插入操作

~~~js
var insertIntoBST = function (root, val) {
  if (!root) {
    const newNode = new TreeNode(val);
    return newNode;
  }
  if (root.val > val) {
    root.left = insertIntoBST(root.left, val);
  } else if (root.val < val) {
    root.right = insertIntoBST(root.right, val);
  }
  return root;
};

~~~

### 删除节点

* 返回给父亲，直接改变父节点的指向

~~~js
var deleteNode = function (root, key) {
  if (!root) return root;
  if (root.val === key) {
    // 没有叶子节点
    if (!root.left && !root.right) {
      return null;
      // 只有右子节点
    } else if (!root.left && root.right) {
      return root.right;
      // 只有左子节点
    } else if (!root.right && root.left) {
      return root.left;
      // 都有
    } else {
      let cur = root.right;
      while (cur.left) {
        cur = cur.left;
      }
      cur.left = root.left;
      return root.right;
    }
  }
  if (root.val > key) {
    root.left = deleteNode(root.left, key);
  } else if (root.val < key) {
    root.right = deleteNode(root.right, key);
  }
  return root;
};

~~~

### 修剪

~~~js
var trimBST = function (root, low, high) {
  if (!root) return root;
  if (root.val < low) {
    return trimBST(root.right, low, high);
  } else if (root.val > high) {
    return trimBST(root.left, low, high);
  }
  root.left = trimBST(root.left, low, high);
  root.right = trimBST(root.right, low, high);
  return root;
};

~~~

### 有序数组转二叉搜索树

~~~js
var sortedArrayToBST = function (nums) {
  const inorder = (arr, left, right) => {
    if (left > right) return null;
    const mid = Math.floor((left + right) / 2);
    const rootVal = arr[mid];
    const root = new TreeNode(rootVal);
    root.left = sortedArrayToBST(nums, 0, mid - 1);
    root.right = sortedArrayToBST(nums, mid + 1, right);
    return root;
  };
  return inorder(nums, 0, nums.length - 1);
};

~~~

### 转换成累加树

~~~js
var convertBST = function (root) {
  let prev = null;
  const inorder = (node) => {
    if (!node) return node;
    inorder(node.right);
    if (prev) node.val += prev.val;
    prev = node;
    inorder(node.left);
  };
  inorder(root);
  return root;
};

~~~



## 路径

### 所有路径

* 回溯

~~~js
var binaryTreePaths = function (root) {
  let res = [];
  const getPath = (node, curPath) => {
    if (node.left === null && node.right === null) {
      curPath += node.val
      res.push(curPath)
      return
    }
       // 中 
    curPath += node.val + '->'
    node.left && getPath(node.left,curPath)
    node.right && getPath(node.right,curPath)

  };
  getPath(root, "");
  return res;
};

~~~

### 找树左下角的值

~~~js
var findBottomLeftValue = function (root) {
  let maxDeepth = 0;
  let resNode = null;
  const dfs = (node, curPath) => {
    // 叶子节点
    if (node.left === null && node.right === null) {
      if (curPath > maxDeepth) {
        maxDeepth = curPath;
        resNode = node.val;
      }
      return;
    }
    node.left && dfs(node.left, curPath + 1);
    node.right && dfs(node.right, curPath + 1);
  };
  dfs(root, 1);
  return resNode;
};

~~~



# 数组

## 移动零

~~~js
~~~



## 二维数组

### 螺旋矩阵 II

~~~js
var generateMatrix = function (n) {
  let left = 0;
  let right = n - 1;
  let top = 0;
  let bottom = n - 1;
  let count = 1;
  const res = new Array(n).fill().map(() => new Array(n));
  while (left < right && top < bottom) {
    for (let i = left; i < right; i++) {
      res[top][i] = count++;
    }
    for (let i = top; i < bottom; i++) {
      res[i][right] = count++;
    }
    for (let i = right; i > left; i--) {
      res[bottom][i] = count++;
    }
    for (let i = bottom; i > top; i--) {
      res[i][left] = count++;
    }
    left++;
    right--;
    top++;
    bottom--;
  }
  if (left === right) {
    for (let i = top; i <= bottom; i++) {
      res[i][left] = count++;
    }
  } else {
    for (let i = left; i <= right; i++) {
      res[top][i] = count++;
    }
  }
  return res;
};
~~~

### →→→→→螺旋矩阵

~~~js
var spiralOrder = function (matrix) {
  if (matrix.length === 0) return [];
  let top = 0;
  let bottom = matrix.length - 1;
  let left = 0;
  let right = matrix[0].length - 1;
  const res = [];
  while (top < bottom && left < right) {
    for (let i = left; i < right; i++) {
      res.push(matrix[top][i]);
    }
    for (let i = top; i < bottom; i++) {
      res.push(matrix[i][right]);
    }
    for (let i = right; i > left; i--) {
      res.push(matrix[bottom][i]);
    }
    for (let i = bottom; i > top; i--) {
      res.push(matrix[i][left]);
    }
    left++;
    top++;
    right--;
    bottom--;
  }
  if (bottom === top) {
    for (let i = left; i <= right; i++) {
      res.push(matrix[top][i]);
    }
  } else if (left === right) {
    for (let i = top; i <= bottom; i++) {
      res.push(matrix[i][left]);
    }
  }
  return res;
};

~~~

## 二分查找

### →→→→→二分查找

~~~js
var search = function (nums, target) {
  if (nums.length === 0) return -1;
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return -1;
};

~~~

### 有效的完全平方数

~~~js
var isPerfectSquare = function (num) {
  let left = 1;
  let right = num;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (mid * mid === num) {
      return true;
    } else if (mid * mid < num) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return false
};

~~~

### 搜索插入位置

~~~js
var searchInsert = function (nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  // [1,3,5,6]  right = mid - 1 = 0  需要返回 1 的位置
  return right + 1;
};

~~~

### →→→→x 的平方根

~~~js
var mySqrt = function (x) {
  let left = 0;
  let right = x;
  let ans = 0;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    const num = mid * mid;
    if (num === x) {
      return mid;
    } else if (num > x) {
      right = mid - 1;
    } else {
      left = mid + 1;
      ans = mid;
    }
  }
  return ans;
};

~~~

### →→→→在排序数组中查找元素的第一个和最后一个位置

* 右边界区左边找
* 左边界区右边找
* 找的都带等于号

~~~js
var searchRange = function (nums, target) {
  // 找到比他小的
  const left = getLeft(nums, target);
  // 找到比他大的
  const right = getRight(nums, target);
  if (left === -2 || right === -2) {
    return [-1, -1];
  }
  // 这个数存在
  if (right - left > 1) {
    return [left + 1, right - 1];
  }
  return [-1, -1];
};
function getLeft(nums, target) {
  let leftBorder = -2;
  let left = 0;
  let right = nums.length-1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] >= target) {
      right = mid - 1;
      leftBorder = right;
    } else {
      left = mid + 1;
    }
  }
  return leftBorder;
}
function getRight(nums, target) {
  let rightBorder = -2;
  let left = 0;
  let right = nums.length -1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] <= target) {
      left = mid + 1;
      rightBorder = left;
    } else {
      right = mid - 1;
    }
  }
  return rightBorder;
}

~~~

### →→→→搜索二维矩阵

~~~js
var searchMatrix = function (matrix, target) {
  if (matrix.length === 0) return false;
  for (const nums of matrix) {
    const res = bsSearch(nums, target);
    if (res >= 0) return true;
  }
  return false;
};

const bsSearch = (nums, target) => {
  let left = 0;
  let right = nums.length-1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return 1;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return -1;
};

~~~

### →→→→寻找峰值

~~~js
var findPeakElement = function (nums) {
  const n = nums.length;
  let left = 0;
  let right = n - 1;
  let ans = -1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (compare(nums, mid - 1, mid)<0 && compare(nums, mid, mid + 1)>0) {
      ans = mid;
      break;
    }
    if (compare(nums, mid, mid - 1) > 0) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return ans;
};
const get = (nums, index) => {
  if (index < 0 || index > nums.length - 1) {
    return [0, 0];
  }
  return [1, nums[index]];
};
const compare = (nums, index1, index2) => {
  const num1 = get(nums, index1);
  const num2 = get(nums, index2);
  // 越界情况处理
  if (num1[0] !== num2[0]) {
    return num1[0] > num2[0] ? 1 : -1;
  }
  if (num1[1] === num2[1]) {
    return 0;
  }

  return num1[1] > num2[1] ? 1 : -1;
};

~~~

### →→→→→搜索旋转排序数组

~~~js
var search = function (nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    }
    if (nums[mid] > nums[right]) {
      // 左边升序，右边循环
      // 进而判断在左边还是右边
      // 左边
      if (nums[left] <= target && nums[mid] > target) {
        right = mid - 1;
      } else {
        // 右边
        left = mid + 1;
      }
    } else {
      // 左边循环，右边升序
      if (nums[right] >= target && nums[mid] < target) {
        // 右边
        left = mid + 1;
      } else {
        // 左边
        right = mid - 1;
      }
    }
  }
  return -1;
};

~~~



## →→→→旋转图像

* 行列交换完再反转

~~~js
var rotate = function (matrix) {
  const n = matrix.length;
  for (let i = 0; i < n; i++) {
    for (let j = i; j < n; j++) {
      const temp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = temp;
    }
  }
  return matrix.map((item) => item.reverse());
};
~~~

## 用 Rand7() 实现 Rand10()

~~~js
var rand10 = function() {
    let range,isAdd5
    do{
        range = rand7()
    }while(range >5)
    do{
        isAdd5 = rand7()
    }while(isAdd5 === 4)
    return isAdd5 <4?range:range + 5
};
~~~

## →→→→最长公共前缀

~~~js
var longestCommonPrefix = function (strs) {
  if (strs.length === 0) {
    return "";
  }
  let ans = strs[0];
  for (let i = 1; i < strs.length; i++) {
    let j = 0
    for (; j < ans.length && j < strs[i].length; j++) {
      if (ans[j] !== strs[i][j]) {
        break;
      }
    }
    ans = ans.substr(0, j);
    if (ans === "") return ans;
  }
  return ans
};

~~~

## →→→最大数

~~~js
var largestNumber = function(nums) {
    quickSort(nums,0,nums.length-1)
    return nums[0] == '0'?'0':nums.join('')
};
function quickSort(nums,start,end){
    if(start>=end)return
    var index = start
    var pivot = nums[start]
    for(let i = start+1;i<=end;i++){
        if(nums[i]+''+pivot>pivot+''+nums[i]){
            index++
            swap(nums,index,i)
        }
    }
    swap(nums,index,start)
    quickSort(nums,start,index-1)
    quickSort(nums,index+1,end)
}
function swap(nums,l,r){
    var temp = nums[l]
    nums[l] = nums[r]
    nums[r] = temp
}

~~~



# 图

## →→→→→岛屿数量

~~~js
var numIslands = function (grid) {
  let res = 0;
  const x = grid.length;
  const y = grid[0].length;
  for (let i = 0; i < x; i++) {
    for (let j = 0; j < y; j++) {
      if (grid[i][j] === "1") {
        res++;
        dfs(i, j);
      }
    }
  }
  function dfs(i, j) {
    if (i >= x || i < 0 || j >= y || j < 0 || grid[i][j] === "0") {
      return;
    }
    grid[i][j] = "0";
    dfs(i - 1, j);
    dfs(i, j - 1);
    dfs(i + 1, j);
    dfs(i, j + 1);
  }
  return res;
};

~~~

# 栈

## →→→→→有效的括号

~~~js
function isValid(str) {
  const stack = [];
  for (let i = 0; i < str.length; i++) {
    const c = str[i];
    switch (c) {
      case "[":
        stack.push("]");
        break;
      case "(":
        stack.push(")");
        break;
      case "{":
        stack.push("}");
        break;
      default:
        if(stack.pop()!==c) return false
    }
  }
  return !stack.length
}
~~~

## →→→→用栈实现队列

* 反正取的时候需要从 out 中取
* peek 的时候是 this.pop 哦

~~~js
var MyQueue = function () {
  this.stackIn = [];
  this.stackOut = [];
};
MyQueue.prototype.push = function (x) {
  this.stackIn.push(x);
};
MyQueue.prototype.pop = function () {
  const size = this.stackOut.length;
  if (size > 0) {
    return this.stackOut.pop();
  }
  while (this.stackIn.length) {
    this.stackOut.push(this.stackIn.pop());
  }
  const result = this.stackOut.pop();
  return result;
};
MyQueue.prototype.peek = function () {
  const res = this.pop();
  this.stackOut.push(res);
  return res;
};
MyQueue.prototype.empty = function () {
  return this.stackOut.length === 0 && this.stackIn.length === 0;
};

~~~

## →→→→最小栈

* 维护两个栈

~~~js
class MinStack {
  constructor() {
    this.stack = [];
    this.minStack = [];
  }
  push(element) {
    this.stack.push(element);
    this.minStack.push(Math.min(element, this.getMin() ?? Infinity));
  }
  pop() {
    this.stack.pop();
    this.minStack.pop();
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  getMin() {
    return this.minStack[this.minStack.length - 1];
  }
}

~~~

## →→→→字符串解码

~~~js
var decodeString = function (s) {
  let numStack = [];
  let strStack = [];
  let num = 0;
  let str = "";
  for (const char of s) {
    if (!isNaN(char)) {
      num = num * 10 + Number(char);
    } else if (char === "[") {
        // 上一个已经重复完了的字符加入
      strStack.push(str);
      str = "";
       // 前面的数字加入
      numStack.push(num);
      num = 0;
    } else if (char === "]") {
        // 结束了
      let times = numStack.pop();
        // 本轮的 times 重复和上一次的字符拼接 
      str = strStack.pop() + str.repeat(times);
    } else {
      str += char;
    }
  }
  // 返回
  return str;
};

~~~

## 删除字符串中的所有相邻重复项

~~~js
var removeDuplicates = function (s) {
  const stack = [];
  for (const c of s) {
    if (c === stack[stack.length - 1]) {
      stack.pop();
    } else {
      stack.push(c);
    }
  }
  return stack.join("");
};

~~~

## 逆波兰表达式求值

~~~js
var evalRPN = function (tokens) {
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i] === "/" || tokens[i] === "-" || tokens[i] === "+" || tokens[i] === "*") {
      const n2 = stack.pop();
      const n1 = stack.pop();
      if (tokens[i] === "/") {
        // parseInt：往 0 靠
        stack.push(parseInt(n1 / n2));
      } else if (tokens[i] === "*") {
        stack.push(n1 * n2);
      } else if (tokens[i] === "-") {
        stack.push(n1 - n2);
      } else {
        stack.push(n1 + n2);
      }
    } else {
      stack.push(Number(tokens[i]));
    }
  }
  return stack[0];
};

~~~

## →→→基本计算器二

~~~js
var calculate = function(s) {
	const nums = []
	let cur = 0
	let prevOp = '+'
	s = s + '+'
	
	for (let i = 0; i < s.length; i++) {
        // 看字符串是否是数字
		if (s[i] >= '0' && s[i] <= '9') {
			cur = cur * 10 + s[i].charCodeAt(0) -'0'.charCodeAt(0)
		} else if (s[i] == ' ') {
            // 空格
			continue
		} else {
            // 操作符
			if (prevOp == '+') { 
                nums.push(cur)
            } else if (prevOp == '-') {
                nums.push( -1 * cur) 
            } else if (prevOp == '*') {
                nums[nums.length - 1] *=  cur 
            } else if (prevOp == '/') {
                nums[nums.length - 1]  =  (nums[nums.length - 1] / cur) | 0
            }
            prevOp = s[i] 
            cur = 0 
		}
	}
    let sum = 0
    nums.forEach(v => {
        sum += v
    })
    return sum
};
~~~



# 队列

## 用队列实现栈

~~~js
var MyStack = function () {
  this.queue = [];
};

MyStack.prototype.push = function (x) {
  this.queue.push(x);
};
// 栈顶：队列的最后一个元素
MyStack.prototype.pop = function () {
  let size = this.queue.length;
  while (size > 1) {
    // pop:队头
    this.queue.push(this.queue.shift());
    size--;
  }
  const res = this.queue.shift();
  return res;
};

MyStack.prototype.top = function () {
  const res = this.queue.pop();
  this.queue.push(res);
  return res;
};

MyStack.prototype.empty = function () {
  return this.queue.length === 0;
};

~~~

## 滑动窗口最大值

~~~js
var maxSlidingWindow = function (nums, k) {
  const n = nums.length;
  const q = [];
  // 开头的情况
  for (let i = 0; i < k; i++) {
    // 遇到比自己大的自己就弹出
    while (q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i);
  }
  // 第一个答案
  const ans = [nums[q[0]]];
  for (let i = k; i < n; i++) {
    // 遇到比他大的就弹出
    // 下标对应的元素是严格单调递减的
    while (q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i);
    // 窗口往前
    while (q[0] <= i - k) {
      q.shift();
    }
    ans.push(nums[q[0]]);
  }
  return ans;
};

~~~



# 单调栈

>字眼：找到左边或者右边第一个比当前元素大/小的元素
>
>递增：大
>
>递减：小
>
>作用：存放遍历过的元素和当前元素进行对比，当前元素和栈口进行比较

![image-20240507201659709](https://gitee.com/coderlisa/img/raw/master/202407061841534.png)

## 每日温度

* 单调递增

~~~js
var dailyTemperatures = function(temperatures) {
  const res = new Array(temperatures.length).fill(0)
  const stack = [0]
  for (let i = 0; i < temperatures.length; i++){
    // 栈口的下标
    let top = stack[stack.length - 1]
    if (temperatures[i] <= temperatures[top]) {
      stack.push(i)
    } else {
      while (temperatures[i] > temperatures[top] && stack.length) {
        res[top] = i - top
        stack.pop()
        // 继续跟下一个比
        top = stack[stack.length -1]
      }
      stack.push(i)
    }
  }
  return res
};
~~~

## 下一个更大元素一

* 单调递增

* nums1 是 nums2 的子集

~~~js
var nextGreaterElement = function (nums1, nums2) {
  const res = [];
  const stack = [];
  const map = new Map();
  stack.push(0);
  for (let i = 1; i < nums2.length; i++) {
    let top = stack[stack.length - 1];
    if (nums2[i] <= nums2[top]) {
      stack.push(i);
    } else {
      while (nums2[i] > nums2[top] && stack.length) {
        map.set(nums2[top], nums2[i]);
        stack.pop();
        top = stack[stack.length - 1];
      }
      stack.push(i);
    }
  }
  for (let i = 0; i < nums1.length; i++) {
    res[i] = map.get(nums1[i]) || -1;
  }
  return res;
};

~~~

## 下一个更大元素二

* 单调递增

* 成环==》取模的方式
  * i ==》 i % nums.length

~~~js
var nextGreaterElements = function (nums) {
  const res = new Array(nums.length).fill(-1);
  const stack = [];
  stack.push(0);
  for (let i = 1; i < nums.length * 2; i++) {
    let top = stack[stack.length - 1];
    if (nums[i % nums.length] <= nums[top]) {
      stack.push(i % nums.length);
    } else {
      while (stack.length > 0 && nums[i % nums.length] > nums[top]) {
        res[top] = nums[i % nums.length];
        stack.pop();
        top = stack[stack.length - 1];
      }
      stack.push(i % nums.length);
    }
  }
  return res;
};

~~~

## 接雨水

* 单调递增

~~~js
var trap = function (height) {
  let res = 0;
  const stack = [];
  stack.push(0);
  for (let i = 1; i < height.length; i++) {
    let top = stack[stack.length - 1];
    if (height[i] <= height[top]) {
      stack.push(i);
    } else {
      while (stack.length && height[i] > height[top]) {
        // 已经弹出来了之前 top
        // 现在是单调递增栈的下一个
        stack.pop();
        if (stack.length) {
          // 垂直方向上计算
          // 处理栈口元素
          const h = Math.min(height[i], height[stack[stack.length - 1]]) - height[top];
          const width = i - stack[stack.length - 1] - 1;
          res += h * width;
        }
        top = stack[stack.length - 1];
      }
      stack.push(i);
    }
  }
  return res;
};

~~~



# 回溯

>- 回溯 backtracking 三部曲
>
>- 确定参数和返回值
>
>  - 参数
>    - 很多，一般无法一开始就确定
>
>  - 返回值
>    - void
>
>- 确定终止条件
>
>  - 收集结果
>    - 一般在叶子节点
>
>  - return
>
>- 确定单层搜索逻辑
>
>  - for 循环（集合的元素集）
>
>    - 处理节点
>      - 处理集合的每一个元素
>
>    - 递归函数 backtracking
>
>    - 回溯操作

## 组合

### 组合

~~~js
var combine = function (n, k) {
  const path = [];
  const res = [];
  const backtracking = (n, k, startIndex) => {
    if (k === path.length) {
      res.push([...path]);
      return;
    }
    for (let i = startIndex; i <= n; i++) {
      path.push(i);
      backtracking(n, k, i + 1);
      path.pop();
    }
  };
  backtracking(n, k, 1);
  return res;
};

var combine = function (n, k) {
  const path = [];
  const res = [];
  const backtracking = (n, k, startIndex) => {
    if (k === path.length) {
      res.push([...path]);
      return;
    }
    for (let i = startIndex; i <= n - (k - path.length) + 1; i++) {
      path.push(i);
      backtracking(n, k, i + 1);
      path.pop();
    }
  };
  backtracking(n, k, 1);
  return res;
};

~~~

### →→→→组合总和

* 无重复元素但可重复选取

~~~js
var combinationSum = function(candidates, target) {
  const res = []
  const path = []
  const backtracking = (curSum, target, candidates,startIndex) => {
    if(curSum>target) return
    if (curSum === target) {
      res.push([...path])
      return
    }
    for (let i = startIndex; i < candidates.length; i++){
      curSum += candidates[i]
      path.push(candidates[i])
      backtracking(curSum, target, candidates,i)
      curSum -= candidates[i]
      path.pop()
    }
  }
  backtracking(0, target, candidates, 0)
  return res
};
~~~

### 组合总和 II

~~~js
var combinationSum2 = function (candidates, target) {
  const n = candidates.length;
  candidates.sort((a, b) => a - b);
  let used = new Array(n).fill(false);
  let res = [];
  let path = [];
  const backtracking = (target, currentSum, startIndex) => {
    if (target < currentSum) return;
    if (target === currentSum) {
      res.push([...path]);
      return;
    }
    for (let i = startIndex; i < n; i++){
      if ((i > 0 && used[i-1] === false && candidates[i] === candidates[i - 1])) {
        continue
      }
      currentSum += candidates[i]
      path.push(candidates[i])
      used[i] = true
      backtracking(target, currentSum, i + 1)
      currentSum -= candidates[i]
      path.pop()
      used[i] = false
    }
  };
  backtracking(target, 0, 0);
  return res
};

~~~

### 组合总和 III

>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
>
>只使用数字1到9
>每个数字 最多使用一次

~~~js
var combinationSum3 = function (k, n) {
  const res = [];
  const path = [];
  const backtracking = (targetSum, k, sum, startIndex) => {
    if (sum > targetSum) return;
    if (k === path.length) {
      if (sum === targetSum) {
        res.push([...path]);
        return;
      }
    }
    for (let i = startIndex; i <= 9 - (k - path.length) + 1; i++) {
      sum += i;
      path.push(i);
      backtracking(targetSum, k, sum, i + 1);
      sum -= i;
      path.pop();
    }
  };
  backtracking(n, k, 0, 1);
  return res;
};

~~~

### 电话号码的字母组合

~~~js
var letterCombinations = function (digits) {
  const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"];
    // 输入了几个数字
  const n = digits.length;
  if (!n) return [];
  const res = [];
  const path = [];
  const backtracking = (digits, need, index) => {
    if (path.length === need) {
      res.push(path.join(""));
      return;
    }
    const digit = digits[index]
    for (const v of map[digit]) {
      path.push(v);
      backtracking(digits, need, index + 1);
      path.pop();
    }
  };
  backtracking(digits, n, 0);
  return res;
};

~~~

## →→→→括号生成

~~~js
var generateParenthesis = function(n) {
    const res = []
    const backtracking = (leftCount,rightCount,str)=>{
        if(str.length === 2 * n){
            res.push(str)
            return
        }
        if(leftCount){
            backtracking(leftCount-1,rightCount,str+'(')
        }
        if(leftCount < rightCount){
            backtracking(leftCount,rightCount-1,str +')')
        }
    }
    backtracking(n,n,'')
    return res
};
~~~

## 分割

### 分割回文串

~~~js
var partition = function (s) {
  const res = [];
  const path = [];
  const backtracking = (s, startIndex) => {
    if (startIndex === s.length) {
      res.push([...path]);
      return;
    }
    for (let i = startIndex; i < s.length; i++) {
      const item = s.slice(startIndex, i + 1);
      if (!isValid(item)) {
        continue;
      }
      path.push(item);
      backtracking(s, i + 1);
      path.pop();
    }
  };
  backtracking(s, 0);
  return res;
};
function isValid(str) {
  let i = 0;
  let j = str.length - 1;
  while (i < j) {
    if (str[i] !== str[j]) {
      return false;
    }
    i++;
    j--;
  }
  return true;
}

~~~

### →→→→→复原 ip 地址

~~~js
var restoreIpAddresses = function(s) {
    let path = []
    const res = []
    const backtracking = (s,startIndex)=>{
        if(path.length > 4) return
        if(startIndex === s.length && path.length === 4){
            res.push(path.join('.'))
            return
        }
        for(let i = startIndex;i<s.length;i++){
            const str = s.slice(startIndex,i+1)
            if(isValid(str)){
                path.push(str)
                backtracking(s,i+1)
                path.pop()
            }
        }
    }
    backtracking(s,0)
    return res
};
function isValid(str){
    if(+str > 255) return false
    if(str.length > 3) return false
    if(str.length > 1 && str[0]==='0') return false
    return true
}
~~~

## 子集

### →→→→子集

~~~js
var subsets = function(nums) {
  const res = []
  const path = []
  const backtracking = (nums, startIndex) => {
    res.push([...path])
    if (startIndex === nums.length) return
    for (let i = startIndex; i < nums.length; i++){
      path.push(nums[i])
      backtracking(nums, i + 1)
      path.pop()
    }
  }
  backtracking(nums, 0)
  return res
};
~~~

### 子集 II

~~~js
var subsetsWithDup = function (nums) {
  nums.sort((a, b) => a - b);
  const res = [];
  const path = [];
  const n = nums.length;
  const used = new Array(n).fill(false);
  const backtracking = (nums, startIndex) => {
    res.push([...path]);
    if (startIndex === n) {
      return;
    }
    for (let i = startIndex; i < n; i++) {
      if (i > 0 && nums[i - 1] === nums[i] && !used[i - 1]) continue;
      used[i] = true;
      path.push(nums[i]);
      backtracking(nums, i + 1);
      used[i] = false;
      path.pop();
    }
  };
  backtracking(nums, 0);
  return res;
};

~~~

### 非递减子序列

~~~js
var findSubsequences = function (nums) {
  const res = [];
  const path = [];
  const backtracking = (nums, startIndex) => {
    if (path.length >= 2) {
      res.push([...path]);
    }
    if (startIndex === nums.length) {
      return;
    }
    const used = {};
    for (let i = startIndex; i < nums.length; i++) {
      if (path.length && nums[i] < path[path.length - 1]) {
        continue;
      }
      if (used[nums[i]]) continue;
      used[nums[i]] = true;
      path.push(nums[i]);
      backtracking(nums, i + 1);
      path.pop();
    }
  };
  backtracking(nums, 0);
  return res;
};

~~~

## 排列

### →→→→→全排列

>不含重复数字的数组

~~~js
var permute = function(nums) {
  const path = []
  const res = [] 
  const used = new Array(nums.length).fill(false)
  const backtracking = (nums) => {
    if (path.length === nums.length) {
      res.push([...path])
      return
    }
    for (let i = 0; i < nums.length; i++){
      if (used[i] === true) continue
      used[i] = true
      path.push(nums[i])
      backtracking(nums)
      path.pop()
      used[i] = false
    }
  }
  backtracking(nums)
  return res
};
~~~

### 全排列二

~~~js
var permuteUnique = function (nums) {
  const res = [];
  const path = [];
  nums.sort((a, b) => a - b);
  const used = new Array(nums.length).fill(false);
  const backtracking = (nums) => {
    if (path.length === nums.length) {
      res.push([...path]);
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (i > 0 && !used[i - 1] && nums[i] === nums[i - 1]) {
        continue;
      }
      if (used[i]) {
        continue;
      }
      used[i] = true;
      path.push(nums[i]);
      backtracking(nums);
      used[i] = false;
      path.pop();
    }
  };
  backtracking(nums);
  return res;
};

~~~



# 贪心

## 排序

### 分发饼干

~~~js
var findContentChildren = function (g, s) {
  g.sort((a, b) => a - b);
  s.sort((a, b) => a - b);
  let res = 0;
  let index = s.length - 1;
  for (let i = g.length - 1; i >= 0; i--) {
    if (s[index] >= g[i]) {
      index--;
      res++;
    }
    if (index < 0) {
      break;
    }
  }
  return res;
};

~~~

### k次取反后最大化的数组和

~~~js
var largestSumAfterKNegations = function (nums, k) {
  let sum = 0;
  nums.sort((a, b) => Math.abs(b) - Math.abs(a));
  for (let i = 0; i < nums.length; i++) {
    if (k > 0 && nums[i] < 0) {
      nums[i] = -nums[i];
      k--;
    }
    // 已经加完了
    sum += nums[i];
  }
  // k 还有剩余
  // 如果是奇数：奇数次变换之后还是一样
  // 如果是偶数：减去两倍的最小的正数
  if (k % 2 !== 0) {
    sum -= 2*nums[nums.length - 1];
  }
  return sum;
};

~~~



## 分类讨论

### 摆动序列

~~~js
var wiggleMaxLength = function(nums) {
    let prediff = 0
    let curdiff = 0
    let res = 1
    for(let i = 0;i<nums.length;i++){
        curdiff = nums[i+1]-nums[i]
        if(curdiff < 0 && prediff >=0 || curdiff>0&&prediff <=0){
            res++
            prediff = curdiff
        }
    }
    return res
};
~~~

### 柠檬水找零

~~~js
var lemonadeChange = function(bills) {
  let five = 0
  let ten = 0
  for (let i = 0; i < bills.length;i++)
  {
    if (bills[i] === 5) {
      five++
    } else if (bills[i] === 10) {
      if (five > 0) {
        five--
        ten++
      } else {
        return false
      }
    } else if (bills[i] === 20) {
      if (ten > 0) {
        ten--
        if (five > 0) {
          five--
        } else {
          return false
        }
      } else {
        if (five >= 3) {
          five=five-3
        } else {
          return false
        }
      }
    }
  }
return true
};
~~~



## 遍历求和

### →→→→→最大子数组和

~~~js
var maxSubArray = function (nums) {
  let res = -Infinity;
  let sum = 0;
  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    if (sum > res) {
      res = sum;
    }
    if (sum < 0) {
      sum = 0;
    }
  }
  return res;
};

~~~

### →→→卖股票的最佳时机 II

~~~js
var maxProfit = function (prices) {
  let sum = 0;
  for (let i = 0; i < prices.length; i++) {
    if (prices[i + 1] - prices[i] > 0) {
      sum += prices[i + 1] - prices[i];
    }
  }
  return sum;
};

~~~

### 加油站

~~~js
var canCompleteCircuit = function (gas, cost) {
  let curSum = 0;
  let totalSum = 0;
  let start = 0;
  for (let i = 0; i < gas.length; i++) {
    curSum += gas[i] - cost[i];
    totalSum += gas[i] - cost[i];
    if (curSum < 0) {
      curSum = 0;
      start = i + 1;
    }
  }
  if (totalSum >= 0) return start;
  return -1;
};

~~~



## 区间

### 跳跃游戏

~~~js
var canJump = function (nums) {
  let cover = 0;
  for (let i = 0; i <= cover; i++) {
    // 能不能覆盖住一整个范围
    cover = Math.max(cover, nums[i] + i);
    if (cover >= nums.length - 1) return true;
  }
  return false;
};

~~~

### 跳跃游戏二

~~~js
var jump = function (nums) {
  if (nums.length === 1) return 0;
  let res = 0;
  let cover = 0;
  // 最大覆盖的下标
  let cur = 0;
  for (let i = 0; i < nums.length; i++) {
    cover = Math.max(cover, i + nums[i]);
    if (i === cur) {
      // cur 不是最后一个，需要跳下一层
      if (cur !== nums.length - 1) {
        res++;
        cur = cover;
        // 跳完发现覆盖到了
        if (cover >= nums.length - 1) {
          break;
        }
        // 已经到了最大数组末尾
      }
    }
  }
  return res;
};

~~~

### 用最少数量的箭引爆气球

~~~js
var findMinArrowShots = function (points) {
  if (points.length === 0) return 0;
  points.sort((a, b) => {
    return a[0] - b[0];
  });
  let res = 1;
  for (let i = 1; i < points.length; i++) {
    // cur 左边界大于 prev 右边界，分开了
    if (points[i][0] > points[i - 1][1]) {
      res++;
    } else {
      points[i][1] = Math.min(points[i][1], points[i - 1][1]);
    }
  }
  return res;
};

~~~



## 两边分别考虑

### 根据身高重建队列

~~~js
var reconstructQueue = function (people) {
  people.sort((a, b) => {
    if (b[0] !== a[0]) {
      // 身高不同，从高到低排序
      return b[0] - a[0];
    } else {
      // 身高相同，从低到高排序
      return a[1] - b[1];
    }
  });
  // console.log(people);
  const res = [];
  for (let i = 0; i < people.length; i++) {
    res.splice(people[i][1], 0, people[i]);
  }
  return res
};


~~~

### 无重叠区间

* 找出有几个重叠区间
* 左边界排序

~~~js
var eraseOverlapIntervals = function (intervals) {
  let count = 0;
  intervals.sort((a, b) => a[0] - b[0]);
  for (let i = 1; i < intervals.length; i++) {
    if (intervals[i][0] < intervals[i - 1][1]) {
      // 重叠了，count++
      count++;
      // 移除了，取重叠区间的右区间的最小值
      // 进行更新
      intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]);
    }
  }
  return count;
};


~~~

## 划分字母区间

* 记录每个字母出现的最远位置：`hash[s[i].charCodeAt() - "a".charCodeAt()]`

~~~js
const str = "Hello";
const firstCharCode = str.charCodeAt(0);
console.log(firstCharCode); // 输出 72，代表字符 "H" 的 Unicode 编码
~~~

~~~js
var partitionLabels = function (s) {
  const hash = new Array(26).fill(0);
  for (let i = 0; i < s.length; i++) {
    hash[s[i].charCodeAt() - "a".charCodeAt()] = i;
  }
  // 存储每个区间的长度
  let res = [];
  let left = 0;
  let right = 0;
  for (let i = 0; i < s.length; i++) {
    right = Math.max(right, hash[s[i].charCodeAt() - "a".charCodeAt()]);
    // 找到区间，记录长度
    if (i === right) {
      res.push(right - left + 1);
      // 更新起始位置
      left = right + 1;
    }
  }
  return res;
};

~~~

## →→→→→合并区间

* 左边界排序
* 重叠或者不重叠

~~~js
var merge = function (intervals) {
  if (intervals.length === 0) return [];
  intervals.sort((a, b) => a[0] - b[0]);
  const res = [intervals[0]]
  for (let i = 1; i < intervals.length; i++){
      // 重叠了
    if (intervals[i][0] <= res[res.length-1][1]) {
        // 需要更新右边界：要哪个的右边界
      res[res.length-1][1] = Math.max(intervals[i][1],res[res.length-1][1])
    } else {
        // 没有重叠直接 push 进去
      res.push(intervals[i])
    }
  }
  return res
};

~~~

## 单调自增的数字

~~~js
var monotoneIncreasingDigits = function(n) {
  const str = n.toString().split('')
  let flag = str.length
  for (let i = str.length - 1; i > 0; i--){
    if (str[i - 1] > str[i]) {
      str[i - 1]--
      // 记录哪里开始变成9
      flag= i
    }
  }
  for (let i = flag; i < str.length; i++){
    str[i]='9'
  }
  return str.join('')
  
};
~~~

## →→→→下一个排列

* 情况一：1,2,3  ==>  1,3,2
* 情况二：3,2,1  ==>  1,2,3
* nums[i] 都 >=

~~~js
var nextPermutation = function (nums) {
  let i = nums.length - 2;
  while (i >= 0 && nums[i] >= nums[i + 1]) {
    i--;
  }
  if (i >= 0) {
    let j = nums.length - 1;
    while (j >= 0 && nums[i] >= nums[j]) {
      j--;
    }
    swap(i, j);
  }
  let l = i + 1;
  let r = nums.length - 1;
  while (l < r) {
    swap(l, r);
    l++;
    r--;
  }
  function swap(i, j) {
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }
};
~~~

~~~js
function nextPermutation(nums) {
  // 向左遍历，i从倒数第二开始是为了nums[i+1]要存在
  let i = nums.length - 2;
  // 寻找第一个小于右邻居的数
  while (i >= 0 && nums[i] >= nums[i + 1]) {
    i--;
  }
  // 这个数在数组中存在，从它身后挑一个数，和它换
  if (i >= 0) {
    let j = nums.length - 1;
    // 从最后一项，向左遍历
    while (j >= 0 && nums[j] <= nums[i]) {
      // 寻找第一个大于 nums[i] 的数
      j--;
    }
    [nums[i], nums[j]] = [nums[j], nums[i]]; // 两数交换，实现变大
  }
  // 如果 i = -1，说明是递减排列，如 3 2 1，没有下一排列，直接翻转为最小排列：1 2 3
  // 双指针排序
  let l = i + 1;
  let r = nums.length - 1;
  while (l < r) {
    // i 右边的数进行翻转，使得变大的幅度小一些
    [nums[l], nums[r]] = [nums[r], nums[l]];
    l++;
    r--;
  }
}

~~~

# 位运算

## 只出现一次的数字

